import os

BASE_DIR = "/mnt/dados/ClinicaAI/backend/apps"  # Caminho base para seus apps

# Lista de todos os aplicativos que criamos
apps = [
    "whatsapp",
    "conhecimento",
    "voip",
    "iot",
    "aprovacoes",
    "mensagens",
    "produtividade",
    "compromissos",
    "central_ajuda",
    "servico_campo",
    "planilhas_horas",
    "projeto",
    "pesquisas",
    "automacao_marketing",
    "eventos",
    "marketing_sms",
    "marketing_email",
    "redes_sociais",
    "frota",
    "indicacoes",
    "avaliacoes",
    "folgas",
    "recrutamento",
    "recursos_humanos",
    "qualidade",
    "manutencao",
    "compras",
    "plm",
    "fabricacao",
    "inventario",
    "elearning",
    "chat_ao_vivo",
    "forum",
    "blog",
    "ecommerce",
    "criador_sites",
    "locacao",
    "assinaturas",
    "crm",
    "vendas",
    "assinar_documentos",
    "documentos",
    "planilhas",
    "despesas",
    "faturamento",
    "financeiro",
    "agendamentos",
    "pacientes",
]

# Corrigir o arquivo apps.py de cada módulo
for app in apps:
    app_dir = os.path.join(BASE_DIR, app)
    apps_file_path = os.path.join(app_dir, "apps.py")

    # Verificar se o arquivo apps.py existe
    if os.path.exists(apps_file_path):
        # Reescrever o arquivo apps.py com o valor correto para name
        with open(apps_file_path, "w") as f:
            f.write(
                f"from django.apps import AppConfig\n\n"
                f"class {app.capitalize()}Config(AppConfig):\n"
                f"    default_auto_field = 'django.db.models.BigAutoField'\n"
                f"    name = 'apps.{app}'\n"
            )

print("Correção dos arquivos apps.py concluída com sucesso.")
import os
import subprocess

BASE_DIR = "/mnt/dados/ClinicaAI/backend/apps"
SETTINGS_FILE = "/mnt/dados/ClinicaAI/backend/ClinicaAI/settings.py"


def adicionar_ao_installed_apps(nome_modulo):
    # Verificar e adicionar o módulo ao INSTALLED_APPS se ainda não estiver lá
    with open(SETTINGS_FILE, "r") as f:
        settings_content = f.readlines()

    installed_apps_index = None
    for i, line in enumerate(settings_content):
        if "INSTALLED_APPS" in line:
            installed_apps_index = i
            break

    if installed_apps_index is not None:
        modulo_entry = f"    'apps.{nome_modulo}',\n"
        if modulo_entry not in settings_content:
            # Adicionar após a linha "INSTALLED_APPS = ["
            settings_content.insert(installed_apps_index + 2, modulo_entry)
            with open(SETTINGS_FILE, "w") as f:
                f.writelines(settings_content)
            print(f"Módulo 'apps.{nome_modulo}' adicionado ao INSTALLED_APPS.")


def criar_pasta_modulo(nome_modulo):
    app_dir = os.path.join(BASE_DIR, nome_modulo)
    if not os.path.exists(app_dir):
        os.makedirs(app_dir)
        print(f"Pasta {app_dir} criada com sucesso.")
    return app_dir


def criar_models_agendamento(app_dir):
    models_path = os.path.join(app_dir, "models.py")
    with open(models_path, "w") as f:
        f.write(
            """
from django.db import models
from apps.pacientes.models import Paciente

class Agendamento(models.Model):
    paciente = models.ForeignKey(Paciente, on_delete=models.CASCADE, related_name='agendamentos')
    data_horario = models.DateTimeField()
    tipo_consulta = models.CharField(max_length=50)
    status = models.CharField(max_length=20, choices=[
        ('agendado', 'Agendado'),
        ('cancelado', 'Cancelado'),
        ('realizado', 'Realizado'),
    ])
    observacoes = models.TextField(blank=True)

    def __str__(self):
        return f"Agendamento de {self.paciente.nome_completo} em {self.data_horario}"
"""
        )
    print("Arquivo models.py para Agendamento criado com sucesso.")


def criar_models_prontuario(app_dir):
    models_path = os.path.join(app_dir, "models.py")
    with open(models_path, "w") as f:
        f.write(
            """
from django.db import models
from apps.pacientes.models import Paciente

class Prontuario(models.Model):
    paciente = models.ForeignKey(Paciente, on_delete=models.CASCADE, related_name='prontuarios')
    data_registro = models.DateTimeField(auto_now_add=True)
    descricao = models.TextField()
    medico_responsavel = models.CharField(max_length=100)

    def __str__(self):
        return f"Prontuário de {self.paciente.nome_completo} - {self.data_registro.strftime('%d/%m/%Y')}"
"""
        )
    print("Arquivo models.py para Prontuário criado com sucesso.")


def criar_views_serializers_urls(nome_modulo):
    app_dir = os.path.join(BASE_DIR, nome_modulo)

    # Nome da classe do modelo no singular
    nome_classe = (
        nome_modulo.capitalize()[:-1]
        if nome_modulo.endswith("s")
        else nome_modulo.capitalize()
    )

    # Criar serializers.py
    serializers_path = os.path.join(app_dir, "serializers.py")
    with open(serializers_path, "w") as f:
        f.write(
            f"""
from rest_framework import serializers
from .models import {nome_classe}

class {nome_classe}Serializer(serializers.ModelSerializer):
    class Meta:
        model = {nome_classe}
        fields = '__all__'
"""
        )
    print(f"Arquivo serializers.py para {nome_classe} criado com sucesso.")

    # Criar views.py
    views_path = os.path.join(app_dir, "views.py")
    with open(views_path, "w") as f:
        f.write(
            f"""
from rest_framework import viewsets
from .models import {nome_classe}
from .serializers import {nome_classe}Serializer

class {nome_classe}ViewSet(viewsets.ModelViewSet):
    queryset = {nome_classe}.objects.all()
    serializer_class = {nome_classe}Serializer
"""
        )
    print(f"Arquivo views.py para {nome_classe} criado com sucesso.")

    # Criar urls.py
    urls_path = os.path.join(app_dir, "urls.py")
    with open(urls_path, "w") as f:
        f.write(
            f"""
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import {nome_classe}ViewSet

router = DefaultRouter()
router.register(r'{nome_modulo.lower()}', {nome_classe}ViewSet)

urlpatterns = [
    path('', include(router.urls)),
]
"""
        )
    print(f"Arquivo urls.py para {nome_classe} criado com sucesso.")


def criar_admin(nome_modulo):
    app_dir = os.path.join(BASE_DIR, nome_modulo)

    # Nome da classe do modelo no singular
    nome_classe = (
        nome_modulo.capitalize()[:-1]
        if nome_modulo.endswith("s")
        else nome_modulo.capitalize()
    )

    admin_path = os.path.join(app_dir, "admin.py")
    with open(admin_path, "w") as f:
        f.write(
            f"""
from django.contrib import admin
from .models import {nome_classe}

admin.site.register({nome_classe})
"""
        )
    print(f"Arquivo admin.py para {nome_classe} criado com sucesso.")


def rodar_migracoes():
    # Executar os comandos de makemigrations e migrate
    try:
        subprocess.run(["python", "manage.py", "makemigrations"], check=True)
        subprocess.run(["python", "manage.py", "migrate"], check=True)
        print("Migrações criadas e aplicadas com sucesso.")
    except subprocess.CalledProcessError as e:
        print(f"Erro ao rodar migrações: {e}")


if __name__ == "__main__":
    # Criar módulo Agendamentos
    agendamento_dir = criar_pasta_modulo("agendamentos")
    criar_models_agendamento(agendamento_dir)
    criar_views_serializers_urls("agendamentos")
    criar_admin("agendamentos")
    adicionar_ao_installed_apps("agendamentos")

    # Criar módulo Prontuário
    prontuario_dir = criar_pasta_modulo("prontuarios")
    criar_models_prontuario(prontuario_dir)
    criar_views_serializers_urls("prontuarios")
    criar_admin("prontuarios")
    adicionar_ao_installed_apps("prontuarios")

    # Rodar migrações
    rodar_migracoes()
from rest_framework import viewsets
from .models import Transacao
from .serializers import TransacaoSerializer


class TransacaoViewSet(viewsets.ModelViewSet):
    queryset = Transacao.objects.all()
    serializer_class = TransacaoSerializer
from django.db import models


class Transacao(models.Model):
    descricao = models.CharField(max_length=255)
    valor = models.DecimalField(max_digits=10, decimal_places=2)
    data = models.DateField()
    categoria = models.CharField(max_length=100)
    tipo = models.CharField(
        max_length=50, choices=[("receita", "Receita"), ("despesa", "Despesa")]
    )

    def __str__(self):
        return f"{self.descricao} - {self.valor}"
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import TransacaoViewSet

router = DefaultRouter()
router.register(r"transacoes", TransacaoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Transacao


@admin.register(Transacao)
class TransacaoAdmin(admin.ModelAdmin):
    list_display = ("descricao", "valor", "data", "categoria", "tipo")
from rest_framework import serializers
from .models import Transacao


class TransacaoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Transacao
        fields = "__all__"
import os
import subprocess

BASE_DIR = "/mnt/dados/ClinicaAI/backend/apps/pacientes"


def criar_pasta_se_necessario():
    if not os.path.exists(BASE_DIR):
        os.makedirs(BASE_DIR)
        print(f"Pasta {BASE_DIR} criada com sucesso.")


def criar_models():
    models_path = os.path.join(BASE_DIR, "models.py")
    with open(models_path, "w") as f:
        f.write(
            """
from django.db import models
from django.utils.translation import gettext_lazy as _

class Paciente(models.Model):
    # Dados Pessoais
    nome_completo = models.CharField(_("Nome Completo"), max_length=255)
    cpf = models.CharField(_("CPF"), max_length=14, unique=True)
    rg = models.CharField(_("RG"), max_length=20, blank=True)
    data_nascimento = models.DateField(_("Data de Nascimento"))
    sexo = models.CharField(
        _("Sexo"),
        max_length=1,
        choices=[
            ('M', 'Masculino'),
            ('F', 'Feminino'),
            ('O', 'Outro'),
        ]
    )
    estado_civil = models.CharField(_("Estado Civil"), max_length=50, blank=True)
    profissao = models.CharField(_("Profissão"), max_length=100, blank=True)
    endereco = models.CharField(_("Endereço"), max_length=255)
    numero = models.CharField(_("Número"), max_length=10)
    complemento = models.CharField(_("Complemento"), max_length=100, blank=True)
    bairro = models.CharField(_("Bairro"), max_length=100)
    cidade = models.CharField(_("Cidade"), max_length=100)
    estado = models.CharField(_("Estado"), max_length=2)
    cep = models.CharField(_("CEP"), max_length=9)
    telefone_fixo = models.CharField(_("Telefone Fixo"), max_length=15, blank=True)
    telefone_celular = models.CharField(_("Telefone Celular"), max_length=15)
    email = models.EmailField(_("Email"), blank=True)
    convenio = models.CharField(_("Convênio"), max_length=100, blank=True)
    numero_carteirinha = models.CharField(_("Número da Carteirinha"), max_length=50, blank=True)
    validade_carteirinha = models.DateField(_("Validade da Carteirinha"), blank=True, null=True)
    responsavel_financeiro = models.CharField(_("Responsável Financeiro"), max_length=255, blank=True)
    parentesco_responsavel = models.CharField(_("Parentesco do Responsável"), max_length=50, blank=True)
    cpf_responsavel = models.CharField(_("CPF do Responsável"), max_length=14, blank=True)
    rg_responsavel = models.CharField(_("RG do Responsável"), max_length=20, blank=True)
    telefone_responsavel = models.CharField(_("Telefone do Responsável"), max_length=15, blank=True)
    consentimento_lgpd = models.BooleanField(_("Consentimento LGPD"), default=False)
    data_consentimento = models.DateTimeField(_("Data do Consentimento"), blank=True, null=True)
    observacoes = models.TextField(_("Observações"), blank=True)
    foto = models.ImageField(_("Foto"), upload_to='fotos_pacientes', blank=True)
    data_cadastro = models.DateTimeField(_("Data do Cadastro"), auto_now_add=True)
    data_atualizacao = models.DateTimeField(_("Data da Última Atualização"), auto_now=True)

    def __str__(self):
        return self.nome_completo

    class Meta:
        verbose_name = _("Paciente")
        verbose_name_plural = _("Pacientes")
"""
        )
    print("Arquivo models.py criado com sucesso.")


def criar_serializers():
    serializers_path = os.path.join(BASE_DIR, "serializers.py")
    with open(serializers_path, "w") as f:
        f.write(
            """
from rest_framework import serializers
from .models import Paciente

class PacienteSerializer(serializers.ModelSerializer):
    class Meta:
        model = Paciente
        fields = '__all__'
"""
        )
    print("Arquivo serializers.py criado com sucesso.")


def criar_views():
    views_path = os.path.join(BASE_DIR, "views.py")
    with open(views_path, "w") as f:
        f.write(
            """
from rest_framework import viewsets
from .models import Paciente
from .serializers import PacienteSerializer

class PacienteViewSet(viewsets.ModelViewSet):
    queryset = Paciente.objects.all()
    serializer_class = PacienteSerializer
"""
        )
    print("Arquivo views.py criado com sucesso.")


def criar_urls():
    urls_path = os.path.join(BASE_DIR, "urls.py")
    with open(urls_path, "w") as f:
        f.write(
            """
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PacienteViewSet

router = DefaultRouter()
router.register(r'pacientes', PacienteViewSet)

urlpatterns = [
    path('', include(router.urls)),
]
"""
        )
    print("Arquivo urls.py criado com sucesso.")


def criar_admin():
    admin_path = os.path.join(BASE_DIR, "admin.py")
    with open(admin_path, "w") as f:
        f.write(
            """
from django.contrib import admin
from .models import Paciente

admin.site.register(Paciente)
"""
        )
    print("Arquivo admin.py criado com sucesso.")


def rodar_migracoes():
    # Executar os comandos de makemigrations e migrate
    try:
        subprocess.run(
            ["python", "manage.py", "makemigrations", "pacientes"], check=True
        )
        subprocess.run(["python", "manage.py", "migrate"], check=True)
        print("Migrações criadas e aplicadas com sucesso.")
    except subprocess.CalledProcessError as e:
        print(f"Erro ao rodar migrações: {e}")


if __name__ == "__main__":
    criar_pasta_se_necessario()
    criar_models()
    criar_serializers()
    criar_views()
    criar_urls()
    criar_admin()
    rodar_migracoes()
import os

BASE_DIR = "/mnt/dados/ClinicaAI/backend/apps"  # Caminho base para seus apps
apps = [
    "whatsapp",
    "conhecimento",
    "voip",
    "iot",
    "aprovacoes",
    "mensagens",
    "produtividade",
    "compromissos",
    "central_ajuda",
    "servico_campo",
    "planilhas_horas",
    "projeto",
    "pesquisas",
    "automacao_marketing",
    "eventos",
    "marketing_sms",
    "marketing_email",
    "redes_sociais",
    "frota",
    "indicacoes",
    "avaliacoes",
    "folgas",
    "recrutamento",
    "recursos_humanos",
    "qualidade",
    "manutencao",
    "compras",
    "plm",
    "fabricacao",
    "inventario",
    "elearning",
    "chat_ao_vivo",
    "forum",
    "blog",
    "ecommerce",
    "criador_sites",
    "locacao",
    "assinaturas",
    "crm",
    "vendas",
    "assinar_documentos",
    "documentos",
    "planilhas",
    "despesas",
    "faturamento",
    "financeiro",
    "agendamentos",
    "pacientes",
]

for app in apps:
    app_dir = os.path.join(BASE_DIR, app)
    if not os.path.exists(app_dir):
        os.makedirs(app_dir)
        # Criando arquivos básicos em cada app
        with open(os.path.join(app_dir, "models.py"), "w") as f:
            f.write(
                f"from django.db import models\n\n"
                f"class {app.capitalize()}(models.Model):\n"
                f"    nome = models.CharField(max_length=100)\n\n"
                f"    def __str__(self):\n"
                f"        return self.nome\n"
            )

        with open(os.path.join(app_dir, "views.py"), "w") as f:
            f.write(
                f"from rest_framework import viewsets\n"
                f"from .models import {app.capitalize()}\n"
                f"from .serializers import {app.capitalize()}Serializer\n\n"
                f"class {app.capitalize()}ViewSet(viewsets.ModelViewSet):\n"
                f"    queryset = {app.capitalize()}.objects.all()\n"
                f"    serializer_class = {app.capitalize()}Serializer\n"
            )

        with open(os.path.join(app_dir, "serializers.py"), "w") as f:
            f.write(
                f"from rest_framework import serializers\n"
                f"from .models import {app.capitalize()}\n\n"
                f"class {app.capitalize()}Serializer(serializers.ModelSerializer):\n"
                f"    class Meta:\n"
                f"        model = {app.capitalize()}\n"
                f"        fields = '__all__'\n"
            )

        with open(os.path.join(app_dir, "admin.py"), "w") as f:
            f.write(
                f"from django.contrib import admin\n"
                f"from .models import {app.capitalize()}\n\n"
                f"admin.site.register({app.capitalize()})\n"
            )

        with open(os.path.join(app_dir, "apps.py"), "w") as f:
            f.write(
                f"from django.apps import AppConfig\n\n"
                f"class {app.capitalize()}Config(AppConfig):\n"
                f"    default_auto_field = 'django.db.models.BigAutoField'\n"
                f"    name = 'apps.{app}'\n"
            )

print("Estrutura básica dos módulos criada com sucesso.")
from rest_framework import viewsets
from .models import DespesasModel
from .serializers import DespesasSerializer


class DespesasViewSet(viewsets.ModelViewSet):
    queryset = DespesasModel.objects.all()
    serializer_class = DespesasSerializer
from django.apps import AppConfig


class DespesasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.despesas"
from django.db import models


class DespesasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import DespesasViewSet

router = DefaultRouter()
router.register(r"despesas", DespesasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import DespesasModel


@admin.register(DespesasModel)
class DespesasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import DespesasModel


class DespesasSerializer(serializers.ModelSerializer):
    class Meta:
        model = DespesasModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import IndicacoesModel
from .serializers import IndicacoesSerializer


class IndicacoesViewSet(viewsets.ModelViewSet):
    queryset = IndicacoesModel.objects.all()
    serializer_class = IndicacoesSerializer
from django.apps import AppConfig


class IndicacoesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.indicacoes"
from django.db import models


class IndicacoesModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import IndicacoesViewSet

router = DefaultRouter()
router.register(r"indicacoes", IndicacoesViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import IndicacoesModel


@admin.register(IndicacoesModel)
class IndicacoesAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import IndicacoesModel


class IndicacoesSerializer(serializers.ModelSerializer):
    class Meta:
        model = IndicacoesModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
# Módulo Prontuários - Views (views.py)

from . import views
from rest_framework.routers import DefaultRouter
from django.urls import path, include
from rest_framework import viewsets
from .models import (
    Prontuario,
    HistoricoMedicamentos,
    EvolucaoClinica,
    DadosVitais,
    HistoricoAcessosProntuario,
    ExameComplementar,
)
from .serializers import (
    ProntuarioSerializer,
    HistoricoMedicamentosSerializer,
    EvolucaoClinicaSerializer,
    DadosVitaisSerializer,
    HistoricoAcessosProntuarioSerializer,
    ExameComplementarSerializer,
)
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from rest_framework.decorators import action
from rest_framework.permissions import BasePermission, SAFE_METHODS

# Custom permission to restrict read/write access based on user roles


class IsAdminOrReadOnly(BasePermission):
    def has_permission(self, request, view):
        if request.method in SAFE_METHODS:
            return True
        return request.user and request.user.is_staff


class IsDoctorOrReadOnly(BasePermission):
    def has_permission(self, request, view):
        if request.method in SAFE_METHODS:
            return True
        return (
            request.user
            and request.user.groups.filter(name="Doctor").exists()
            or request.user.is_staff
        )


# Views


class ProntuarioViewSet(viewsets.ModelViewSet):
    queryset = Prontuario.objects.all()
    serializer_class = ProntuarioSerializer
    permission_classes = [IsAuthenticated]

    def create(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de criar
        data = request.data.copy()
        sensitive_fields = ["created_by", "updated_by", "uuid"]
        for field in sensitive_fields:
            data.pop(field, None)
        serializer = self.get_serializer(data=data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(
            serializer.data, status=status.HTTP_201_CREATED, headers=headers
        )

    def update(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de atualizar
        data = request.data.copy()
        sensitive_fields = ["created_by", "updated_by", "uuid"]
        for field in sensitive_fields:
            data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


class HistoricoMedicamentosViewSet(viewsets.ModelViewSet):
    queryset = HistoricoMedicamentos.objects.all()
    serializer_class = HistoricoMedicamentosSerializer
    permission_classes = [IsAuthenticated, IsAdminOrReadOnly]

    def create(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de criar
        data = request.data.copy()
        sensitive_fields = ["prescrito_por"]
        for field in sensitive_fields:
            if not request.user.is_staff:
                data.pop(field, None)
        serializer = self.get_serializer(data=data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(
            serializer.data, status=status.HTTP_201_CREATED, headers=headers
        )

    def update(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de atualizar
        data = request.data.copy()
        sensitive_fields = ["prescrito_por"]
        for field in sensitive_fields:
            if not request.user.is_staff:
                data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


class EvolucaoClinicaViewSet(viewsets.ModelViewSet):
    queryset = EvolucaoClinica.objects.all()
    serializer_class = EvolucaoClinicaSerializer
    permission_classes = [IsAuthenticated, IsDoctorOrReadOnly]

    def update(self, request, *args, **kwargs):
        # Limitar campos que podem ser editados por diferentes tipos de
        # usuários
        data = request.data.copy()
        restricted_fields = ["data_evolucao", "profissional_responsavel"]
        if not request.user.is_staff:
            for field in restricted_fields:
                data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


class DadosVitaisViewSet(viewsets.ModelViewSet):
    queryset = DadosVitais.objects.all()
    serializer_class = DadosVitaisSerializer
    permission_classes = [IsAuthenticated, IsDoctorOrReadOnly]

    def create(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de criar
        data = request.data.copy()
        sensitive_fields = [
            "pressao_arterial",
            "frequencia_cardiaca",
            "temperatura",
            "saturacao_oxigenio",
            "glicemia",
            "colesterol_total",
            "triglicerides",
        ]
        if (
            not request.user.groups.filter(name="Doctor").exists()
            and not request.user.is_staff
        ):
            for field in sensitive_fields:
                data.pop(field, None)
        serializer = self.get_serializer(data=data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(
            serializer.data, status=status.HTTP_201_CREATED, headers=headers
        )

    def update(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de atualizar
        data = request.data.copy()
        sensitive_fields = [
            "pressao_arterial",
            "frequencia_cardiaca",
            "temperatura",
            "saturacao_oxigenio",
            "glicemia",
            "colesterol_total",
            "triglicerides",
        ]
        if (
            not request.user.groups.filter(name="Doctor").exists()
            and not request.user.is_staff
        ):
            for field in sensitive_fields:
                data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


class HistoricoAcessosProntuarioViewSet(viewsets.ModelViewSet):
    queryset = HistoricoAcessosProntuario.objects.all()
    serializer_class = HistoricoAcessosProntuarioSerializer
    permission_classes = [IsAuthenticated]

    def list(self, request, *args, **kwargs):
        # Restringir campos sensíveis durante a listagem
        if not request.user.is_staff:
            queryset = self.filter_queryset(self.get_queryset()).defer(
                "usuario", "tipo_acesso"
            )
        else:
            queryset = self.filter_queryset(self.get_queryset())
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)


class ExameComplementarViewSet(viewsets.ModelViewSet):
    queryset = ExameComplementar.objects.all()
    serializer_class = ExameComplementarSerializer
    permission_classes = [IsAuthenticated, IsDoctorOrReadOnly]

    def create(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de criar
        data = request.data.copy()
        sensitive_fields = ["resultado", "imagem_associada"]
        if (
            not request.user.groups.filter(name="Doctor").exists()
            and not request.user.is_staff
        ):
            for field in sensitive_fields:
                data.pop(field, None)
        serializer = self.get_serializer(data=data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(
            serializer.data, status=status.HTTP_201_CREATED, headers=headers
        )

    def update(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de atualizar
        data = request.data.copy()
        sensitive_fields = ["resultado", "imagem_associada"]
        if (
            not request.user.groups.filter(name="Doctor").exists()
            and not request.user.is_staff
        ):
            for field in sensitive_fields:
                data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


# URL Routing (urls.py)

router = DefaultRouter()
router.register(r"prontuarios", views.ProntuarioViewSet)
router.register(r"historico_medicamentos", views.HistoricoMedicamentosViewSet)
router.register(r"evolucoes_clinicas", views.EvolucaoClinicaViewSet)
router.register(r"dados_vitais", views.DadosVitaisViewSet)
router.register(r"historico_acessos", views.HistoricoAcessosProntuarioViewSet)
router.register(r"exames_complementares", views.ExameComplementarViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
# Módulo Prontuários - Criação do Modelo (models.py)

from django.db import models
from django.utils.translation import gettext_lazy as _
import uuid
from django.conf import settings


class Prontuario(models.Model):
    # Identificador Único Global
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    # Dados Relacionados ao Paciente
    paciente = models.ForeignKey(
    "pacientes.Paciente",
    on_delete=models.CASCADE,
    related_name="prontuarios",  # Alterar para evitar conflito com campo em Paciente
)

    # Evoluções Clínicas e Atendimentos
    data_atendimento = models.DateTimeField(_("Data do Atendimento"))
    profissional_responsavel = models.ForeignKey(
    "profissionais.Profissional",
    on_delete=models.SET_NULL,
    null=True,
    related_name="exames_solicitados_complementar",  # Alterar para um nome único
)

    queixa_principal = models.TextField(_("Queixa Principal"), blank=True)
    historico_doenca_atual = models.TextField(
        _("Histórico da Doença Atual"), blank=True
    )
    antecedentes_pessoais = models.TextField(_("Antecedentes Pessoais"), blank=True)
    exame_fisico_cabeca_pescoco = models.TextField(
        _("Exame Físico - Cabeça e Pescoço"), blank=True
    )
    exame_fisico_torax = models.TextField(_("Exame Físico - Tórax"), blank=True)
    exame_fisico_abdomen = models.TextField(_("Exame Físico - Abdômen"), blank=True)
    exame_fisico_membros = models.TextField(
        _("Exame Físico - Membros Superiores e Inferiores"), blank=True
    )
    hipotese_diagnostica = models.TextField(_("Hipótese Diagnóstica"), blank=True)
    conduta = models.TextField(_("Conduta/Plano"), blank=True)
    prescricao = models.TextField(_("Prescrição Médica"), blank=True)
    tratamentos_previos = models.TextField(_("Tratamentos Prévio(s)"), blank=True)

    # Diagnósticos
    diagnostico_final = models.CharField(
        _("Diagnóstico Final"), max_length=255, blank=True
    )
    cid_10 = models.CharField(_("CID-10"), max_length=10, blank=True)

    # Anotações de Outros Profissionais
    anotacoes_profissionais = models.TextField(
        _("Anotações de Outros Profissionais"), blank=True
    )

    # Referências e Encaminhamentos
    encaminhamentos = models.TextField(_("Encaminhamentos"), blank=True)
    referencias_especialidades = models.TextField(
        _("Referências para Especialidades"), blank=True
    )

    # Consentimento e Termos
    consentimento_informado = models.BooleanField(
        _("Consentimento Informado Assinado"), default=False
    )

    # Histórico Familiar
    historico_familiar = models.TextField(_("Histórico Familiar"), blank=True)
    risco_genetico = models.TextField(_("Risco Genético Identificado"), blank=True)

    # Dados Psicológicos e Sociais
    dados_psicossociais = models.TextField(
        _("Dados Psicológicos e Sociais"), blank=True
    )
    estado_emocional = models.TextField(_("Estado Emocional"), blank=True)
    transtornos_identificados = models.TextField(
        _("Transtornos Identificados"), blank=True
    )
    medicacoes_psiquiatricas = models.TextField(
        _("Medicações Psiquiátricas"), blank=True
    )

    # Histórico de Hábitos de Vida
    tabagismo = models.BooleanField(_("Tabagismo"), default=False)
    etilismo = models.BooleanField(_("Etilismo"), default=False)
    uso_drogas = models.BooleanField(_("Uso de Drogas"), default=False)
    atividade_fisica = models.CharField(
        _("Atividade Física"), max_length=255, blank=True
    )
    alimentacao = models.CharField(_("Alimentação"), max_length=255, blank=True)
    qualidade_sono = models.CharField(
        _("Qualidade do Sono"), max_length=255, blank=True
    )
    ocupacao = models.CharField(_("Ocupação"), max_length=255, blank=True)
    nivel_estresse = models.CharField(
        _("Nível de Estresse"), max_length=255, blank=True
    )
    medicacoes_nao_prescritas = models.TextField(
        _("Medicações Não Prescritas"), blank=True
    )

    # Histórico de Cirurgias e Internações
    historico_cirurgias = models.TextField(_("Histórico de Cirurgias"), blank=True)
    historico_internacoes = models.TextField(_("Histórico de Internações"), blank=True)

    # Histórico de Imunizações
    imunizacoes = models.TextField(_("Histórico de Imunizações"), blank=True)

    # Estratificação de Risco
    estratificacao_risco = models.CharField(
        _("Estratificação de Risco"), max_length=255, blank=True
    )
    risco_quedas = models.CharField(_("Risco de Quedas"), max_length=255, blank=True)

    # Motivo do Atendimento
    motivo_atendimento = models.CharField(
        _("Motivo do Atendimento"), max_length=255, blank=True
    )

    # Acompanhamento de Doenças Crônicas
    diabetes_hemoglobina_glicada = models.DecimalField(
        _("Hemoglobina Glicada (%)"),
        max_digits=4,
        decimal_places=2,
        blank=True,
        null=True,
    )
    funcao_renal_taxa_filtracao = models.DecimalField(
        _("Taxa de Filtração Glomerular (mL/min)"),
        max_digits=5,
        decimal_places=2,
        blank=True,
        null=True,
    )

    # Avaliação Nutricional
    imc = models.DecimalField(
        _("Índice de Massa Corporal (IMC)"),
        max_digits=4,
        decimal_places=1,
        blank=True,
        null=True,
    )
    percentual_gordura_corporal = models.DecimalField(
        _("Percentual de Gordura Corporal (%)"),
        max_digits=4,
        decimal_places=1,
        blank=True,
        null=True,
    )
    dieta_recomendada = models.TextField(_("Dieta Recomendada"), blank=True)

    # Planos de Saúde e Seguros
    plano_saude = models.CharField(_("Plano de Saúde"), max_length=255, blank=True)
    numero_plano_saude = models.CharField(
        _("Número do Plano de Saúde"), max_length=255, blank=True
    )

    # Auditoria
    created_at = models.DateTimeField(_("Data de Criação"), auto_now_add=True)
    updated_at = models.DateTimeField(_("Última Atualização"), auto_now=True)
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name="prontuarios_criados",
    )
    updated_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name="prontuarios_atualizados",
    )

    class Meta:
        verbose_name = _("Prontuário")
        verbose_name_plural = _("Prontuários")

    def __str__(self):
        return f"Prontuário do paciente: {self.paciente.nome_completo}"


class HistoricoMedicamentos(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="historico_medicamentos"
    )
    medicamento = models.CharField(_("Medicamento"), max_length=255)
    dosagem = models.CharField(_("Dosagem"), max_length=255)
    frequencia = models.CharField(_("Frequência"), max_length=255)
    duracao = models.CharField(_("Duração"), max_length=255)
    observacoes = models.TextField(_("Observações"), blank=True)
    prescrito_por = models.ForeignKey(
        "profissionais.Profissional", on_delete=models.SET_NULL, null=True
    )
    data_prescricao = models.DateTimeField(_("Data da Prescrição"), auto_now_add=True)

    class Meta:
        verbose_name = _("Histórico de Medicamento")
        verbose_name_plural = _("Histórico de Medicamentos")

    def __str__(self):
        return f"Medicamento: {self.medicamento} - Paciente: {self.prontuario.paciente.nome_completo}"


class EvolucaoClinica(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="evolucoes_clinicas"
    )
    data_evolucao = models.DateTimeField(_("Data da Evolução"), auto_now_add=True)
    profissional_responsavel = models.ForeignKey(
        "profissionais.Profissional", on_delete=models.SET_NULL, null=True
    )
    descricao = models.TextField(_("Descrição da Evolução"))

    class Meta:
        verbose_name = _("Evolução Clínica")
        verbose_name_plural = _("Evoluções Clínicas")

    def __str__(self):
        return f"Evolução em {self.data_evolucao} - Paciente: {self.prontuario.paciente.nome_completo}"


class DadosVitais(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="dados_vitais"
    )
    data_registro = models.DateTimeField(_("Data do Registro"), auto_now_add=True)
    pressao_arterial = models.CharField(
        _("Pressão Arterial"), max_length=50, blank=True
    )
    frequencia_cardiaca = models.CharField(
        _("Frequência Cardíaca"), max_length=50, blank=True
    )
    temperatura = models.DecimalField(
        _("Temperatura Corporal (°C)"),
        max_digits=4,
        decimal_places=1,
        blank=True,
        null=True,
    )
    saturacao_oxigenio = models.CharField(
        _("Saturação de Oxigênio (%)"), max_length=50, blank=True
    )
    peso = models.DecimalField(
        _("Peso (kg)"), max_digits=5, decimal_places=2, blank=True, null=True
    )
    altura = models.DecimalField(
        _("Altura (m)"), max_digits=4, decimal_places=2, blank=True, null=True
    )
    glicemia = models.DecimalField(
        _("Glicemia (mg/dL)"), max_digits=5, decimal_places=2, blank=True, null=True
    )
    colesterol_total = models.DecimalField(
        _("Colesterol Total (mg/dL)"),
        max_digits=5,
        decimal_places=2,
        blank=True,
        null=True,
    )
    triglicerides = models.DecimalField(
        _("Triglicérides (mg/dL)"),
        max_digits=5,
        decimal_places=2,
        blank=True,
        null=True,
    )

    class Meta:
        verbose_name = _("Dados Vitais")
        verbose_name_plural = _("Dados Vitais")

    def __str__(self):
        return f"Dados Vitais em {self.data_registro} - Paciente: {self.prontuario.paciente.nome_completo}"


class HistoricoAcessosProntuario(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="historico_acessos"
    )
    usuario = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True
    )
    data_acesso = models.DateTimeField(_("Data do Acesso"), auto_now_add=True)
    tipo_acesso = models.CharField(
        _("Tipo de Acesso"),
        max_length=50,
        choices=[("visualizacao", "Visualização"), ("alteracao", "Alteração")],
    )

    class Meta:
        verbose_name = _("Histórico de Acesso ao Prontuário")
        verbose_name_plural = _("Histórico de Acessos ao Prontuário")

    def __str__(self):
        return f"Acesso em {self.data_acesso} - Paciente: {self.prontuario.paciente.nome_completo} por {self.usuario}"


class ExameComplementar(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="exames_complementares"
    )
    tipo_exame = models.CharField(_("Tipo de Exame"), max_length=255)
    data_solicitacao = models.DateTimeField(_("Data da Solicitação"), auto_now_add=True)
    data_resultado = models.DateTimeField(_("Data do Resultado"), null=True, blank=True)
    resultado = models.TextField(_("Resultado do Exame"), blank=True)
    profissional_responsavel = models.ForeignKey(
        "profissionais.Profissional",
        on_delete=models.SET_NULL,
        null=True,
        related_name="exames_solicitados",
    )
    imagem_associada = models.ImageField(
        _("Imagem Associada"), upload_to="exames/imagens/", blank=True, null=True
    )

    class Meta:
        verbose_name = _("Exame Complementar")
        verbose_name_plural = _("Exames Complementares")

    def __str__(self):
        return f"Exame: {self.tipo_exame} - Paciente: {self.prontuario.paciente.nome_completo}"


class ProcedimentoRealizado(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="procedimentos_realizados"
    )
    tipo_procedimento = models.CharField(_("Tipo de Procedimento"), max_length=255)
    data_procedimento = models.DateTimeField(
        _("Data do Procedimento"), auto_now_add=True
    )
    profissional_responsavel = models.ForeignKey(
        "profissionais.Profissional",
        on_delete=models.SET_NULL,
        null=True,
        related_name="procedimentos_realizados",
    )
    observacoes = models.TextField(_("Observações"), blank=True)
    consentimento_associado = models.ForeignKey(
        "assinaturas.Assinatura",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="procedimentos_consentidos",
    )

    class Meta:
        verbose_name = _("Procedimento Realizado")
        verbose_name_plural = _("Procedimentos Realizados")
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ProntuarioViewSet

router = DefaultRouter()
router.register(r"prontuarios", ProntuarioViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Prontuario

admin.site.register(Prontuario)
# Módulo Prontuários - Serializers (serializers.py)

from rest_framework import serializers
from .models import (
    Prontuario,
    HistoricoMedicamentos,
    EvolucaoClinica,
    DadosVitais,
    HistoricoAcessosProntuario,
    ExameComplementar,
)


class ProntuarioSerializer(serializers.ModelSerializer):
    class Meta:
        model = Prontuario
        fields = "__all__"


class HistoricoMedicamentosSerializer(serializers.ModelSerializer):
    class Meta:
        model = HistoricoMedicamentos
        fields = "__all__"


class EvolucaoClinicaSerializer(serializers.ModelSerializer):
    class Meta:
        model = EvolucaoClinica
        fields = "__all__"


class DadosVitaisSerializer(serializers.ModelSerializer):
    class Meta:
        model = DadosVitais
        fields = "__all__"


class HistoricoAcessosProntuarioSerializer(serializers.ModelSerializer):
    class Meta:
        model = HistoricoAcessosProntuario
        fields = "__all__"


class ExameComplementarSerializer(serializers.ModelSerializer):
    class Meta:
        model = ExameComplementar
        fields = "__all__"
from django.test import TestCase
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from django.contrib.auth.models import User, Group
from .models import (
    Prontuario,
    HistoricoMedicamentos,
    EvolucaoClinica,
    DadosVitais,
    HistoricoAcessosProntuario,
    ExameComplementar,
)


class ProntuarioAPITestCase(APITestCase):
    def setUp(self):
        # Criação de usuários e grupos para testar permissões
        self.admin_user = User.objects.create_superuser(
            "admin", "admin@example.com", "password123"
        )
        self.doctor_user = User.objects.create_user(
            "doctor", "doctor@example.com", "password123"
        )
        doctor_group, created = Group.objects.get_or_create(name="Doctor")
        self.doctor_user.groups.add(doctor_group)
        self.patient_user = User.objects.create_user(
            "patient", "patient@example.com", "password123"
        )

        # Criação de dados iniciais
        self.prontuario = Prontuario.objects.create(paciente_id=1)

    def test_create_prontuario_as_admin(self):
        self.client.force_authenticate(user=self.admin_user)
        data = {"paciente": 1, "queixa_principal": "Dor de cabeça persistente"}
        response = self.client.post(reverse("prontuarios-list"), data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

    def test_create_prontuario_as_patient(self):
        self.client.force_authenticate(user=self.patient_user)
        data = {"paciente": 1, "queixa_principal": "Dor de cabeça persistente"}
        response = self.client.post(reverse("prontuarios-list"), data)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_list_prontuarios_as_doctor(self):
        self.client.force_authenticate(user=self.doctor_user)
        response = self.client.get(reverse("prontuarios-list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)


class HistoricoMedicamentosAPITestCase(APITestCase):
    def setUp(self):
        self.admin_user = User.objects.create_superuser(
            "admin", "admin@example.com", "password123"
        )
        self.doctor_user = User.objects.create_user(
            "doctor", "doctor@example.com", "password123"
        )
        doctor_group, created = Group.objects.get_or_create(name="Doctor")
        self.doctor_user.groups.add(doctor_group)
        self.patient_user = User.objects.create_user(
            "patient", "patient@example.com", "password123"
        )

        # Criação de dados iniciais
        self.medicamento = HistoricoMedicamentos.objects.create(
            prontuario_id=1, medicamento="Paracetamol", dosagem="500mg"
        )

    def test_create_medicamento_as_doctor(self):
        self.client.force_authenticate(user=self.doctor_user)
        data = {"prontuario": 1, "medicamento": "Ibuprofeno", "dosagem": "400mg"}
        response = self.client.post(reverse("historico_medicamentos-list"), data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

    def test_update_medicamento_as_patient(self):
        self.client.force_authenticate(user=self.patient_user)
        data = {"medicamento": "Aspirina"}
        response = self.client.patch(
            reverse("historico_medicamentos-detail", args=[self.medicamento.id]), data
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)


class EvolucaoClinicaAPITestCase(APITestCase):
    def setUp(self):
        self.admin_user = User.objects.create_superuser(
            "admin", "admin@example.com", "password123"
        )
        self.doctor_user = User.objects.create_user(
            "doctor", "doctor@example.com", "password123"
        )
        doctor_group, created = Group.objects.get_or_create(name="Doctor")
        self.doctor_user.groups.add(doctor_group)

        # Criação de dados iniciais
        self.evolucao = EvolucaoClinica.objects.create(
            prontuario_id=1, descricao="Paciente com sintomas de gripe"
        )

    def test_update_evolucao_as_doctor(self):
        self.client.force_authenticate(user=self.doctor_user)
        data = {"descricao": "Paciente com febre alta e tosse"}
        response = self.client.patch(
            reverse("evolucoes_clinicas-detail", args=[self.evolucao.id]), data
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_update_evolucao_as_patient(self):
        self.client.force_authenticate(user=self.patient_user)
        data = {"descricao": "Tentativa de atualização não permitida"}
        response = self.client.patch(
            reverse("evolucoes_clinicas-detail", args=[self.evolucao.id]), data
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)


class DadosVitaisAPITestCase(APITestCase):
    def setUp(self):
        self.doctor_user = User.objects.create_user(
            "doctor", "doctor@example.com", "password123"
        )
        doctor_group, created = Group.objects.get_or_create(name="Doctor")
        self.doctor_user.groups.add(doctor_group)

        # Criação de dados iniciais
        self.dados_vitais = DadosVitais.objects.create(
            prontuario_id=1, pressao_arterial="120/80"
        )

    def test_create_dados_vitais_as_doctor(self):
        self.client.force_authenticate(user=self.doctor_user)
        data = {
            "prontuario": 1,
            "pressao_arterial": "130/85",
            "frequencia_cardiaca": "75",
        }
        response = self.client.post(reverse("dados_vitais-list"), data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

    def test_create_dados_vitais_as_unauthorized_user(self):
        unauthorized_user = User.objects.create_user(
            "unauthorized", "unauthorized@example.com", "password123"
        )
        self.client.force_authenticate(user=unauthorized_user)
        data = {"prontuario": 1, "pressao_arterial": "130/85"}
        response = self.client.post(reverse("dados_vitais-list"), data)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)
from django.shortcuts import render

# Create your views here.
from django.apps import AppConfig


class Central_ajudaConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.central_ajuda"
from django.db import models

# Create your models here.
from django.contrib import admin

# Register your models here.
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import Marketing_smsModel
from .serializers import Marketing_smsSerializer


class Marketing_smsViewSet(viewsets.ModelViewSet):
    queryset = Marketing_smsModel.objects.all()
    serializer_class = Marketing_smsSerializer
from django.apps import AppConfig


class Marketing_smsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.marketing_sms"
from django.db import models


class Marketing_smsModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Marketing_smsViewSet

router = DefaultRouter()
router.register(r"marketing_sms", Marketing_smsViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Marketing_smsModel


@admin.register(Marketing_smsModel)
class Marketing_smsAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import Marketing_smsModel


class Marketing_smsSerializer(serializers.ModelSerializer):
    class Meta:
        model = Marketing_smsModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import CompromissosModel
from .serializers import CompromissosSerializer


class CompromissosViewSet(viewsets.ModelViewSet):
    queryset = CompromissosModel.objects.all()
    serializer_class = CompromissosSerializer
from django.apps import AppConfig


class CompromissosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.compromissos"
from django.db import models


class CompromissosModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import CompromissosViewSet

router = DefaultRouter()
router.register(r"compromissos", CompromissosViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import CompromissosModel


@admin.register(CompromissosModel)
class CompromissosAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import CompromissosModel


class CompromissosSerializer(serializers.ModelSerializer):
    class Meta:
        model = CompromissosModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from django.shortcuts import render

# Create your views here.
from django.apps import AppConfig


class AprovacoesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.aprovacoes"
from django.db import models

# Create your models here.
from django.contrib import admin

# Register your models here.
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import ForumModel
from .serializers import ForumSerializer


class ForumViewSet(viewsets.ModelViewSet):
    queryset = ForumModel.objects.all()
    serializer_class = ForumSerializer
from django.apps import AppConfig


class ForumConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.forum"
from django.db import models


class ForumModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ForumViewSet

router = DefaultRouter()
router.register(r"forum", ForumViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import ForumModel


@admin.register(ForumModel)
class ForumAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import ForumModel


class ForumSerializer(serializers.ModelSerializer):
    class Meta:
        model = ForumModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from django.shortcuts import render

# Create your views here.
from django.apps import AppConfig


class IotConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.iot"
from django.db import models


class DispositivoIoT(models.Model):
    nome = models.CharField(max_length=255, verbose_name="Nome do Dispositivo")
    descricao = models.TextField(blank=True, verbose_name="Descrição")
    status = models.CharField(
        max_length=100,
        choices=[("ativo", "Ativo"), ("inativo", "Inativo")],
        default="ativo",
    )
    data_registro = models.DateTimeField(
        auto_now_add=True, verbose_name="Data de Registro"
    )
    ultima_comunicacao = models.DateTimeField(
        blank=True, null=True, verbose_name="Última Comunicação"
    )

    class Meta:
        verbose_name = "Dispositivo IoT"
        verbose_name_plural = "Dispositivos IoT"

    def __str__(self):
        return self.nome
from django.contrib import admin

# Register your models here.
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import Servico_campoModel
from .serializers import Servico_campoSerializer


class Servico_campoViewSet(viewsets.ModelViewSet):
    queryset = Servico_campoModel.objects.all()
    serializer_class = Servico_campoSerializer
from django.apps import AppConfig


class Servico_campoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.servico_campo"
from django.db import models


class Servico_campoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Servico_campoViewSet

router = DefaultRouter()
router.register(r"servico_campo", Servico_campoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Servico_campoModel


@admin.register(Servico_campoModel)
class Servico_campoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import Servico_campoModel


class Servico_campoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Servico_campoModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import ElearningModel
from .serializers import ElearningSerializer


class ElearningViewSet(viewsets.ModelViewSet):
    queryset = ElearningModel.objects.all()
    serializer_class = ElearningSerializer
from django.apps import AppConfig


class ElearningConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.elearning"
from django.db import models


class ElearningModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ElearningViewSet

router = DefaultRouter()
router.register(r"elearning", ElearningViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import ElearningModel


@admin.register(ElearningModel)
class ElearningAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import ElearningModel


class ElearningSerializer(serializers.ModelSerializer):
    class Meta:
        model = ElearningModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from django.shortcuts import render

# Create your views here.
from django.apps import AppConfig


class WhatsappConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.whatsapp"
from django.db import models

# Create your models here.
from django.contrib import admin

# Register your models here.
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import Criador_sitesModel
from .serializers import Criador_sitesSerializer


class Criador_sitesViewSet(viewsets.ModelViewSet):
    queryset = Criador_sitesModel.objects.all()
    serializer_class = Criador_sitesSerializer
from django.apps import AppConfig


class Criador_sitesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.criador_sites"
from django.db import models


class Criador_sitesModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Criador_sitesViewSet

router = DefaultRouter()
router.register(r"criador_sites", Criador_sitesViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Criador_sitesModel


@admin.register(Criador_sitesModel)
class Criador_sitesAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import Criador_sitesModel


class Criador_sitesSerializer(serializers.ModelSerializer):
    class Meta:
        model = Criador_sitesModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import InventarioModel
from .serializers import InventarioSerializer


class InventarioViewSet(viewsets.ModelViewSet):
    queryset = InventarioModel.objects.all()
    serializer_class = InventarioSerializer
from django.apps import AppConfig


class InventarioConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.inventario"
from django.db import models


class InventarioModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import InventarioViewSet

router = DefaultRouter()
router.register(r"inventario", InventarioViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import InventarioModel


@admin.register(InventarioModel)
class InventarioAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import InventarioModel


class InventarioSerializer(serializers.ModelSerializer):
    class Meta:
        model = InventarioModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from django.shortcuts import render

# Create your views here.
from django.apps import AppConfig


class PesquisasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.pesquisas"
from django.db import models

# Create your models here.
from django.contrib import admin

# Register your models here.
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import Planilhas_horasModel
from .serializers import Planilhas_horasSerializer


class Planilhas_horasViewSet(viewsets.ModelViewSet):
    queryset = Planilhas_horasModel.objects.all()
    serializer_class = Planilhas_horasSerializer
from django.apps import AppConfig


class Planilhas_horasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.planilhas_horas"
from django.db import models


class Planilhas_horasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Planilhas_horasViewSet

router = DefaultRouter()
router.register(r"planilhas_horas", Planilhas_horasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Planilhas_horasModel


@admin.register(Planilhas_horasModel)
class Planilhas_horasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import Planilhas_horasModel


class Planilhas_horasSerializer(serializers.ModelSerializer):
    class Meta:
        model = Planilhas_horasModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import CrmModel
from .serializers import CrmSerializer


class CrmViewSet(viewsets.ModelViewSet):
    queryset = CrmModel.objects.all()
    serializer_class = CrmSerializer
from django.apps import AppConfig


class CrmConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.crm"
from django.db import models


class CrmModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import CrmViewSet

router = DefaultRouter()
router.register(r"crm", CrmViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import CrmModel


@admin.register(CrmModel)
class CrmAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import CrmModel


class CrmSerializer(serializers.ModelSerializer):
    class Meta:
        model = CrmModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import Transacao
from .serializers import TransacaoSerializer


class TransacaoViewSet(viewsets.ModelViewSet):
    queryset = Transacao.objects.all()
    serializer_class = TransacaoSerializer
from django.apps import AppConfig


class FinanceiroConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.financeiro"
from django.db import models


class Transacao(models.Model):
    descricao = models.CharField(max_length=255)
    valor = models.DecimalField(max_digits=10, decimal_places=2)
    data = models.DateField()
    categoria = models.CharField(max_length=100)
    tipo = models.CharField(
        max_length=50, choices=[("receita", "Receita"), ("despesa", "Despesa")]
    )

    def __str__(self):
        return f"{self.descricao} - {self.valor}"
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import TransacaoViewSet

router = DefaultRouter()
router.register(r"transacoes", TransacaoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Transacao


@admin.register(Transacao)
class TransacaoAdmin(admin.ModelAdmin):
    list_display = ("descricao", "valor", "data", "categoria", "tipo")
from rest_framework import serializers
from .models import Transacao


class TransacaoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Transacao
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import Redes_sociaisModel
from .serializers import Redes_sociaisSerializer


class Redes_sociaisViewSet(viewsets.ModelViewSet):
    queryset = Redes_sociaisModel.objects.all()
    serializer_class = Redes_sociaisSerializer
from django.apps import AppConfig


class Redes_sociaisConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.redes_sociais"
from django.db import models


class Redes_sociaisModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Redes_sociaisViewSet

router = DefaultRouter()
router.register(r"redes_sociais", Redes_sociaisViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Redes_sociaisModel


@admin.register(Redes_sociaisModel)
class Redes_sociaisAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import Redes_sociaisModel


class Redes_sociaisSerializer(serializers.ModelSerializer):
    class Meta:
        model = Redes_sociaisModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
# Módulo Profissionais - Views (views.py)

from rest_framework import viewsets, status
from apps.profissionais.models import (
    Especialidade,
    Profissional,
    Disponibilidade,
    RegistroHorasTrabalhadas,
)
from .serializers import (
    EspecialidadeSerializer,
    ProfissionalSerializer,
    DisponibilidadeSerializer,
    RegistroHorasTrabalhadasSerializer,
)
from rest_framework.permissions import IsAuthenticated, BasePermission
from rest_framework.response import Response
from rest_framework.decorators import action
from django.utils import timezone

# Custom Permissions


class IsAdminOrReadOnly(BasePermission):
    def has_permission(self, request, view):
        if request.method in ["GET"]:
            return True
        return request.user and request.user.is_staff


class IsProfissionalOrReadOnly(BasePermission):
    def has_object_permission(self, request, view, obj):
        if request.method in ["GET", "HEAD", "OPTIONS"]:
            return True
        return obj.usuario == request.user or request.user.is_staff


# Views


class EspecialidadeViewSet(viewsets.ModelViewSet):
    queryset = Especialidade.objects.all()
    serializer_class = EspecialidadeSerializer
    permission_classes = [IsAuthenticated, IsAdminOrReadOnly]


class ProfissionalViewSet(viewsets.ModelViewSet):
    queryset = Profissional.objects.all()
    serializer_class = ProfissionalSerializer
    permission_classes = [IsAuthenticated, IsAdminOrReadOnly]


class DisponibilidadeViewSet(viewsets.ModelViewSet):
    queryset = Disponibilidade.objects.all()
    serializer_class = DisponibilidadeSerializer
    permission_classes = [IsAuthenticated, IsProfissionalOrReadOnly]

    def create(self, request, *args, **kwargs):
        # Validar se a disponibilidade é para uma data futura
        data = request.data.copy()
        dia = data.get("dia")
        if dia:
            dia = timezone.datetime.strptime(dia, "%Y-%m-%d").date()
            if dia < timezone.now().date():
                return Response(
                    {"detail": "A disponibilidade deve ser para uma data futura."},
                    status=status.HTTP_400_BAD_REQUEST,
                )
        return super().create(request, *args, **kwargs)


class RegistroHorasTrabalhadasViewSet(viewsets.ModelViewSet):
    queryset = RegistroHorasTrabalhadas.objects.all()
    serializer_class = RegistroHorasTrabalhadasSerializer
    permission_classes = [IsAuthenticated, IsProfissionalOrReadOnly]

    @action(detail=False, methods=["get"], permission_classes=[IsAuthenticated])
    def minhas_horas(self, request):
        # Retornar as horas trabalhadas do profissional autenticado
        if hasattr(request.user, "profissional"):
            profissional = request.user.profissional
            queryset = RegistroHorasTrabalhadas.objects.filter(
                profissional=profissional
            )
            serializer = self.get_serializer(queryset, many=True)
            return Response(serializer.data)
        return Response(
            {"detail": "Usuário não é um profissional."},
            status=status.HTTP_400_BAD_REQUEST,
        )
from django.apps import AppConfig


class ProfissionaisConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.profissionais"
# Módulo Profissionais - Criação do Modelo (models.py)

from django.db import models
from django.utils.translation import gettext_lazy as _
import uuid
from django.conf import settings


class Especialidade(models.Model):
    nome = models.CharField(
        max_length=100, unique=True, verbose_name=_("Nome da Especialidade")
    )
    descricao = models.TextField(blank=True, verbose_name=_("Descrição"))

    class Meta:
        verbose_name = _("Especialidade")
        verbose_name_plural = _("Especialidades")
        app_label = "profissionais"

    def __str__(self):
        return self.nome


class Profissional(models.Model):
    # Identificador Único Global
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    # Dados Pessoais
    usuario = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="profissional",
        verbose_name=_("Usuário"),
    )
    nome_completo = models.CharField(max_length=255, verbose_name=_("Nome Completo"))
    cpf = models.CharField(max_length=11, unique=True, verbose_name=_("CPF"))
    registro_conselho = models.CharField(
        max_length=50, unique=True, verbose_name=_("Registro no Conselho")
    )
    conselho = models.CharField(
        max_length=100, verbose_name=_("Conselho de Classe (CRM, CRO, etc.)")
    )
    especialidades = models.ManyToManyField(
        Especialidade, related_name="profissionais", verbose_name=_("Especialidades")
    )
    telefone = models.CharField(max_length=20, blank=True, verbose_name=_("Telefone"))
    email = models.EmailField(max_length=255, verbose_name=_("E-mail"))
    endereco = models.CharField(max_length=255, blank=True, verbose_name=_("Endereço"))
    tipo_contratacao = models.CharField(
        max_length=50,
        choices=[
            ("CLT", "CLT"),
            ("PJ", "Pessoa Jurídica"),
            ("Freelancer", "Freelancer"),
        ],
        verbose_name=_("Tipo de Contratação"),
    )
    documentos = models.FileField(
        upload_to="documentos_profissionais/", blank=True, verbose_name=_("Documentos")
    )

    # Dados Profissionais
    horario_atendimento_inicio = models.TimeField(
        verbose_name=_("Horário de Início do Atendimento")
    )
    horario_atendimento_fim = models.TimeField(
        verbose_name=_("Horário de Fim do Atendimento")
    )
    dias_atendimento = models.CharField(
        max_length=50, verbose_name=_("Dias da Semana para Atendimento")
    )

    class Meta:
        verbose_name = _("Profissional")
        verbose_name_plural = _("Profissionais")

    def __str__(self):
        return f"{self.nome_completo} ({self.registro_conselho})"


class Disponibilidade(models.Model):
    profissional = models.ForeignKey(
        Profissional,
        on_delete=models.CASCADE,
        related_name="disponibilidades",
        verbose_name=_("Profissional"),
    )
    dia = models.DateField(verbose_name=_("Dia da Disponibilidade"))
    horario_inicio = models.TimeField(verbose_name=_("Horário de Início"))
    horario_fim = models.TimeField(verbose_name=_("Horário de Fim"))
    disponivel = models.BooleanField(default=True, verbose_name=_("Disponível"))

    class Meta:
        verbose_name = _("Disponibilidade")
        verbose_name_plural = _("Disponibilidades")
        unique_together = (("profissional", "dia", "horario_inicio", "horario_fim"),)

    def __str__(self):
        return f"Disponibilidade de {self.profissional.nome_completo} em {self.dia}"


class RegistroHorasTrabalhadas(models.Model):
    profissional = models.ForeignKey(
        Profissional,
        on_delete=models.CASCADE,
        related_name="horas_trabalhadas",
        verbose_name=_("Profissional"),
    )
    dia = models.DateField(verbose_name=_("Dia"))
    horas_trabalhadas = models.DecimalField(
        max_digits=4, decimal_places=2, verbose_name=_("Horas Trabalhadas")
    )

    class Meta:
        verbose_name = _("Registro de Horas Trabalhadas")
        verbose_name_plural = _("Registros de Horas Trabalhadas")

    def __str__(self):
        return f"Horas trabalhadas por {self.profissional.nome_completo} em {self.dia}"
# Módulo Profissionais - URLs (urls.py)

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r"especialidades", views.EspecialidadeViewSet)
router.register(r"profissionais", views.ProfissionalViewSet)
router.register(r"disponibilidades", views.DisponibilidadeViewSet)
router.register(r"horas_trabalhadas", views.RegistroHorasTrabalhadasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
import random
from django.core.management.base import BaseCommand
from apps.profissionais.models import Profissional, Especialidade
from apps.pacientes.models import Paciente
from apps.exames.models import Exame
from apps.agendamentos.models import Agendamento
from apps.prontuarios.models import Prontuario
from django.contrib.auth import get_user_model
from datetime import date, timedelta, datetime
from faker import Faker
from django.utils import timezone

User = get_user_model()
fake = Faker('pt_BR')

class Command(BaseCommand):
    help = 'Popula o banco de dados com dados de teste mais realistas'

    def handle(self, *args, **kwargs):
        self.stdout.write("Populando banco de dados...\n")
        
        # Criando usuários de exemplo
        users = []
        for i in range(1, 6):
            username = f"usuario{i}"
            user, created = User.objects.get_or_create(username=username, defaults={'password': f"senha123{i}"})
            users.append(user)

        # Criando especialidades
        especialidades_nomes = [
            "Cardiologia", "Dermatologia", "Ortopedia", "Neurologia", "Pediatria"
        ]
        especialidades = []
        for especialidade_nome in especialidades_nomes:
            especialidade, created = Especialidade.objects.get_or_create(nome=especialidade_nome)
            especialidades.append(especialidade)

        # Criando profissionais de saúde
        for i in range(1, 6):
            cpf = self.gerar_cpf_unico()
            registro_conselho = f"CRP-{random.randint(1000, 9999)}"  # Registro único
            profissional, created = Profissional.objects.get_or_create(
                usuario=random.choice(users),
                defaults={
                    'nome_completo': fake.name(),
                    'cpf': cpf,
                    'registro_conselho': registro_conselho,
                    'conselho': "CRM",
                    'telefone': f"1199999{i:04d}",
                    'email': f"profissional{i}@clinicaai.com",
                    'endereco': f"Rua Exemplo, {i}",
                    'tipo_contratacao': random.choice(["CLT", "PJ", "Freelancer"]),
                    'horario_atendimento_inicio': "08:00",
                    'horario_atendimento_fim': "17:00",
                    'dias_atendimento': random.choice(["Segunda a Sexta", "Segunda a Sábado"])
                }
            )
            if created:
                profissional.especialidades.set([random.choice(especialidades)])

        # Criando pacientes
        for i in range(1, 11):
            username = f"paciente{i}"
            user, created = User.objects.get_or_create(username=username, defaults={'password': f"senha123{i}"})
            if hasattr(user, 'paciente') or hasattr(user, 'profissional'):
                continue  # Pule usuários já associados
            cpf = self.gerar_cpf_unico()
            Paciente.objects.get_or_create(
                cpf=cpf,
                defaults={
                    'nome_completo': fake.name(),
                    'data_nascimento': date(1980, 1, 1) + timedelta(days=random.randint(0, 15000)),
                    'telefone_celular': f"99999{random.randint(1000, 9999)}",
                    'email': f"paciente{i}@teste.com"
                }
            )

        # Criando exames
        pacientes = Paciente.objects.all()
        profissionais = Profissional.objects.all()
        exames_nomes = [
            "Exame de sangue", "Raio X", "Ultrassom", "ECG", "Teste de glicose"
        ]
        exames = []
        for exame_nome in exames_nomes:
            paciente = random.choice(pacientes)
            profissional = random.choice(profissionais)
            exame, created = Exame.objects.get_or_create(
                tipo_exame=exame_nome,
                paciente=paciente,
                profissional_solicitante=profissional,
                defaults={
                    'observacoes': f"Descrição do {exame_nome}",
                    'data_solicitacao': date.today()
                }
            )
            exames.append(exame)

        # Criando agendamentos sem conflitos
        for i in range(1, 11):
            profissional = random.choice(profissionais)
            data_agendamento = date.today() + timedelta(days=random.randint(1, 30))
            horario_inicio = random.randint(8, 16)
            horario_fim = horario_inicio + 1  # Garante que o horário de fim seja posterior

            if not Agendamento.objects.filter(
                profissional=profissional,
                data_agendamento=data_agendamento,
                horario_inicio=f"{horario_inicio}:00"
            ).exists():
                Agendamento.objects.create(
                    paciente=random.choice(pacientes),
                    profissional=profissional,
                    data_agendamento=data_agendamento,
                    horario_inicio=f"{horario_inicio}:00",
                    horario_fim=f"{horario_fim}:00",
                    tipo_consulta=random.choice(["Consulta de rotina", "Retorno", "Urgência"])
                )

        # Criando prontuários
        agendamentos = Agendamento.objects.all()
        for agendamento in agendamentos:
            Prontuario.objects.update_or_create(
                paciente=agendamento.paciente,
                profissional_responsavel=agendamento.profissional,
                data_atendimento=datetime.combine(agendamento.data_agendamento, datetime.min.time(), tzinfo=timezone.utc),
                defaults={
                    'queixa_principal': "Diagnóstico fictício e tratamento sugerido."
                }
            )

        self.stdout.write(self.style.SUCCESS("Banco de dados populado com sucesso!"))

    def gerar_cpf_unico(self):
        while True:
            cpf = f"{random.randint(10000000000, 99999999999)}"
            if not Profissional.objects.filter(cpf=cpf).exists() and not Paciente.objects.filter(cpf=cpf).exists():
                return cpf
from django.core.management.base import BaseCommand
from apps.profissionais.models import Profissional, Especialidade
from apps.pacientes.models import Paciente
from apps.exames.models import Exame
from apps.agendamentos.models import Agendamento
from apps.prontuarios.models import Prontuario
from django.contrib.auth import get_user_model

User = get_user_model()

class Command(BaseCommand):
    help = 'Apaga todos os dados do banco de dados'

    def handle(self, *args, **kwargs):
        self.stdout.write("Apagando todos os dados do banco de dados...\n")

        # Apagar os registros em ordem para evitar erros de chaves estrangeiras
        Agendamento.objects.all().delete()
        Prontuario.objects.all().delete()
        Exame.objects.all().delete()
        Paciente.objects.all().delete()
        Profissional.objects.all().delete()
        Especialidade.objects.all().delete()
        User.objects.exclude(is_superuser=True).delete()  # Preserva o superusuário

        self.stdout.write(self.style.SUCCESS("Todos os dados foram apagados com sucesso!"))
import random
from django.core.management.base import BaseCommand
from apps.profissionais.models import Profissional, Especialidade
from apps.pacientes.models import Paciente
from apps.exames.models import Exame
from apps.agendamentos.models import Agendamento
from apps.prontuarios.models import Prontuario
from django.contrib.auth import get_user_model
from datetime import date, timedelta, datetime
from django.utils import timezone

User = get_user_model()

class Command(BaseCommand):
    help = 'Popula o banco de dados com dados de teste'

    def handle(self, *args, **kwargs):
        self.stdout.write("Populando banco de dados...\n")
        
        # Criando usuários de exemplo
        users = []
        for i in range(1, 6):
            username = f"usuario{i}"
            user, created = User.objects.get_or_create(username=username, defaults={'password': f"senha123{i}"})
            users.append(user)

        # Criando especialidades
        especialidades_nomes = [
            "Cardiologia", "Dermatologia", "Ortopedia", "Neurologia", "Pediatria"
        ]
        especialidades = []
        for especialidade_nome in especialidades_nomes:
            especialidade, created = Especialidade.objects.get_or_create(nome=especialidade_nome)
            especialidades.append(especialidade)

        # Criando profissionais de saúde
        for i in range(1, 6):
            cpf = self.gerar_cpf_unico()
            registro_conselho = f"CRP-{random.randint(1000, 9999)}"  # Registro único
            profissional, created = Profissional.objects.get_or_create(
                usuario=random.choice(users),
                defaults={
                    'nome_completo': f"Profissional {i}",
                    'cpf': cpf,
                    'registro_conselho': registro_conselho,
                    'conselho': "CRM",
                    'telefone': f"1199999{i:04d}",
                    'email': f"profissional{i}@clinicaai.com",
                    'endereco': f"Rua Exemplo, {i}",
                    'tipo_contratacao': random.choice(["CLT", "PJ", "Freelancer"]),
                    'horario_atendimento_inicio': "08:00",
                    'horario_atendimento_fim': "17:00",
                    'dias_atendimento': random.choice(["Segunda a Sexta", "Segunda a Sábado"])
                }
            )
            if created:
                profissional.especialidades.set([random.choice(especialidades)])

        # Criando pacientes
        for i in range(1, 11):
            username = f"paciente{i}"
            user, created = User.objects.get_or_create(username=username, defaults={'password': f"senha123{i}"})
            if hasattr(user, 'paciente') or hasattr(user, 'profissional'):
                continue  # Pule usuários já associados
            cpf = self.gerar_cpf_unico()
            Paciente.objects.get_or_create(
                cpf=cpf,
                defaults={
                    'nome_completo': f"Paciente {i}",
                    'data_nascimento': date(1980, 1, 1) + timedelta(days=random.randint(0, 15000)),
                    'telefone_celular': f"99999{random.randint(1000, 9999)}",
                    'email': f"paciente{i}@teste.com"
                }
            )

        # Criando exames
        pacientes = Paciente.objects.all()
        profissionais = Profissional.objects.all()
        exames_nomes = [
            "Exame de sangue", "Raio X", "Ultrassom", "ECG", "Teste de glicose"
        ]
        exames = []
        for exame_nome in exames_nomes:
            paciente = random.choice(pacientes)
            profissional = random.choice(profissionais)
            exame, created = Exame.objects.get_or_create(
                tipo_exame=exame_nome,
                paciente=paciente,
                profissional_solicitante=profissional,
                defaults={
                    'observacoes': f"Descrição do {exame_nome}",
                    'data_solicitacao': date.today()
                }
            )
            exames.append(exame)

        # Criando agendamentos
        for i in range(1, 11):
            horario_inicio = random.randint(8, 16)
            horario_fim = horario_inicio + 1  # Garante que o horário de fim seja posterior
            Agendamento.objects.get_or_create(
                paciente=random.choice(pacientes),
                profissional=random.choice(profissionais),
                data_agendamento=date.today() + timedelta(days=random.randint(1, 30)),
                horario_inicio=f"{horario_inicio}:00",
                horario_fim=f"{horario_fim}:00",
                tipo_consulta=random.choice(["Consulta de rotina", "Retorno", "Urgência"])
            )

        # Criando prontuários
        agendamentos = Agendamento.objects.all()
        for agendamento in agendamentos:
            Prontuario.objects.update_or_create(
                paciente=agendamento.paciente,
                profissional_responsavel=agendamento.profissional,
                data_atendimento=datetime.combine(agendamento.data_agendamento, datetime.min.time(), tzinfo=timezone.utc),
                defaults={
                    'queixa_principal': "Diagnóstico fictício e tratamento sugerido."
                }
            )

        self.stdout.write(self.style.SUCCESS("Banco de dados populado com sucesso!"))

    def gerar_cpf_unico(self):
        while True:
            cpf = f"{random.randint(10000000000, 99999999999)}"
            if not Profissional.objects.filter(cpf=cpf).exists() and not Paciente.objects.filter(cpf=cpf).exists():
                return cpf
from django.contrib import admin
from .models import Profissional, Especialidade, Disponibilidade, RegistroHorasTrabalhadas

@admin.register(Profissional)
class ProfissionalAdmin(admin.ModelAdmin):
    list_display = ['nome_completo', 'registro_conselho', 'conselho', 'email']
    search_fields = ['nome_completo', 'registro_conselho']

@admin.register(Especialidade)
class EspecialidadeAdmin(admin.ModelAdmin):
    list_display = ['nome', 'descricao']
    search_fields = ['nome']

@admin.register(Disponibilidade)
class DisponibilidadeAdmin(admin.ModelAdmin):
    list_display = ['profissional', 'dia', 'horario_inicio', 'horario_fim']
    list_filter = ['dia', 'disponivel']

@admin.register(RegistroHorasTrabalhadas)
class RegistroHorasTrabalhadasAdmin(admin.ModelAdmin):
    list_display = ['profissional', 'dia', 'horas_trabalhadas']
    list_filter = ['dia']
# Módulo Profissionais - Serializers (serializers.py)

from rest_framework import serializers
from apps.profissionais.models import (
    Especialidade,
    Profissional,
    Disponibilidade,
    RegistroHorasTrabalhadas,
)


class EspecialidadeSerializer(serializers.ModelSerializer):
    class Meta:
        model = Especialidade
        fields = "__all__"


class ProfissionalSerializer(serializers.ModelSerializer):
    class Meta:
        model = Profissional
        fields = "__all__"


class DisponibilidadeSerializer(serializers.ModelSerializer):
    class Meta:
        model = Disponibilidade
        fields = "__all__"


class RegistroHorasTrabalhadasSerializer(serializers.ModelSerializer):
    class Meta:
        model = RegistroHorasTrabalhadas
        fields = "__all__"
# Módulo Assinaturas - Views (views.py)

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Documento, Assinatura
from .serializers import DocumentoSerializer, AssinaturaSerializer
from django.utils import timezone
import threading
from django.core.exceptions import ValidationError
import logging

logger = logging.getLogger(__name__)


def enviar_notificacao(titulo, mensagem, destinatarios):
    # Função de envio de notificação (placeholder)
    pass

class DocumentoViewSet(viewsets.ModelViewSet):
    queryset = Documento.objects.all()
    serializer_class = DocumentoSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna os documentos do paciente ou profissional autenticado
        user = self.request.user
        if hasattr(user, 'paciente'):
            return Documento.objects.filter(paciente=user.paciente)
        elif hasattr(user, 'profissional'):
            return Documento.objects.filter(autor=user.profissional)
        return Documento.objects.none()

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def assinar(self, request, pk=None):
        # Ação para assinar um documento
        documento = self.get_object()
        if hasattr(request.user, 'profissional'):
            profissional = request.user.profissional

            # Verificar se o documento está expirado antes de permitir a assinatura
            if documento.is_expired():
                return Response(
                    {'detail': 'Não é possível assinar um documento expirado.'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            dados_assinatura = {
                'documento': documento.id,
                'assinante': profissional.id,
                'dupla_autenticacao': request.data.get('dupla_autenticacao', False),
                'biometria_hash': request.data.get('biometria_hash', None),
                'ip_assinatura': request.META.get('REMOTE_ADDR'),
                'localizacao_assinatura': request.data.get('localizacao_assinatura', None)
            }
            serializer = AssinaturaSerializer(data=dados_assinatura)
            try:
                serializer.is_valid(raise_exception=True)
                serializer.save()
            except ValidationError as e:
                logger.error(f"Erro ao validar assinatura: {e}")
                return Response({'detail': 'Erro ao validar assinatura.', 'errors': e.detail}, status=status.HTTP_400_BAD_REQUEST)

            # Atualiza o status do documento para "Assinado" se necessário
            documento.status = 'Assinado'
            documento.save()

            # Enviar notificação para o paciente ou partes interessadas
            threading.Thread(target=enviar_notificacao, args=(
                'Documento Assinado',
                f'O documento "{documento.titulo}" foi assinado pelo profissional {profissional.nome_completo}.',
                [documento.paciente.usuario.email] if documento.paciente else []
            )).start()

            return Response({'detail': 'Documento assinado com sucesso.'}, status=status.HTTP_200_OK)
        return Response({'detail': 'Permissão negada.'}, status=status.HTTP_403_FORBIDDEN)


class AssinaturaViewSet(viewsets.ModelViewSet):
    queryset = Assinatura.objects.all()
    serializer_class = AssinaturaSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna as assinaturas do profissional autenticado
        user = self.request.user
        if hasattr(user, 'profissional'):
            return Assinatura.objects.filter(assinante=user.profissional)
        return Assinatura.objects.none()

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def validar_assinatura(self, request, pk=None):
        # Ação para validar a integridade da assinatura
        assinatura = self.get_object()
        if assinatura.validar_biometria(request.data.get('biometria_dados', '')):
            return Response({'detail': 'A assinatura é válida.'}, status=status.HTTP_200_OK)
        return Response({'detail': 'A integridade da assinatura não foi confirmada.'}, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def cancelar_assinatura(self, request, pk=None):
        # Ação para cancelar uma assinatura
        assinatura = self.get_object()
        if assinatura.assinante.usuario == request.user:
            assinatura.delete()
            assinatura.documento.status = 'Pendente'
            assinatura.documento.save()
            return Response({'detail': 'Assinatura cancelada com sucesso.'}, status=status.HTTP_200_OK)
        return Response({'detail': 'Você não tem permissão para cancelar esta assinatura.'}, status=status.HTTP_403_FORBIDDEN)
from django.apps import AppConfig


class AssinaturasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.assinaturas"
from django.db import models
from django.utils import timezone
import uuid
from apps.pacientes.models import Paciente

from apps.profissionais.models import Profissional
from django.core.validators import FileExtensionValidator
from django.conf import settings
import hashlib
from datetime import timedelta


class Documento(models.Model):
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    titulo = models.CharField(max_length=255, verbose_name="Título do Documento")
    descricao = models.TextField(
        verbose_name="Descrição do Documento", blank=True, null=True
    )
    data_criacao = models.DateTimeField(auto_now_add=True)
    data_atualizacao = models.DateTimeField(auto_now=True)
    autor = models.ForeignKey(
        Profissional,
        on_delete=models.SET_NULL,
        null=True,
        related_name="documentos_criados",
    )
    paciente = models.ForeignKey(
        Paciente,
        on_delete=models.CASCADE,
        related_name="documentos",
        blank=True,
        null=True,
    )
    arquivo = models.FileField(
        upload_to="documentos/",
        verbose_name="Arquivo do Documento",
        blank=True,
        null=True,
        validators=[FileExtensionValidator(allowed_extensions=["pdf"])],
    )
    status = models.CharField(
        max_length=20,
        choices=[("Pendente", "Pendente"), ("Assinado", "Assinado")],
        default="Pendente",
    )
    data_expiracao = models.DateField(
        blank=True, null=True, verbose_name="Data de Expiração do Documento"
    )
    hash_documento = models.CharField(
        max_length=256, verbose_name="Hash do Documento", blank=True, null=True
    )
    consentimento_informado = models.BooleanField(
        default=False, verbose_name="Consentimento Informado"
    )
    exigencias_legais = models.TextField(
        verbose_name="Exigências Legais", blank=True, null=True
    )
    versao = models.IntegerField(default=1, verbose_name="Versão do Documento")
    compliance_regulamentar = models.TextField(
        verbose_name="Conformidade Regulamentar", blank=True, null=True
    )
    associado_prontuario = models.BooleanField(
        default=False, verbose_name="Associado ao Prontuário"
    )
    analise_automatizada = models.TextField(
        verbose_name="Análise Automatizada de Risco", blank=True, null=True
    )

    class Meta:
        ordering = ["-data_criacao"]
        verbose_name = "Documento"
        verbose_name_plural = "Documentos"

    def __str__(self):
        return f"{self.titulo} - {self.get_status_display()}"

    def is_expired(self):
        # Verifica se o documento está expirado
        if self.data_expiracao:
            return timezone.now().date() > self.data_expiracao
        return False

    def gerar_hash_documento(self):
        # Gera o hash do documento para garantir integridade
        if self.arquivo:
            hasher = hashlib.sha256()
            with self.arquivo.open("rb") as f:
                buf = f.read()
                hasher.update(buf)
            self.hash_documento = hasher.hexdigest()
            self.save()

    def definir_expiracao_padrao(self):
        # Define uma data de expiração padrão para o documento se não estiver
        # definida
        if not self.data_expiracao:
            self.data_expiracao = timezone.now().date() + timedelta(days=365)
            self.save()


class Assinatura(models.Model):
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    documento = models.ForeignKey(
        Documento, on_delete=models.CASCADE, related_name="assinaturas"
    )
    assinante = models.ForeignKey(
        Profissional, on_delete=models.CASCADE, related_name="assinaturas_realizadas"
    )
    data_assinatura = models.DateTimeField(default=timezone.now)
    assinatura_eletronica = models.TextField(
        verbose_name="Assinatura Eletrônica", blank=True, null=True
    )
    validade_assinatura = models.DateField(
        blank=True, null=True, verbose_name="Validade da Assinatura"
    )
    ip_assinatura = models.GenericIPAddressField(
        verbose_name="Endereço IP da Assinatura", blank=True, null=True
    )
    localizacao_assinatura = models.CharField(
        max_length=255, verbose_name="Localização da Assinatura", blank=True, null=True
    )
    biometria_hash = models.CharField(
        max_length=256, verbose_name="Hash da Biometria", blank=True, null=True
    )
    dupla_autenticacao = models.BooleanField(
        default=False, verbose_name="Autenticação em Duas Etapas"
    )
    ferramenta_dispositivo = models.CharField(
        max_length=100,
        verbose_name="Ferramenta/Dispositivo Utilizado",
        blank=True,
        null=True,
    )
    historico_eventos = models.TextField(
        verbose_name="Histórico de Eventos", blank=True, null=True
    )

    class Meta:
        ordering = ["-data_assinatura"]
        verbose_name = "Assinatura"
        verbose_name_plural = "Assinaturas"

    def __str__(self):
        return f"Assinatura de {self.assinante.nome_completo} no documento {self.documento.titulo}"

    def is_valid(self):
        # Verifica se a assinatura ainda é válida
        if self.validade_assinatura:
            return timezone.now().date() <= self.validade_assinatura
        return True

    def gerar_assinatura_eletronica(self):
        # Gera uma assinatura eletrônica única usando hash do documento,
        # informações do assinante e autenticação em duas etapas
        if self.documento and self.assinante:
            dados = f"{self.documento.hash_documento}{self.assinante.uuid}{self.data_assinatura}"
            if self.dupla_autenticacao:
                dados += "dupla_autenticacao"
            self.assinatura_eletronica = hashlib.sha256(dados.encode()).hexdigest()
            self.save()

    def validar_biometria(self, biometria_dados):
        # Valida a biometria fornecida comparando com o hash armazenado
        if biometria_dados:
            biometria_hash = hashlib.sha256(biometria_dados.encode()).hexdigest()
            return biometria_hash == self.biometria_hash
        return False

    def registrar_evento(self, evento):
        # Registra um evento no histórico de assinatura
        if self.historico_eventos:
            self.historico_eventos += f"\n{timezone.now()}: {evento}"
        else:
            self.historico_eventos = f"{timezone.now()}: {evento}"
        self.save()
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import AssinaturaViewSet

router = DefaultRouter()
router.register(r"assinaturas", AssinaturaViewSet)


urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Assinatura


@admin.register(Assinatura)
class AssinaturasAdmin(admin.ModelAdmin):
    list_display = ("documento", "assinante", "data_assinatura", "validade_assinatura")
# Módulo Assinaturas - Serializers (serializers.py)

from rest_framework import serializers
from .models import Documento, Assinatura
from django.utils import timezone


class DocumentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Documento
        fields = "__all__"
        read_only_fields = [
            "uuid",
            "data_criacao",
            "data_atualizacao",
            "hash_documento",
            "versao",
            "analise_automatizada",
        ]

    def validate(self, data):
        # Validação para garantir que a data de expiração não seja anterior à
        # data atual
        if "data_expiracao" in data and data["data_expiracao"]:
            if data["data_expiracao"] < timezone.now().date():
                raise serializers.ValidationError(
                    "A data de expiração não pode ser anterior à data atual."
                )
        # Validação de conformidade regulamentar
        if not data.get("compliance_regulamentar"):
            raise serializers.ValidationError(
                "É necessário especificar a conformidade regulamentar para garantir que o documento atende aos padrões legais."
            )
        # Validação de interoperabilidade
        if data.get("associado_prontuario") and not data.get("paciente"):
            raise serializers.ValidationError(
                "Documentos associados ao prontuário devem estar vinculados a um paciente."
            )
        return data

    def create(self, validated_data):
        # Lógica adicional ao criar um documento, como definir a expiração
        # padrão e gerar o hash
        documento = super().create(validated_data)
        documento.definir_expiracao_padrao()
        documento.gerar_hash_documento()
        return documento

    def update(self, instance, validated_data):
        # Atualiza a versão do documento ao fazer alterações
        instance.versao += 1
        instance = super().update(instance, validated_data)
        instance.gerar_hash_documento()
        return instance


class AssinaturaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Assinatura
        fields = "__all__"
        read_only_fields = [
            "uuid",
            "data_assinatura",
            "assinatura_eletronica",
            "historico_eventos",
        ]

    def validate(self, data):
        # Validação para garantir que a assinatura eletrônica tenha integridade
        if data.get("documento") and data.get("assinante"):
            documento = data["documento"]
            if documento.is_expired():
                raise serializers.ValidationError(
                    "Não é possível assinar um documento expirado."
                )
            # Validação de dupla autenticação
            if documento.consentimento_informado and not data.get("dupla_autenticacao"):
                raise serializers.ValidationError(
                    "Documentos que exigem consentimento informado precisam de autenticação em duas etapas."
                )
        # Verificação de integridade de assinatura com hash
        if data.get("assinatura_eletronica") and data.get("biometria_hash"):
            if not self.validar_integridade_assinatura(
                data["assinatura_eletronica"], data["biometria_hash"]
            ):
                raise serializers.ValidationError(
                    "A integridade da assinatura não foi confirmada."
                )
        return data

    def create(self, validated_data):
        # Lógica para gerar assinatura eletrônica ao criar uma assinatura
        assinatura = super().create(validated_data)
        assinatura.gerar_assinatura_eletronica()
        assinatura.registrar_evento("Assinatura criada.")
        return assinatura

    def update(self, instance, validated_data):
        # Lógica adicional ao atualizar uma assinatura
        instance = super().update(instance, validated_data)
        instance.registrar_evento("Assinatura atualizada.")
        return instance

    def validar_integridade_assinatura(self, assinatura_eletronica, biometria_hash):
        # Lógica simulada para validar a integridade da assinatura com base no hash armazenado
        # (Aqui pode ser feita uma validação mais complexa em um serviço externo)
        return True
# Módulo Assinaturas - Tests (tests.py)

from rest_framework.test import APITestCase, APIClient
from rest_framework import status
from django.urls import reverse
from .models import Documento, Assinatura
from apps.pacientes.models import Paciente

from apps.profissionais.models import Profissional

from django.contrib.auth import get_user_model
from django.utils import timezone
import uuid
from unittest.mock import patch

User = get_user_model()


class AssinaturasAPITestCase(APITestCase):
    def setUp(self):
        # Configurar usuários, paciente, profissional, documento e assinatura
        # para os testes
        self.client = APIClient()
        self.user_paciente = User.objects.create_user(
            username="paciente", password="testpassword"
        )
        self.paciente = Paciente.objects.create(
            usuario=self.user_paciente, nome_completo="Paciente Teste"
        )

        self.user_profissional = User.objects.create_user(
            username="profissional", password="testpassword"
        )
        self.profissional = Profissional.objects.create(
            usuario=self.user_profissional, nome_completo="Profissional Teste"
        )

        self.documento = Documento.objects.create(
            uuid=uuid.uuid4(),
            titulo="Documento Teste",
            descricao="Descrição do documento teste",
            autor=self.profissional,
            paciente=self.paciente,
            data_expiracao=timezone.now().date() + timezone.timedelta(days=30),
            status="Pendente",
        )
        self.documento_url = reverse(
            "documento-detail", kwargs={"pk": self.documento.pk}
        )

    def test_assinar_documento(self):
        # Teste para assinar um documento
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("documento-assinar", kwargs={"pk": self.documento.pk}),
            {
                "dupla_autenticacao": True,
                "biometria_hash": "hash_teste",
                "localizacao_assinatura": "Local Teste",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.documento.refresh_from_db()
        self.assertEqual(self.documento.status, "Assinado")

    def test_assinar_documento_expirado(self):
        # Teste para garantir que não é possível assinar um documento expirado
        self.documento.data_expiracao = timezone.now().date() - timezone.timedelta(
            days=1
        )
        self.documento.save()
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("documento-assinar", kwargs={"pk": self.documento.pk}),
            {
                "dupla_autenticacao": True,
                "biometria_hash": "hash_teste",
                "localizacao_assinatura": "Local Teste",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn(
            "Não é possível assinar um documento expirado.", response.data["detail"]
        )

    def test_cancelar_assinatura(self):
        # Teste para cancelar uma assinatura
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("documento-assinar", kwargs={"pk": self.documento.pk}),
            {
                "dupla_autenticacao": True,
                "biometria_hash": "hash_teste",
                "localizacao_assinatura": "Local Teste",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        assinatura = Assinatura.objects.get(documento=self.documento)

        response = self.client.post(
            reverse("assinatura-cancelar-assinatura", kwargs={"pk": assinatura.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertFalse(Assinatura.objects.filter(pk=assinatura.pk).exists())
        self.documento.refresh_from_db()
        self.assertEqual(self.documento.status, "Pendente")

    def test_validar_assinatura(self):
        # Teste para validar uma assinatura
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("documento-assinar", kwargs={"pk": self.documento.pk}),
            {
                "dupla_autenticacao": True,
                "biometria_hash": "hash_teste",
                "localizacao_assinatura": "Local Teste",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        assinatura = Assinatura.objects.get(documento=self.documento)

        response = self.client.post(
            reverse("assinatura-validar-assinatura", kwargs={"pk": assinatura.pk}),
            {"biometria_dados": "hash_teste"},
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["detail"], "A assinatura é válida.")

    def test_notificacao_assinatura_documento(self, mock_send_notification):
        # Teste para garantir que a notificação é enviada ao assinar um
        # documento
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("documento-assinar", kwargs={"pk": self.documento.pk}),
            {
                "dupla_autenticacao": True,
                "biometria_hash": "hash_teste",
                "localizacao_assinatura": "Local Teste",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        mock_send_notification.assert_called_once()
from rest_framework import viewsets
from .models import DocumentosModel
from .serializers import DocumentosSerializer


class DocumentosViewSet(viewsets.ModelViewSet):
    queryset = DocumentosModel.objects.all()
    serializer_class = DocumentosSerializer
from django.apps import AppConfig


class DocumentosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.documentos"
from django.db import models
from django.utils.translation import gettext_lazy as _


class DocumentosModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = _("Documento")
        verbose_name_plural = _("Documentos")
        app_label = "documentos"

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import DocumentosViewSet

router = DefaultRouter()
router.register(r"documentos", DocumentosViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import DocumentosModel


@admin.register(DocumentosModel)
class DocumentosAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import DocumentosModel


class DocumentosSerializer(serializers.ModelSerializer):
    class Meta:
        model = DocumentosModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import RecrutamentoModel
from .serializers import RecrutamentoSerializer


class RecrutamentoViewSet(viewsets.ModelViewSet):
    queryset = RecrutamentoModel.objects.all()
    serializer_class = RecrutamentoSerializer
from django.apps import AppConfig


class RecrutamentoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.recrutamento"
from django.db import models


class RecrutamentoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import RecrutamentoViewSet

router = DefaultRouter()
router.register(r"recrutamento", RecrutamentoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import RecrutamentoModel


@admin.register(RecrutamentoModel)
class RecrutamentoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import RecrutamentoModel


class RecrutamentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = RecrutamentoModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import FolgasModel
from .serializers import FolgasSerializer


class FolgasViewSet(viewsets.ModelViewSet):
    queryset = FolgasModel.objects.all()
    serializer_class = FolgasSerializer
from django.apps import AppConfig


class FolgasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.folgas"
from django.db import models


class FolgasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import FolgasViewSet

router = DefaultRouter()
router.register(r"folgas", FolgasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import FolgasModel


@admin.register(FolgasModel)
class FolgasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import FolgasModel


class FolgasSerializer(serializers.ModelSerializer):
    class Meta:
        model = FolgasModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import Marketing_emailModel
from .serializers import Marketing_emailSerializer


class Marketing_emailViewSet(viewsets.ModelViewSet):
    queryset = Marketing_emailModel.objects.all()
    serializer_class = Marketing_emailSerializer
from django.apps import AppConfig


class Marketing_emailConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.marketing_email"
from django.db import models


class Marketing_emailModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Marketing_emailViewSet

router = DefaultRouter()
router.register(r"marketing_email", Marketing_emailViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Marketing_emailModel


@admin.register(Marketing_emailModel)
class Marketing_emailAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import Marketing_emailModel


class Marketing_emailSerializer(serializers.ModelSerializer):
    class Meta:
        model = Marketing_emailModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from django.shortcuts import render

# Create your views here.
from django.apps import AppConfig


class ConhecimentoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.conhecimento"
from django.db import models

# Create your models here.
from django.contrib import admin

# Register your models here.
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import ProjetoModel
from .serializers import ProjetoSerializer


class ProjetoViewSet(viewsets.ModelViewSet):
    queryset = ProjetoModel.objects.all()
    serializer_class = ProjetoSerializer
from django.apps import AppConfig


class ProjetoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.projeto"
from django.db import models


class ProjetoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ProjetoViewSet

router = DefaultRouter()
router.register(r"projeto", ProjetoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import ProjetoModel


@admin.register(ProjetoModel)
class ProjetoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import ProjetoModel


class ProjetoSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProjetoModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import MensagensModel
from .serializers import MensagensSerializer


class MensagensViewSet(viewsets.ModelViewSet):
    queryset = MensagensModel.objects.all()
    serializer_class = MensagensSerializer
from django.apps import AppConfig


class MensagensConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.mensagens"
from django.db import models


class MensagensModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import MensagensViewSet

router = DefaultRouter()
router.register(r"mensagens", MensagensViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import MensagensModel


@admin.register(MensagensModel)
class MensagensAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import MensagensModel


class MensagensSerializer(serializers.ModelSerializer):
    class Meta:
        model = MensagensModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import Chat_ao_vivoModel
from .serializers import Chat_ao_vivoSerializer


class Chat_ao_vivoViewSet(viewsets.ModelViewSet):
    queryset = Chat_ao_vivoModel.objects.all()
    serializer_class = Chat_ao_vivoSerializer
from django.apps import AppConfig


class Chat_ao_vivoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.chat_ao_vivo"
from django.db import models


class Chat_ao_vivoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Chat_ao_vivoViewSet

router = DefaultRouter()
router.register(r"chat_ao_vivo", Chat_ao_vivoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Chat_ao_vivoModel


@admin.register(Chat_ao_vivoModel)
class Chat_ao_vivoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import Chat_ao_vivoModel


class Chat_ao_vivoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Chat_ao_vivoModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from django.shortcuts import render

# Create your views here.
from django.apps import AppConfig


class EventosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.eventos"
from django.db import models

# Create your models here.
from django.contrib import admin

# Register your models here.
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import PlmModel
from .serializers import PlmSerializer


class PlmViewSet(viewsets.ModelViewSet):
    queryset = PlmModel.objects.all()
    serializer_class = PlmSerializer
from django.apps import AppConfig


class PlmConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.plm"
from django.db import models


class PlmModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PlmViewSet

router = DefaultRouter()
router.register(r"plm", PlmViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import PlmModel


@admin.register(PlmModel)
class PlmAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import PlmModel


class PlmSerializer(serializers.ModelSerializer):
    class Meta:
        model = PlmModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import ManutencaoModel
from .serializers import ManutencaoSerializer


class ManutencaoViewSet(viewsets.ModelViewSet):
    queryset = ManutencaoModel.objects.all()
    serializer_class = ManutencaoSerializer
from django.apps import AppConfig


class ManutencaoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.manutencao"
from django.db import models


class ManutencaoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ManutencaoViewSet

router = DefaultRouter()
router.register(r"manutencao", ManutencaoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import ManutencaoModel


@admin.register(ManutencaoModel)
class ManutencaoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import ManutencaoModel


class ManutencaoSerializer(serializers.ModelSerializer):
    class Meta:
        model = ManutencaoModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from django.shortcuts import render

# Create your views here.
from django.apps import AppConfig


class ProdutividadeConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.produtividade"
from django.db import models

# Create your models here.
from django.contrib import admin

# Register your models here.
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import FrotaModel
from .serializers import FrotaSerializer


class FrotaViewSet(viewsets.ModelViewSet):
    queryset = FrotaModel.objects.all()
    serializer_class = FrotaSerializer
from django.apps import AppConfig


class FrotaConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.frota"
from django.db import models


class FrotaModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import FrotaViewSet

router = DefaultRouter()
router.register(r"frota", FrotaViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import FrotaModel


@admin.register(FrotaModel)
class FrotaAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import FrotaModel


class FrotaSerializer(serializers.ModelSerializer):
    class Meta:
        model = FrotaModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import FaturamentoModel
from .serializers import FaturamentoSerializer


class FaturamentoViewSet(viewsets.ModelViewSet):
    queryset = FaturamentoModel.objects.all()
    serializer_class = FaturamentoSerializer
from django.apps import AppConfig


class FaturamentoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.faturamento"
from django.db import models


class FaturamentoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import FaturamentoViewSet

router = DefaultRouter()
router.register(r"faturamento", FaturamentoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import FaturamentoModel


@admin.register(FaturamentoModel)
class FaturamentoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import FaturamentoModel


class FaturamentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = FaturamentoModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import LocacaoModel
from .serializers import LocacaoSerializer


class LocacaoViewSet(viewsets.ModelViewSet):
    queryset = LocacaoModel.objects.all()
    serializer_class = LocacaoSerializer
from django.apps import AppConfig


class LocacaoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.locacao"
from django.db import models


class LocacaoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import LocacaoViewSet

router = DefaultRouter()
router.register(r"locacao", LocacaoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import LocacaoModel


@admin.register(LocacaoModel)
class LocacaoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import LocacaoModel


class LocacaoSerializer(serializers.ModelSerializer):
    class Meta:
        model = LocacaoModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import FabricacaoModel
from .serializers import FabricacaoSerializer


class FabricacaoViewSet(viewsets.ModelViewSet):
    queryset = FabricacaoModel.objects.all()
    serializer_class = FabricacaoSerializer
from django.apps import AppConfig


class FabricacaoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.fabricacao"
from django.db import models


class FabricacaoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import FabricacaoViewSet

router = DefaultRouter()
router.register(r"fabricacao", FabricacaoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import FabricacaoModel


@admin.register(FabricacaoModel)
class FabricacaoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import FabricacaoModel


class FabricacaoSerializer(serializers.ModelSerializer):
    class Meta:
        model = FabricacaoModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import VendasModel
from .serializers import VendasSerializer


class VendasViewSet(viewsets.ModelViewSet):
    queryset = VendasModel.objects.all()
    serializer_class = VendasSerializer
from django.apps import AppConfig


class VendasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.vendas"
from django.db import models


class VendasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import VendasViewSet

router = DefaultRouter()
router.register(r"vendas", VendasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import VendasModel


@admin.register(VendasModel)
class VendasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import VendasModel


class VendasSerializer(serializers.ModelSerializer):
    class Meta:
        model = VendasModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import EcommerceModel
from .serializers import EcommerceSerializer


class EcommerceViewSet(viewsets.ModelViewSet):
    queryset = EcommerceModel.objects.all()
    serializer_class = EcommerceSerializer
from django.apps import AppConfig


class EcommerceConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.ecommerce"
from django.db import models


class EcommerceModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import EcommerceViewSet

router = DefaultRouter()
router.register(r"ecommerce", EcommerceViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import EcommerceModel


@admin.register(EcommerceModel)
class EcommerceAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import EcommerceModel


class EcommerceSerializer(serializers.ModelSerializer):
    class Meta:
        model = EcommerceModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import BlogModel
from .serializers import BlogSerializer


class BlogViewSet(viewsets.ModelViewSet):
    queryset = BlogModel.objects.all()
    serializer_class = BlogSerializer
from django.apps import AppConfig


class BlogConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.blog"
from django.db import models


class BlogModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import BlogViewSet

router = DefaultRouter()
router.register(r"blog", BlogViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import BlogModel


@admin.register(BlogModel)
class BlogAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import BlogModel


class BlogSerializer(serializers.ModelSerializer):
    class Meta:
        model = BlogModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
# Módulo Atendimentos - Views (views.py)

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Atendimento
from .serializers import AtendimentoSerializer
from django.utils import timezone
import threading


class IsProfissional(IsAuthenticated):
    def has_permission(self, request, view):
        return super().has_permission(
    request, view) and hasattr(
        request.user, 'profissional')


class AtendimentoViewSet(viewsets.ModelViewSet):
    queryset = Atendimento.objects.all()
    serializer_class = AtendimentoSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna os atendimentos do usuário autenticado (paciente ou
        # profissional)
        user = self.request.user
        if hasattr(user, 'paciente'):
            return Atendimento.objects.filter(paciente=user.paciente)
        elif hasattr(user, 'profissional'):
            return Atendimento.objects.filter(profissional=user.profissional)
        return Atendimento.objects.none()

    @action(detail=True, methods=['post'], permission_classes=[IsProfissional])
    def concluir(self, request, pk=None):
        # Ação para concluir um atendimento
        atendimento = self.get_object()
        if atendimento.profissional != request.user.profissional:
            return Response(
    {
        'detail': 'Você não tem permissão para concluir este atendimento.'},
         status=status.HTTP_403_FORBIDDEN)

        serializer = self.get_serializer(
    atendimento, data={
        'status': 'Concluído'}, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        

        return Response(
            {'detail': 'Atendimento concluído com sucesso.'}, status=status.HTTP_200_OK)

    @ action(detail=False, methods=['get'],
             permission_classes=[IsAuthenticated])
    def meus_atendimentos(self, request):
        # Retorna os atendimentos do paciente ou profissional autenticado
        user= self.request.user
        if hasattr(user, 'paciente'):
            atendimentos= Atendimento.objects.filter(paciente=user.paciente)
        elif hasattr(user, 'profissional'):
            atendimentos= Atendimento.objects.filter(profissional=user.profissional)
        else:
            return Response(
    {
        'detail': 'Você não tem permissão para visualizar atendimentos.'},
         status = status.HTTP_403_FORBIDDEN)

        serializer= self.get_serializer(atendimentos, many=True)
        return Response(serializer.data)

    @ action(detail=True, methods=['post'],
             permission_classes=[IsProfissional])
    def cancelar(self, request, pk=None):
        # Ação para cancelar um atendimento
        atendimento= self.get_object()
        if atendimento.profissional != request.user.profissional:
            return Response(
    {
        'detail': 'Você não tem permissão para cancelar este atendimento.'},
         status = status.HTTP_403_FORBIDDEN)

        motivo= request.data.get('motivo_cancelamento')
        if not motivo:
            return Response({'detail': 'Motivo do cancelamento deve ser informado.'},
                            status=status.HTTP_400_BAD_REQUEST)

        serializer= self.get_serializer(atendimento, data={'status': 'Cancelado'}, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

       

    @ action(detail=True, methods=['post'],
             permission_classes=[IsProfissional])
    def reagendar(self, request, pk=None):
        # Ação para reagendar um atendimento
        atendimento= self.get_object()
        if atendimento.profissional != request.user.profissional:
            return Response(
    {
        'detail': 'Você não tem permissão para reagendar este atendimento.'},
         status=status.HTTP_403_FORBIDDEN)

        nova_data= request.data.get('data_atendimento')
        novo_horario_inicio= request.data.get('horario_inicio')
        novo_horario_fim= request.data.get('horario_fim')

        if not nova_data or not novo_horario_inicio or not novo_horario_fim:
            return Response({'detail': 'Dados de reagendamento incompletos.'},
                            status=status.HTTP_400_BAD_REQUEST)

        serializer= self.get_serializer(atendimento, data={
            'data_atendimento': nova_data,
            'horario_inicio': novo_horario_inicio,
            'horario_fim': novo_horario_fim,
            'status': 'Pendente'
        }, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

    #finalizzar o arquivo views.py
    
from django.db import models
from django.utils import timezone
from apps.pacientes.models import Paciente
from apps.profissionais.models import Profissional
from apps.agendamentos.models import Agendamento
from apps.documentos.models import DocumentosModel
from apps.financeiro.models import Transacao
from apps.assinaturas.models import Assinatura
from apps.prontuarios.models import ProcedimentoRealizado

# Ajuste o caminho conforme a localização do modelo
from apps.iot.models import DispositivoIoT


class Atendimento(models.Model):
    STATUS_CHOICES = [
        ("Pendente", "Pendente"),
        ("Em Andamento", "Em Andamento"),
        ("Concluído", "Concluído"),
        ("Cancelado", "Cancelado"),
        ("Aguardando Documentação", "Aguardando Documentação"),
        ("Aguardando Pagamento", "Aguardando Pagamento"),
    ]

    paciente = models.ForeignKey(
        Paciente, on_delete=models.CASCADE, related_name="atendimentos"
    )
    profissional = models.ForeignKey(
        Profissional, on_delete=models.CASCADE, related_name="atendimentos"
    )
    agendamento = models.OneToOneField(
        Agendamento,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="atendimento",
    )
    procedimentos = models.ManyToManyField(
        ProcedimentoRealizado, related_name="atendimentos", blank=True
    )
    dispositivos_iot = models.ManyToManyField(
        DispositivoIoT, related_name="atendimentos", blank=True
    )
    # seguro_saude = models.ForeignKey(SeguroSaude, on_delete=models.SET_NULL, null=True, blank=True, related_name='atendimentos')
    data_atendimento = models.DateField(default=timezone.now)
    horario_inicio = models.TimeField()
    horario_fim = models.TimeField()
    status = models.CharField(max_length=30, choices=STATUS_CHOICES, default="Pendente")
    diagnostico = models.TextField(null=True, blank=True)
    prescricao = models.TextField(null=True, blank=True)
    tratamento = models.TextField(null=True, blank=True)
    assinatura_profissional = models.ForeignKey(
        Assinatura,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="assinaturas_profissionais",
    )
    autorizacao_paciente = models.ForeignKey(
        Assinatura,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="autorizacoes_pacientes",
    )
    feedback_paciente = models.TextField(null=True, blank=True)
    valor = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    transacao_financeira = models.OneToOneField(
        Transacao,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="atendimento",
    )
    recomendacoes_ia = models.TextField(null=True, blank=True)
    recomendacoes_automaticas = models.TextField(null=True, blank=True)
    avaliacao_risco = models.DecimalField(
        max_digits=5, decimal_places=2, null=True, blank=True
    )
    consentimento_paciente = models.BooleanField(default=False)
    documentacao_completa = models.BooleanField(default=False)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Atendimento"
        verbose_name_plural = "Atendimentos"
        ordering = ["-data_atendimento", "-horario_inicio"]

    def __str__(self):
        return f"Atendimento de {self.paciente.nome_completo} com {self.profissional.nome_completo} em {self.data_atendimento}"

    def save(self, *args, **kwargs):
        # Lógica adicional para integração com IoT, IA e outros serviços
        if self.status == "Concluído" and not self.transacao_financeira:
            # Cria uma transação financeira se o atendimento for concluído
            self.transacao_financeira = Transacao.objects.create(
                paciente=self.paciente,
                valor=self.valor,
                descricao=f"Pagamento pelo atendimento em {self.data_atendimento}",
                status="Pendente",
            )

        # Integração com IA e Machine Learning para análise do atendimento
        # Exemplo: Enviar dados para serviço de IA para sugerir tratamentos ou
        # analisar feedback

        super().save(*args, **kwargs)

    def finalizar_atendimento(self):
        # Método para finalizar o atendimento e garantir todas as validações
        # necessárias
        if self.status == "Concluído":
            if not self.assinatura_profissional or not self.autorizacao_paciente:
                raise ValueError(
                    "Assinatura do profissional e autorização do paciente são obrigatórias para concluir o atendimento."
                )
            if not self.diagnostico or not self.prescricao:
                raise ValueError(
                    "Diagnóstico e prescrição são obrigatórios para concluir o atendimento."
                )

        # Atualiza o status do agendamento associado
        if self.agendamento:
            self.agendamento.status = "Concluído"
            self.agendamento.save()

        # Enviar notificações para o paciente e profissional

        self.save()


class AuditoriaAtendimento(models.Model):
    atendimento = models.ForeignKey(
        Atendimento, on_delete=models.CASCADE, related_name="auditorias"
    )
    usuario = models.CharField(max_length=255)
    alteracoes = models.TextField()
    data_alteracao = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = "Auditoria de Atendimento"
        verbose_name_plural = "Auditorias de Atendimentos"
        ordering = ["-data_alteracao"]

    def __str__(self):
        return f"Auditoria do Atendimento {self.atendimento.id} por {self.usuario} em {self.data_alteracao}"
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import AtendimentoViewSet

router = DefaultRouter()
router.register(r"atendimentos", AtendimentoViewSet, basename="atendimento")

urlpatterns = [
    path("", include(router.urls)),
]
from rest_framework import serializers
from django.utils import timezone
from .models import Atendimento
from apps.agendamentos.models import Agendamento
from apps.financeiro.models import Transacao
from apps.documentos.models import DocumentosModel


class AtendimentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Atendimento
        fields = '__all__'

    def validate(self, data):
        # Validação para garantir que a data e horário do atendimento sejam
        # futuros, caso o atendimento ainda esteja pendente
        if data['status'] == 'Pendente' and (data['data_atendimento'] < timezone.now().date() or (
            data['data_atendimento'] == timezone.now().date() and data['horario_inicio'] <= timezone.now().time())):
            raise serializers.ValidationError(
                "A data e o horário do atendimento pendente devem ser futuros.")

        # Garantir que a hora de fim do atendimento seja posterior à hora de
        # início
        if data['horario_fim'] <= data['horario_inicio']:
            raise serializers.ValidationError(
                "O horário de fim deve ser posterior ao horário de início.")

        # Validação para garantir que o agendamento associado não tenha sido
        # concluído antes do atendimento
        agendamento = data.get('agendamento')
        if agendamento and agendamento.status == 'Concluído':
            raise serializers.ValidationError(
                "O agendamento associado já foi concluído e não pode ser usado para um novo atendimento.")

        # Garantir que a assinatura do profissional e a autorização do paciente
        # estejam presentes ao concluir o atendimento
        if data['status'] == 'Concluído':
            if not data.get('assinatura_profissional'):
                raise serializers.ValidationError(
                    "A assinatura do profissional é obrigatória para concluir o atendimento.")
            if not data.get('autorizacao_paciente'):
                raise serializers.ValidationError(
                    "A autorização do paciente é obrigatória para concluir o atendimento.")

        # Garantir que diagnóstico e feedback estejam presentes ao concluir o
        # atendimento
        if data['status'] == 'Concluído':
            if not data.get('diagnostico'):
                raise serializers.ValidationError(
                    "O diagnóstico é obrigatório para concluir o atendimento.")
            if not data.get('feedback_paciente'):
                raise serializers.ValidationError(
                    "O feedback do paciente é obrigatório para concluir o atendimento.")

        return data

    def create(self, validated_data):
        # Lógica adicional ao criar um atendimento, como atualizar o status do
        # agendamento relacionado
        agendamento = validated_data.get('agendamento')
        if agendamento:
            agendamento.status = 'Concluído'
            agendamento.save()

        

        return super().create(validated_data)

    def update(self, instance, validated_data):
        # Atualizar a transação financeira, se houver alteração no status do
        # atendimento
        if 'status' in validated_data and validated_data[
            'status'] == 'Concluído' and not instance.transacao_financeira:
            # Garantir que o valor do atendimento seja positivo
            valor= validated_data.get('valor', 0)
            if valor <= 0:
                raise serializers.ValidationError(
                    "O valor do atendimento deve ser positivo para criar uma transação financeira.")

            # Criar uma transação financeira relacionada
            transacao= Transacao.objects.create(
                paciente = instance.paciente,
                valor = valor,
                descricao = f'Pagamento pelo atendimento realizado em {instance.data_atendimento}',
                status = 'Pendente'
            )
            instance.transacao_financeira = transacao

        # Garantir que o status seja consistente com os campos obrigatórios
        if validated_data.get('status') == 'Concluído':
            if not instance.tratamento or not instance.prescricao:
                raise serializers.ValidationError("O atendimento não pode ser concluído sem um tratamento e uma prescrição adequados.")

       

        # Atualizar o status do agendamento para manter a consistência
        if instance.agendamento:
            instance.agendamento.status = 'Concluído'
            instance.agendamento.save()

        return super().update(instance, validated_data)
# Módulo Atendimentos - Tests (tests.py)

from rest_framework.test import APITestCase, APIClient
from rest_framework import status
from django.urls import reverse
from .models import Atendimento
from apps.pacientes.models import Paciente

from apps.profissionais.models import Profissional
import Profissional
from django.contrib.auth import get_user_model
from django.utils import timezone
import uuid
from unittest.mock import patch

User = get_user_model()


class AtendimentoAPITestCase(APITestCase):
    def setUp(self):
        # Configurar usuários, paciente, profissional e atendimento para os
        # testes
        self.client = APIClient()
        self.user_paciente = User.objects.create_user(
            username="paciente", password="testpassword"
        )
        self.paciente = Paciente.objects.create(
            usuario=self.user_paciente, nome_completo="Paciente Teste"
        )

        self.user_profissional = User.objects.create_user(
            username="profissional", password="testpassword"
        )
        self.profissional = Profissional.objects.create(
            usuario=self.user_profissional, nome_completo="Profissional Teste"
        )

        self.user_outro_profissional = User.objects.create_user(
            username="outro_profissional", password="testpassword"
        )
        self.outro_profissional = Profissional.objects.create(
            usuario=self.user_outro_profissional,
            nome_completo="Outro Profissional Teste",
        )

        self.atendimento = Atendimento.objects.create(
            uuid=uuid.uuid4(),
            paciente=self.paciente,
            profissional=self.profissional,
            data_atendimento=timezone.now().date() + timezone.timedelta(days=1),
            horario_inicio="10:00",
            horario_fim="11:00",
            tipo_atendimento="Consulta",
        )
        self.atendimento_url = reverse(
            "atendimento-detail", kwargs={"pk": self.atendimento.pk}
        )

    def test_concluir_atendimento(self):
        # Teste para concluir um atendimento
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("atendimento-concluir", kwargs={"pk": self.atendimento.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.atendimento.refresh_from_db()
        self.assertEqual(self.atendimento.status, "Concluído")

    def test_concluir_atendimento_permissao_negada(self):
        # Teste para garantir que outro profissional não possa concluir o
        # atendimento
        self.client.force_authenticate(user=self.outro_profissional)
        response = self.client.post(
            reverse("atendimento-concluir", kwargs={"pk": self.atendimento.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_cancelar_atendimento(self):
        # Teste para cancelar um atendimento
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("atendimento-cancelar", kwargs={"pk": self.atendimento.pk}),
            {"motivo_cancelamento": "Imprevisto"},
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.atendimento.refresh_from_db()
        self.assertEqual(self.atendimento.status, "Cancelado")

    def test_reagendar_atendimento(self):
        # Teste para reagendar um atendimento
        self.client.force_authenticate(user=self.user_profissional)
        nova_data = timezone.now().date() + timezone.timedelta(days=2)
        response = self.client.post(
            reverse("atendimento-reagendar", kwargs={"pk": self.atendimento.pk}),
            {
                "data_atendimento": nova_data,
                "horario_inicio": "11:00",
                "horario_fim": "12:00",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.atendimento.refresh_from_db()
        self.assertEqual(self.atendimento.data_atendimento, nova_data)
        self.assertEqual(self.atendimento.horario_inicio, "11:00")
        self.assertEqual(self.atendimento.horario_fim, "12:00")

    def test_meus_atendimentos_paciente(self):
        # Teste para listar atendimentos do paciente autenticado
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.get(reverse("atendimento-meus-atendimentos"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["id"], self.atendimento.id)

    def test_meus_atendimentos_profissional(self):
        # Teste para listar atendimentos do profissional autenticado
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.get(reverse("atendimento-meus-atendimentos"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["id"], self.atendimento.id)

    def test_notificacao_concluir_atendimento(self, mock_send_notification):
        # Teste para garantir que a notificação é enviada ao concluir o
        # atendimento
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("atendimento-concluir", kwargs={"pk": self.atendimento.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        mock_send_notification.assert_called_once()
from django.shortcuts import render

# Create your views here.
from django.apps import AppConfig


class VoipConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.voip"
from django.db import models

# Create your models here.
from django.contrib import admin

# Register your models here.
from django.test import TestCase

# Create your tests here.
# Módulo Exames - Views (views.py)

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Exame
from .serializers import ExameSerializer
from django.utils import timezone
import threading


class ExameViewSet(viewsets.ModelViewSet):
    queryset = Exame.objects.all()
    serializer_class = ExameSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna os exames do paciente autenticado ou exames solicitados por
        # um profissional autenticado
        user = self.request.user
        if hasattr(user, 'paciente'):
            return Exame.objects.filter(paciente=user.paciente)
        elif hasattr(user, 'profissional'):
            return Exame.objects.filter(
    profissional_solicitante=user.profissional)
        return Exame.objects.none()

    @action(detail=True, methods=['post'],
            permission_classes=[IsAuthenticated])
    def registrar_resultado(self, request, pk=None):
        # Ação para registrar o resultado de um exame
        exame = self.get_object()
        if hasattr(
    request.user,
     'profissional') and exame.profissional_solicitante != request.user.profissional:
            return Response(
    {
        'detail': 'Você não tem permissão para registrar o resultado deste exame.'},
         status=status.HTTP_403_FORBIDDEN)

        serializer = self.get_serializer(
    exame, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        # Adicionar integração com Machine Learning para análise dos resultados
        self.analisar_resultados(exame)

        return Response(
            {'detail': 'Resultado do exame registrado com sucesso.'}, status=status.HTTP_200_OK)

    def analisar_resultados(self, exame):
        # Integração com Machine Learning para analisar resultados de exames
        # Simulação de chamada para um serviço de IA que analisa os resultados
        # do exame
        if exame.resultados:
            threading.Thread(
    target=self.enviar_para_analise_ml, args=(
        exame,)).start()

    def enviar_para_analise_ml(self, exame):
        # Simulação de envio dos resultados do exame para um serviço de Machine Learning
        # Aqui pode ser feita a integração com um serviço externo de análise de
        # saúde
        print(
            f"Enviando resultados do exame {exame.tipo_exame} para análise de IA.")
        # Implementar a lógica real de integração aqui

    @ action(detail=True, methods=['post'],
             permission_classes=[IsAuthenticated])
    def cancelar_exame(self, request, pk=None):
        # Ação para cancelar um exame
        exame= self.get_object()
        if hasattr(
    request.user,
     'profissional') and exame.profissional_solicitante != request.user.profissional:
            return Response(
    {
        'detail': 'Você não tem permissão para cancelar este exame.'},
         status = status.HTTP_403_FORBIDDEN)

        exame.status= 'Cancelado'
        exame.save()

        
        return Response({'detail': 'Exame cancelado com sucesso.'},
                        status=status.HTTP_200_OK)
# Módulo Exames - Models (models.py)

from django.db import models
from django.utils import timezone
import uuid
from apps.pacientes.models import Paciente
from apps.profissionais.models import Profissional
from apps.documentos.models import DocumentosModel


class Exame(models.Model):
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    paciente = models.ForeignKey(
        Paciente, on_delete=models.CASCADE, related_name="exames"
    )
    profissional_solicitante = models.ForeignKey(
    Profissional,
    on_delete=models.SET_NULL,
    null=True,
    related_name="exames_solicitados_exame",  # Alterar para um nome único
    verbose_name="Profissional Solicitante",
)

    tipo_exame = models.CharField(max_length=100, verbose_name="Tipo de Exame")
    data_solicitacao = models.DateField(
        default=timezone.now, verbose_name="Data de Solicitação"
    )
    data_realizacao = models.DateField(
        blank=True, null=True, verbose_name="Data de Realização"
    )
    resultados = models.TextField(
        verbose_name="Resultados do Exame", blank=True, null=True
    )
    documento_resultado = models.ForeignKey(
        DocumentosModel,
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
        related_name="exames_resultados",
        verbose_name="Documento do Resultado",
    )
    observacoes = models.TextField(verbose_name="Observações", blank=True, null=True)
    status = models.CharField(
        max_length=20,
        choices=[
            ("Solicitado", "Solicitado"),
            ("Realizado", "Realizado"),
            ("Cancelado", "Cancelado"),
        ],
        default="Solicitado",
    )
    data_criacao = models.DateTimeField(auto_now_add=True)
    data_atualizacao = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["-data_solicitacao"]
        verbose_name = "Exame"
        verbose_name_plural = "Exames"

    def __str__(self):
        return f"Exame {self.tipo_exame} de {self.paciente.nome_completo}"

    def is_realizado(self):
        return self.status == "Realizado"
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ExameViewSet

router = DefaultRouter()
router.register(r"examess", ExameViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
# Módulo Exames - Serializers (serializers.py)

from rest_framework import serializers
from .models import Exame


class ExameSerializer(serializers.ModelSerializer):
    class Meta:
        model = Exame
        fields = "__all__"
        read_only_fields = ["data_criacao", "data_atualizacao"]

    def validate(self, data):
        # Validação para garantir que a data de realização não seja anterior à
        # data de solicitação
        if "data_realizacao" in data and data["data_realizacao"]:
            if data["data_realizacao"] < data["data_solicitacao"]:
                raise serializers.ValidationError(
                    "A data de realização não pode ser anterior à data de solicitação do exame."
                )

        # Validação para garantir que se o exame estiver realizado, a data de
        # realização deve estar preenchida
        if data.get("status") == "Realizado" and not data.get("data_realizacao"):
            raise serializers.ValidationError(
                "A data de realização deve ser informada quando o status for 'Realizado'."
            )

        # Validação para garantir que se o exame estiver realizado, o documento
        # do resultado deve estar presente
        if data.get("status") == "Realizado" and not data.get("documento_resultado"):
            raise serializers.ValidationError(
                "O documento do resultado deve ser anexado quando o status for 'Realizado'."
            )

        return data
# Módulo Exames - Tests (tests.py)

from rest_framework.test import APITestCase, APIClient
from rest_framework import status
from django.urls import reverse
from .models import Exame
from apps.pacientes.models import Paciente
from apps.profissionais.models import Profissional
from django.contrib.auth import get_user_model
from django.utils import timezone
import uuid
from unittest.mock import patch

User = get_user_model()

User = get_user_model()


class ExameAPITestCase(APITestCase):
    def setUp(self):
        # Configurar usuários, paciente, profissional e exame para os testes
        self.client = APIClient()
        self.user_paciente = User.objects.create_user(
            username="paciente", password="testpassword"
        )
        self.paciente = Paciente.objects.create(
            usuario=self.user_paciente, nome_completo="Paciente Teste"
        )

        self.user_profissional = User.objects.create_user(
            username="profissional", password="testpassword"
        )
        self.profissional = Profissional.objects.create(
            usuario=self.user_profissional, nome_completo="Profissional Teste"
        )

        self.user_outro_profissional = User.objects.create_user(
            username="outro_profissional", password="testpassword"
        )
        self.outro_profissional = Profissional.objects.create(
            usuario=self.user_outro_profissional,
            nome_completo="Outro Profissional Teste",
        )

        self.exame = Exame.objects.create(
            uuid=uuid.uuid4(),
            paciente=self.paciente,
            profissional_solicitante=self.profissional,
            tipo_exame="Hemograma",
            data_solicitacao=timezone.now().date(),
        )
        self.exame_url = reverse("exame-detail", kwargs={"pk": self.exame.pk})

    def test_registrar_resultado_exame(self):
        # Teste para registrar o resultado de um exame
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("exame-registrar-resultado", kwargs={"pk": self.exame.pk}),
            {
                "resultados": "Resultados normais",
                "status": "Realizado",
                "data_realizacao": timezone.now().date(),
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.exame.refresh_from_db()
        self.assertEqual(self.exame.status, "Realizado")
        self.assertEqual(self.exame.resultados, "Resultados normais")

    def test_registrar_resultado_permissao_negada(self):
        # Teste para garantir que outro profissional não possa registrar o
        # resultado do exame
        self.client.force_authenticate(user=self.outro_profissional)
        response = self.client.post(
            reverse("exame-registrar-resultado", kwargs={"pk": self.exame.pk}),
            {"resultados": "Resultados alterados", "status": "Realizado"},
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_cancelar_exame(self):
        # Teste para cancelar um exame
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("exame-cancelar-exame", kwargs={"pk": self.exame.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.exame.refresh_from_db()
        self.assertEqual(self.exame.status, "Cancelado")

    def test_cancelar_exame_por_paciente(self):
        # Teste para garantir que o paciente não possa cancelar o exame
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.post(
            reverse("exame-cancelar-exame", kwargs={"pk": self.exame.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_registrar_resultado_sem_data_realizacao(self):
        # Teste para tentar registrar o resultado sem fornecer a data de
        # realização
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("exame-registrar-resultado", kwargs={"pk": self.exame.pk}),
            {"resultados": "Resultados normais", "status": "Realizado"},
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_meus_exames_paciente(self):
        # Teste para listar exames do paciente autenticado
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.get(reverse("exame-list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["id"], self.exame.id)

    def test_meus_exames_profissional(self):
        # Teste para listar exames solicitados pelo profissional autenticado
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.get(reverse("exame-list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["id"], self.exame.id)

    def test_notificacao_registrar_resultado(self, mock_send_notification):
        # Teste para garantir que a notificação é enviada ao registrar o
        # resultado do exame
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("exame-registrar-resultado", kwargs={"pk": self.exame.pk}),
            {
                "resultados": "Resultados normais",
                "status": "Realizado",
                "data_realizacao": timezone.now().date(),
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        mock_send_notification.assert_called_once()

    def test_notificacao_cancelar_exame(self, mock_send_notification):
        # Teste para garantir que a notificação é enviada ao cancelar um exame
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("exame-cancelar-exame", kwargs={"pk": self.exame.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        mock_send_notification.assert_called_once()

    @patch("exames.views.ExameViewSet.analisar_resultados")
    def test_integracao_machine_learning(self, mock_analisar_resultados):
        # Teste para garantir que a integração com Machine Learning seja
        # acionada ao registrar resultados
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("exame-registrar-resultado", kwargs={"pk": self.exame.pk}),
            {
                "resultados": "Resultados normais",
                "status": "Realizado",
                "data_realizacao": timezone.now().date(),
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        mock_analisar_resultados.assert_called_once_with(self.exame)
from rest_framework import viewsets
from .models import ComprasModel
from .serializers import ComprasSerializer


class ComprasViewSet(viewsets.ModelViewSet):
    queryset = ComprasModel.objects.all()
    serializer_class = ComprasSerializer
from django.apps import AppConfig


class ComprasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.compras"
from django.db import models


class ComprasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ComprasViewSet

router = DefaultRouter()
router.register(r"compras", ComprasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import ComprasModel


@admin.register(ComprasModel)
class ComprasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import ComprasModel


class ComprasSerializer(serializers.ModelSerializer):
    class Meta:
        model = ComprasModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
# Incremento 3: Melhorias nas Visualizações (views.py)

from rest_framework import viewsets, permissions, filters
from rest_framework.pagination import PageNumberPagination
from django_filters.rest_framework import DjangoFilterBackend
from .models import Paciente
from .serializers import PacienteSerializer


class PacientePagination(PageNumberPagination):
    page_size = 10
    page_size_query_param = "page_size"
    max_page_size = 100


class PacienteViewSet(viewsets.ModelViewSet):
    queryset = Paciente.objects.all()
    serializer_class = PacienteSerializer
    permission_classes = [permissions.IsAuthenticated]
    pagination_class = PacientePagination
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]
    filterset_fields = ["sexo", "estado_civil", "cidade", "estado"]
    search_fields = ["nome_completo", "cpf", "email"]
    ordering_fields = ["nome_completo", "data_nascimento", "created_at"]
    ordering = ["nome_completo"]

    def get_permissions(self):
        if self.action in ["list", "retrieve"]:
            return [permissions.IsAuthenticated()]
        return [permissions.IsAdminUser()]
from django.apps import AppConfig


class PacientesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.pacientes"
from cryptography.fernet import Fernet
from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _
import uuid
from django.utils import timezone

# Gerar uma chave de criptografia para uso nos campos sensíveis (a chave deve ser armazenada em um local seguro)
# Aqui estamos simulando a recuperação da chave do arquivo de configurações
cipher_suite = Fernet(settings.ENCRYPTION_KEY)


class Paciente(models.Model):
    # Identificador Único Global
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    # Dados Pessoais
    nome_completo = models.CharField(_("Nome Completo"), max_length=255)
    foto = models.ImageField(
        _("Foto"), upload_to="pacientes/fotos/", blank=True, null=True
    )
    cpf = models.CharField(_("CPF"), max_length=255, unique=True)
    rg = models.CharField(_("RG"), max_length=255, blank=True)
    data_nascimento = models.DateField(_("Data de Nascimento"))
    sexo = models.CharField(
        _("Sexo"),
        max_length=1,
        choices=[
            ("M", "Masculino"),
            ("F", "Feminino"),
            ("O", "Outro"),
        ],
    )
    estado_civil = models.CharField(_("Estado Civil"), max_length=50, blank=True)
    profissao = models.CharField(_("Profissão"), max_length=100, blank=True)
    nacionalidade = models.CharField(_("Nacionalidade"), max_length=100, blank=True)
    naturalidade = models.CharField(_("Naturalidade"), max_length=100, blank=True)
    endereco = models.CharField(_("Endereço"), max_length=255)
    numero = models.CharField(_("Número"), max_length=10)
    complemento = models.CharField(_("Complemento"), max_length=100, blank=True)
    bairro = models.CharField(_("Bairro"), max_length=100)
    cidade = models.CharField(_("Cidade"), max_length=100)
    estado = models.CharField(_("Estado"), max_length=100)
    cep = models.CharField(_("CEP"), max_length=9, blank=True)
    telefone_residencial = models.CharField(
        _("Telefone Residencial"), max_length=20, blank=True
    )
    telefone_celular = models.CharField(
        _("Telefone Celular"), max_length=20, blank=True
    )
    email = models.EmailField(_("E-mail"), blank=True)
    contato_emergencia = models.CharField(
        _("Contato de Emergência"), max_length=255, blank=True
    )
    telefone_emergencia = models.CharField(
        _("Telefone de Emergência"), max_length=20, blank=True
    )

    # Dados Complementares
    nome_mae = models.CharField(_("Nome da Mãe"), max_length=255, blank=True)
    nome_pai = models.CharField(_("Nome do Pai"), max_length=255, blank=True)
    consentimento_lgpd = models.BooleanField(_("Consentimento LGPD"), default=False)
    observacoes = models.TextField(_("Observações"), blank=True)

    # Relacionamentos
    prontuario = models.OneToOneField(
    "prontuarios.Prontuario",
    on_delete=models.SET_NULL,
    null=True,
    blank=True,
    related_name="paciente_prontuario",  
)

    

    # Auditoria
    created_at = models.DateTimeField(_("Data de Criação"), auto_now_add=True)
    updated_at = models.DateTimeField(_("Última Atualização"), auto_now=True)

    class Meta:
        app_label = "pacientes"
        verbose_name = _("Paciente")
        verbose_name_plural = _("Pacientes")

    def __str__(self):
        return self.nome_completo

    def save(self, *args, **kwargs):
        # Criptografar CPF e RG antes de salvar
        if self.cpf:
            self.cpf = cipher_suite.encrypt(self.cpf.encode()).decode()
        if self.rg:
            self.rg = cipher_suite.encrypt(self.rg.encode()).decode()
        super().save(*args, **kwargs)

    def decrypt_cpf(self):
        # Descriptografar o CPF para uso
        if self.cpf:
            return cipher_suite.decrypt(self.cpf.encode()).decode()
        return None

    def decrypt_rg(self):
        # Descriptografar o RG para uso
        if self.rg:
            return cipher_suite.decrypt(self.rg.encode()).decode()
        return None
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PacienteViewSet

router = DefaultRouter()
router.register(r"pacientes", PacienteViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Paciente

admin.site.register(Paciente)
# Incremento 2: Melhorias no Serializador (serializers.py)

from rest_framework import serializers
from .models import Paciente
from django.core.validators import validate_email
import re


class PacienteSerializer(serializers.ModelSerializer):
    class Meta:
        model = Paciente
        fields = [
            "uuid",
            "nome_completo",
            "foto",
            "data_nascimento",
            "sexo",
            "estado_civil",
            "profissao",
            "nacionalidade",
            "naturalidade",
            "endereco",
            "numero",
            "complemento",
            "bairro",
            "cidade",
            "estado",
            "cep",
            "telefone_residencial",
            "telefone_celular",
            "email",
            "contato_emergencia",
            "telefone_emergencia",
            "nome_mae",
            "nome_pai",
            "consentimento_lgpd",
            "observacoes",
            "created_at",
            "updated_at",
        ]
        read_only_fields = ["created_at", "updated_at"]

    def validate_cpf(self, value):
        # Validação simples de CPF (apenas para garantir formato válido)
        if not re.match(r"\d{3}\.\d{3}\.\d{3}-\d{2}", value):
            raise serializers.ValidationError(
                "CPF deve estar no formato XXX.XXX.XXX-XX"
            )
        return value

    def validate_email(self, value):
        # Validação de e-mail
        try:
            validate_email(value)
        except BaseException:
            raise serializers.ValidationError("E-mail inválido")
        return value
# Incremento 4: Melhorias no Módulo de Testes (tests.py)

from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from django.contrib.auth.models import User
from .models import Paciente


class PacienteTests(APITestCase):
    def setUp(self):
        # Criação de usuário para autenticação
        self.user = User.objects.create_user(
            username="testuser", password="testpassword"
        )
        self.admin_user = User.objects.create_superuser(
            username="admin", password="adminpassword"
        )
        self.client.login(username="testuser", password="testpassword")

        # Dados do paciente para testes
        self.paciente_data = {
            "nome_completo": "João da Silva",
            "cpf": "123.456.789-00",
            "data_nascimento": "1980-01-01",
            "sexo": "M",
            "estado_civil": "Solteiro",
            "endereco": "Rua A",
            "numero": "123",
            "bairro": "Centro",
            "cidade": "São Paulo",
            "estado": "SP",
            "telefone_celular": "(11) 91234-5678",
            "email": "joao.silva@example.com",
            "consentimento_lgpd": True,
        }

    def test_create_paciente_unauthorized(self):
        # Tentativa de criação de paciente sem ser administrador
        response = self.client.post(reverse("paciente-list"), self.paciente_data)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_create_paciente_authorized(self):
        # Criação de paciente como administrador
        self.client.login(username="admin", password="adminpassword")
        response = self.client.post(reverse("paciente-list"), self.paciente_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Paciente.objects.count(), 1)
        self.assertEqual(Paciente.objects.get().nome_completo, "João da Silva")

    def test_list_pacientes(self):
        # Listar pacientes após criação
        self.client.login(username="admin", password="adminpassword")
        self.client.post(reverse("paciente-list"), self.paciente_data)
        response = self.client.get(reverse("paciente-list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data["results"]), 1)

    def test_permissions(self):
        # Verificar permissões de acesso para listagem
        response = self.client.get(reverse("paciente-list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.client.logout()
        response = self.client.get(reverse("paciente-list"))
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
from rest_framework import viewsets
from .models import PlanilhasModel
from .serializers import PlanilhasSerializer


class PlanilhasViewSet(viewsets.ModelViewSet):
    queryset = PlanilhasModel.objects.all()
    serializer_class = PlanilhasSerializer
from django.apps import AppConfig


class PlanilhasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.planilhas"
from django.db import models


class PlanilhasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PlanilhasViewSet

router = DefaultRouter()
router.register(r"planilhas", PlanilhasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import PlanilhasModel


@admin.register(PlanilhasModel)
class PlanilhasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import PlanilhasModel


class PlanilhasSerializer(serializers.ModelSerializer):
    class Meta:
        model = PlanilhasModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from django.shortcuts import render

# Create your views here.
from django.apps import AppConfig


class Automacao_marketingConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.automacao_marketing"
from django.db import models

# Create your models here.
from django.contrib import admin

# Register your models here.
from django.test import TestCase

# Create your tests here.
# Módulo Agendamentos - Views (views.py)

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Agendamento
from .serializers import AgendamentoSerializer
from django.utils import timezone
from django.core.mail import send_mail
from django.conf import settings
import logging
import threading
import uuid

logger = logging.getLogger(__name__)


class AgendamentoViewSet(viewsets.ModelViewSet):
    serializer_class = AgendamentoSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna os agendamentos futuros do usuário autenticado (paciente ou
        # profissional)
        user = self.request.user
        if hasattr(user, 'paciente'):
            return Agendamento.objects.filter(
    paciente=user.paciente,
     data_agendamento__gte=timezone.now().date())
        elif hasattr(user, 'profissional'):
            return Agendamento.objects.filter(
    profissional=user.profissional,
     data_agendamento__gte=timezone.now().date())
        return Agendamento.objects.none()

    @action(detail=True, methods=['post'],
            permission_classes=[IsAuthenticated])
    def confirmar(self, request, pk=None):
        # Ação para confirmar o agendamento pelo paciente
        agendamento = self.get_object()
        if hasattr(
    request.user,
     'paciente') and agendamento.paciente != request.user.paciente:
            return Response(
    {
        'detail': 'Você não tem permissão para confirmar este agendamento.'},
         status=status.HTTP_403_FORBIDDEN)

        if agendamento.confirmado_pelo_paciente:
            return Response({'detail': 'Agendamento já foi confirmado.'},
                            status=status.HTTP_400_BAD_REQUEST)

        agendamento.confirmado_pelo_paciente = True
        agendamento.save()

       

    @ action(detail=True, methods=['post'],
             permission_classes=[IsAuthenticated])
    def cancelar(self, request, pk=None):
        # Ação para cancelar um agendamento
        agendamento= self.get_object()
        motivo= request.data.get('motivo_cancelamento')
        if not motivo:
            return Response({'detail': 'Motivo do cancelamento deve ser informado.'},
                            status=status.HTTP_400_BAD_REQUEST)

        # Verificar permissões de cancelamento
        if hasattr(
    request.user,
     'paciente') and agendamento.paciente != request.user.paciente:
            return Response(
    {
        'detail': 'Você não tem permissão para cancelar este agendamento.'},
         status = status.HTTP_403_FORBIDDEN)
        if hasattr(
    request.user,
     'profissional') and agendamento.profissional != request.user.profissional:
            return Response(
    {
        'detail': 'Você não tem permissão para cancelar este agendamento.'},
         status = status.HTTP_403_FORBIDDEN)

        agendamento.status= 'Cancelado'
        agendamento.motivo_cancelamento= motivo
        agendamento.save()

       

    @ action(detail=True, methods=['post'],
             permission_classes=[IsAuthenticated])
    def reagendar(self, request, pk=None):
        # Ação para reagendar um agendamento
        agendamento= self.get_object()
        nova_data= request.data.get('data_agendamento')
        novo_horario_inicio= request.data.get('horario_inicio')
        novo_horario_fim= request.data.get('horario_fim')

        if not nova_data or not novo_horario_inicio or not novo_horario_fim:
            return Response({'detail': 'Dados de reagendamento incompletos.'},
                            status=status.HTTP_400_BAD_REQUEST)

        # Validação para garantir que a nova data e horário sejam futuros
        if nova_data < timezone.now().date() or (nova_data == timezone.now().date()
                                    and novo_horario_inicio <= timezone.now().time()):
            return Response({'detail': 'A nova data e horário devem ser no futuro.'},
                            status=status.HTTP_400_BAD_REQUEST)

        # Validação para garantir que a capacidade da sala não seja excedida
        # (Exemplo para IoT)
        if agendamento.sala_atendimento:
            capacidade_sala= agendamento.sala_atendimento.capacidade  # Supondo que o modelo de sala tenha um campo 'capacidade'
            ocupacao_atual= Agendamento.objects.filter(
                data_agendamento=nova_data,
                horario_inicio__lt=novo_horario_fim,
                horario_fim__gt=novo_horario_inicio,
                sala_atendimento=agendamento.sala_atendimento
            ).count()
            if ocupacao_atual >= capacidade_sala:
                return Response(
    {
        'detail': 'A capacidade da sala de atendimento foi excedida.'},
         status=status.HTTP_400_BAD_REQUEST)

        # Atualizar o agendamento com a nova data e horário
        agendamento.data_agendamento= nova_data
        agendamento.horario_inicio= novo_horario_inicio
        agendamento.horario_fim= novo_horario_fim
        agendamento.status= 'Agendado'
        agendamento.motivo_cancelamento= ''  # Limpar motivo de cancelamento, se houver
        agendamento.save()

     

    @ action(detail=False, methods=['get'],
             permission_classes=[IsAuthenticated])
    def meus_agendamentos(self, request):
        # Retorna os agendamentos do paciente ou profissional autenticado
        if hasattr(request.user, 'paciente'):
            agendamentos= Agendamento.objects.filter(paciente=request.user.paciente)
        elif hasattr(request.user, 'profissional'):
            agendamentos= Agendamento.objects.filter(profissional=request.user.profissional)
        else:
            return Response(
    {
        'detail': 'Você não tem permissão para visualizar agendamentos.'},
         status=status.HTTP_403_FORBIDDEN)

        serializer= self.get_serializer(agendamentos, many=True)
        return Response(serializer.data)
from django.apps import AppConfig


class AgendamentosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.agendamentos"
from django.db import models
from django.utils.translation import gettext_lazy as _
from django.conf import settings
from apps.profissionais.models import Profissional

from apps.pacientes.models import Paciente

import uuid


class Agendamento(models.Model):
    # Identificador Único Global
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    paciente = models.ForeignKey(
    'pacientes.Paciente', on_delete=models.CASCADE, related_name='agendamentos'
)




    profissional = models.ForeignKey(
        Profissional, on_delete=models.CASCADE, related_name="agendamentos_profissional"
    )

    # Dados do Agendamento
    data_agendamento = models.DateField(verbose_name=_("Data do Agendamento"))
    horario_inicio = models.TimeField(verbose_name=_("Horário de Início"))
    horario_fim = models.TimeField(verbose_name=_("Horário de Fim"))
    tipo_consulta = models.CharField(
        max_length=50,
        choices=[
            ("Consulta Inicial", "Consulta Inicial"),
            ("Retorno", "Retorno"),
            ("Exame", "Exame"),
            ("Teleconsulta", "Teleconsulta"),
        ],
        default="Consulta Inicial",
        verbose_name=_("Tipo de Consulta"),
    )
    local_atendimento = models.CharField(
        max_length=50,
        choices=[
            ("Presencial", "Presencial"),
            ("Telemedicina", "Telemedicina"),
            ("Visita Domiciliar", "Visita Domiciliar"),
        ],
        default="Presencial",
        verbose_name=_("Local do Atendimento"),
    )
    status = models.CharField(
        max_length=20,
        choices=[
            ("Agendado", "Agendado"),
            ("Cancelado", "Cancelado"),
            ("Concluído", "Concluído"),
        ],
        default="Agendado",
        verbose_name=_("Status do Agendamento"),
    )
    motivo_cancelamento = models.TextField(
        blank=True, null=True, verbose_name=_("Motivo do Cancelamento")
    )
    confirmado_pelo_paciente = models.BooleanField(
        default=False, verbose_name=_("Confirmado pelo Paciente")
    )
    observacoes = models.TextField(blank=True, verbose_name=_("Observações"))
    sintomas_iniciais = models.TextField(
        blank=True, verbose_name=_("Sintomas Iniciais")
    )
    tipo_atendimento = models.CharField(
        max_length=20,
        choices=[("Emergencial", "Emergencial"), ("Rotina", "Rotina")],
        default="Rotina",
        verbose_name=_("Tipo de Atendimento"),
    )
    motivo_consulta = models.CharField(
        max_length=255, blank=True, verbose_name=_("Motivo da Consulta")
    )

    # Dados Financeiros
    meio_pagamento = models.CharField(
        max_length=50,
        choices=[
            ("Cartão de Crédito", "Cartão de Crédito"),
            ("Convênio", "Convênio"),
            ("Dinheiro", "Dinheiro"),
            ("PIX", "PIX"),
        ],
        blank=True,
        verbose_name=_("Meio de Pagamento"),
    )
    status_financeiro = models.CharField(
        max_length=20,
        choices=[("Pago", "Pago"), ("Pendente", "Pendente")],
        default="Pendente",
        verbose_name=_("Status Financeiro"),
    )

    # Notificações e Lembretes
    canal_preferencial = models.CharField(
        max_length=20,
        choices=[("WhatsApp", "WhatsApp"), ("SMS", "SMS"), ("Email", "Email")],
        default="WhatsApp",
        verbose_name=_("Canal Preferencial de Notificação"),
    )
    lembrete_enviado_em = models.DateTimeField(
        blank=True, null=True, verbose_name=_("Lembrete Enviado em")
    )
    status_notificacao = models.CharField(
        max_length=20,
        choices=[("Enviado", "Enviado"), ("Lido", "Lido"), ("Pendente", "Pendente")],
        default="Pendente",
        verbose_name=_("Status da Notificação"),
    )

    # Automação e Integração IoT
    equipamentos_necessarios = models.CharField(
        max_length=255, blank=True, verbose_name=_("Equipamentos Necessários")
    )
    sala_atendimento = models.CharField(
        max_length=50, blank=True, verbose_name=_("Sala de Atendimento")
    )
    dispositivo_iot = models.CharField(
        max_length=100, blank=True, verbose_name=_("Dispositivo IoT Necessário")
    )

    # Dados para IA e Machine Learning
    probabilidade_cancelamento = models.DecimalField(
        max_digits=5,
        decimal_places=2,
        null=True,
        blank=True,
        verbose_name=_("Probabilidade de Cancelamento (%)"),
    )
    tempo_espera_estimado = models.DurationField(
        blank=True, null=True, verbose_name=_("Tempo de Espera Estimado")
    )
    preferencias_paciente = models.CharField(
        max_length=255, blank=True, verbose_name=_("Preferências do Paciente")
    )
    confirmar_atendimento_automatico = models.BooleanField(
        default=False, verbose_name=_("Confirmar Atendimento Automaticamente")
    )

    # Histórico de Modificações
    log_modificacoes = models.TextField(
        blank=True, verbose_name=_("Histórico de Modificações")
    )
    historico_cancelamentos = models.TextField(
        blank=True, verbose_name=_("Histórico de Cancelamentos")
    )

    # Pré-Check-in
    pre_checkin_realizado = models.BooleanField(
        default=False, verbose_name=_("Pré-Check-in Realizado")
    )

    # Dados de Controle
    criado_em = models.DateTimeField(auto_now_add=True, verbose_name=_("Criado em"))
    atualizado_em = models.DateTimeField(auto_now=True, verbose_name=_("Atualizado em"))

    class Meta:
        verbose_name = _("Agendamento")
        verbose_name_plural = _("Agendamentos")
        app_label = "agendamentos"
        unique_together = (("profissional", "data_agendamento", "horario_inicio"),)

    def __str__(self):
        return f"Agendamento de {self.paciente.nome_completo} com {self.profissional.nome_completo} em {self.data_agendamento} às {self.horario_inicio}"
# Módulo Agendamentos - URLs (urls.py)

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import AgendamentoViewSet

router = DefaultRouter()
router.register(r"agendamentos", AgendamentoViewSet, basename="agendamento")

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Agendamento

admin.site.register(Agendamento)
# Módulo Agendamentos - Serializers (serializers.py)

from rest_framework import serializers
from django.utils import timezone
from .models import Agendamento
import uuid


class AgendamentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Agendamento
        fields = "__all__"

    def validate(self, data):
        # Validação para garantir que a data e horário do agendamento sejam
        # futuros
        if data["data_agendamento"] < timezone.now().date():
            raise serializers.ValidationError("A data do agendamento deve ser futura.")
        if (
            data["data_agendamento"] == timezone.now().date()
            and data["horario_inicio"] <= timezone.now().time()
        ):
            raise serializers.ValidationError("O horário de início deve ser no futuro.")

        # Validação para garantir que o horário de fim seja posterior ao
        # horário de início
        if data["horario_fim"] <= data["horario_inicio"]:
            raise serializers.ValidationError(
                "O horário de fim deve ser posterior ao horário de início."
            )

        # Validação para garantir que não haja sobreposição de agendamentos
        # para o mesmo profissional
        agendamentos_existentes = Agendamento.objects.filter(
            profissional=data["profissional"],
            data_agendamento=data["data_agendamento"],
            horario_inicio__lt=data["horario_fim"],
            horario_fim__gt=data["horario_inicio"],
        ).exclude(uuid=data.get("uuid"))
        if agendamentos_existentes.exists():
            raise serializers.ValidationError(
                "O horário do agendamento conflita com outro agendamento existente para este profissional."
            )

        # Validação para garantir que não haja sobreposição de agendamentos
        # para o mesmo paciente
        agendamentos_paciente = Agendamento.objects.filter(
            paciente=data["paciente"],
            data_agendamento=data["data_agendamento"],
            horario_inicio__lt=data["horario_fim"],
            horario_fim__gt=data["horario_inicio"],
        ).exclude(uuid=data.get("uuid"))
        if agendamentos_paciente.exists():
            raise serializers.ValidationError(
                "O paciente já possui um agendamento no mesmo horário."
            )

        # Validação para garantir que o status financeiro esteja correto se o
        # agendamento for concluído
        if data["status"] == "Concluído" and data["status_financeiro"] != "Pago":
            raise serializers.ValidationError(
                "Agendamentos concluídos devem ter o status financeiro como 'Pago'."
            )

        # Validação para garantir que o motivo do cancelamento esteja
        # preenchido se o agendamento for cancelado
        if data["status"] == "Cancelado" and not data.get("motivo_cancelamento"):
            raise serializers.ValidationError(
                "O motivo do cancelamento deve ser informado quando o agendamento for cancelado."
            )

        # Validação para garantir que o canal preferencial de notificação seja
        # consistente com as preferências do paciente
        if data["canal_preferencial"] not in ["WhatsApp", "SMS", "Email"]:
            raise serializers.ValidationError(
                "Canal preferencial de notificação inválido."
            )

        # Validação para garantir a disponibilidade dos equipamentos e sala de
        # atendimento
        if data.get("equipamentos_necessarios") or data.get("sala_atendimento"):
            conflitos = Agendamento.objects.filter(
                data_agendamento=data["data_agendamento"],
                horario_inicio__lt=data["horario_fim"],
                horario_fim__gt=data["horario_inicio"],
                sala_atendimento=data.get("sala_atendimento"),
            ).exclude(uuid=data.get("uuid"))
            if conflitos.exists():
                raise serializers.ValidationError(
                    "A sala de atendimento ou equipamentos necessários já estão reservados para outro agendamento no mesmo horário."
                )

        # Validação para garantir que o profissional não esteja de férias ou
        # ausente na data de agendamento
        if (
            hasattr(data["profissional"], "ferias")
            and data["profissional"]
            .ferias.filter(
                inicio__lte=data["data_agendamento"], fim__gte=data["data_agendamento"]
            )
            .exists()
        ):
            raise serializers.ValidationError(
                "O profissional está de férias ou ausente na data selecionada."
            )

        # Validação para limitar o número de agendamentos do mesmo paciente no
        # mesmo dia
        limite_agendamentos_paciente = Agendamento.objects.filter(
            paciente=data["paciente"], data_agendamento=data["data_agendamento"]
        ).count()
        if limite_agendamentos_paciente >= 3:
            raise serializers.ValidationError(
                "O paciente já possui muitos agendamentos para o mesmo dia."
            )

        # Validação de pré-check-in
        if data.get("pre_checkin_realizado") and not data.get(
            "confirmado_pelo_paciente"
        ):
            raise serializers.ValidationError(
                "O pré-check-in não pode ser realizado sem a confirmação do paciente."
            )

        # Validação para garantir que o agendamento não ocorra em feriados ou
        # dias bloqueados
        if (
            hasattr(data["profissional"], "dias_bloqueados")
            and data["profissional"]
            .dias_bloqueados.filter(data=data["data_agendamento"])
            .exists()
        ):
            raise serializers.ValidationError(
                "O agendamento não pode ser feito em um feriado ou dia bloqueado para este profissional."
            )

        # Validação para garantir que o status seja consistente com a
        # confirmação do paciente
        if data["status"] == "Concluído" and not data.get("confirmado_pelo_paciente"):
            raise serializers.ValidationError(
                "O agendamento não pode ser concluído sem a confirmação do paciente."
            )

        return data
# Módulo Agendamentos - Tests (tests.py)

from rest_framework.test import APITestCase, APIClient
from rest_framework import status
from django.urls import reverse
from .models import Agendamento
from apps.pacientes.models import Paciente
from apps.profissionais.models import Profissional
from django.utils import timezone
from django.contrib.auth import get_user_model
import uuid
from unittest.mock import patch

User = get_user_model()

class AgendamentoAPITestCase(APITestCase):
    def setUp(self):
        # Configurar usuários, paciente, profissional e agendamento para os testes
        self.client = APIClient()
        self.user_paciente = User.objects.create_user(
            username="paciente", password="testpassword"
        )
        self.paciente = Paciente.objects.create(
            usuario=self.user_paciente, nome_completo="Paciente Teste"
        )

        self.user_profissional = User.objects.create_user(
            username="profissional", password="testpassword"
        )
        self.profissional = Profissional.objects.create(
            usuario=self.user_profissional, nome_completo="Profissional Teste"
        )

        self.user_outro_paciente = User.objects.create_user(
            username="outro_paciente", password="testpassword"
        )
        self.outro_paciente = Paciente.objects.create(
            usuario=self.user_outro_paciente, nome_completo="Outro Paciente Teste"
        )

        self.agendamento = Agendamento.objects.create(
            uuid=uuid.uuid4(),
            paciente=self.paciente,
            profissional=self.profissional,
            data_agendamento=timezone.now().date() + timezone.timedelta(days=1),
            horario_inicio="10:00",
            horario_fim="11:00",
            tipo_consulta="Consulta Inicial",
        )
        self.agendamento_url = reverse(
            "agendamento-detail", kwargs={"pk": self.agendamento.pk}
        )

    def test_confirmar_agendamento(self):
        # Teste para confirmar um agendamento
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.post(
            reverse("agendamento-confirmar", kwargs={"pk": self.agendamento.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.agendamento.refresh_from_db()
        self.assertTrue(self.agendamento.confirmado_pelo_paciente)

    def test_confirmar_agendamento_outro_paciente(self):
        # Teste para garantir que um paciente não possa confirmar agendamento de outro paciente
        self.client.force_authenticate(user=self.user_outro_paciente)
        response = self.client.post(
            reverse("agendamento-confirmar", kwargs={"pk": self.agendamento.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_cancelar_agendamento(self):
        # Teste para cancelar um agendamento
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.post(
            reverse("agendamento-cancelar", kwargs={"pk": self.agendamento.pk}),
            {"motivo_cancelamento": "Imprevisto"},
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.agendamento.refresh_from_db()
        self.assertEqual(self.agendamento.status, "Cancelado")
        self.assertEqual(self.agendamento.motivo_cancelamento, "Imprevisto")

    def test_cancelar_agendamento_outro_paciente(self):
        # Teste para garantir que um paciente não possa cancelar agendamento de outro paciente
        self.client.force_authenticate(user=self.user_outro_paciente)
        response = self.client.post(
            reverse("agendamento-cancelar", kwargs={"pk": self.agendamento.pk}),
            {"motivo_cancelamento": "Imprevisto"},
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_reagendar_agendamento(self):
        # Teste para reagendar um agendamento
        self.client.force_authenticate(user=self.user_paciente)
        nova_data = timezone.now().date() + timezone.timedelta(days=2)
        response = self.client.post(
            reverse("agendamento-reagendar", kwargs={"pk": self.agendamento.pk}),
            {
                "data_agendamento": nova_data,
                "horario_inicio": "11:00",
                "horario_fim": "12:00",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.agendamento.refresh_from_db()
        self.assertEqual(self.agendamento.data_agendamento, nova_data)
        self.assertEqual(self.agendamento.horario_inicio, "11:00")
        self.assertEqual(self.agendamento.horario_fim, "12:00")

    def test_reagendar_agendamento_data_passada(self):
        # Teste para garantir que não seja possível reagendar para uma data passada
        self.client.force_authenticate(user=self.user_paciente)
        nova_data = timezone.now().date() - timezone.timedelta(days=1)
        response = self.client.post(
            reverse("agendamento-reagendar", kwargs={"pk": self.agendamento.pk}),
            {
                "data_agendamento": nova_data,
                "horario_inicio": "11:00",
                "horario_fim": "12:00",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    @patch("apps.agendamentos.views.send_notification")
    def test_confirmar_agendamento_notificacao(self, mock_send_notification):
        # Teste para confirmar um agendamento e verificar se a notificação foi enviada
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.post(
            reverse("agendamento-confirmar", kwargs={"pk": self.agendamento.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        mock_send_notification.assert_called_once()

    def test_meus_agendamentos(self):
        # Teste para listar agendamentos do paciente autenticado
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.get(reverse("agendamento-meus-agendamentos"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["id"], self.agendamento.id)

    def test_meus_agendamentos_outro_paciente(self):
        # Teste para garantir que um paciente veja apenas seus próprios agendamentos
        self.client.force_authenticate(user=self.user_outro_paciente)
        response = self.client.get(reverse("agendamento-meus-agendamentos"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 0)
from rest_framework import viewsets
from .models import Recursos_humanosModel
from .serializers import Recursos_humanosSerializer


class Recursos_humanosViewSet(viewsets.ModelViewSet):
    queryset = Recursos_humanosModel.objects.all()
    serializer_class = Recursos_humanosSerializer
from django.apps import AppConfig


class Recursos_humanosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.recursos_humanos"
from django.db import models


class Recursos_humanosModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Recursos_humanosViewSet

router = DefaultRouter()
router.register(r"recursos_humanos", Recursos_humanosViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Recursos_humanosModel


@admin.register(Recursos_humanosModel)
class Recursos_humanosAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import Recursos_humanosModel


class Recursos_humanosSerializer(serializers.ModelSerializer):
    class Meta:
        model = Recursos_humanosModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import QualidadeModel
from .serializers import QualidadeSerializer


class QualidadeViewSet(viewsets.ModelViewSet):
    queryset = QualidadeModel.objects.all()
    serializer_class = QualidadeSerializer
from django.apps import AppConfig


class QualidadeConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.qualidade"
from django.db import models


class QualidadeModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import QualidadeViewSet

router = DefaultRouter()
router.register(r"qualidade", QualidadeViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import QualidadeModel


@admin.register(QualidadeModel)
class QualidadeAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import QualidadeModel


class QualidadeSerializer(serializers.ModelSerializer):
    class Meta:
        model = QualidadeModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import AvaliacoesModel
from .serializers import AvaliacoesSerializer


class AvaliacoesViewSet(viewsets.ModelViewSet):
    queryset = AvaliacoesModel.objects.all()
    serializer_class = AvaliacoesSerializer
from django.apps import AppConfig


class AvaliacoesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.avaliacoes"
from django.db import models


class AvaliacoesModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import AvaliacoesViewSet

router = DefaultRouter()
router.register(r"avaliacoes", AvaliacoesViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import AvaliacoesModel


@admin.register(AvaliacoesModel)
class AvaliacoesAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import AvaliacoesModel


class AvaliacoesSerializer(serializers.ModelSerializer):
    class Meta:
        model = AvaliacoesModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
from rest_framework import viewsets
from .models import Assinar_documentosModel
from .serializers import Assinar_documentosSerializer


class Assinar_documentosViewSet(viewsets.ModelViewSet):
    queryset = Assinar_documentosModel.objects.all()
    serializer_class = Assinar_documentosSerializer
from django.apps import AppConfig


class Assinar_documentosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.assinar_documentos"
from django.db import models


class Assinar_documentosModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Assinar_documentosViewSet

router = DefaultRouter()
router.register(r"assinar_documentos", Assinar_documentosViewSet)

urlpatterns = [
    path("", include(router.urls)),
]
from django.contrib import admin
from .models import Assinar_documentosModel


@admin.register(Assinar_documentosModel)
class Assinar_documentosAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")
from rest_framework import serializers
from .models import Assinar_documentosModel


class Assinar_documentosSerializer(serializers.ModelSerializer):
    class Meta:
        model = Assinar_documentosModel
        fields = "__all__"
from django.test import TestCase

# Create your tests here.
import os
import concurrent.futures
from django.core.management import call_command
import django


def criar_estrutura_modulo(modulo_nome, base_path):
    pasta_modulo = os.path.join(base_path, "apps", modulo_nome)

    try:
        # Criar pasta do módulo
        os.makedirs(pasta_modulo, exist_ok=True)
        print(f"Pasta {pasta_modulo} criada com sucesso.")

        # Criar models.py
        models_content = f"""from django.db import models

class {modulo_nome.capitalize()}Model(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome
"""
        criar_arquivo(os.path.join(pasta_modulo, "models.py"), models_content)

        # Criar serializers.py
        serializers_content = f"""from rest_framework import serializers
from .models import {modulo_nome.capitalize()}Model

class {modulo_nome.capitalize()}Serializer(serializers.ModelSerializer):
    class Meta:
        model = {modulo_nome.capitalize()}Model
        fields = '__all__'
"""
        criar_arquivo(os.path.join(pasta_modulo, "serializers.py"), serializers_content)

        # Criar views.py
        views_content = f"""from rest_framework import viewsets
from .models import {modulo_nome.capitalize()}Model
from .serializers import {modulo_nome.capitalize()}Serializer

class {modulo_nome.capitalize()}ViewSet(viewsets.ModelViewSet):
    queryset = {modulo_nome.capitalize()}Model.objects.all()
    serializer_class = {modulo_nome.capitalize()}Serializer
"""
        criar_arquivo(os.path.join(pasta_modulo, "views.py"), views_content)

        # Criar urls.py
        urls_content = f"""from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import {modulo_nome.capitalize()}ViewSet

router = DefaultRouter()
router.register(r'{modulo_nome}', {modulo_nome.capitalize()}ViewSet)

urlpatterns = [
    path('', include(router.urls)),
]
"""
        criar_arquivo(os.path.join(pasta_modulo, "urls.py"), urls_content)

        # Criar admin.py
        admin_content = f"""from django.contrib import admin
from .models import {modulo_nome.capitalize()}Model

@admin.register({modulo_nome.capitalize()}Model)
class {modulo_nome.capitalize()}Admin(admin.ModelAdmin):
    list_display = ('nome', 'criado_em', 'atualizado_em')
"""
        criar_arquivo(os.path.join(pasta_modulo, "admin.py"), admin_content)

        print(f"Arquivos do módulo {modulo_nome} criados com sucesso.")

    except Exception as e:
        print(f"Erro ao criar estrutura do módulo {modulo_nome}: {e}")


def criar_estrutura_modulos(base_path):
    settings_path = os.path.join(base_path, "ClinicaAI", "settings.py")
    modulos = [
        "crm",
        "vendas",
        "recrutamento",
        "recursos_humanos",
        "ecommerce",
        "compromissos",
        "mensagens",
        "servico_campo",
        "planilhas_horas",
        "projeto",
        "qualidade",
        "compras",
        "manutencao",
        "forum",
        "blog",
        "elearning",
        "plm",
        "fabricacao",
        "inventario",
        "chat_ao_vivo",
        "criador_sites",
        "locacao",
        "assinaturas",
        "assinar_documentos",
        "documentos",
        "planilhas",
        "despesas",
        "faturamento",
        "marketing_sms",
        "marketing_email",
        "redes_sociais",
        "frota",
        "indicacoes",
        "avaliacoes",
        "folgas",
    ]

    with concurrent.futures.ThreadPoolExecutor() as executor:
        executor.map(lambda modulo: criar_estrutura_modulo(modulo, base_path), modulos)

    # Atualizar urls.py principal
    urls_principal_path = os.path.join(base_path, "ClinicaAI", "urls.py")
    urls_principal_content = [
        "from django.contrib import admin",
        "from django.urls import path, include",
        "",
        "urlpatterns = [",
        "    path('admin/', admin.site.urls),",
    ]
    for modulo_nome in modulos:
        urls_principal_content.append(
            f"    path('{modulo_nome}/', include('apps.{modulo_nome}.urls')),"
        )
    urls_principal_content.append("]")
    urls_principal_content = "\n".join(urls_principal_content)
    criar_arquivo(urls_principal_path, urls_principal_content)

    # Atualizar settings.py para incluir os módulos em INSTALLED_APPS
    atualizar_installed_apps(settings_path, modulos)


def atualizar_installed_apps(settings_path, modulos):
    with open(settings_path, "r") as settings_file:
        settings_content = settings_file.read()

    installed_apps_start = settings_content.find("INSTALLED_APPS = [")
    if installed_apps_start != -1:
        installed_apps_end = settings_content.find("\n]", installed_apps_start) + 1
        installed_apps_section = settings_content[
            installed_apps_start:installed_apps_end
        ]
        for modulo_nome in modulos:
            app_entry = f"    'apps.{modulo_nome}',"
            if app_entry not in installed_apps_section:
                installed_apps_section += f"\n{app_entry}"
        new_settings_content = (
            settings_content[:installed_apps_start]
            + installed_apps_section
            + settings_content[installed_apps_end:]
        )
        criar_arquivo(settings_path, new_settings_content)


def criar_arquivo(caminho, conteudo):
    with open(caminho, "w") as arquivo:
        arquivo.write(conteudo)
    print(f"Arquivo {caminho} criado com sucesso.")


if __name__ == "__main__":
    base_path = os.path.dirname(os.path.abspath(__file__))
    criar_estrutura_modulos(base_path)

    # Configurar as configurações do Django antes de rodar os comandos de migração
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "ClinicaAI.settings")
    django.setup()

    # Após criar os arquivos, rodar as migrações para todos os módulos
    call_command("makemigrations")
    call_command("migrate")
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys




def main():
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "ClinicaAI.settings")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()
import os


def listar_arquivos(caminho):
    """Lista todos os arquivos em um diretório e subdiretórios."""
    with open("lista_arquivos.txt", "w") as arquivo_saida:
        for root, _, files in os.walk(caminho):
            for file in files:
                arquivo_saida.write(os.path.join(root, file) + "\n")


if __name__ == "__main__":
    listar_arquivos("/mnt/dados/ClinicaAI/backend/apps/")
    listar_arquivos("/mnt/dados/ClinicaAI/backend/ClinicaAI")
"""
ASGI config for ClinicaAI project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "ClinicaAI.settings")

application = get_asgi_application()

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path("admin/", admin.site.urls),
    path("crm/", include("apps.crm.urls")),
    path("vendas/", include("apps.vendas.urls")),
    path("recrutamento/", include("apps.recrutamento.urls")),
    path("recursos_humanos/", include("apps.recursos_humanos.urls")),
    path("ecommerce/", include("apps.ecommerce.urls")),
    path("compromissos/", include("apps.compromissos.urls")),
    path("mensagens/", include("apps.mensagens.urls")),
    path("servico_campo/", include("apps.servico_campo.urls")),
    path("planilhas_horas/", include("apps.planilhas_horas.urls")),
    path("projeto/", include("apps.projeto.urls")),
    path("qualidade/", include("apps.qualidade.urls")),
    path("compras/", include("apps.compras.urls")),
    path("manutencao/", include("apps.manutencao.urls")),
    path("forum/", include("apps.forum.urls")),
    path("blog/", include("apps.blog.urls")),
    path("elearning/", include("apps.elearning.urls")),
    path("plm/", include("apps.plm.urls")),
    path("fabricacao/", include("apps.fabricacao.urls")),
    path("inventario/", include("apps.inventario.urls")),
    path("chat_ao_vivo/", include("apps.chat_ao_vivo.urls")),
    path("criador_sites/", include("apps.criador_sites.urls")),
    path("locacao/", include("apps.locacao.urls")),
    path("assinaturas/", include("apps.assinaturas.urls")),
    path("assinar_documentos/", include("apps.assinar_documentos.urls")),
    path("documentos/", include("apps.documentos.urls")),
    path("planilhas/", include("apps.planilhas.urls")),
    path("despesas/", include("apps.despesas.urls")),
    path("faturamento/", include("apps.faturamento.urls")),
    path("marketing_sms/", include("apps.marketing_sms.urls")),
    path("marketing_email/", include("apps.marketing_email.urls")),
    path("redes_sociais/", include("apps.redes_sociais.urls")),
    path("frota/", include("apps.frota.urls")),
    path("indicacoes/", include("apps.indicacoes.urls")),
    path("avaliacoes/", include("apps.avaliacoes.urls")),
    path("folgas/", include("apps.folgas.urls")),
    path("pacientes/", include("apps.pacientes.urls")),
    path("prontuarios/", include("apps.prontuarios.urls")),
    path("exames/", include("apps.exames.urls")),
    path("atendimentos/", include("apps.atendimentos.urls")),
    path("agendamentos/", include("apps.agendamentos.urls")),
    path("profissionais/", include("apps.profissionais.urls")),
]
"""
WSGI config for ClinicaAI project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "ClinicaAI.settings")

application = get_wsgi_application()
"""
Django settings for ClinicaAI project.

Generated by 'django-admin startproject' using Django 4.2.16.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""

import sys
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
sys.path.append(str(BASE_DIR / "apps"))

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure-xp07(pa6ct^w3$k9-dqf0c-6r%)b(x!s)6(csocel=e5tm2s*3"

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition


INSTALLED_APPS = [
    # Django core apps
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    'django_filters',
    # Third-party apps
    "prometheus_client",
    "drf_yasg",
    "channels",
    "corsheaders",
    "rest_framework",
    # Project apps (ordered by dependencies)
    "apps.profissionais",
    "apps.pacientes",
    "apps.prontuarios",
    "apps.exames",
    "apps.atendimentos",
    "apps.agendamentos",
    "apps.assinaturas",
    "apps.assinar_documentos",
    "apps.documentos",
    "apps.financeiro",
    "apps.faturamento",
    "apps.crm",
    "apps.vendas",
    "apps.ecommerce",
    "apps.blog",
    "apps.marketing_sms",
    "apps.marketing_email",
    "apps.redes_sociais",
    "apps.automacao_marketing",
    "apps.conhecimento",
    "apps.chat_ao_vivo",
    "apps.mensagens",
    "apps.whatsapp",
    "apps.voip",
    "apps.forum",
    "apps.central_ajuda",
    "apps.eventos",
    "apps.indicacoes",
    "apps.elearning",
    "apps.projeto",
    "apps.planilhas_horas",
    "apps.produtividade",
    "apps.compromissos",
    "apps.servico_campo",
    "apps.qualidade",
    "apps.recursos_humanos",
    "apps.recrutamento",
    "apps.folgas",
    "apps.avaliacoes",
    "apps.plm",
    "apps.fabricacao",
    "apps.inventario",
    "apps.locacao",
    "apps.frota",
    "apps.aprovacoes",
    "apps.despesas",
    "apps.compras",
    "apps.manutencao",
    "apps.planilhas",
    "apps.criador_sites",
    "apps.iot",
]


MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "ClinicaAI.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "ClinicaAI.wsgi.application"
ENCRYPTION_KEY = "b-Q_0ri6gj0fA45I33ZBTM5OAA4yRijdXJdREVyKSZs="

# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "clinicaai",
        "USER": "diego",
        "PASSWORD": "Mouse2250@#86",
        "HOST": "localhost",
        "PORT": "5432",
    }
}


# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = "static/"

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"
CORS_ALLOWED_ORIGINS = ["http://localhost:3000"]
ASGI_APPLICATION = "ClinicaAI.asgi.application"
CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels_redis.core.RedisChannelLayer",
        "CONFIG": {
            "hosts": [("127.0.0.1", 6379)],
        },
    },
}
CELERY_BROKER_URL = "redis://localhost:6379/0"
CELERY_RESULT_BACKEND = "redis://localhost:6379/0"
REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ),
    "DEFAULT_PERMISSION_CLASSES": ("rest_framework.permissions.IsAuthenticated",),
}
