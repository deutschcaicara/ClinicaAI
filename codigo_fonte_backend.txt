### C:\ClinicaAI\backend\manage.py ###
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'ClinicaAI.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


### C:\ClinicaAI\backend\requirements.txt ###
### C:\ClinicaAI\backend\txt.py ###
import os

def save_backend_source_code(project_path, output_file):
    # Diretórios e arquivos a excluir
    exclude_dirs = {'.venv', '__pycache__', '.git', 'migrations', 'node_modules'}
    exclude_extensions = {'.pyc', '.log'}
    
    with open(output_file, 'w', encoding='utf-8') as output:
        for root, dirs, files in os.walk(project_path):
            # Remove diretórios a excluir da iteração
            dirs[:] = [d for d in dirs if d not in exclude_dirs]
            
            for file in files:
                # Ignorar arquivos com extensões irrelevantes
                if any(file.endswith(ext) for ext in exclude_extensions):
                    continue
                
                # Caminho completo do arquivo
                file_path = os.path.join(root, file)
                
                try:
                    # Ler e salvar o conteúdo do arquivo
                    with open(file_path, 'r', encoding='utf-8') as f:
                        output.write(f"### {file_path} ###\n")
                        output.write(f.read())
                        output.write("\n\n")
                except Exception as e:
                    print(f"Erro ao processar {file_path}: {e}")

if __name__ == "__main__":
    # Caminho do backend e arquivo de saída
    backend_path = r"C:\ClinicaAI\backend"
    output_file = r"C:\ClinicaAI\codigo_fonte_backend.txt"
    
    save_backend_source_code(backend_path, output_file)
    print(f"Código fonte do backend salvo em {output_file}")


### C:\ClinicaAI\backend\apps\agendamentos\admin.py ###
from django.contrib import admin
from .models import Agendamento

admin.site.register(Agendamento)


### C:\ClinicaAI\backend\apps\agendamentos\apps.py ###
from django.apps import AppConfig


class AgendamentosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.agendamentos"


### C:\ClinicaAI\backend\apps\agendamentos\models.py ###
from django.db import models
from django.utils.translation import gettext_lazy as _
from django.conf import settings
from apps.profissionais.models import Profissional

from apps.pacientes.models import Paciente

import uuid


class Agendamento(models.Model):
    # Identificador Único Global
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    paciente = models.ForeignKey(
    'pacientes.Paciente', on_delete=models.CASCADE, related_name='agendamentos'
)




    profissional = models.ForeignKey(
        Profissional, on_delete=models.CASCADE, related_name="agendamentos_profissional"
    )

    # Dados do Agendamento
    data_agendamento = models.DateField(verbose_name=_("Data do Agendamento"))
    horario_inicio = models.TimeField(verbose_name=_("Horário de Início"))
    horario_fim = models.TimeField(verbose_name=_("Horário de Fim"))
    tipo_consulta = models.CharField(
        max_length=50,
        choices=[
            ("Consulta Inicial", "Consulta Inicial"),
            ("Retorno", "Retorno"),
            ("Exame", "Exame"),
            ("Teleconsulta", "Teleconsulta"),
        ],
        default="Consulta Inicial",
        verbose_name=_("Tipo de Consulta"),
    )
    local_atendimento = models.CharField(
        max_length=50,
        choices=[
            ("Presencial", "Presencial"),
            ("Telemedicina", "Telemedicina"),
            ("Visita Domiciliar", "Visita Domiciliar"),
        ],
        default="Presencial",
        verbose_name=_("Local do Atendimento"),
    )
    status = models.CharField(
        max_length=20,
        choices=[
            ("Agendado", "Agendado"),
            ("Cancelado", "Cancelado"),
            ("Concluído", "Concluído"),
        ],
        default="Agendado",
        verbose_name=_("Status do Agendamento"),
    )
    motivo_cancelamento = models.TextField(
        blank=True, null=True, verbose_name=_("Motivo do Cancelamento")
    )
    confirmado_pelo_paciente = models.BooleanField(
        default=False, verbose_name=_("Confirmado pelo Paciente")
    )
    observacoes = models.TextField(blank=True, verbose_name=_("Observações"))
    sintomas_iniciais = models.TextField(
        blank=True, verbose_name=_("Sintomas Iniciais")
    )
    tipo_atendimento = models.CharField(
        max_length=20,
        choices=[("Emergencial", "Emergencial"), ("Rotina", "Rotina")],
        default="Rotina",
        verbose_name=_("Tipo de Atendimento"),
    )
    motivo_consulta = models.CharField(
        max_length=255, blank=True, verbose_name=_("Motivo da Consulta")
    )

    # Dados Financeiros
    meio_pagamento = models.CharField(
        max_length=50,
        choices=[
            ("Cartão de Crédito", "Cartão de Crédito"),
            ("Convênio", "Convênio"),
            ("Dinheiro", "Dinheiro"),
            ("PIX", "PIX"),
        ],
        blank=True,
        verbose_name=_("Meio de Pagamento"),
    )
    status_financeiro = models.CharField(
        max_length=20,
        choices=[("Pago", "Pago"), ("Pendente", "Pendente")],
        default="Pendente",
        verbose_name=_("Status Financeiro"),
    )

    # Notificações e Lembretes
    canal_preferencial = models.CharField(
        max_length=20,
        choices=[("WhatsApp", "WhatsApp"), ("SMS", "SMS"), ("Email", "Email")],
        default="WhatsApp",
        verbose_name=_("Canal Preferencial de Notificação"),
    )
    lembrete_enviado_em = models.DateTimeField(
        blank=True, null=True, verbose_name=_("Lembrete Enviado em")
    )
    status_notificacao = models.CharField(
        max_length=20,
        choices=[("Enviado", "Enviado"), ("Lido", "Lido"), ("Pendente", "Pendente")],
        default="Pendente",
        verbose_name=_("Status da Notificação"),
    )

    # Automação e Integração IoT
    equipamentos_necessarios = models.CharField(
        max_length=255, blank=True, verbose_name=_("Equipamentos Necessários")
    )
    sala_atendimento = models.CharField(
        max_length=50, blank=True, verbose_name=_("Sala de Atendimento")
    )
    dispositivo_iot = models.CharField(
        max_length=100, blank=True, verbose_name=_("Dispositivo IoT Necessário")
    )

    # Dados para IA e Machine Learning
    probabilidade_cancelamento = models.DecimalField(
        max_digits=5,
        decimal_places=2,
        null=True,
        blank=True,
        verbose_name=_("Probabilidade de Cancelamento (%)"),
    )
    tempo_espera_estimado = models.DurationField(
        blank=True, null=True, verbose_name=_("Tempo de Espera Estimado")
    )
    preferencias_paciente = models.CharField(
        max_length=255, blank=True, verbose_name=_("Preferências do Paciente")
    )
    confirmar_atendimento_automatico = models.BooleanField(
        default=False, verbose_name=_("Confirmar Atendimento Automaticamente")
    )

    # Histórico de Modificações
    log_modificacoes = models.TextField(
        blank=True, verbose_name=_("Histórico de Modificações")
    )
    historico_cancelamentos = models.TextField(
        blank=True, verbose_name=_("Histórico de Cancelamentos")
    )

    # Pré-Check-in
    pre_checkin_realizado = models.BooleanField(
        default=False, verbose_name=_("Pré-Check-in Realizado")
    )

    # Dados de Controle
    criado_em = models.DateTimeField(auto_now_add=True, verbose_name=_("Criado em"))
    atualizado_em = models.DateTimeField(auto_now=True, verbose_name=_("Atualizado em"))

    class Meta:
        verbose_name = _("Agendamento")
        verbose_name_plural = _("Agendamentos")
        app_label = "agendamentos"
        unique_together = (("profissional", "data_agendamento", "horario_inicio"),)

    def __str__(self):
        return f"Agendamento de {self.paciente.nome_completo} com {self.profissional.nome_completo} em {self.data_agendamento} às {self.horario_inicio}"


### C:\ClinicaAI\backend\apps\agendamentos\serializers.py ###
# Módulo Agendamentos - Serializers (serializers.py)

from rest_framework import serializers
from django.utils import timezone
from .models import Agendamento
import uuid


class AgendamentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Agendamento
        fields = "__all__"

    def validate(self, data):
        # Validação para garantir que a data e horário do agendamento sejam
        # futuros
        if data["data_agendamento"] < timezone.now().date():
            raise serializers.ValidationError("A data do agendamento deve ser futura.")
        if (
            data["data_agendamento"] == timezone.now().date()
            and data["horario_inicio"] <= timezone.now().time()
        ):
            raise serializers.ValidationError("O horário de início deve ser no futuro.")

        # Validação para garantir que o horário de fim seja posterior ao
        # horário de início
        if data["horario_fim"] <= data["horario_inicio"]:
            raise serializers.ValidationError(
                "O horário de fim deve ser posterior ao horário de início."
            )

        # Validação para garantir que não haja sobreposição de agendamentos
        # para o mesmo profissional
        agendamentos_existentes = Agendamento.objects.filter(
            profissional=data["profissional"],
            data_agendamento=data["data_agendamento"],
            horario_inicio__lt=data["horario_fim"],
            horario_fim__gt=data["horario_inicio"],
        ).exclude(uuid=data.get("uuid"))
        if agendamentos_existentes.exists():
            raise serializers.ValidationError(
                "O horário do agendamento conflita com outro agendamento existente para este profissional."
            )

        # Validação para garantir que não haja sobreposição de agendamentos
        # para o mesmo paciente
        agendamentos_paciente = Agendamento.objects.filter(
            paciente=data["paciente"],
            data_agendamento=data["data_agendamento"],
            horario_inicio__lt=data["horario_fim"],
            horario_fim__gt=data["horario_inicio"],
        ).exclude(uuid=data.get("uuid"))
        if agendamentos_paciente.exists():
            raise serializers.ValidationError(
                "O paciente já possui um agendamento no mesmo horário."
            )

        # Validação para garantir que o status financeiro esteja correto se o
        # agendamento for concluído
        if data["status"] == "Concluído" and data["status_financeiro"] != "Pago":
            raise serializers.ValidationError(
                "Agendamentos concluídos devem ter o status financeiro como 'Pago'."
            )

        # Validação para garantir que o motivo do cancelamento esteja
        # preenchido se o agendamento for cancelado
        if data["status"] == "Cancelado" and not data.get("motivo_cancelamento"):
            raise serializers.ValidationError(
                "O motivo do cancelamento deve ser informado quando o agendamento for cancelado."
            )

        # Validação para garantir que o canal preferencial de notificação seja
        # consistente com as preferências do paciente
        if data["canal_preferencial"] not in ["WhatsApp", "SMS", "Email"]:
            raise serializers.ValidationError(
                "Canal preferencial de notificação inválido."
            )

        # Validação para garantir a disponibilidade dos equipamentos e sala de
        # atendimento
        if data.get("equipamentos_necessarios") or data.get("sala_atendimento"):
            conflitos = Agendamento.objects.filter(
                data_agendamento=data["data_agendamento"],
                horario_inicio__lt=data["horario_fim"],
                horario_fim__gt=data["horario_inicio"],
                sala_atendimento=data.get("sala_atendimento"),
            ).exclude(uuid=data.get("uuid"))
            if conflitos.exists():
                raise serializers.ValidationError(
                    "A sala de atendimento ou equipamentos necessários já estão reservados para outro agendamento no mesmo horário."
                )

        # Validação para garantir que o profissional não esteja de férias ou
        # ausente na data de agendamento
        if (
            hasattr(data["profissional"], "ferias")
            and data["profissional"]
            .ferias.filter(
                inicio__lte=data["data_agendamento"], fim__gte=data["data_agendamento"]
            )
            .exists()
        ):
            raise serializers.ValidationError(
                "O profissional está de férias ou ausente na data selecionada."
            )

        # Validação para limitar o número de agendamentos do mesmo paciente no
        # mesmo dia
        limite_agendamentos_paciente = Agendamento.objects.filter(
            paciente=data["paciente"], data_agendamento=data["data_agendamento"]
        ).count()
        if limite_agendamentos_paciente >= 3:
            raise serializers.ValidationError(
                "O paciente já possui muitos agendamentos para o mesmo dia."
            )

        # Validação de pré-check-in
        if data.get("pre_checkin_realizado") and not data.get(
            "confirmado_pelo_paciente"
        ):
            raise serializers.ValidationError(
                "O pré-check-in não pode ser realizado sem a confirmação do paciente."
            )

        # Validação para garantir que o agendamento não ocorra em feriados ou
        # dias bloqueados
        if (
            hasattr(data["profissional"], "dias_bloqueados")
            and data["profissional"]
            .dias_bloqueados.filter(data=data["data_agendamento"])
            .exists()
        ):
            raise serializers.ValidationError(
                "O agendamento não pode ser feito em um feriado ou dia bloqueado para este profissional."
            )

        # Validação para garantir que o status seja consistente com a
        # confirmação do paciente
        if data["status"] == "Concluído" and not data.get("confirmado_pelo_paciente"):
            raise serializers.ValidationError(
                "O agendamento não pode ser concluído sem a confirmação do paciente."
            )

        return data


### C:\ClinicaAI\backend\apps\agendamentos\tests.py ###
# Módulo Agendamentos - Tests (tests.py)

from rest_framework.test import APITestCase, APIClient
from rest_framework import status
from django.urls import reverse
from .models import Agendamento
from apps.pacientes.models import Paciente
from apps.profissionais.models import Profissional
from django.utils import timezone
from django.contrib.auth import get_user_model
import uuid
from unittest.mock import patch

User = get_user_model()

class AgendamentoAPITestCase(APITestCase):
    def setUp(self):
        # Configurar usuários, paciente, profissional e agendamento para os testes
        self.client = APIClient()
        self.user_paciente = User.objects.create_user(
            username="paciente", password="testpassword"
        )
        self.paciente = Paciente.objects.create(
            usuario=self.user_paciente, nome_completo="Paciente Teste"
        )

        self.user_profissional = User.objects.create_user(
            username="profissional", password="testpassword"
        )
        self.profissional = Profissional.objects.create(
            usuario=self.user_profissional, nome_completo="Profissional Teste"
        )

        self.user_outro_paciente = User.objects.create_user(
            username="outro_paciente", password="testpassword"
        )
        self.outro_paciente = Paciente.objects.create(
            usuario=self.user_outro_paciente, nome_completo="Outro Paciente Teste"
        )

        self.agendamento = Agendamento.objects.create(
            uuid=uuid.uuid4(),
            paciente=self.paciente,
            profissional=self.profissional,
            data_agendamento=timezone.now().date() + timezone.timedelta(days=1),
            horario_inicio="10:00",
            horario_fim="11:00",
            tipo_consulta="Consulta Inicial",
        )
        self.agendamento_url = reverse(
            "agendamento-detail", kwargs={"pk": self.agendamento.pk}
        )

    def test_confirmar_agendamento(self):
        # Teste para confirmar um agendamento
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.post(
            reverse("agendamento-confirmar", kwargs={"pk": self.agendamento.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.agendamento.refresh_from_db()
        self.assertTrue(self.agendamento.confirmado_pelo_paciente)

    def test_confirmar_agendamento_outro_paciente(self):
        # Teste para garantir que um paciente não possa confirmar agendamento de outro paciente
        self.client.force_authenticate(user=self.user_outro_paciente)
        response = self.client.post(
            reverse("agendamento-confirmar", kwargs={"pk": self.agendamento.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_cancelar_agendamento(self):
        # Teste para cancelar um agendamento
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.post(
            reverse("agendamento-cancelar", kwargs={"pk": self.agendamento.pk}),
            {"motivo_cancelamento": "Imprevisto"},
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.agendamento.refresh_from_db()
        self.assertEqual(self.agendamento.status, "Cancelado")
        self.assertEqual(self.agendamento.motivo_cancelamento, "Imprevisto")

    def test_cancelar_agendamento_outro_paciente(self):
        # Teste para garantir que um paciente não possa cancelar agendamento de outro paciente
        self.client.force_authenticate(user=self.user_outro_paciente)
        response = self.client.post(
            reverse("agendamento-cancelar", kwargs={"pk": self.agendamento.pk}),
            {"motivo_cancelamento": "Imprevisto"},
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_reagendar_agendamento(self):
        # Teste para reagendar um agendamento
        self.client.force_authenticate(user=self.user_paciente)
        nova_data = timezone.now().date() + timezone.timedelta(days=2)
        response = self.client.post(
            reverse("agendamento-reagendar", kwargs={"pk": self.agendamento.pk}),
            {
                "data_agendamento": nova_data,
                "horario_inicio": "11:00",
                "horario_fim": "12:00",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.agendamento.refresh_from_db()
        self.assertEqual(self.agendamento.data_agendamento, nova_data)
        self.assertEqual(self.agendamento.horario_inicio, "11:00")
        self.assertEqual(self.agendamento.horario_fim, "12:00")

    def test_reagendar_agendamento_data_passada(self):
        # Teste para garantir que não seja possível reagendar para uma data passada
        self.client.force_authenticate(user=self.user_paciente)
        nova_data = timezone.now().date() - timezone.timedelta(days=1)
        response = self.client.post(
            reverse("agendamento-reagendar", kwargs={"pk": self.agendamento.pk}),
            {
                "data_agendamento": nova_data,
                "horario_inicio": "11:00",
                "horario_fim": "12:00",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    @patch("apps.agendamentos.views.send_notification")
    def test_confirmar_agendamento_notificacao(self, mock_send_notification):
        # Teste para confirmar um agendamento e verificar se a notificação foi enviada
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.post(
            reverse("agendamento-confirmar", kwargs={"pk": self.agendamento.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        mock_send_notification.assert_called_once()

    def test_meus_agendamentos(self):
        # Teste para listar agendamentos do paciente autenticado
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.get(reverse("agendamento-meus-agendamentos"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["id"], self.agendamento.id)

    def test_meus_agendamentos_outro_paciente(self):
        # Teste para garantir que um paciente veja apenas seus próprios agendamentos
        self.client.force_authenticate(user=self.user_outro_paciente)
        response = self.client.get(reverse("agendamento-meus-agendamentos"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 0)


### C:\ClinicaAI\backend\apps\agendamentos\urls.py ###
# Módulo Agendamentos - URLs (urls.py)

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import AgendamentoViewSet

router = DefaultRouter()
router.register(r"agendamentos", AgendamentoViewSet, basename="agendamento")

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\agendamentos\views.py ###
# Módulo Agendamentos - Views (views.py)

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Agendamento
from .serializers import AgendamentoSerializer
from django.utils import timezone
from django.core.mail import send_mail
from django.conf import settings
import logging
import threading
import uuid

logger = logging.getLogger(__name__)


class AgendamentoViewSet(viewsets.ModelViewSet):
    serializer_class = AgendamentoSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna os agendamentos futuros do usuário autenticado (paciente ou
        # profissional)
        user = self.request.user
        if hasattr(user, 'paciente'):
            return Agendamento.objects.filter(
    paciente=user.paciente,
     data_agendamento__gte=timezone.now().date())
        elif hasattr(user, 'profissional'):
            return Agendamento.objects.filter(
    profissional=user.profissional,
     data_agendamento__gte=timezone.now().date())
        return Agendamento.objects.none()

    @action(detail=True, methods=['post'],
            permission_classes=[IsAuthenticated])
    def confirmar(self, request, pk=None):
        # Ação para confirmar o agendamento pelo paciente
        agendamento = self.get_object()
        if hasattr(
    request.user,
     'paciente') and agendamento.paciente != request.user.paciente:
            return Response(
    {
        'detail': 'Você não tem permissão para confirmar este agendamento.'},
         status=status.HTTP_403_FORBIDDEN)

        if agendamento.confirmado_pelo_paciente:
            return Response({'detail': 'Agendamento já foi confirmado.'},
                            status=status.HTTP_400_BAD_REQUEST)

        agendamento.confirmado_pelo_paciente = True
        agendamento.save()

       

    @ action(detail=True, methods=['post'],
             permission_classes=[IsAuthenticated])
    def cancelar(self, request, pk=None):
        # Ação para cancelar um agendamento
        agendamento= self.get_object()
        motivo= request.data.get('motivo_cancelamento')
        if not motivo:
            return Response({'detail': 'Motivo do cancelamento deve ser informado.'},
                            status=status.HTTP_400_BAD_REQUEST)

        # Verificar permissões de cancelamento
        if hasattr(
    request.user,
     'paciente') and agendamento.paciente != request.user.paciente:
            return Response(
    {
        'detail': 'Você não tem permissão para cancelar este agendamento.'},
         status = status.HTTP_403_FORBIDDEN)
        if hasattr(
    request.user,
     'profissional') and agendamento.profissional != request.user.profissional:
            return Response(
    {
        'detail': 'Você não tem permissão para cancelar este agendamento.'},
         status = status.HTTP_403_FORBIDDEN)

        agendamento.status= 'Cancelado'
        agendamento.motivo_cancelamento= motivo
        agendamento.save()

       

    @ action(detail=True, methods=['post'],
             permission_classes=[IsAuthenticated])
    def reagendar(self, request, pk=None):
        # Ação para reagendar um agendamento
        agendamento= self.get_object()
        nova_data= request.data.get('data_agendamento')
        novo_horario_inicio= request.data.get('horario_inicio')
        novo_horario_fim= request.data.get('horario_fim')

        if not nova_data or not novo_horario_inicio or not novo_horario_fim:
            return Response({'detail': 'Dados de reagendamento incompletos.'},
                            status=status.HTTP_400_BAD_REQUEST)

        # Validação para garantir que a nova data e horário sejam futuros
        if nova_data < timezone.now().date() or (nova_data == timezone.now().date()
                                    and novo_horario_inicio <= timezone.now().time()):
            return Response({'detail': 'A nova data e horário devem ser no futuro.'},
                            status=status.HTTP_400_BAD_REQUEST)

        # Validação para garantir que a capacidade da sala não seja excedida
        # (Exemplo para IoT)
        if agendamento.sala_atendimento:
            capacidade_sala= agendamento.sala_atendimento.capacidade  # Supondo que o modelo de sala tenha um campo 'capacidade'
            ocupacao_atual= Agendamento.objects.filter(
                data_agendamento=nova_data,
                horario_inicio__lt=novo_horario_fim,
                horario_fim__gt=novo_horario_inicio,
                sala_atendimento=agendamento.sala_atendimento
            ).count()
            if ocupacao_atual >= capacidade_sala:
                return Response(
    {
        'detail': 'A capacidade da sala de atendimento foi excedida.'},
         status=status.HTTP_400_BAD_REQUEST)

        # Atualizar o agendamento com a nova data e horário
        agendamento.data_agendamento= nova_data
        agendamento.horario_inicio= novo_horario_inicio
        agendamento.horario_fim= novo_horario_fim
        agendamento.status= 'Agendado'
        agendamento.motivo_cancelamento= ''  # Limpar motivo de cancelamento, se houver
        agendamento.save()

     

    @ action(detail=False, methods=['get'],
             permission_classes=[IsAuthenticated])
    def meus_agendamentos(self, request):
        # Retorna os agendamentos do paciente ou profissional autenticado
        if hasattr(request.user, 'paciente'):
            agendamentos= Agendamento.objects.filter(paciente=request.user.paciente)
        elif hasattr(request.user, 'profissional'):
            agendamentos= Agendamento.objects.filter(profissional=request.user.profissional)
        else:
            return Response(
    {
        'detail': 'Você não tem permissão para visualizar agendamentos.'},
         status=status.HTTP_403_FORBIDDEN)

        serializer= self.get_serializer(agendamentos, many=True)
        return Response(serializer.data)


### C:\ClinicaAI\backend\apps\agendamentos\__init__.py ###


### C:\ClinicaAI\backend\apps\aprovacoes\admin.py ###
from django.contrib import admin

# Register your models here.


### C:\ClinicaAI\backend\apps\aprovacoes\apps.py ###
from django.apps import AppConfig


class AprovacoesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.aprovacoes"


### C:\ClinicaAI\backend\apps\aprovacoes\models.py ###
from django.db import models

# Create your models here.


### C:\ClinicaAI\backend\apps\aprovacoes\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\aprovacoes\views.py ###
from django.shortcuts import render

# Create your views here.


### C:\ClinicaAI\backend\apps\aprovacoes\__init__.py ###


### C:\ClinicaAI\backend\apps\assinar_documentos\admin.py ###
from django.contrib import admin
from .models import Assinar_documentosModel


@admin.register(Assinar_documentosModel)
class Assinar_documentosAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\assinar_documentos\apps.py ###
from django.apps import AppConfig


class Assinar_documentosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.assinar_documentos"


### C:\ClinicaAI\backend\apps\assinar_documentos\models.py ###
from django.db import models


class Assinar_documentosModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\assinar_documentos\serializers.py ###
from rest_framework import serializers
from .models import Assinar_documentosModel


class Assinar_documentosSerializer(serializers.ModelSerializer):
    class Meta:
        model = Assinar_documentosModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\assinar_documentos\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\assinar_documentos\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Assinar_documentosViewSet

router = DefaultRouter()
router.register(r"assinar_documentos", Assinar_documentosViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\assinar_documentos\views.py ###
from rest_framework import viewsets
from .models import Assinar_documentosModel
from .serializers import Assinar_documentosSerializer


class Assinar_documentosViewSet(viewsets.ModelViewSet):
    queryset = Assinar_documentosModel.objects.all()
    serializer_class = Assinar_documentosSerializer


### C:\ClinicaAI\backend\apps\assinar_documentos\__init__.py ###


### C:\ClinicaAI\backend\apps\assinaturas\admin.py ###
from django.contrib import admin
from .models import Assinatura


@admin.register(Assinatura)
class AssinaturasAdmin(admin.ModelAdmin):
    list_display = ("documento", "assinante", "data_assinatura", "validade_assinatura")


### C:\ClinicaAI\backend\apps\assinaturas\apps.py ###
from django.apps import AppConfig


class AssinaturasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.assinaturas"


### C:\ClinicaAI\backend\apps\assinaturas\models.py ###
from django.db import models
from django.utils import timezone
import uuid
from apps.pacientes.models import Paciente

from apps.profissionais.models import Profissional
from django.core.validators import FileExtensionValidator
from django.conf import settings
import hashlib
from datetime import timedelta


class Documento(models.Model):
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    titulo = models.CharField(max_length=255, verbose_name="Título do Documento")
    descricao = models.TextField(
        verbose_name="Descrição do Documento", blank=True, null=True
    )
    data_criacao = models.DateTimeField(auto_now_add=True)
    data_atualizacao = models.DateTimeField(auto_now=True)
    autor = models.ForeignKey(
        Profissional,
        on_delete=models.SET_NULL,
        null=True,
        related_name="documentos_criados",
    )
    paciente = models.ForeignKey(
        Paciente,
        on_delete=models.CASCADE,
        related_name="documentos",
        blank=True,
        null=True,
    )
    arquivo = models.FileField(
        upload_to="documentos/",
        verbose_name="Arquivo do Documento",
        blank=True,
        null=True,
        validators=[FileExtensionValidator(allowed_extensions=["pdf"])],
    )
    status = models.CharField(
        max_length=20,
        choices=[("Pendente", "Pendente"), ("Assinado", "Assinado")],
        default="Pendente",
    )
    data_expiracao = models.DateField(
        blank=True, null=True, verbose_name="Data de Expiração do Documento"
    )
    hash_documento = models.CharField(
        max_length=256, verbose_name="Hash do Documento", blank=True, null=True
    )
    consentimento_informado = models.BooleanField(
        default=False, verbose_name="Consentimento Informado"
    )
    exigencias_legais = models.TextField(
        verbose_name="Exigências Legais", blank=True, null=True
    )
    versao = models.IntegerField(default=1, verbose_name="Versão do Documento")
    compliance_regulamentar = models.TextField(
        verbose_name="Conformidade Regulamentar", blank=True, null=True
    )
    associado_prontuario = models.BooleanField(
        default=False, verbose_name="Associado ao Prontuário"
    )
    analise_automatizada = models.TextField(
        verbose_name="Análise Automatizada de Risco", blank=True, null=True
    )

    class Meta:
        ordering = ["-data_criacao"]
        verbose_name = "Documento"
        verbose_name_plural = "Documentos"

    def __str__(self):
        return f"{self.titulo} - {self.get_status_display()}"

    def is_expired(self):
        # Verifica se o documento está expirado
        if self.data_expiracao:
            return timezone.now().date() > self.data_expiracao
        return False

    def gerar_hash_documento(self):
        # Gera o hash do documento para garantir integridade
        if self.arquivo:
            hasher = hashlib.sha256()
            with self.arquivo.open("rb") as f:
                buf = f.read()
                hasher.update(buf)
            self.hash_documento = hasher.hexdigest()
            self.save()

    def definir_expiracao_padrao(self):
        # Define uma data de expiração padrão para o documento se não estiver
        # definida
        if not self.data_expiracao:
            self.data_expiracao = timezone.now().date() + timedelta(days=365)
            self.save()


class Assinatura(models.Model):
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    documento = models.ForeignKey(
        Documento, on_delete=models.CASCADE, related_name="assinaturas"
    )
    assinante = models.ForeignKey(
        Profissional, on_delete=models.CASCADE, related_name="assinaturas_realizadas"
    )
    data_assinatura = models.DateTimeField(default=timezone.now)
    assinatura_eletronica = models.TextField(
        verbose_name="Assinatura Eletrônica", blank=True, null=True
    )
    validade_assinatura = models.DateField(
        blank=True, null=True, verbose_name="Validade da Assinatura"
    )
    ip_assinatura = models.GenericIPAddressField(
        verbose_name="Endereço IP da Assinatura", blank=True, null=True
    )
    localizacao_assinatura = models.CharField(
        max_length=255, verbose_name="Localização da Assinatura", blank=True, null=True
    )
    biometria_hash = models.CharField(
        max_length=256, verbose_name="Hash da Biometria", blank=True, null=True
    )
    dupla_autenticacao = models.BooleanField(
        default=False, verbose_name="Autenticação em Duas Etapas"
    )
    ferramenta_dispositivo = models.CharField(
        max_length=100,
        verbose_name="Ferramenta/Dispositivo Utilizado",
        blank=True,
        null=True,
    )
    historico_eventos = models.TextField(
        verbose_name="Histórico de Eventos", blank=True, null=True
    )

    class Meta:
        ordering = ["-data_assinatura"]
        verbose_name = "Assinatura"
        verbose_name_plural = "Assinaturas"

    def __str__(self):
        return f"Assinatura de {self.assinante.nome_completo} no documento {self.documento.titulo}"

    def is_valid(self):
        # Verifica se a assinatura ainda é válida
        if self.validade_assinatura:
            return timezone.now().date() <= self.validade_assinatura
        return True

    def gerar_assinatura_eletronica(self):
        # Gera uma assinatura eletrônica única usando hash do documento,
        # informações do assinante e autenticação em duas etapas
        if self.documento and self.assinante:
            dados = f"{self.documento.hash_documento}{self.assinante.uuid}{self.data_assinatura}"
            if self.dupla_autenticacao:
                dados += "dupla_autenticacao"
            self.assinatura_eletronica = hashlib.sha256(dados.encode()).hexdigest()
            self.save()

    def validar_biometria(self, biometria_dados):
        # Valida a biometria fornecida comparando com o hash armazenado
        if biometria_dados:
            biometria_hash = hashlib.sha256(biometria_dados.encode()).hexdigest()
            return biometria_hash == self.biometria_hash
        return False

    def registrar_evento(self, evento):
        # Registra um evento no histórico de assinatura
        if self.historico_eventos:
            self.historico_eventos += f"\n{timezone.now()}: {evento}"
        else:
            self.historico_eventos = f"{timezone.now()}: {evento}"
        self.save()


### C:\ClinicaAI\backend\apps\assinaturas\serializers.py ###
# Módulo Assinaturas - Serializers (serializers.py)

from rest_framework import serializers
from .models import Documento, Assinatura
from django.utils import timezone


class DocumentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Documento
        fields = "__all__"
        read_only_fields = [
            "uuid",
            "data_criacao",
            "data_atualizacao",
            "hash_documento",
            "versao",
            "analise_automatizada",
        ]

    def validate(self, data):
        # Validação para garantir que a data de expiração não seja anterior à
        # data atual
        if "data_expiracao" in data and data["data_expiracao"]:
            if data["data_expiracao"] < timezone.now().date():
                raise serializers.ValidationError(
                    "A data de expiração não pode ser anterior à data atual."
                )
        # Validação de conformidade regulamentar
        if not data.get("compliance_regulamentar"):
            raise serializers.ValidationError(
                "É necessário especificar a conformidade regulamentar para garantir que o documento atende aos padrões legais."
            )
        # Validação de interoperabilidade
        if data.get("associado_prontuario") and not data.get("paciente"):
            raise serializers.ValidationError(
                "Documentos associados ao prontuário devem estar vinculados a um paciente."
            )
        return data

    def create(self, validated_data):
        # Lógica adicional ao criar um documento, como definir a expiração
        # padrão e gerar o hash
        documento = super().create(validated_data)
        documento.definir_expiracao_padrao()
        documento.gerar_hash_documento()
        return documento

    def update(self, instance, validated_data):
        # Atualiza a versão do documento ao fazer alterações
        instance.versao += 1
        instance = super().update(instance, validated_data)
        instance.gerar_hash_documento()
        return instance


class AssinaturaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Assinatura
        fields = "__all__"
        read_only_fields = [
            "uuid",
            "data_assinatura",
            "assinatura_eletronica",
            "historico_eventos",
        ]

    def validate(self, data):
        # Validação para garantir que a assinatura eletrônica tenha integridade
        if data.get("documento") and data.get("assinante"):
            documento = data["documento"]
            if documento.is_expired():
                raise serializers.ValidationError(
                    "Não é possível assinar um documento expirado."
                )
            # Validação de dupla autenticação
            if documento.consentimento_informado and not data.get("dupla_autenticacao"):
                raise serializers.ValidationError(
                    "Documentos que exigem consentimento informado precisam de autenticação em duas etapas."
                )
        # Verificação de integridade de assinatura com hash
        if data.get("assinatura_eletronica") and data.get("biometria_hash"):
            if not self.validar_integridade_assinatura(
                data["assinatura_eletronica"], data["biometria_hash"]
            ):
                raise serializers.ValidationError(
                    "A integridade da assinatura não foi confirmada."
                )
        return data

    def create(self, validated_data):
        # Lógica para gerar assinatura eletrônica ao criar uma assinatura
        assinatura = super().create(validated_data)
        assinatura.gerar_assinatura_eletronica()
        assinatura.registrar_evento("Assinatura criada.")
        return assinatura

    def update(self, instance, validated_data):
        # Lógica adicional ao atualizar uma assinatura
        instance = super().update(instance, validated_data)
        instance.registrar_evento("Assinatura atualizada.")
        return instance

    def validar_integridade_assinatura(self, assinatura_eletronica, biometria_hash):
        # Lógica simulada para validar a integridade da assinatura com base no hash armazenado
        # (Aqui pode ser feita uma validação mais complexa em um serviço externo)
        return True


### C:\ClinicaAI\backend\apps\assinaturas\tests.py ###
# Módulo Assinaturas - Tests (tests.py)

from rest_framework.test import APITestCase, APIClient
from rest_framework import status
from django.urls import reverse
from .models import Documento, Assinatura
from apps.pacientes.models import Paciente

from apps.profissionais.models import Profissional

from django.contrib.auth import get_user_model
from django.utils import timezone
import uuid
from unittest.mock import patch

User = get_user_model()


class AssinaturasAPITestCase(APITestCase):
    def setUp(self):
        # Configurar usuários, paciente, profissional, documento e assinatura
        # para os testes
        self.client = APIClient()
        self.user_paciente = User.objects.create_user(
            username="paciente", password="testpassword"
        )
        self.paciente = Paciente.objects.create(
            usuario=self.user_paciente, nome_completo="Paciente Teste"
        )

        self.user_profissional = User.objects.create_user(
            username="profissional", password="testpassword"
        )
        self.profissional = Profissional.objects.create(
            usuario=self.user_profissional, nome_completo="Profissional Teste"
        )

        self.documento = Documento.objects.create(
            uuid=uuid.uuid4(),
            titulo="Documento Teste",
            descricao="Descrição do documento teste",
            autor=self.profissional,
            paciente=self.paciente,
            data_expiracao=timezone.now().date() + timezone.timedelta(days=30),
            status="Pendente",
        )
        self.documento_url = reverse(
            "documento-detail", kwargs={"pk": self.documento.pk}
        )

    def test_assinar_documento(self):
        # Teste para assinar um documento
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("documento-assinar", kwargs={"pk": self.documento.pk}),
            {
                "dupla_autenticacao": True,
                "biometria_hash": "hash_teste",
                "localizacao_assinatura": "Local Teste",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.documento.refresh_from_db()
        self.assertEqual(self.documento.status, "Assinado")

    def test_assinar_documento_expirado(self):
        # Teste para garantir que não é possível assinar um documento expirado
        self.documento.data_expiracao = timezone.now().date() - timezone.timedelta(
            days=1
        )
        self.documento.save()
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("documento-assinar", kwargs={"pk": self.documento.pk}),
            {
                "dupla_autenticacao": True,
                "biometria_hash": "hash_teste",
                "localizacao_assinatura": "Local Teste",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn(
            "Não é possível assinar um documento expirado.", response.data["detail"]
        )

    def test_cancelar_assinatura(self):
        # Teste para cancelar uma assinatura
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("documento-assinar", kwargs={"pk": self.documento.pk}),
            {
                "dupla_autenticacao": True,
                "biometria_hash": "hash_teste",
                "localizacao_assinatura": "Local Teste",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        assinatura = Assinatura.objects.get(documento=self.documento)

        response = self.client.post(
            reverse("assinatura-cancelar-assinatura", kwargs={"pk": assinatura.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertFalse(Assinatura.objects.filter(pk=assinatura.pk).exists())
        self.documento.refresh_from_db()
        self.assertEqual(self.documento.status, "Pendente")

    def test_validar_assinatura(self):
        # Teste para validar uma assinatura
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("documento-assinar", kwargs={"pk": self.documento.pk}),
            {
                "dupla_autenticacao": True,
                "biometria_hash": "hash_teste",
                "localizacao_assinatura": "Local Teste",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        assinatura = Assinatura.objects.get(documento=self.documento)

        response = self.client.post(
            reverse("assinatura-validar-assinatura", kwargs={"pk": assinatura.pk}),
            {"biometria_dados": "hash_teste"},
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["detail"], "A assinatura é válida.")

    def test_notificacao_assinatura_documento(self, mock_send_notification):
        # Teste para garantir que a notificação é enviada ao assinar um
        # documento
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("documento-assinar", kwargs={"pk": self.documento.pk}),
            {
                "dupla_autenticacao": True,
                "biometria_hash": "hash_teste",
                "localizacao_assinatura": "Local Teste",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        mock_send_notification.assert_called_once()


### C:\ClinicaAI\backend\apps\assinaturas\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import AssinaturaViewSet

router = DefaultRouter()
router.register(r"assinaturas", AssinaturaViewSet)


urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\assinaturas\views.py ###
# Módulo Assinaturas - Views (views.py)

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Documento, Assinatura
from .serializers import DocumentoSerializer, AssinaturaSerializer
from django.utils import timezone
import threading
from django.core.exceptions import ValidationError
import logging

logger = logging.getLogger(__name__)


def enviar_notificacao(titulo, mensagem, destinatarios):
    # Função de envio de notificação (placeholder)
    pass

class DocumentoViewSet(viewsets.ModelViewSet):
    queryset = Documento.objects.all()
    serializer_class = DocumentoSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna os documentos do paciente ou profissional autenticado
        user = self.request.user
        if hasattr(user, 'paciente'):
            return Documento.objects.filter(paciente=user.paciente)
        elif hasattr(user, 'profissional'):
            return Documento.objects.filter(autor=user.profissional)
        return Documento.objects.none()

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def assinar(self, request, pk=None):
        # Ação para assinar um documento
        documento = self.get_object()
        if hasattr(request.user, 'profissional'):
            profissional = request.user.profissional

            # Verificar se o documento está expirado antes de permitir a assinatura
            if documento.is_expired():
                return Response(
                    {'detail': 'Não é possível assinar um documento expirado.'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            dados_assinatura = {
                'documento': documento.id,
                'assinante': profissional.id,
                'dupla_autenticacao': request.data.get('dupla_autenticacao', False),
                'biometria_hash': request.data.get('biometria_hash', None),
                'ip_assinatura': request.META.get('REMOTE_ADDR'),
                'localizacao_assinatura': request.data.get('localizacao_assinatura', None)
            }
            serializer = AssinaturaSerializer(data=dados_assinatura)
            try:
                serializer.is_valid(raise_exception=True)
                serializer.save()
            except ValidationError as e:
                logger.error(f"Erro ao validar assinatura: {e}")
                return Response({'detail': 'Erro ao validar assinatura.', 'errors': e.detail}, status=status.HTTP_400_BAD_REQUEST)

            # Atualiza o status do documento para "Assinado" se necessário
            documento.status = 'Assinado'
            documento.save()

            # Enviar notificação para o paciente ou partes interessadas
            threading.Thread(target=enviar_notificacao, args=(
                'Documento Assinado',
                f'O documento "{documento.titulo}" foi assinado pelo profissional {profissional.nome_completo}.',
                [documento.paciente.usuario.email] if documento.paciente else []
            )).start()

            return Response({'detail': 'Documento assinado com sucesso.'}, status=status.HTTP_200_OK)
        return Response({'detail': 'Permissão negada.'}, status=status.HTTP_403_FORBIDDEN)


class AssinaturaViewSet(viewsets.ModelViewSet):
    queryset = Assinatura.objects.all()
    serializer_class = AssinaturaSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna as assinaturas do profissional autenticado
        user = self.request.user
        if hasattr(user, 'profissional'):
            return Assinatura.objects.filter(assinante=user.profissional)
        return Assinatura.objects.none()

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def validar_assinatura(self, request, pk=None):
        # Ação para validar a integridade da assinatura
        assinatura = self.get_object()
        if assinatura.validar_biometria(request.data.get('biometria_dados', '')):
            return Response({'detail': 'A assinatura é válida.'}, status=status.HTTP_200_OK)
        return Response({'detail': 'A integridade da assinatura não foi confirmada.'}, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def cancelar_assinatura(self, request, pk=None):
        # Ação para cancelar uma assinatura
        assinatura = self.get_object()
        if assinatura.assinante.usuario == request.user:
            assinatura.delete()
            assinatura.documento.status = 'Pendente'
            assinatura.documento.save()
            return Response({'detail': 'Assinatura cancelada com sucesso.'}, status=status.HTTP_200_OK)
        return Response({'detail': 'Você não tem permissão para cancelar esta assinatura.'}, status=status.HTTP_403_FORBIDDEN)


### C:\ClinicaAI\backend\apps\assinaturas\__init__.py ###


### C:\ClinicaAI\backend\apps\atendimentos\models.py ###
from django.db import models
from django.utils import timezone
from apps.pacientes.models import Paciente
from apps.profissionais.models import Profissional
from apps.agendamentos.models import Agendamento
from apps.documentos.models import DocumentosModel
from apps.financeiro.models import Transacao
from apps.assinaturas.models import Assinatura
from apps.prontuarios.models import ProcedimentoRealizado

# Ajuste o caminho conforme a localização do modelo
from apps.iot.models import DispositivoIoT


class Atendimento(models.Model):
    STATUS_CHOICES = [
        ("Pendente", "Pendente"),
        ("Em Andamento", "Em Andamento"),
        ("Concluído", "Concluído"),
        ("Cancelado", "Cancelado"),
        ("Aguardando Documentação", "Aguardando Documentação"),
        ("Aguardando Pagamento", "Aguardando Pagamento"),
    ]

    paciente = models.ForeignKey(
        Paciente, on_delete=models.CASCADE, related_name="atendimentos"
    )
    profissional = models.ForeignKey(
        Profissional, on_delete=models.CASCADE, related_name="atendimentos"
    )
    agendamento = models.OneToOneField(
        Agendamento,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="atendimento",
    )
    procedimentos = models.ManyToManyField(
        ProcedimentoRealizado, related_name="atendimentos", blank=True
    )
    dispositivos_iot = models.ManyToManyField(
        DispositivoIoT, related_name="atendimentos", blank=True
    )
    # seguro_saude = models.ForeignKey(SeguroSaude, on_delete=models.SET_NULL, null=True, blank=True, related_name='atendimentos')
    data_atendimento = models.DateField(default=timezone.now)
    horario_inicio = models.TimeField()
    horario_fim = models.TimeField()
    status = models.CharField(max_length=30, choices=STATUS_CHOICES, default="Pendente")
    diagnostico = models.TextField(null=True, blank=True)
    prescricao = models.TextField(null=True, blank=True)
    tratamento = models.TextField(null=True, blank=True)
    assinatura_profissional = models.ForeignKey(
        Assinatura,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="assinaturas_profissionais",
    )
    autorizacao_paciente = models.ForeignKey(
        Assinatura,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="autorizacoes_pacientes",
    )
    feedback_paciente = models.TextField(null=True, blank=True)
    valor = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    transacao_financeira = models.OneToOneField(
        Transacao,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="atendimento",
    )
    recomendacoes_ia = models.TextField(null=True, blank=True)
    recomendacoes_automaticas = models.TextField(null=True, blank=True)
    avaliacao_risco = models.DecimalField(
        max_digits=5, decimal_places=2, null=True, blank=True
    )
    consentimento_paciente = models.BooleanField(default=False)
    documentacao_completa = models.BooleanField(default=False)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Atendimento"
        verbose_name_plural = "Atendimentos"
        ordering = ["-data_atendimento", "-horario_inicio"]

    def __str__(self):
        return f"Atendimento de {self.paciente.nome_completo} com {self.profissional.nome_completo} em {self.data_atendimento}"

    def save(self, *args, **kwargs):
        # Lógica adicional para integração com IoT, IA e outros serviços
        if self.status == "Concluído" and not self.transacao_financeira:
            # Cria uma transação financeira se o atendimento for concluído
            self.transacao_financeira = Transacao.objects.create(
                paciente=self.paciente,
                valor=self.valor,
                descricao=f"Pagamento pelo atendimento em {self.data_atendimento}",
                status="Pendente",
            )

        # Integração com IA e Machine Learning para análise do atendimento
        # Exemplo: Enviar dados para serviço de IA para sugerir tratamentos ou
        # analisar feedback

        super().save(*args, **kwargs)

    def finalizar_atendimento(self):
        # Método para finalizar o atendimento e garantir todas as validações
        # necessárias
        if self.status == "Concluído":
            if not self.assinatura_profissional or not self.autorizacao_paciente:
                raise ValueError(
                    "Assinatura do profissional e autorização do paciente são obrigatórias para concluir o atendimento."
                )
            if not self.diagnostico or not self.prescricao:
                raise ValueError(
                    "Diagnóstico e prescrição são obrigatórios para concluir o atendimento."
                )

        # Atualiza o status do agendamento associado
        if self.agendamento:
            self.agendamento.status = "Concluído"
            self.agendamento.save()

        # Enviar notificações para o paciente e profissional

        self.save()


class AuditoriaAtendimento(models.Model):
    atendimento = models.ForeignKey(
        Atendimento, on_delete=models.CASCADE, related_name="auditorias"
    )
    usuario = models.CharField(max_length=255)
    alteracoes = models.TextField()
    data_alteracao = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = "Auditoria de Atendimento"
        verbose_name_plural = "Auditorias de Atendimentos"
        ordering = ["-data_alteracao"]

    def __str__(self):
        return f"Auditoria do Atendimento {self.atendimento.id} por {self.usuario} em {self.data_alteracao}"


### C:\ClinicaAI\backend\apps\atendimentos\serializers.py ###
from rest_framework import serializers
from django.utils import timezone
from .models import Atendimento
from apps.agendamentos.models import Agendamento
from apps.financeiro.models import Transacao
from apps.documentos.models import DocumentosModel


class AtendimentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Atendimento
        fields = '__all__'

    def validate(self, data):
        # Validação para garantir que a data e horário do atendimento sejam
        # futuros, caso o atendimento ainda esteja pendente
        if data['status'] == 'Pendente' and (data['data_atendimento'] < timezone.now().date() or (
            data['data_atendimento'] == timezone.now().date() and data['horario_inicio'] <= timezone.now().time())):
            raise serializers.ValidationError(
                "A data e o horário do atendimento pendente devem ser futuros.")

        # Garantir que a hora de fim do atendimento seja posterior à hora de
        # início
        if data['horario_fim'] <= data['horario_inicio']:
            raise serializers.ValidationError(
                "O horário de fim deve ser posterior ao horário de início.")

        # Validação para garantir que o agendamento associado não tenha sido
        # concluído antes do atendimento
        agendamento = data.get('agendamento')
        if agendamento and agendamento.status == 'Concluído':
            raise serializers.ValidationError(
                "O agendamento associado já foi concluído e não pode ser usado para um novo atendimento.")

        # Garantir que a assinatura do profissional e a autorização do paciente
        # estejam presentes ao concluir o atendimento
        if data['status'] == 'Concluído':
            if not data.get('assinatura_profissional'):
                raise serializers.ValidationError(
                    "A assinatura do profissional é obrigatória para concluir o atendimento.")
            if not data.get('autorizacao_paciente'):
                raise serializers.ValidationError(
                    "A autorização do paciente é obrigatória para concluir o atendimento.")

        # Garantir que diagnóstico e feedback estejam presentes ao concluir o
        # atendimento
        if data['status'] == 'Concluído':
            if not data.get('diagnostico'):
                raise serializers.ValidationError(
                    "O diagnóstico é obrigatório para concluir o atendimento.")
            if not data.get('feedback_paciente'):
                raise serializers.ValidationError(
                    "O feedback do paciente é obrigatório para concluir o atendimento.")

        return data

    def create(self, validated_data):
        # Lógica adicional ao criar um atendimento, como atualizar o status do
        # agendamento relacionado
        agendamento = validated_data.get('agendamento')
        if agendamento:
            agendamento.status = 'Concluído'
            agendamento.save()

        

        return super().create(validated_data)

    def update(self, instance, validated_data):
        # Atualizar a transação financeira, se houver alteração no status do
        # atendimento
        if 'status' in validated_data and validated_data[
            'status'] == 'Concluído' and not instance.transacao_financeira:
            # Garantir que o valor do atendimento seja positivo
            valor= validated_data.get('valor', 0)
            if valor <= 0:
                raise serializers.ValidationError(
                    "O valor do atendimento deve ser positivo para criar uma transação financeira.")

            # Criar uma transação financeira relacionada
            transacao= Transacao.objects.create(
                paciente = instance.paciente,
                valor = valor,
                descricao = f'Pagamento pelo atendimento realizado em {instance.data_atendimento}',
                status = 'Pendente'
            )
            instance.transacao_financeira = transacao

        # Garantir que o status seja consistente com os campos obrigatórios
        if validated_data.get('status') == 'Concluído':
            if not instance.tratamento or not instance.prescricao:
                raise serializers.ValidationError("O atendimento não pode ser concluído sem um tratamento e uma prescrição adequados.")

       

        # Atualizar o status do agendamento para manter a consistência
        if instance.agendamento:
            instance.agendamento.status = 'Concluído'
            instance.agendamento.save()

        return super().update(instance, validated_data)


### C:\ClinicaAI\backend\apps\atendimentos\tests.py ###
# Módulo Atendimentos - Tests (tests.py)

from rest_framework.test import APITestCase, APIClient
from rest_framework import status
from django.urls import reverse
from .models import Atendimento
from apps.pacientes.models import Paciente

from apps.profissionais.models import Profissional
import Profissional
from django.contrib.auth import get_user_model
from django.utils import timezone
import uuid
from unittest.mock import patch

User = get_user_model()


class AtendimentoAPITestCase(APITestCase):
    def setUp(self):
        # Configurar usuários, paciente, profissional e atendimento para os
        # testes
        self.client = APIClient()
        self.user_paciente = User.objects.create_user(
            username="paciente", password="testpassword"
        )
        self.paciente = Paciente.objects.create(
            usuario=self.user_paciente, nome_completo="Paciente Teste"
        )

        self.user_profissional = User.objects.create_user(
            username="profissional", password="testpassword"
        )
        self.profissional = Profissional.objects.create(
            usuario=self.user_profissional, nome_completo="Profissional Teste"
        )

        self.user_outro_profissional = User.objects.create_user(
            username="outro_profissional", password="testpassword"
        )
        self.outro_profissional = Profissional.objects.create(
            usuario=self.user_outro_profissional,
            nome_completo="Outro Profissional Teste",
        )

        self.atendimento = Atendimento.objects.create(
            uuid=uuid.uuid4(),
            paciente=self.paciente,
            profissional=self.profissional,
            data_atendimento=timezone.now().date() + timezone.timedelta(days=1),
            horario_inicio="10:00",
            horario_fim="11:00",
            tipo_atendimento="Consulta",
        )
        self.atendimento_url = reverse(
            "atendimento-detail", kwargs={"pk": self.atendimento.pk}
        )

    def test_concluir_atendimento(self):
        # Teste para concluir um atendimento
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("atendimento-concluir", kwargs={"pk": self.atendimento.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.atendimento.refresh_from_db()
        self.assertEqual(self.atendimento.status, "Concluído")

    def test_concluir_atendimento_permissao_negada(self):
        # Teste para garantir que outro profissional não possa concluir o
        # atendimento
        self.client.force_authenticate(user=self.outro_profissional)
        response = self.client.post(
            reverse("atendimento-concluir", kwargs={"pk": self.atendimento.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_cancelar_atendimento(self):
        # Teste para cancelar um atendimento
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("atendimento-cancelar", kwargs={"pk": self.atendimento.pk}),
            {"motivo_cancelamento": "Imprevisto"},
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.atendimento.refresh_from_db()
        self.assertEqual(self.atendimento.status, "Cancelado")

    def test_reagendar_atendimento(self):
        # Teste para reagendar um atendimento
        self.client.force_authenticate(user=self.user_profissional)
        nova_data = timezone.now().date() + timezone.timedelta(days=2)
        response = self.client.post(
            reverse("atendimento-reagendar", kwargs={"pk": self.atendimento.pk}),
            {
                "data_atendimento": nova_data,
                "horario_inicio": "11:00",
                "horario_fim": "12:00",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.atendimento.refresh_from_db()
        self.assertEqual(self.atendimento.data_atendimento, nova_data)
        self.assertEqual(self.atendimento.horario_inicio, "11:00")
        self.assertEqual(self.atendimento.horario_fim, "12:00")

    def test_meus_atendimentos_paciente(self):
        # Teste para listar atendimentos do paciente autenticado
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.get(reverse("atendimento-meus-atendimentos"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["id"], self.atendimento.id)

    def test_meus_atendimentos_profissional(self):
        # Teste para listar atendimentos do profissional autenticado
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.get(reverse("atendimento-meus-atendimentos"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["id"], self.atendimento.id)

    def test_notificacao_concluir_atendimento(self, mock_send_notification):
        # Teste para garantir que a notificação é enviada ao concluir o
        # atendimento
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("atendimento-concluir", kwargs={"pk": self.atendimento.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        mock_send_notification.assert_called_once()


### C:\ClinicaAI\backend\apps\atendimentos\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import AtendimentoViewSet

router = DefaultRouter()
router.register(r"atendimentos", AtendimentoViewSet, basename="atendimento")

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\atendimentos\views.py ###
# Módulo Atendimentos - Views (views.py)

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Atendimento
from .serializers import AtendimentoSerializer
from django.utils import timezone
import threading


class IsProfissional(IsAuthenticated):
    def has_permission(self, request, view):
        return super().has_permission(
    request, view) and hasattr(
        request.user, 'profissional')


class AtendimentoViewSet(viewsets.ModelViewSet):
    queryset = Atendimento.objects.all()
    serializer_class = AtendimentoSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna os atendimentos do usuário autenticado (paciente ou
        # profissional)
        user = self.request.user
        if hasattr(user, 'paciente'):
            return Atendimento.objects.filter(paciente=user.paciente)
        elif hasattr(user, 'profissional'):
            return Atendimento.objects.filter(profissional=user.profissional)
        return Atendimento.objects.none()

    @action(detail=True, methods=['post'], permission_classes=[IsProfissional])
    def concluir(self, request, pk=None):
        # Ação para concluir um atendimento
        atendimento = self.get_object()
        if atendimento.profissional != request.user.profissional:
            return Response(
    {
        'detail': 'Você não tem permissão para concluir este atendimento.'},
         status=status.HTTP_403_FORBIDDEN)

        serializer = self.get_serializer(
    atendimento, data={
        'status': 'Concluído'}, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        

        return Response(
            {'detail': 'Atendimento concluído com sucesso.'}, status=status.HTTP_200_OK)

    @ action(detail=False, methods=['get'],
             permission_classes=[IsAuthenticated])
    def meus_atendimentos(self, request):
        # Retorna os atendimentos do paciente ou profissional autenticado
        user= self.request.user
        if hasattr(user, 'paciente'):
            atendimentos= Atendimento.objects.filter(paciente=user.paciente)
        elif hasattr(user, 'profissional'):
            atendimentos= Atendimento.objects.filter(profissional=user.profissional)
        else:
            return Response(
    {
        'detail': 'Você não tem permissão para visualizar atendimentos.'},
         status = status.HTTP_403_FORBIDDEN)

        serializer= self.get_serializer(atendimentos, many=True)
        return Response(serializer.data)

    @ action(detail=True, methods=['post'],
             permission_classes=[IsProfissional])
    def cancelar(self, request, pk=None):
        # Ação para cancelar um atendimento
        atendimento= self.get_object()
        if atendimento.profissional != request.user.profissional:
            return Response(
    {
        'detail': 'Você não tem permissão para cancelar este atendimento.'},
         status = status.HTTP_403_FORBIDDEN)

        motivo= request.data.get('motivo_cancelamento')
        if not motivo:
            return Response({'detail': 'Motivo do cancelamento deve ser informado.'},
                            status=status.HTTP_400_BAD_REQUEST)

        serializer= self.get_serializer(atendimento, data={'status': 'Cancelado'}, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

       

    @ action(detail=True, methods=['post'],
             permission_classes=[IsProfissional])
    def reagendar(self, request, pk=None):
        # Ação para reagendar um atendimento
        atendimento= self.get_object()
        if atendimento.profissional != request.user.profissional:
            return Response(
    {
        'detail': 'Você não tem permissão para reagendar este atendimento.'},
         status=status.HTTP_403_FORBIDDEN)

        nova_data= request.data.get('data_atendimento')
        novo_horario_inicio= request.data.get('horario_inicio')
        novo_horario_fim= request.data.get('horario_fim')

        if not nova_data or not novo_horario_inicio or not novo_horario_fim:
            return Response({'detail': 'Dados de reagendamento incompletos.'},
                            status=status.HTTP_400_BAD_REQUEST)

        serializer= self.get_serializer(atendimento, data={
            'data_atendimento': nova_data,
            'horario_inicio': novo_horario_inicio,
            'horario_fim': novo_horario_fim,
            'status': 'Pendente'
        }, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

    #finalizzar o arquivo views.py
    


### C:\ClinicaAI\backend\apps\atendimentos\__init__.py ###


### C:\ClinicaAI\backend\apps\authentication\admin.py ###
from django.contrib import admin

# Register your models here.


### C:\ClinicaAI\backend\apps\authentication\apps.py ###
from django.apps import AppConfig

class AuthenticationConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.authentication'


### C:\ClinicaAI\backend\apps\authentication\models.py ###
from django.db import models

# Create your models here.


### C:\ClinicaAI\backend\apps\authentication\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\authentication\urls.py ###
from django.urls import path
from .views import CustomTokenObtainPairView, LogoutView

urlpatterns = [
    path('token/', CustomTokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('logout/', LogoutView.as_view(), name='logout'),
]


### C:\ClinicaAI\backend\apps\authentication\views.py ###
from django.shortcuts import render

# Create your views here.
from rest_framework_simplejwt.views import TokenObtainPairView
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from rest_framework.permissions import IsAuthenticated


# Endpoint para login
class CustomTokenObtainPairView(TokenObtainPairView):
    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        try:
            serializer.is_valid(raise_exception=True)
            return Response(serializer.validated_data, status=status.HTTP_200_OK)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_401_UNAUTHORIZED)

# Endpoint para logout esse comentado funciona com o pacote rest_framework_simplejwt
#class LogoutView(APIView):
#    def post(self, request):
#        try:
#            # Opcional: implementar lógica de invalidação de token
#            return Response({"message": "Logout realizado com sucesso"}, status=status.HTTP_200_OK)
#        except Exception as e:
#            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

class LogoutView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        try:
            refresh_token = request.data.get("refresh")  # Recupera o token de refresh do payload
            if refresh_token:
                token = RefreshToken(refresh_token)
                token.blacklist()  # Adiciona o token à lista negra
            return Response({"message": "Logout realizado com sucesso"}, status=200)
        except Exception as e:
            return Response({"error": str(e)}, status=400)

### C:\ClinicaAI\backend\apps\authentication\__init__.py ###


### C:\ClinicaAI\backend\apps\automacao_marketing\admin.py ###
from django.contrib import admin

# Register your models here.


### C:\ClinicaAI\backend\apps\automacao_marketing\apps.py ###
from django.apps import AppConfig


class Automacao_marketingConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.automacao_marketing"


### C:\ClinicaAI\backend\apps\automacao_marketing\models.py ###
from django.db import models

# Create your models here.


### C:\ClinicaAI\backend\apps\automacao_marketing\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\automacao_marketing\views.py ###
from django.shortcuts import render

# Create your views here.


### C:\ClinicaAI\backend\apps\automacao_marketing\__init__.py ###


### C:\ClinicaAI\backend\apps\avaliacoes\admin.py ###
from django.contrib import admin
from .models import AvaliacoesModel


@admin.register(AvaliacoesModel)
class AvaliacoesAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\avaliacoes\apps.py ###
from django.apps import AppConfig


class AvaliacoesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.avaliacoes"


### C:\ClinicaAI\backend\apps\avaliacoes\models.py ###
from django.db import models


class AvaliacoesModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\avaliacoes\serializers.py ###
from rest_framework import serializers
from .models import AvaliacoesModel


class AvaliacoesSerializer(serializers.ModelSerializer):
    class Meta:
        model = AvaliacoesModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\avaliacoes\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\avaliacoes\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import AvaliacoesViewSet

router = DefaultRouter()
router.register(r"avaliacoes", AvaliacoesViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\avaliacoes\views.py ###
from rest_framework import viewsets
from .models import AvaliacoesModel
from .serializers import AvaliacoesSerializer


class AvaliacoesViewSet(viewsets.ModelViewSet):
    queryset = AvaliacoesModel.objects.all()
    serializer_class = AvaliacoesSerializer


### C:\ClinicaAI\backend\apps\avaliacoes\__init__.py ###


### C:\ClinicaAI\backend\apps\blog\admin.py ###
from django.contrib import admin
from .models import BlogModel


@admin.register(BlogModel)
class BlogAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\blog\apps.py ###
from django.apps import AppConfig


class BlogConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.blog"


### C:\ClinicaAI\backend\apps\blog\models.py ###
from django.db import models


class BlogModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\blog\serializers.py ###
from rest_framework import serializers
from .models import BlogModel


class BlogSerializer(serializers.ModelSerializer):
    class Meta:
        model = BlogModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\blog\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\blog\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import BlogViewSet

router = DefaultRouter()
router.register(r"blog", BlogViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\blog\views.py ###
from rest_framework import viewsets
from .models import BlogModel
from .serializers import BlogSerializer


class BlogViewSet(viewsets.ModelViewSet):
    queryset = BlogModel.objects.all()
    serializer_class = BlogSerializer


### C:\ClinicaAI\backend\apps\blog\__init__.py ###


### C:\ClinicaAI\backend\apps\central_ajuda\admin.py ###
from django.contrib import admin

# Register your models here.


### C:\ClinicaAI\backend\apps\central_ajuda\apps.py ###
from django.apps import AppConfig


class Central_ajudaConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.central_ajuda"


### C:\ClinicaAI\backend\apps\central_ajuda\models.py ###
from django.db import models

# Create your models here.


### C:\ClinicaAI\backend\apps\central_ajuda\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\central_ajuda\views.py ###
from django.shortcuts import render

# Create your views here.


### C:\ClinicaAI\backend\apps\central_ajuda\__init__.py ###


### C:\ClinicaAI\backend\apps\chat_ao_vivo\admin.py ###
from django.contrib import admin
from .models import Chat_ao_vivoModel


@admin.register(Chat_ao_vivoModel)
class Chat_ao_vivoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\chat_ao_vivo\apps.py ###
from django.apps import AppConfig


class Chat_ao_vivoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.chat_ao_vivo"


### C:\ClinicaAI\backend\apps\chat_ao_vivo\models.py ###
from django.db import models


class Chat_ao_vivoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\chat_ao_vivo\serializers.py ###
from rest_framework import serializers
from .models import Chat_ao_vivoModel


class Chat_ao_vivoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Chat_ao_vivoModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\chat_ao_vivo\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\chat_ao_vivo\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Chat_ao_vivoViewSet

router = DefaultRouter()
router.register(r"chat_ao_vivo", Chat_ao_vivoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\chat_ao_vivo\views.py ###
from rest_framework import viewsets
from .models import Chat_ao_vivoModel
from .serializers import Chat_ao_vivoSerializer


class Chat_ao_vivoViewSet(viewsets.ModelViewSet):
    queryset = Chat_ao_vivoModel.objects.all()
    serializer_class = Chat_ao_vivoSerializer


### C:\ClinicaAI\backend\apps\chat_ao_vivo\__init__.py ###


### C:\ClinicaAI\backend\apps\compras\admin.py ###
from django.contrib import admin
from .models import ComprasModel


@admin.register(ComprasModel)
class ComprasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\compras\apps.py ###
from django.apps import AppConfig


class ComprasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.compras"


### C:\ClinicaAI\backend\apps\compras\models.py ###
from django.db import models


class ComprasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\compras\serializers.py ###
from rest_framework import serializers
from .models import ComprasModel


class ComprasSerializer(serializers.ModelSerializer):
    class Meta:
        model = ComprasModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\compras\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\compras\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ComprasViewSet

router = DefaultRouter()
router.register(r"compras", ComprasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\compras\views.py ###
from rest_framework import viewsets
from .models import ComprasModel
from .serializers import ComprasSerializer


class ComprasViewSet(viewsets.ModelViewSet):
    queryset = ComprasModel.objects.all()
    serializer_class = ComprasSerializer


### C:\ClinicaAI\backend\apps\compras\__init__.py ###


### C:\ClinicaAI\backend\apps\compromissos\admin.py ###
from django.contrib import admin
from .models import CompromissosModel


@admin.register(CompromissosModel)
class CompromissosAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\compromissos\apps.py ###
from django.apps import AppConfig


class CompromissosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.compromissos"


### C:\ClinicaAI\backend\apps\compromissos\models.py ###
from django.db import models


class CompromissosModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\compromissos\serializers.py ###
from rest_framework import serializers
from .models import CompromissosModel


class CompromissosSerializer(serializers.ModelSerializer):
    class Meta:
        model = CompromissosModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\compromissos\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\compromissos\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import CompromissosViewSet

router = DefaultRouter()
router.register(r"compromissos", CompromissosViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\compromissos\views.py ###
from rest_framework import viewsets
from .models import CompromissosModel
from .serializers import CompromissosSerializer


class CompromissosViewSet(viewsets.ModelViewSet):
    queryset = CompromissosModel.objects.all()
    serializer_class = CompromissosSerializer


### C:\ClinicaAI\backend\apps\compromissos\__init__.py ###


### C:\ClinicaAI\backend\apps\conhecimento\admin.py ###
from django.contrib import admin

# Register your models here.


### C:\ClinicaAI\backend\apps\conhecimento\apps.py ###
from django.apps import AppConfig


class ConhecimentoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.conhecimento"


### C:\ClinicaAI\backend\apps\conhecimento\models.py ###
from django.db import models

# Create your models here.


### C:\ClinicaAI\backend\apps\conhecimento\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\conhecimento\views.py ###
from django.shortcuts import render

# Create your views here.


### C:\ClinicaAI\backend\apps\conhecimento\__init__.py ###


### C:\ClinicaAI\backend\apps\criador_sites\admin.py ###
from django.contrib import admin
from .models import Criador_sitesModel


@admin.register(Criador_sitesModel)
class Criador_sitesAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\criador_sites\apps.py ###
from django.apps import AppConfig


class Criador_sitesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.criador_sites"


### C:\ClinicaAI\backend\apps\criador_sites\models.py ###
from django.db import models


class Criador_sitesModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\criador_sites\serializers.py ###
from rest_framework import serializers
from .models import Criador_sitesModel


class Criador_sitesSerializer(serializers.ModelSerializer):
    class Meta:
        model = Criador_sitesModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\criador_sites\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\criador_sites\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Criador_sitesViewSet

router = DefaultRouter()
router.register(r"criador_sites", Criador_sitesViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\criador_sites\views.py ###
from rest_framework import viewsets
from .models import Criador_sitesModel
from .serializers import Criador_sitesSerializer


class Criador_sitesViewSet(viewsets.ModelViewSet):
    queryset = Criador_sitesModel.objects.all()
    serializer_class = Criador_sitesSerializer


### C:\ClinicaAI\backend\apps\criador_sites\__init__.py ###


### C:\ClinicaAI\backend\apps\crm\admin.py ###
from django.contrib import admin
from .models import CrmModel


@admin.register(CrmModel)
class CrmAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\crm\apps.py ###
from django.apps import AppConfig


class CrmConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.crm"


### C:\ClinicaAI\backend\apps\crm\models.py ###
from django.db import models


class CrmModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\crm\serializers.py ###
from rest_framework import serializers
from .models import CrmModel


class CrmSerializer(serializers.ModelSerializer):
    class Meta:
        model = CrmModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\crm\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\crm\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import CrmViewSet

router = DefaultRouter()
router.register(r"crm", CrmViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\crm\views.py ###
from rest_framework import viewsets
from .models import CrmModel
from .serializers import CrmSerializer


class CrmViewSet(viewsets.ModelViewSet):
    queryset = CrmModel.objects.all()
    serializer_class = CrmSerializer


### C:\ClinicaAI\backend\apps\crm\__init__.py ###


### C:\ClinicaAI\backend\apps\dashboard\admin.py ###


### C:\ClinicaAI\backend\apps\dashboard\apps.py ###
from django.apps import AppConfig


class DocumentosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.dashboard"


### C:\ClinicaAI\backend\apps\dashboard\models.py ###


### C:\ClinicaAI\backend\apps\dashboard\serializers.py ###


### C:\ClinicaAI\backend\apps\dashboard\urls.py ###
from django.urls import path
from .views import dashboard_data

urlpatterns = [
    path('dashboard/', dashboard_data, name='dashboard_data'),
]


### C:\ClinicaAI\backend\apps\dashboard\views.py ###
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view(['GET'])
def dashboard_data(request):
    data = {
        "cards": [
            {"title": "Pacientes Ativos", "value": 25},
            {"title": "Agendamentos do Dia", "value": 15},
            {"title": "Exames Pendentes", "value": 7},
        ]
    }
    return Response(data)


### C:\ClinicaAI\backend\apps\despesas\admin.py ###
from django.contrib import admin
from .models import DespesasModel


@admin.register(DespesasModel)
class DespesasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\despesas\apps.py ###
from django.apps import AppConfig


class DespesasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.despesas"


### C:\ClinicaAI\backend\apps\despesas\models.py ###
from django.db import models


class DespesasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\despesas\serializers.py ###
from rest_framework import serializers
from .models import DespesasModel


class DespesasSerializer(serializers.ModelSerializer):
    class Meta:
        model = DespesasModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\despesas\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\despesas\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import DespesasViewSet

router = DefaultRouter()
router.register(r"despesas", DespesasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\despesas\views.py ###
from rest_framework import viewsets
from .models import DespesasModel
from .serializers import DespesasSerializer


class DespesasViewSet(viewsets.ModelViewSet):
    queryset = DespesasModel.objects.all()
    serializer_class = DespesasSerializer


### C:\ClinicaAI\backend\apps\despesas\__init__.py ###


### C:\ClinicaAI\backend\apps\documentos\admin.py ###
from django.contrib import admin
from .models import DocumentosModel


@admin.register(DocumentosModel)
class DocumentosAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\documentos\apps.py ###
from django.apps import AppConfig


class DocumentosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.documentos"


### C:\ClinicaAI\backend\apps\documentos\models.py ###
from django.db import models
from django.utils.translation import gettext_lazy as _


class DocumentosModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = _("Documento")
        verbose_name_plural = _("Documentos")
        app_label = "documentos"

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\documentos\serializers.py ###
from rest_framework import serializers
from .models import DocumentosModel


class DocumentosSerializer(serializers.ModelSerializer):
    class Meta:
        model = DocumentosModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\documentos\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\documentos\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import DocumentosViewSet

router = DefaultRouter()
router.register(r"documentos", DocumentosViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\documentos\views.py ###
from rest_framework import viewsets
from .models import DocumentosModel
from .serializers import DocumentosSerializer


class DocumentosViewSet(viewsets.ModelViewSet):
    queryset = DocumentosModel.objects.all()
    serializer_class = DocumentosSerializer


### C:\ClinicaAI\backend\apps\documentos\__init__.py ###


### C:\ClinicaAI\backend\apps\ecommerce\admin.py ###
from django.contrib import admin
from .models import EcommerceModel


@admin.register(EcommerceModel)
class EcommerceAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\ecommerce\apps.py ###
from django.apps import AppConfig


class EcommerceConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.ecommerce"


### C:\ClinicaAI\backend\apps\ecommerce\models.py ###
from django.db import models


class EcommerceModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\ecommerce\serializers.py ###
from rest_framework import serializers
from .models import EcommerceModel


class EcommerceSerializer(serializers.ModelSerializer):
    class Meta:
        model = EcommerceModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\ecommerce\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\ecommerce\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import EcommerceViewSet

router = DefaultRouter()
router.register(r"ecommerce", EcommerceViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\ecommerce\views.py ###
from rest_framework import viewsets
from .models import EcommerceModel
from .serializers import EcommerceSerializer


class EcommerceViewSet(viewsets.ModelViewSet):
    queryset = EcommerceModel.objects.all()
    serializer_class = EcommerceSerializer


### C:\ClinicaAI\backend\apps\ecommerce\__init__.py ###


### C:\ClinicaAI\backend\apps\elearning\admin.py ###
from django.contrib import admin
from .models import ElearningModel


@admin.register(ElearningModel)
class ElearningAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\elearning\apps.py ###
from django.apps import AppConfig


class ElearningConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.elearning"


### C:\ClinicaAI\backend\apps\elearning\models.py ###
from django.db import models


class ElearningModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\elearning\serializers.py ###
from rest_framework import serializers
from .models import ElearningModel


class ElearningSerializer(serializers.ModelSerializer):
    class Meta:
        model = ElearningModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\elearning\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\elearning\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ElearningViewSet

router = DefaultRouter()
router.register(r"elearning", ElearningViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\elearning\views.py ###
from rest_framework import viewsets
from .models import ElearningModel
from .serializers import ElearningSerializer


class ElearningViewSet(viewsets.ModelViewSet):
    queryset = ElearningModel.objects.all()
    serializer_class = ElearningSerializer


### C:\ClinicaAI\backend\apps\elearning\__init__.py ###


### C:\ClinicaAI\backend\apps\eventos\admin.py ###
from django.contrib import admin

# Register your models here.


### C:\ClinicaAI\backend\apps\eventos\apps.py ###
from django.apps import AppConfig


class EventosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.eventos"


### C:\ClinicaAI\backend\apps\eventos\models.py ###
from django.db import models

# Create your models here.


### C:\ClinicaAI\backend\apps\eventos\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\eventos\views.py ###
from django.shortcuts import render

# Create your views here.


### C:\ClinicaAI\backend\apps\eventos\__init__.py ###


### C:\ClinicaAI\backend\apps\exames\models.py ###
# Módulo Exames - Models (models.py)

from django.db import models
from django.utils import timezone
import uuid
from apps.pacientes.models import Paciente
from apps.profissionais.models import Profissional
from apps.documentos.models import DocumentosModel


class Exame(models.Model):
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    paciente = models.ForeignKey(
        Paciente, on_delete=models.CASCADE, related_name="exames"
    )
    profissional_solicitante = models.ForeignKey(
    Profissional,
    on_delete=models.SET_NULL,
    null=True,
    related_name="exames_solicitados_exame",  # Alterar para um nome único
    verbose_name="Profissional Solicitante",
)

    tipo_exame = models.CharField(max_length=100, verbose_name="Tipo de Exame")
    data_solicitacao = models.DateField(
        default=timezone.now, verbose_name="Data de Solicitação"
    )
    data_realizacao = models.DateField(
        blank=True, null=True, verbose_name="Data de Realização"
    )
    resultados = models.TextField(
        verbose_name="Resultados do Exame", blank=True, null=True
    )
    documento_resultado = models.ForeignKey(
        DocumentosModel,
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
        related_name="exames_resultados",
        verbose_name="Documento do Resultado",
    )
    observacoes = models.TextField(verbose_name="Observações", blank=True, null=True)
    status = models.CharField(
        max_length=20,
        choices=[
            ("Solicitado", "Solicitado"),
            ("Realizado", "Realizado"),
            ("Cancelado", "Cancelado"),
        ],
        default="Solicitado",
    )
    data_criacao = models.DateTimeField(auto_now_add=True)
    data_atualizacao = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["-data_solicitacao"]
        verbose_name = "Exame"
        verbose_name_plural = "Exames"

    def __str__(self):
        return f"Exame {self.tipo_exame} de {self.paciente.nome_completo}"

    def is_realizado(self):
        return self.status == "Realizado"


### C:\ClinicaAI\backend\apps\exames\serializers.py ###
# Módulo Exames - Serializers (serializers.py)

from rest_framework import serializers
from .models import Exame


class ExameSerializer(serializers.ModelSerializer):
    class Meta:
        model = Exame
        fields = "__all__"
        read_only_fields = ["data_criacao", "data_atualizacao"]

    def validate(self, data):
        # Validação para garantir que a data de realização não seja anterior à
        # data de solicitação
        if "data_realizacao" in data and data["data_realizacao"]:
            if data["data_realizacao"] < data["data_solicitacao"]:
                raise serializers.ValidationError(
                    "A data de realização não pode ser anterior à data de solicitação do exame."
                )

        # Validação para garantir que se o exame estiver realizado, a data de
        # realização deve estar preenchida
        if data.get("status") == "Realizado" and not data.get("data_realizacao"):
            raise serializers.ValidationError(
                "A data de realização deve ser informada quando o status for 'Realizado'."
            )

        # Validação para garantir que se o exame estiver realizado, o documento
        # do resultado deve estar presente
        if data.get("status") == "Realizado" and not data.get("documento_resultado"):
            raise serializers.ValidationError(
                "O documento do resultado deve ser anexado quando o status for 'Realizado'."
            )

        return data


### C:\ClinicaAI\backend\apps\exames\tests.py ###
# Módulo Exames - Tests (tests.py)

from rest_framework.test import APITestCase, APIClient
from rest_framework import status
from django.urls import reverse
from .models import Exame
from apps.pacientes.models import Paciente
from apps.profissionais.models import Profissional
from django.contrib.auth import get_user_model
from django.utils import timezone
import uuid
from unittest.mock import patch

User = get_user_model()

User = get_user_model()


class ExameAPITestCase(APITestCase):
    def setUp(self):
        # Configurar usuários, paciente, profissional e exame para os testes
        self.client = APIClient()
        self.user_paciente = User.objects.create_user(
            username="paciente", password="testpassword"
        )
        self.paciente = Paciente.objects.create(
            usuario=self.user_paciente, nome_completo="Paciente Teste"
        )

        self.user_profissional = User.objects.create_user(
            username="profissional", password="testpassword"
        )
        self.profissional = Profissional.objects.create(
            usuario=self.user_profissional, nome_completo="Profissional Teste"
        )

        self.user_outro_profissional = User.objects.create_user(
            username="outro_profissional", password="testpassword"
        )
        self.outro_profissional = Profissional.objects.create(
            usuario=self.user_outro_profissional,
            nome_completo="Outro Profissional Teste",
        )

        self.exame = Exame.objects.create(
            uuid=uuid.uuid4(),
            paciente=self.paciente,
            profissional_solicitante=self.profissional,
            tipo_exame="Hemograma",
            data_solicitacao=timezone.now().date(),
        )
        self.exame_url = reverse("exame-detail", kwargs={"pk": self.exame.pk})

    def test_registrar_resultado_exame(self):
        # Teste para registrar o resultado de um exame
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("exame-registrar-resultado", kwargs={"pk": self.exame.pk}),
            {
                "resultados": "Resultados normais",
                "status": "Realizado",
                "data_realizacao": timezone.now().date(),
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.exame.refresh_from_db()
        self.assertEqual(self.exame.status, "Realizado")
        self.assertEqual(self.exame.resultados, "Resultados normais")

    def test_registrar_resultado_permissao_negada(self):
        # Teste para garantir que outro profissional não possa registrar o
        # resultado do exame
        self.client.force_authenticate(user=self.outro_profissional)
        response = self.client.post(
            reverse("exame-registrar-resultado", kwargs={"pk": self.exame.pk}),
            {"resultados": "Resultados alterados", "status": "Realizado"},
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_cancelar_exame(self):
        # Teste para cancelar um exame
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("exame-cancelar-exame", kwargs={"pk": self.exame.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.exame.refresh_from_db()
        self.assertEqual(self.exame.status, "Cancelado")

    def test_cancelar_exame_por_paciente(self):
        # Teste para garantir que o paciente não possa cancelar o exame
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.post(
            reverse("exame-cancelar-exame", kwargs={"pk": self.exame.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_registrar_resultado_sem_data_realizacao(self):
        # Teste para tentar registrar o resultado sem fornecer a data de
        # realização
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("exame-registrar-resultado", kwargs={"pk": self.exame.pk}),
            {"resultados": "Resultados normais", "status": "Realizado"},
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_meus_exames_paciente(self):
        # Teste para listar exames do paciente autenticado
        self.client.force_authenticate(user=self.user_paciente)
        response = self.client.get(reverse("exame-list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["id"], self.exame.id)

    def test_meus_exames_profissional(self):
        # Teste para listar exames solicitados pelo profissional autenticado
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.get(reverse("exame-list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]["id"], self.exame.id)

    def test_notificacao_registrar_resultado(self, mock_send_notification):
        # Teste para garantir que a notificação é enviada ao registrar o
        # resultado do exame
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("exame-registrar-resultado", kwargs={"pk": self.exame.pk}),
            {
                "resultados": "Resultados normais",
                "status": "Realizado",
                "data_realizacao": timezone.now().date(),
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        mock_send_notification.assert_called_once()

    def test_notificacao_cancelar_exame(self, mock_send_notification):
        # Teste para garantir que a notificação é enviada ao cancelar um exame
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("exame-cancelar-exame", kwargs={"pk": self.exame.pk})
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        mock_send_notification.assert_called_once()

    @patch("exames.views.ExameViewSet.analisar_resultados")
    def test_integracao_machine_learning(self, mock_analisar_resultados):
        # Teste para garantir que a integração com Machine Learning seja
        # acionada ao registrar resultados
        self.client.force_authenticate(user=self.user_profissional)
        response = self.client.post(
            reverse("exame-registrar-resultado", kwargs={"pk": self.exame.pk}),
            {
                "resultados": "Resultados normais",
                "status": "Realizado",
                "data_realizacao": timezone.now().date(),
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        mock_analisar_resultados.assert_called_once_with(self.exame)


### C:\ClinicaAI\backend\apps\exames\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ExameViewSet

router = DefaultRouter()
router.register(r"examess", ExameViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\exames\views.py ###
# Módulo Exames - Views (views.py)

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Exame
from .serializers import ExameSerializer
from django.utils import timezone
import threading


class ExameViewSet(viewsets.ModelViewSet):
    queryset = Exame.objects.all()
    serializer_class = ExameSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna os exames do paciente autenticado ou exames solicitados por
        # um profissional autenticado
        user = self.request.user
        if hasattr(user, 'paciente'):
            return Exame.objects.filter(paciente=user.paciente)
        elif hasattr(user, 'profissional'):
            return Exame.objects.filter(
    profissional_solicitante=user.profissional)
        return Exame.objects.none()

    @action(detail=True, methods=['post'],
            permission_classes=[IsAuthenticated])
    def registrar_resultado(self, request, pk=None):
        # Ação para registrar o resultado de um exame
        exame = self.get_object()
        if hasattr(
    request.user,
     'profissional') and exame.profissional_solicitante != request.user.profissional:
            return Response(
    {
        'detail': 'Você não tem permissão para registrar o resultado deste exame.'},
         status=status.HTTP_403_FORBIDDEN)

        serializer = self.get_serializer(
    exame, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        # Adicionar integração com Machine Learning para análise dos resultados
        self.analisar_resultados(exame)

        return Response(
            {'detail': 'Resultado do exame registrado com sucesso.'}, status=status.HTTP_200_OK)

    def analisar_resultados(self, exame):
        # Integração com Machine Learning para analisar resultados de exames
        # Simulação de chamada para um serviço de IA que analisa os resultados
        # do exame
        if exame.resultados:
            threading.Thread(
    target=self.enviar_para_analise_ml, args=(
        exame,)).start()

    def enviar_para_analise_ml(self, exame):
        # Simulação de envio dos resultados do exame para um serviço de Machine Learning
        # Aqui pode ser feita a integração com um serviço externo de análise de
        # saúde
        print(
            f"Enviando resultados do exame {exame.tipo_exame} para análise de IA.")
        # Implementar a lógica real de integração aqui

    @ action(detail=True, methods=['post'],
             permission_classes=[IsAuthenticated])
    def cancelar_exame(self, request, pk=None):
        # Ação para cancelar um exame
        exame= self.get_object()
        if hasattr(
    request.user,
     'profissional') and exame.profissional_solicitante != request.user.profissional:
            return Response(
    {
        'detail': 'Você não tem permissão para cancelar este exame.'},
         status = status.HTTP_403_FORBIDDEN)

        exame.status= 'Cancelado'
        exame.save()

        
        return Response({'detail': 'Exame cancelado com sucesso.'},
                        status=status.HTTP_200_OK)


### C:\ClinicaAI\backend\apps\exames\__init__.py ###


### C:\ClinicaAI\backend\apps\fabricacao\admin.py ###
from django.contrib import admin
from .models import FabricacaoModel


@admin.register(FabricacaoModel)
class FabricacaoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\fabricacao\apps.py ###
from django.apps import AppConfig


class FabricacaoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.fabricacao"


### C:\ClinicaAI\backend\apps\fabricacao\models.py ###
from django.db import models


class FabricacaoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\fabricacao\serializers.py ###
from rest_framework import serializers
from .models import FabricacaoModel


class FabricacaoSerializer(serializers.ModelSerializer):
    class Meta:
        model = FabricacaoModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\fabricacao\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\fabricacao\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import FabricacaoViewSet

router = DefaultRouter()
router.register(r"fabricacao", FabricacaoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\fabricacao\views.py ###
from rest_framework import viewsets
from .models import FabricacaoModel
from .serializers import FabricacaoSerializer


class FabricacaoViewSet(viewsets.ModelViewSet):
    queryset = FabricacaoModel.objects.all()
    serializer_class = FabricacaoSerializer


### C:\ClinicaAI\backend\apps\fabricacao\__init__.py ###


### C:\ClinicaAI\backend\apps\faturamento\admin.py ###
from django.contrib import admin
from .models import FaturamentoModel


@admin.register(FaturamentoModel)
class FaturamentoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\faturamento\apps.py ###
from django.apps import AppConfig


class FaturamentoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.faturamento"


### C:\ClinicaAI\backend\apps\faturamento\models.py ###
from django.db import models


class FaturamentoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\faturamento\serializers.py ###
from rest_framework import serializers
from .models import FaturamentoModel


class FaturamentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = FaturamentoModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\faturamento\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\faturamento\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import FaturamentoViewSet

router = DefaultRouter()
router.register(r"faturamento", FaturamentoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\faturamento\views.py ###
from rest_framework import viewsets
from .models import FaturamentoModel
from .serializers import FaturamentoSerializer


class FaturamentoViewSet(viewsets.ModelViewSet):
    queryset = FaturamentoModel.objects.all()
    serializer_class = FaturamentoSerializer


### C:\ClinicaAI\backend\apps\faturamento\__init__.py ###


### C:\ClinicaAI\backend\apps\financeiro\admin.py ###
from django.contrib import admin
from .models import Transacao


@admin.register(Transacao)
class TransacaoAdmin(admin.ModelAdmin):
    list_display = ("descricao", "valor", "data", "categoria", "tipo")


### C:\ClinicaAI\backend\apps\financeiro\apps.py ###
from django.apps import AppConfig


class FinanceiroConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.financeiro"


### C:\ClinicaAI\backend\apps\financeiro\models.py ###
from django.db import models


class Transacao(models.Model):
    descricao = models.CharField(max_length=255)
    valor = models.DecimalField(max_digits=10, decimal_places=2)
    data = models.DateField()
    categoria = models.CharField(max_length=100)
    tipo = models.CharField(
        max_length=50, choices=[("receita", "Receita"), ("despesa", "Despesa")]
    )

    def __str__(self):
        return f"{self.descricao} - {self.valor}"


### C:\ClinicaAI\backend\apps\financeiro\serializers.py ###
from rest_framework import serializers
from .models import Transacao


class TransacaoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Transacao
        fields = "__all__"


### C:\ClinicaAI\backend\apps\financeiro\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\financeiro\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import TransacaoViewSet

router = DefaultRouter()
router.register(r"transacoes", TransacaoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\financeiro\views.py ###
from rest_framework import viewsets
from .models import Transacao
from .serializers import TransacaoSerializer


class TransacaoViewSet(viewsets.ModelViewSet):
    queryset = Transacao.objects.all()
    serializer_class = TransacaoSerializer


### C:\ClinicaAI\backend\apps\financeiro\__init__.py ###


### C:\ClinicaAI\backend\apps\folgas\admin.py ###
from django.contrib import admin
from .models import FolgasModel


@admin.register(FolgasModel)
class FolgasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\folgas\apps.py ###
from django.apps import AppConfig


class FolgasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.folgas"


### C:\ClinicaAI\backend\apps\folgas\models.py ###
from django.db import models


class FolgasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\folgas\serializers.py ###
from rest_framework import serializers
from .models import FolgasModel


class FolgasSerializer(serializers.ModelSerializer):
    class Meta:
        model = FolgasModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\folgas\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\folgas\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import FolgasViewSet

router = DefaultRouter()
router.register(r"folgas", FolgasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\folgas\views.py ###
from rest_framework import viewsets
from .models import FolgasModel
from .serializers import FolgasSerializer


class FolgasViewSet(viewsets.ModelViewSet):
    queryset = FolgasModel.objects.all()
    serializer_class = FolgasSerializer


### C:\ClinicaAI\backend\apps\folgas\__init__.py ###


### C:\ClinicaAI\backend\apps\forum\admin.py ###
from django.contrib import admin
from .models import ForumModel


@admin.register(ForumModel)
class ForumAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\forum\apps.py ###
from django.apps import AppConfig


class ForumConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.forum"


### C:\ClinicaAI\backend\apps\forum\models.py ###
from django.db import models


class ForumModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\forum\serializers.py ###
from rest_framework import serializers
from .models import ForumModel


class ForumSerializer(serializers.ModelSerializer):
    class Meta:
        model = ForumModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\forum\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\forum\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ForumViewSet

router = DefaultRouter()
router.register(r"forum", ForumViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\forum\views.py ###
from rest_framework import viewsets
from .models import ForumModel
from .serializers import ForumSerializer


class ForumViewSet(viewsets.ModelViewSet):
    queryset = ForumModel.objects.all()
    serializer_class = ForumSerializer


### C:\ClinicaAI\backend\apps\forum\__init__.py ###


### C:\ClinicaAI\backend\apps\frota\admin.py ###
from django.contrib import admin
from .models import FrotaModel


@admin.register(FrotaModel)
class FrotaAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\frota\apps.py ###
from django.apps import AppConfig


class FrotaConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.frota"


### C:\ClinicaAI\backend\apps\frota\models.py ###
from django.db import models


class FrotaModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\frota\serializers.py ###
from rest_framework import serializers
from .models import FrotaModel


class FrotaSerializer(serializers.ModelSerializer):
    class Meta:
        model = FrotaModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\frota\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\frota\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import FrotaViewSet

router = DefaultRouter()
router.register(r"frota", FrotaViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\frota\views.py ###
from rest_framework import viewsets
from .models import FrotaModel
from .serializers import FrotaSerializer


class FrotaViewSet(viewsets.ModelViewSet):
    queryset = FrotaModel.objects.all()
    serializer_class = FrotaSerializer


### C:\ClinicaAI\backend\apps\frota\__init__.py ###


### C:\ClinicaAI\backend\apps\indicacoes\admin.py ###
from django.contrib import admin
from .models import IndicacoesModel


@admin.register(IndicacoesModel)
class IndicacoesAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\indicacoes\apps.py ###
from django.apps import AppConfig


class IndicacoesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.indicacoes"


### C:\ClinicaAI\backend\apps\indicacoes\models.py ###
from django.db import models


class IndicacoesModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\indicacoes\serializers.py ###
from rest_framework import serializers
from .models import IndicacoesModel


class IndicacoesSerializer(serializers.ModelSerializer):
    class Meta:
        model = IndicacoesModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\indicacoes\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\indicacoes\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import IndicacoesViewSet

router = DefaultRouter()
router.register(r"indicacoes", IndicacoesViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\indicacoes\views.py ###
from rest_framework import viewsets
from .models import IndicacoesModel
from .serializers import IndicacoesSerializer


class IndicacoesViewSet(viewsets.ModelViewSet):
    queryset = IndicacoesModel.objects.all()
    serializer_class = IndicacoesSerializer


### C:\ClinicaAI\backend\apps\indicacoes\__init__.py ###


### C:\ClinicaAI\backend\apps\inventario\admin.py ###
from django.contrib import admin
from .models import InventarioModel


@admin.register(InventarioModel)
class InventarioAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\inventario\apps.py ###
from django.apps import AppConfig


class InventarioConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.inventario"


### C:\ClinicaAI\backend\apps\inventario\models.py ###
from django.db import models


class InventarioModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\inventario\serializers.py ###
from rest_framework import serializers
from .models import InventarioModel


class InventarioSerializer(serializers.ModelSerializer):
    class Meta:
        model = InventarioModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\inventario\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\inventario\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import InventarioViewSet

router = DefaultRouter()
router.register(r"inventario", InventarioViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\inventario\views.py ###
from rest_framework import viewsets
from .models import InventarioModel
from .serializers import InventarioSerializer


class InventarioViewSet(viewsets.ModelViewSet):
    queryset = InventarioModel.objects.all()
    serializer_class = InventarioSerializer


### C:\ClinicaAI\backend\apps\inventario\__init__.py ###


### C:\ClinicaAI\backend\apps\iot\admin.py ###
from django.contrib import admin

# Register your models here.


### C:\ClinicaAI\backend\apps\iot\apps.py ###
from django.apps import AppConfig


class IotConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.iot"


### C:\ClinicaAI\backend\apps\iot\models.py ###
from django.db import models


class DispositivoIoT(models.Model):
    nome = models.CharField(max_length=255, verbose_name="Nome do Dispositivo")
    descricao = models.TextField(blank=True, verbose_name="Descrição")
    status = models.CharField(
        max_length=100,
        choices=[("ativo", "Ativo"), ("inativo", "Inativo")],
        default="ativo",
    )
    data_registro = models.DateTimeField(
        auto_now_add=True, verbose_name="Data de Registro"
    )
    ultima_comunicacao = models.DateTimeField(
        blank=True, null=True, verbose_name="Última Comunicação"
    )

    class Meta:
        verbose_name = "Dispositivo IoT"
        verbose_name_plural = "Dispositivos IoT"

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\iot\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\iot\views.py ###
from django.shortcuts import render

# Create your views here.


### C:\ClinicaAI\backend\apps\iot\__init__.py ###


### C:\ClinicaAI\backend\apps\locacao\admin.py ###
from django.contrib import admin
from .models import LocacaoModel


@admin.register(LocacaoModel)
class LocacaoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\locacao\apps.py ###
from django.apps import AppConfig


class LocacaoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.locacao"


### C:\ClinicaAI\backend\apps\locacao\models.py ###
from django.db import models


class LocacaoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\locacao\serializers.py ###
from rest_framework import serializers
from .models import LocacaoModel


class LocacaoSerializer(serializers.ModelSerializer):
    class Meta:
        model = LocacaoModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\locacao\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\locacao\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import LocacaoViewSet

router = DefaultRouter()
router.register(r"locacao", LocacaoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\locacao\views.py ###
from rest_framework import viewsets
from .models import LocacaoModel
from .serializers import LocacaoSerializer


class LocacaoViewSet(viewsets.ModelViewSet):
    queryset = LocacaoModel.objects.all()
    serializer_class = LocacaoSerializer


### C:\ClinicaAI\backend\apps\locacao\__init__.py ###


### C:\ClinicaAI\backend\apps\manutencao\admin.py ###
from django.contrib import admin
from .models import ManutencaoModel


@admin.register(ManutencaoModel)
class ManutencaoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\manutencao\apps.py ###
from django.apps import AppConfig


class ManutencaoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.manutencao"


### C:\ClinicaAI\backend\apps\manutencao\models.py ###
from django.db import models


class ManutencaoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\manutencao\serializers.py ###
from rest_framework import serializers
from .models import ManutencaoModel


class ManutencaoSerializer(serializers.ModelSerializer):
    class Meta:
        model = ManutencaoModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\manutencao\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\manutencao\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ManutencaoViewSet

router = DefaultRouter()
router.register(r"manutencao", ManutencaoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\manutencao\views.py ###
from rest_framework import viewsets
from .models import ManutencaoModel
from .serializers import ManutencaoSerializer


class ManutencaoViewSet(viewsets.ModelViewSet):
    queryset = ManutencaoModel.objects.all()
    serializer_class = ManutencaoSerializer


### C:\ClinicaAI\backend\apps\manutencao\__init__.py ###


### C:\ClinicaAI\backend\apps\marketing_email\admin.py ###
from django.contrib import admin
from .models import Marketing_emailModel


@admin.register(Marketing_emailModel)
class Marketing_emailAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\marketing_email\apps.py ###
from django.apps import AppConfig


class Marketing_emailConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.marketing_email"


### C:\ClinicaAI\backend\apps\marketing_email\models.py ###
from django.db import models


class Marketing_emailModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\marketing_email\serializers.py ###
from rest_framework import serializers
from .models import Marketing_emailModel


class Marketing_emailSerializer(serializers.ModelSerializer):
    class Meta:
        model = Marketing_emailModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\marketing_email\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\marketing_email\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Marketing_emailViewSet

router = DefaultRouter()
router.register(r"marketing_email", Marketing_emailViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\marketing_email\views.py ###
from rest_framework import viewsets
from .models import Marketing_emailModel
from .serializers import Marketing_emailSerializer


class Marketing_emailViewSet(viewsets.ModelViewSet):
    queryset = Marketing_emailModel.objects.all()
    serializer_class = Marketing_emailSerializer


### C:\ClinicaAI\backend\apps\marketing_email\__init__.py ###


### C:\ClinicaAI\backend\apps\marketing_sms\admin.py ###
from django.contrib import admin
from .models import Marketing_smsModel


@admin.register(Marketing_smsModel)
class Marketing_smsAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\marketing_sms\apps.py ###
from django.apps import AppConfig


class Marketing_smsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.marketing_sms"


### C:\ClinicaAI\backend\apps\marketing_sms\models.py ###
from django.db import models


class Marketing_smsModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\marketing_sms\serializers.py ###
from rest_framework import serializers
from .models import Marketing_smsModel


class Marketing_smsSerializer(serializers.ModelSerializer):
    class Meta:
        model = Marketing_smsModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\marketing_sms\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\marketing_sms\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Marketing_smsViewSet

router = DefaultRouter()
router.register(r"marketing_sms", Marketing_smsViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\marketing_sms\views.py ###
from rest_framework import viewsets
from .models import Marketing_smsModel
from .serializers import Marketing_smsSerializer


class Marketing_smsViewSet(viewsets.ModelViewSet):
    queryset = Marketing_smsModel.objects.all()
    serializer_class = Marketing_smsSerializer


### C:\ClinicaAI\backend\apps\marketing_sms\__init__.py ###


### C:\ClinicaAI\backend\apps\mensagens\admin.py ###
from django.contrib import admin
from .models import MensagensModel


@admin.register(MensagensModel)
class MensagensAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\mensagens\apps.py ###
from django.apps import AppConfig


class MensagensConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.mensagens"


### C:\ClinicaAI\backend\apps\mensagens\models.py ###
from django.db import models


class MensagensModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\mensagens\serializers.py ###
from rest_framework import serializers
from .models import MensagensModel


class MensagensSerializer(serializers.ModelSerializer):
    class Meta:
        model = MensagensModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\mensagens\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\mensagens\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import MensagensViewSet

router = DefaultRouter()
router.register(r"mensagens", MensagensViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\mensagens\views.py ###
from rest_framework import viewsets
from .models import MensagensModel
from .serializers import MensagensSerializer


class MensagensViewSet(viewsets.ModelViewSet):
    queryset = MensagensModel.objects.all()
    serializer_class = MensagensSerializer


### C:\ClinicaAI\backend\apps\mensagens\__init__.py ###


### C:\ClinicaAI\backend\apps\pacientes\admin.py ###
from django.contrib import admin
from .models import Paciente

admin.site.register(Paciente)


### C:\ClinicaAI\backend\apps\pacientes\apps.py ###
from django.apps import AppConfig


class PacientesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.pacientes"

### C:\ClinicaAI\backend\apps\pacientes\models.py ###
from cryptography.fernet import Fernet
from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _
import uuid
from django.utils import timezone

# Gerar uma chave de criptografia para uso nos campos sensíveis (a chave deve ser armazenada em um local seguro)
# Aqui estamos simulando a recuperação da chave do arquivo de configurações
cipher_suite = Fernet(settings.ENCRYPTION_KEY)

class Paciente(models.Model):
    # Identificador Único Global
    uuid = models.UUIDField(unique=True, editable=False, default=uuid.uuid4)

    # Dados Pessoais
    nome_completo = models.CharField(_("Nome Completo"), max_length=255)
    foto = models.ImageField(
        _("Foto"), upload_to="pacientes/fotos/", blank=True, null=True
    )
    cpf = models.CharField(_("CPF"), max_length=255, unique=True)
    rg = models.CharField(_("RG"), max_length=255, blank=True)
    data_nascimento = models.DateField(_("Data de Nascimento"))
    sexo = models.CharField(
        _("Sexo"),
        max_length=1,
        choices=[
            ("M", "Masculino"),
            ("F", "Feminino"),
            ("O", "Outro"),
        ],
    )
    estado_civil = models.CharField(_("Estado Civil"), max_length=50, blank=True)
    profissao = models.CharField(_("Profissão"), max_length=100, blank=True)
    nacionalidade = models.CharField(_("Nacionalidade"), max_length=100, blank=True)
    naturalidade = models.CharField(_("Naturalidade"), max_length=100, blank=True)
    endereco = models.CharField(_("Endereço"), max_length=255)
    numero = models.CharField(_("Número"), max_length=10)
    complemento = models.CharField(_("Complemento"), max_length=100, blank=True)
    bairro = models.CharField(_("Bairro"), max_length=100)
    cidade = models.CharField(_("Cidade"), max_length=100)
    estado = models.CharField(_("Estado"), max_length=100)
    cep = models.CharField(_("CEP"), max_length=9, blank=True)
    telefone_residencial = models.CharField(
        _("Telefone Residencial"), max_length=20, blank=True
    )
    telefone_celular = models.CharField(
        _("Telefone Celular"), max_length=20, blank=True
    )
    email = models.EmailField(_("E-mail"), blank=True)
    contato_emergencia = models.CharField(
        _("Contato de Emergência"), max_length=255, blank=True
    )
    telefone_emergencia = models.CharField(
        _("Telefone de Emergência"), max_length=20, blank=True
    )

    # Dados Complementares
    nome_mae = models.CharField(_("Nome da Mãe"), max_length=255, blank=True)
    nome_pai = models.CharField(_("Nome do Pai"), max_length=255, blank=True)
    consentimento_lgpd = models.BooleanField(_("Consentimento LGPD"), default=False)
    observacoes = models.TextField(_("Observações"), blank=True)

    # Relacionamentos
    prontuario = models.OneToOneField(
        "prontuarios.Prontuario",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="paciente_prontuario",
    )

    # Auditoria
    created_at = models.DateTimeField(_("Data de Criação"), default=timezone.now)
    updated_at = models.DateTimeField(_("Última Atualização"), auto_now=True)

    class Meta:
        app_label = "pacientes"
        verbose_name = _("Paciente")
        verbose_name_plural = _("Pacientes")

    def __str__(self):
        return self.nome_completo

    def save(self, *args, **kwargs):
        # Criptografar CPF e RG antes de salvar
        if self.cpf:
            self.cpf = cipher_suite.encrypt(self.cpf.encode()).decode()
        if self.rg:
            self.rg = cipher_suite.encrypt(self.rg.encode()).decode()
        super().save(*args, **kwargs)

    def decrypt_cpf(self):
        # Descriptografar o CPF para uso
        if self.cpf:
            try:
                return cipher_suite.decrypt(self.cpf.encode()).decode()
            except Exception as e:
                return f"Erro ao descriptografar CPF: {e}"
        return None

    def decrypt_rg(self):
        # Descriptografar o RG para uso
        if self.rg:
            try:
                return cipher_suite.decrypt(self.rg.encode()).decode()
            except Exception as e:
                return f"Erro ao descriptografar RG: {e}"
        return None


### C:\ClinicaAI\backend\apps\pacientes\serializers.py ###
from rest_framework import serializers
from .models import Paciente
from django.core.validators import validate_email
import re
from apps.prontuarios.serializers import ProntuarioSerializer

class PacienteSerializer(serializers.ModelSerializer):
    cpf = serializers.SerializerMethodField()
    rg = serializers.SerializerMethodField()
    prontuario = ProntuarioSerializer(read_only=True)

    class Meta:
        model = Paciente
        fields = [
            "uuid",
            "nome_completo",
            "foto",
            "cpf",
            "rg",
            "data_nascimento",
            "sexo",
            "estado_civil",
            "profissao",
            "nacionalidade",
            "naturalidade",
            "endereco",
            "numero",
            "complemento",
            "bairro",
            "cidade",
            "estado",
            "cep",
            "telefone_residencial",
            "telefone_celular",
            "email",
            "contato_emergencia",
            "telefone_emergencia",
            "nome_mae",
            "nome_pai",
            "consentimento_lgpd",
            "observacoes",
            "created_at",
            "updated_at",
            "prontuario",
        ]
        read_only_fields = ["created_at", "updated_at"]

    def get_cpf(self, obj):
        return obj.decrypt_cpf()

    def get_rg(self, obj):
        return obj.decrypt_rg()

    def validate_cpf(self, value):
        if not value or value.strip() == "":
          raise serializers.ValidationError("CPF não pode estar vazio.")
        if not re.match(r"\d{3}\.\d{3}\.\d{3}-\d{2}", value):
            raise serializers.ValidationError("CPF deve estar no formato XXX.XXX.XXX-XX.")
        return value

    
    def validate_email(self, value):
        # Validação de e-mail
        try:
            validate_email(value)
        except Exception:
            raise serializers.ValidationError("E-mail inválido")
        return value


### C:\ClinicaAI\backend\apps\pacientes\tests.py ###
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from django.contrib.auth.models import User
from .models import Paciente
from rest_framework_simplejwt.tokens import RefreshToken

class PacienteTests(APITestCase):
    def setUp(self):
        # Criação de usuário para autenticação
        self.user = User.objects.create_user(
            username="testuser", password="testpassword"
        )
        self.admin_user = User.objects.create_superuser(
            username="admin", password="adminpassword"
        )
        self.client.login(username="testuser", password="testpassword")
# Gerar token para o admin
        refresh = RefreshToken.for_user(self.admin_user)
        self.client.credentials(HTTP_AUTHORIZATION=f"Bearer {refresh.access_token}")
        # Dados do paciente para testes
        self.paciente_data = {
            "nome_completo": "João da Silva",
            "cpf": "123.456.789-00",
            "rg": "MG-12.345.678",
            "data_nascimento": "1980-01-01",
            "sexo": "M",
            "estado_civil": "Solteiro",
            "endereco": "Rua A",
            "numero": "123",
            "bairro": "Centro",
            "cidade": "São Paulo",
            "estado": "SP",
            "telefone_celular": "(11) 91234-5678",
            "email": "joao.silva@example.com",
            "consentimento_lgpd": True,
        }

    def test_create_paciente(self):
        response = self.client.post(reverse("paciente-list"), self.paciente_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

    def test_create_paciente_unauthorized(self):
        self.client.credentials()  # Remove o token
        response = self.client.post(reverse("paciente-list"), self.paciente_data)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)


    def test_duplicate_cpf(self):
        # Testar duplicidade de CPF
        response = self.client.post(reverse("paciente-list"), self.paciente_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

        # Alterar o CPF no segundo teste
        duplicate_data = self.paciente_data.copy()
        duplicate_data["cpf"] = "987.654.321-00"  # CPF diferente
        response = self.client.post(reverse("paciente-list"), duplicate_data)
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_missing_required_fields(self):
        invalid_data = self.paciente_data.copy()
        invalid_data.pop("cpf")  # Remove CPF
        response = self.client.post(reverse("paciente-list"), invalid_data)
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_list_pacientes(self):
        # Listar pacientes após criação
        self.client.login(username="admin", password="adminpassword")
        self.client.post(reverse("paciente-list"), self.paciente_data)
        response = self.client.get(reverse("paciente-list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data["results"]), 1)

    def test_permissions(self):
        # Verificar permissões de acesso para listagem
        response = self.client.get(reverse("paciente-list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.client.logout()
        response = self.client.get(reverse("paciente-list"))
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

    def test_descriptografia_campos(self):
        # Verificar se CPF e RG são descriptografados corretamente
        self.client.login(username="admin", password="adminpassword")
        response = self.client.post(reverse("paciente-list"), self.paciente_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

        paciente_id = response.data["uuid"]
        response = self.client.get(reverse("paciente-detail", args=[paciente_id]))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["cpf"], "123.456.789-00")
        self.assertEqual(response.data["rg"], "MG-12.345.678")


### C:\ClinicaAI\backend\apps\pacientes\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PacienteViewSet

router = DefaultRouter()
router.register(r'pacientes', PacienteViewSet)

urlpatterns = [
    path('', include(router.urls)),
]


### C:\ClinicaAI\backend\apps\pacientes\views.py ###
# Incremento 3: Melhorias nas Visualizações (views.py)

from rest_framework import viewsets, permissions, filters
from rest_framework.pagination import PageNumberPagination
from django_filters.rest_framework import DjangoFilterBackend
from .models import Paciente
from .serializers import PacienteSerializer
import logging

logger = logging.getLogger(__name__)

class PacientePagination(PageNumberPagination):
    page_size = 10
    page_size_query_param = "page_size"
    max_page_size = 100

class PacienteViewSet(viewsets.ModelViewSet):
    queryset = Paciente.objects.all()
    serializer_class = PacienteSerializer
    pagination_class = PacientePagination
    
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]
    filterset_fields = ["sexo", "estado_civil", "cidade", "estado"]
    search_fields = ["nome_completo", "cpf", "email"]
    ordering_fields = ["nome_completo", "data_nascimento", "created_at"]
    ordering = ["nome_completo"]

    def get_permissions(self):
        if self.action in ["list", "retrieve", "create", "update", "destroy"]:
            return [permissions.IsAuthenticated()]
        return super().get_permissions()

    def list(self, request, *args, **kwargs):
        logger.debug("Listando pacientes")
        response = super().list(request, *args, **kwargs)
        logger.debug(f"Response data: {response.data}")
        return response



### C:\ClinicaAI\backend\apps\pacientes\__init__.py ###


### C:\ClinicaAI\backend\apps\pesquisas\admin.py ###
from django.contrib import admin

# Register your models here.


### C:\ClinicaAI\backend\apps\pesquisas\apps.py ###
from django.apps import AppConfig


class PesquisasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.pesquisas"


### C:\ClinicaAI\backend\apps\pesquisas\models.py ###
from django.db import models

# Create your models here.


### C:\ClinicaAI\backend\apps\pesquisas\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\pesquisas\views.py ###
from django.shortcuts import render

# Create your views here.


### C:\ClinicaAI\backend\apps\pesquisas\__init__.py ###


### C:\ClinicaAI\backend\apps\planilhas\admin.py ###
from django.contrib import admin
from .models import PlanilhasModel


@admin.register(PlanilhasModel)
class PlanilhasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\planilhas\apps.py ###
from django.apps import AppConfig


class PlanilhasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.planilhas"


### C:\ClinicaAI\backend\apps\planilhas\models.py ###
from django.db import models


class PlanilhasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\planilhas\serializers.py ###
from rest_framework import serializers
from .models import PlanilhasModel


class PlanilhasSerializer(serializers.ModelSerializer):
    class Meta:
        model = PlanilhasModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\planilhas\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\planilhas\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PlanilhasViewSet

router = DefaultRouter()
router.register(r"planilhas", PlanilhasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\planilhas\views.py ###
from rest_framework import viewsets
from .models import PlanilhasModel
from .serializers import PlanilhasSerializer


class PlanilhasViewSet(viewsets.ModelViewSet):
    queryset = PlanilhasModel.objects.all()
    serializer_class = PlanilhasSerializer


### C:\ClinicaAI\backend\apps\planilhas\__init__.py ###


### C:\ClinicaAI\backend\apps\planilhas_horas\admin.py ###
from django.contrib import admin
from .models import Planilhas_horasModel


@admin.register(Planilhas_horasModel)
class Planilhas_horasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\planilhas_horas\apps.py ###
from django.apps import AppConfig


class Planilhas_horasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.planilhas_horas"


### C:\ClinicaAI\backend\apps\planilhas_horas\models.py ###
from django.db import models


class Planilhas_horasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\planilhas_horas\serializers.py ###
from rest_framework import serializers
from .models import Planilhas_horasModel


class Planilhas_horasSerializer(serializers.ModelSerializer):
    class Meta:
        model = Planilhas_horasModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\planilhas_horas\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\planilhas_horas\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Planilhas_horasViewSet

router = DefaultRouter()
router.register(r"planilhas_horas", Planilhas_horasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\planilhas_horas\views.py ###
from rest_framework import viewsets
from .models import Planilhas_horasModel
from .serializers import Planilhas_horasSerializer


class Planilhas_horasViewSet(viewsets.ModelViewSet):
    queryset = Planilhas_horasModel.objects.all()
    serializer_class = Planilhas_horasSerializer


### C:\ClinicaAI\backend\apps\planilhas_horas\__init__.py ###


### C:\ClinicaAI\backend\apps\plm\admin.py ###
from django.contrib import admin
from .models import PlmModel


@admin.register(PlmModel)
class PlmAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\plm\apps.py ###
from django.apps import AppConfig


class PlmConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.plm"


### C:\ClinicaAI\backend\apps\plm\models.py ###
from django.db import models


class PlmModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\plm\serializers.py ###
from rest_framework import serializers
from .models import PlmModel


class PlmSerializer(serializers.ModelSerializer):
    class Meta:
        model = PlmModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\plm\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\plm\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PlmViewSet

router = DefaultRouter()
router.register(r"plm", PlmViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\plm\views.py ###
from rest_framework import viewsets
from .models import PlmModel
from .serializers import PlmSerializer


class PlmViewSet(viewsets.ModelViewSet):
    queryset = PlmModel.objects.all()
    serializer_class = PlmSerializer


### C:\ClinicaAI\backend\apps\plm\__init__.py ###


### C:\ClinicaAI\backend\apps\produtividade\admin.py ###
from django.contrib import admin

# Register your models here.


### C:\ClinicaAI\backend\apps\produtividade\apps.py ###
from django.apps import AppConfig


class ProdutividadeConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.produtividade"


### C:\ClinicaAI\backend\apps\produtividade\models.py ###
from django.db import models

# Create your models here.


### C:\ClinicaAI\backend\apps\produtividade\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\produtividade\views.py ###
from django.shortcuts import render

# Create your views here.


### C:\ClinicaAI\backend\apps\produtividade\__init__.py ###


### C:\ClinicaAI\backend\apps\profissionais\admin.py ###
from django.contrib import admin
from .models import Profissional, Especialidade, Disponibilidade, RegistroHorasTrabalhadas

@admin.register(Profissional)
class ProfissionalAdmin(admin.ModelAdmin):
    list_display = ['nome_completo', 'registro_conselho', 'conselho', 'email']
    search_fields = ['nome_completo', 'registro_conselho']

@admin.register(Especialidade)
class EspecialidadeAdmin(admin.ModelAdmin):
    list_display = ['nome', 'descricao']
    search_fields = ['nome']

@admin.register(Disponibilidade)
class DisponibilidadeAdmin(admin.ModelAdmin):
    list_display = ['profissional', 'dia', 'horario_inicio', 'horario_fim']
    list_filter = ['dia', 'disponivel']

@admin.register(RegistroHorasTrabalhadas)
class RegistroHorasTrabalhadasAdmin(admin.ModelAdmin):
    list_display = ['profissional', 'dia', 'horas_trabalhadas']
    list_filter = ['dia']


### C:\ClinicaAI\backend\apps\profissionais\apps.py ###
from django.apps import AppConfig


class ProfissionaisConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.profissionais"


### C:\ClinicaAI\backend\apps\profissionais\models.py ###
# Módulo Profissionais - Criação do Modelo (models.py)

from django.db import models
from django.utils.translation import gettext_lazy as _
import uuid
from django.conf import settings


class Especialidade(models.Model):
    nome = models.CharField(
        max_length=100, unique=True, verbose_name=_("Nome da Especialidade")
    )
    descricao = models.TextField(blank=True, verbose_name=_("Descrição"))

    class Meta:
        verbose_name = _("Especialidade")
        verbose_name_plural = _("Especialidades")
        app_label = "profissionais"

    def __str__(self):
        return self.nome


class Profissional(models.Model):
    # Identificador Único Global
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    # Dados Pessoais
    usuario = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="profissional",
        verbose_name=_("Usuário"),
    )
    nome_completo = models.CharField(max_length=255, verbose_name=_("Nome Completo"))
    cpf = models.CharField(max_length=11, unique=True, verbose_name=_("CPF"))
    registro_conselho = models.CharField(
        max_length=50, unique=True, verbose_name=_("Registro no Conselho")
    )
    conselho = models.CharField(
        max_length=100, verbose_name=_("Conselho de Classe (CRM, CRO, etc.)")
    )
    especialidades = models.ManyToManyField(
        Especialidade, related_name="profissionais", verbose_name=_("Especialidades")
    )
    telefone = models.CharField(max_length=20, blank=True, verbose_name=_("Telefone"))
    email = models.EmailField(max_length=255, verbose_name=_("E-mail"))
    endereco = models.CharField(max_length=255, blank=True, verbose_name=_("Endereço"))
    tipo_contratacao = models.CharField(
        max_length=50,
        choices=[
            ("CLT", "CLT"),
            ("PJ", "Pessoa Jurídica"),
            ("Freelancer", "Freelancer"),
        ],
        verbose_name=_("Tipo de Contratação"),
    )
    documentos = models.FileField(
        upload_to="documentos_profissionais/", blank=True, verbose_name=_("Documentos")
    )

    # Dados Profissionais
    horario_atendimento_inicio = models.TimeField(
        verbose_name=_("Horário de Início do Atendimento")
    )
    horario_atendimento_fim = models.TimeField(
        verbose_name=_("Horário de Fim do Atendimento")
    )
    dias_atendimento = models.CharField(
        max_length=50, verbose_name=_("Dias da Semana para Atendimento")
    )

    class Meta:
        verbose_name = _("Profissional")
        verbose_name_plural = _("Profissionais")

    def __str__(self):
        return f"{self.nome_completo} ({self.registro_conselho})"


class Disponibilidade(models.Model):
    profissional = models.ForeignKey(
        Profissional,
        on_delete=models.CASCADE,
        related_name="disponibilidades",
        verbose_name=_("Profissional"),
    )
    dia = models.DateField(verbose_name=_("Dia da Disponibilidade"))
    horario_inicio = models.TimeField(verbose_name=_("Horário de Início"))
    horario_fim = models.TimeField(verbose_name=_("Horário de Fim"))
    disponivel = models.BooleanField(default=True, verbose_name=_("Disponível"))

    class Meta:
        verbose_name = _("Disponibilidade")
        verbose_name_plural = _("Disponibilidades")
        unique_together = (("profissional", "dia", "horario_inicio", "horario_fim"),)

    def __str__(self):
        return f"Disponibilidade de {self.profissional.nome_completo} em {self.dia}"


class RegistroHorasTrabalhadas(models.Model):
    profissional = models.ForeignKey(
        Profissional,
        on_delete=models.CASCADE,
        related_name="horas_trabalhadas",
        verbose_name=_("Profissional"),
    )
    dia = models.DateField(verbose_name=_("Dia"))
    horas_trabalhadas = models.DecimalField(
        max_digits=4, decimal_places=2, verbose_name=_("Horas Trabalhadas")
    )

    class Meta:
        verbose_name = _("Registro de Horas Trabalhadas")
        verbose_name_plural = _("Registros de Horas Trabalhadas")

    def __str__(self):
        return f"Horas trabalhadas por {self.profissional.nome_completo} em {self.dia}"


### C:\ClinicaAI\backend\apps\profissionais\serializers.py ###
# Módulo Profissionais - Serializers (serializers.py)

from rest_framework import serializers
from apps.profissionais.models import (
    Especialidade,
    Profissional,
    Disponibilidade,
    RegistroHorasTrabalhadas,
)


class EspecialidadeSerializer(serializers.ModelSerializer):
    class Meta:
        model = Especialidade
        fields = "__all__"


class ProfissionalSerializer(serializers.ModelSerializer):
    class Meta:
        model = Profissional
        fields = "__all__"


class DisponibilidadeSerializer(serializers.ModelSerializer):
    class Meta:
        model = Disponibilidade
        fields = "__all__"


class RegistroHorasTrabalhadasSerializer(serializers.ModelSerializer):
    class Meta:
        model = RegistroHorasTrabalhadas
        fields = "__all__"


### C:\ClinicaAI\backend\apps\profissionais\urls.py ###
# Módulo Profissionais - URLs (urls.py)

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'especialidades', views.EspecialidadeViewSet)
router.register(r'profissionais', views.ProfissionalViewSet)
router.register(r'disponibilidades', views.DisponibilidadeViewSet)
router.register(r'horas_trabalhadas', views.RegistroHorasTrabalhadasViewSet)

urlpatterns = [
    path('', include(router.urls)),
    path('list/', views.ProfissionalList.as_view(), name='profissional-list'),
    path('detail/<int:pk>/', views.ProfissionalDetail.as_view(), name='profissional-detail'),
]


### C:\ClinicaAI\backend\apps\profissionais\views.py ###
# Módulo Profissionais - Views (views.py)

from rest_framework import viewsets, status, generics
from apps.profissionais.models import (
    Especialidade,
    Profissional,
    Disponibilidade,
    RegistroHorasTrabalhadas,
)
from .serializers import (
    EspecialidadeSerializer,
    ProfissionalSerializer,
    DisponibilidadeSerializer,
    RegistroHorasTrabalhadasSerializer,
)
from rest_framework.permissions import IsAuthenticated, BasePermission, AllowAny
from rest_framework.response import Response
from rest_framework.decorators import action
from django.utils import timezone

# Custom Permissions


class IsAdminOrReadOnly(BasePermission):
    def has_permission(self, request, view):
        if request.method in ["GET"]:
            return True
        return request.user and request.user.is_staff


class IsProfissionalOrReadOnly(BasePermission):
    def has_object_permission(self, request, view, obj):
        if request.method in ["GET", "HEAD", "OPTIONS"]:
            return True
        return obj.usuario == request.user or request.user.is_staff


# Views


class EspecialidadeViewSet(viewsets.ModelViewSet):
    queryset = Especialidade.objects.all()
    serializer_class = EspecialidadeSerializer
    permission_classes = [IsAuthenticated, IsAdminOrReadOnly]


class ProfissionalViewSet(viewsets.ModelViewSet):
    queryset = Profissional.objects.all()
    serializer_class = ProfissionalSerializer
    permission_classes = [IsAuthenticated, IsAdminOrReadOnly]


class DisponibilidadeViewSet(viewsets.ModelViewSet):
    queryset = Disponibilidade.objects.all()
    serializer_class = DisponibilidadeSerializer
    permission_classes = [IsAuthenticated, IsProfissionalOrReadOnly]

    def create(self, request, *args, **kwargs):
        # Validar se a disponibilidade é para uma data futura
        data = request.data.copy()
        dia = data.get("dia")
        if dia:
            dia = timezone.datetime.strptime(dia, "%Y-%m-%d").date()
            if dia < timezone.now().date():
                return Response(
                    {"detail": "A disponibilidade deve ser para uma data futura."},
                    status=status.HTTP_400_BAD_REQUEST,
                )
        return super().create(request, *args, **kwargs)


class RegistroHorasTrabalhadasViewSet(viewsets.ModelViewSet):
    queryset = RegistroHorasTrabalhadas.objects.all()
    serializer_class = RegistroHorasTrabalhadasSerializer
    permission_classes = [IsAuthenticated, IsProfissionalOrReadOnly]

    @action(detail=False, methods=["get"], permission_classes=[IsAuthenticated])
    def minhas_horas(self, request):
        # Retornar as horas trabalhadas do profissional autenticado
        if hasattr(request.user, "profissional"):
            profissional = request.user.profissional
            queryset = RegistroHorasTrabalhadas.objects.filter(
                profissional=profissional
            )
            serializer = self.get_serializer(queryset, many=True)
            return Response(serializer.data)
        return Response(
            {"detail": "Usuário não é um profissional."},
            status=status.HTTP_400_BAD_REQUEST,
        )


class ProfissionalList(generics.ListCreateAPIView):
    queryset = Profissional.objects.all()
    serializer_class = ProfissionalSerializer
    permission_classes = [IsAuthenticated]  # Exigir autenticação


class ProfissionalDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = Profissional.objects.all()
    serializer_class = ProfissionalSerializer
    permission_classes = [IsAuthenticated]  # Exigir autenticação


### C:\ClinicaAI\backend\apps\profissionais\__init__.py ###


### C:\ClinicaAI\backend\apps\profissionais\management\__init__.py ###


### C:\ClinicaAI\backend\apps\profissionais\management\commands\clear_db.py ###
from django.core.management.base import BaseCommand
from apps.profissionais.models import Profissional, Especialidade
from apps.pacientes.models import Paciente
from apps.exames.models import Exame
from apps.agendamentos.models import Agendamento
from apps.prontuarios.models import Prontuario
from django.contrib.auth import get_user_model

User = get_user_model()

class Command(BaseCommand):
    help = 'Apaga todos os dados do banco de dados'

    def handle(self, *args, **kwargs):
        self.stdout.write("Apagando todos os dados do banco de dados...\n")

        # Apagar os registros em ordem para evitar erros de chaves estrangeiras
        Agendamento.objects.all().delete()
        Prontuario.objects.all().delete()
        Exame.objects.all().delete()
        Paciente.objects.all().delete()
        Profissional.objects.all().delete()
        Especialidade.objects.all().delete()
        User.objects.exclude(is_superuser=True).delete()  # Preserva o superusuário

        self.stdout.write(self.style.SUCCESS("Todos os dados foram apagados com sucesso!"))


### C:\ClinicaAI\backend\apps\profissionais\management\commands\populate_db copy.py ###
import random
from django.core.management.base import BaseCommand
from apps.profissionais.models import Profissional, Especialidade
from apps.pacientes.models import Paciente
from apps.exames.models import Exame
from apps.agendamentos.models import Agendamento
from apps.prontuarios.models import Prontuario
from django.contrib.auth import get_user_model
from datetime import date, timedelta, datetime
from django.utils import timezone

User = get_user_model()

class Command(BaseCommand):
    help = 'Popula o banco de dados com dados de teste'

    def handle(self, *args, **kwargs):
        self.stdout.write("Populando banco de dados...\n")
        
        # Criando usuários de exemplo
        users = []
        for i in range(1, 6):
            username = f"usuario{i}"
            user, created = User.objects.get_or_create(username=username, defaults={'password': f"senha123{i}"})
            users.append(user)

        # Criando especialidades
        especialidades_nomes = [
            "Cardiologia", "Dermatologia", "Ortopedia", "Neurologia", "Pediatria"
        ]
        especialidades = []
        for especialidade_nome in especialidades_nomes:
            especialidade, created = Especialidade.objects.get_or_create(nome=especialidade_nome)
            especialidades.append(especialidade)

        # Criando profissionais de saúde
        for i in range(1, 6):
            cpf = self.gerar_cpf_unico()
            registro_conselho = f"CRP-{random.randint(1000, 9999)}"  # Registro único
            profissional, created = Profissional.objects.get_or_create(
                usuario=random.choice(users),
                defaults={
                    'nome_completo': f"Profissional {i}",
                    'cpf': cpf,
                    'registro_conselho': registro_conselho,
                    'conselho': "CRM",
                    'telefone': f"1199999{i:04d}",
                    'email': f"profissional{i}@clinicaai.com",
                    'endereco': f"Rua Exemplo, {i}",
                    'tipo_contratacao': random.choice(["CLT", "PJ", "Freelancer"]),
                    'horario_atendimento_inicio': "08:00",
                    'horario_atendimento_fim': "17:00",
                    'dias_atendimento': random.choice(["Segunda a Sexta", "Segunda a Sábado"])
                }
            )
            if created:
                profissional.especialidades.set([random.choice(especialidades)])

        # Criando pacientes
        for i in range(1, 11):
            username = f"paciente{i}"
            user, created = User.objects.get_or_create(username=username, defaults={'password': f"senha123{i}"})
            if hasattr(user, 'paciente') or hasattr(user, 'profissional'):
                continue  # Pule usuários já associados
            cpf = self.gerar_cpf_unico()
            Paciente.objects.get_or_create(
                cpf=cpf,
                defaults={
                    'nome_completo': f"Paciente {i}",
                    'data_nascimento': date(1980, 1, 1) + timedelta(days=random.randint(0, 15000)),
                    'telefone_celular': f"99999{random.randint(1000, 9999)}",
                    'email': f"paciente{i}@teste.com"
                }
            )

        # Criando exames
        pacientes = Paciente.objects.all()
        profissionais = Profissional.objects.all()
        exames_nomes = [
            "Exame de sangue", "Raio X", "Ultrassom", "ECG", "Teste de glicose"
        ]
        exames = []
        for exame_nome in exames_nomes:
            paciente = random.choice(pacientes)
            profissional = random.choice(profissionais)
            exame, created = Exame.objects.get_or_create(
                tipo_exame=exame_nome,
                paciente=paciente,
                profissional_solicitante=profissional,
                defaults={
                    'observacoes': f"Descrição do {exame_nome}",
                    'data_solicitacao': date.today()
                }
            )
            exames.append(exame)

        # Criando agendamentos
        for i in range(1, 11):
            horario_inicio = random.randint(8, 16)
            horario_fim = horario_inicio + 1  # Garante que o horário de fim seja posterior
            Agendamento.objects.get_or_create(
                paciente=random.choice(pacientes),
                profissional=random.choice(profissionais),
                data_agendamento=date.today() + timedelta(days=random.randint(1, 30)),
                horario_inicio=f"{horario_inicio}:00",
                horario_fim=f"{horario_fim}:00",
                tipo_consulta=random.choice(["Consulta de rotina", "Retorno", "Urgência"])
            )

        # Criando prontuários
        agendamentos = Agendamento.objects.all()
        for agendamento in agendamentos:
            Prontuario.objects.update_or_create(
                paciente=agendamento.paciente,
                profissional_responsavel=agendamento.profissional,
                data_atendimento=datetime.combine(agendamento.data_agendamento, datetime.min.time(), tzinfo=timezone.utc),
                defaults={
                    'queixa_principal': "Diagnóstico fictício e tratamento sugerido."
                }
            )

        self.stdout.write(self.style.SUCCESS("Banco de dados populado com sucesso!"))

    def gerar_cpf_unico(self):
        while True:
            cpf = f"{random.randint(10000000000, 99999999999)}"
            if not Profissional.objects.filter(cpf=cpf).exists() and not Paciente.objects.filter(cpf=cpf).exists():
                return cpf


### C:\ClinicaAI\backend\apps\profissionais\management\commands\populate_db.py ###
import random
from django.core.management.base import BaseCommand
from apps.profissionais.models import Profissional, Especialidade
from apps.pacientes.models import Paciente
from apps.exames.models import Exame
from apps.agendamentos.models import Agendamento
from apps.prontuarios.models import Prontuario
from django.contrib.auth import get_user_model
from datetime import date, timedelta, datetime
from faker import Faker
from django.utils import timezone

User = get_user_model()
fake = Faker('pt_BR')

class Command(BaseCommand):
    help = 'Popula o banco de dados com dados de teste mais realistas'

    def handle(self, *args, **kwargs):
        self.stdout.write("Populando banco de dados...\n")
        
        # Criando usuários de exemplo
        users = []
        for i in range(1, 6):
            username = f"usuario{i}"
            user, created = User.objects.get_or_create(username=username, defaults={'password': f"senha123{i}"})
            users.append(user)

        # Criando especialidades
        especialidades_nomes = [
            "Cardiologia", "Dermatologia", "Ortopedia", "Neurologia", "Pediatria"
        ]
        especialidades = []
        for especialidade_nome in especialidades_nomes:
            especialidade, created = Especialidade.objects.get_or_create(nome=especialidade_nome)
            especialidades.append(especialidade)

        # Criando profissionais de saúde
        for i in range(1, 6):
            cpf = self.gerar_cpf_unico()
            registro_conselho = f"CRP-{random.randint(1000, 9999)}"  # Registro único
            profissional, created = Profissional.objects.get_or_create(
                usuario=random.choice(users),
                defaults={
                    'nome_completo': fake.name(),
                    'cpf': cpf,
                    'registro_conselho': registro_conselho,
                    'conselho': "CRM",
                    'telefone': f"1199999{i:04d}",
                    'email': f"profissional{i}@clinicaai.com",
                    'endereco': f"Rua Exemplo, {i}",
                    'tipo_contratacao': random.choice(["CLT", "PJ", "Freelancer"]),
                    'horario_atendimento_inicio': "08:00",
                    'horario_atendimento_fim': "17:00",
                    'dias_atendimento': random.choice(["Segunda a Sexta", "Segunda a Sábado"])
                }
            )
            if created:
                profissional.especialidades.set([random.choice(especialidades)])

        # Criando pacientes
        for i in range(1, 11):
            username = f"paciente{i}"
            user, created = User.objects.get_or_create(username=username, defaults={'password': f"senha123{i}"})
            if hasattr(user, 'paciente') or hasattr(user, 'profissional'):
                continue  # Pule usuários já associados
            cpf = self.gerar_cpf_unico()
            Paciente.objects.get_or_create(
                cpf=cpf,
                defaults={
                    'nome_completo': fake.name(),
                    'data_nascimento': date(1980, 1, 1) + timedelta(days=random.randint(0, 15000)),
                    'telefone_celular': f"99999{random.randint(1000, 9999)}",
                    'email': f"paciente{i}@teste.com"
                }
            )

        # Criando exames
        pacientes = Paciente.objects.all()
        profissionais = Profissional.objects.all()
        exames_nomes = [
            "Exame de sangue", "Raio X", "Ultrassom", "ECG", "Teste de glicose"
        ]
        exames = []
        for exame_nome in exames_nomes:
            paciente = random.choice(pacientes)
            profissional = random.choice(profissionais)
            exame, created = Exame.objects.get_or_create(
                tipo_exame=exame_nome,
                paciente=paciente,
                profissional_solicitante=profissional,
                defaults={
                    'observacoes': f"Descrição do {exame_nome}",
                    'data_solicitacao': date.today()
                }
            )
            exames.append(exame)

        # Criando agendamentos sem conflitos
        for i in range(1, 11):
            profissional = random.choice(profissionais)
            data_agendamento = date.today() + timedelta(days=random.randint(1, 30))
            horario_inicio = random.randint(8, 16)
            horario_fim = horario_inicio + 1  # Garante que o horário de fim seja posterior

            if not Agendamento.objects.filter(
                profissional=profissional,
                data_agendamento=data_agendamento,
                horario_inicio=f"{horario_inicio}:00"
            ).exists():
                Agendamento.objects.create(
                    paciente=random.choice(pacientes),
                    profissional=profissional,
                    data_agendamento=data_agendamento,
                    horario_inicio=f"{horario_inicio}:00",
                    horario_fim=f"{horario_fim}:00",
                    tipo_consulta=random.choice(["Consulta de rotina", "Retorno", "Urgência"])
                )

        # Criando prontuários
        agendamentos = Agendamento.objects.all()
        for agendamento in agendamentos:
            Prontuario.objects.update_or_create(
                paciente=agendamento.paciente,
                profissional_responsavel=agendamento.profissional,
                data_atendimento=datetime.combine(agendamento.data_agendamento, datetime.min.time(), tzinfo=timezone.utc),
                defaults={
                    'queixa_principal': "Diagnóstico fictício e tratamento sugerido."
                }
            )

        self.stdout.write(self.style.SUCCESS("Banco de dados populado com sucesso!"))

    def gerar_cpf_unico(self):
        while True:
            cpf = f"{random.randint(10000000000, 99999999999)}"
            if not Profissional.objects.filter(cpf=cpf).exists() and not Paciente.objects.filter(cpf=cpf).exists():
                return cpf


### C:\ClinicaAI\backend\apps\profissionais\management\commands\__init__.py ###


### C:\ClinicaAI\backend\apps\projeto\admin.py ###
from django.contrib import admin
from .models import ProjetoModel


@admin.register(ProjetoModel)
class ProjetoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\projeto\apps.py ###
from django.apps import AppConfig


class ProjetoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.projeto"


### C:\ClinicaAI\backend\apps\projeto\models.py ###
from django.db import models


class ProjetoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\projeto\serializers.py ###
from rest_framework import serializers
from .models import ProjetoModel


class ProjetoSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProjetoModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\projeto\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\projeto\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ProjetoViewSet

router = DefaultRouter()
router.register(r"projeto", ProjetoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\projeto\views.py ###
from rest_framework import viewsets
from .models import ProjetoModel
from .serializers import ProjetoSerializer


class ProjetoViewSet(viewsets.ModelViewSet):
    queryset = ProjetoModel.objects.all()
    serializer_class = ProjetoSerializer


### C:\ClinicaAI\backend\apps\projeto\__init__.py ###


### C:\ClinicaAI\backend\apps\prontuarios\admin.py ###
from django.contrib import admin
from .models import Prontuario

class ProntuarioAdmin(admin.ModelAdmin):
    list_display = ('paciente', 'data_atendimento', 'prescricao', 'profissional_responsavel')

admin.site.register(Prontuario, ProntuarioAdmin)

from .models import Anamnese

admin.site.register(Anamnese)


### C:\ClinicaAI\backend\apps\prontuarios\models.py ###
# Módulo Prontuários - Criação do Modelo (models.py)

from django.db import models
from django.utils.translation import gettext_lazy as _
import uuid
from django.conf import settings


class Prontuario(models.Model):
    # Identificador Único Global
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    # Dados Relacionados ao Paciente
    paciente = models.ForeignKey(
    "pacientes.Paciente",
    on_delete=models.CASCADE,
    related_name="prontuarios",  # Alterar para evitar conflito com campo em Paciente
)

    # Evoluções Clínicas e Atendimentos
    data_atendimento = models.DateTimeField(_("Data do Atendimento"))
    profissional_responsavel = models.ForeignKey(
    "profissionais.Profissional",
    on_delete=models.SET_NULL,
    null=True,
    related_name="exames_solicitados_complementar",  # Alterar para um nome único
)

    queixa_principal = models.TextField(_("Queixa Principal"), blank=True)
    historico_doenca_atual = models.TextField(
        _("Histórico da Doença Atual"), blank=True
    )
    antecedentes_pessoais = models.TextField(_("Antecedentes Pessoais"), blank=True)
    exame_fisico_cabeca_pescoco = models.TextField(
        _("Exame Físico - Cabeça e Pescoço"), blank=True
    )
    exame_fisico_torax = models.TextField(_("Exame Físico - Tórax"), blank=True)
    exame_fisico_abdomen = models.TextField(_("Exame Físico - Abdômen"), blank=True)
    exame_fisico_membros = models.TextField(
        _("Exame Físico - Membros Superiores e Inferiores"), blank=True
    )
    hipotese_diagnostica = models.TextField(_("Hipótese Diagnóstica"), blank=True)
    conduta = models.TextField(_("Conduta/Plano"), blank=True)
    prescricao = models.TextField(_("Prescrição Médica"), blank=True)
    tratamentos_previos = models.TextField(_("Tratamentos Prévio(s)"), blank=True)

    # Diagnósticos
    diagnostico_final = models.CharField(
        _("Diagnóstico Final"), max_length=255, blank=True
    )
    cid_10 = models.CharField(_("CID-10"), max_length=10, blank=True)

    # Anotações de Outros Profissionais
    anotacoes_profissionais = models.TextField(
        _("Anotações de Outros Profissionais"), blank=True
    )

    # Referências e Encaminhamentos
    encaminhamentos = models.TextField(_("Encaminhamentos"), blank=True)
    referencias_especialidades = models.TextField(
        _("Referências para Especialidades"), blank=True
    )

    # Consentimento e Termos
    consentimento_informado = models.BooleanField(
        _("Consentimento Informado Assinado"), default=False
    )

    # Histórico Familiar
    historico_familiar = models.TextField(_("Histórico Familiar"), blank=True)
    risco_genetico = models.TextField(_("Risco Genético Identificado"), blank=True)

    # Dados Psicológicos e Sociais
    dados_psicossociais = models.TextField(
        _("Dados Psicológicos e Sociais"), blank=True
    )
    estado_emocional = models.TextField(_("Estado Emocional"), blank=True)
    transtornos_identificados = models.TextField(
        _("Transtornos Identificados"), blank=True
    )
    medicacoes_psiquiatricas = models.TextField(
        _("Medicações Psiquiátricas"), blank=True
    )

    # Histórico de Hábitos de Vida
    tabagismo = models.BooleanField(_("Tabagismo"), default=False)
    etilismo = models.BooleanField(_("Etilismo"), default=False)
    uso_drogas = models.BooleanField(_("Uso de Drogas"), default=False)
    atividade_fisica = models.CharField(
        _("Atividade Física"), max_length=255, blank=True
    )
    alimentacao = models.CharField(_("Alimentação"), max_length=255, blank=True)
    qualidade_sono = models.CharField(
        _("Qualidade do Sono"), max_length=255, blank=True
    )
    ocupacao = models.CharField(_("Ocupação"), max_length=255, blank=True)
    nivel_estresse = models.CharField(
        _("Nível de Estresse"), max_length=255, blank=True
    )
    medicacoes_nao_prescritas = models.TextField(
        _("Medicações Não Prescritas"), blank=True
    )

    # Histórico de Cirurgias e Internações
    historico_cirurgias = models.TextField(_("Histórico de Cirurgias"), blank=True)
    historico_internacoes = models.TextField(_("Histórico de Internações"), blank=True)

    # Histórico de Imunizações
    imunizacoes = models.TextField(_("Histórico de Imunizações"), blank=True)

    # Estratificação de Risco
    estratificacao_risco = models.CharField(
        _("Estratificação de Risco"), max_length=255, blank=True
    )
    risco_quedas = models.CharField(_("Risco de Quedas"), max_length=255, blank=True)

    # Motivo do Atendimento
    motivo_atendimento = models.CharField(
        _("Motivo do Atendimento"), max_length=255, blank=True
    )

    # Acompanhamento de Doenças Crônicas
    diabetes_hemoglobina_glicada = models.DecimalField(
        _("Hemoglobina Glicada (%)"),
        max_digits=4,
        decimal_places=2,
        blank=True,
        null=True,
    )
    funcao_renal_taxa_filtracao = models.DecimalField(
        _("Taxa de Filtração Glomerular (mL/min)"),
        max_digits=5,
        decimal_places=2,
        blank=True,
        null=True,
    )

    # Avaliação Nutricional
    imc = models.DecimalField(
        _("Índice de Massa Corporal (IMC)"),
        max_digits=4,
        decimal_places=1,
        blank=True,
        null=True,
    )
    percentual_gordura_corporal = models.DecimalField(
        _("Percentual de Gordura Corporal (%)"),
        max_digits=4,
        decimal_places=1,
        blank=True,
        null=True,
    )
    dieta_recomendada = models.TextField(_("Dieta Recomendada"), blank=True)

    # Planos de Saúde e Seguros
    plano_saude = models.CharField(_("Plano de Saúde"), max_length=255, blank=True)
    numero_plano_saude = models.CharField(
        _("Número do Plano de Saúde"), max_length=255, blank=True
    )

    # Auditoria
    created_at = models.DateTimeField(_("Data de Criação"), auto_now_add=True)
    updated_at = models.DateTimeField(_("Última Atualização"), auto_now=True)
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name="prontuarios_criados",
    )
    updated_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name="prontuarios_atualizados",
    )

    prescricao = models.TextField()

    class Meta:
        verbose_name = _("Prontuário")
        verbose_name_plural = _("Prontuários")

    def __str__(self):
        return self.prescricao


class HistoricoMedicamentos(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="historico_medicamentos"
    )
    medicamento = models.CharField(_("Medicamento"), max_length=255)
    dosagem = models.CharField(_("Dosagem"), max_length=255)
    frequencia = models.CharField(_("Frequência"), max_length=255)
    duracao = models.CharField(_("Duração"), max_length=255)
    observacoes = models.TextField(_("Observações"), blank=True)
    prescrito_por = models.ForeignKey(
        "profissionais.Profissional", on_delete=models.SET_NULL, null=True
    )
    data_prescricao = models.DateTimeField(_("Data da Prescrição"), auto_now_add=True)

    class Meta:
        verbose_name = _("Histórico de Medicamento")
        verbose_name_plural = _("Histórico de Medicamentos")

    def __str__(self):
        return f"Medicamento: {self.medicamento} - Paciente: {self.prontuario.paciente.nome_completo}"


class EvolucaoClinica(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="evolucoes_clinicas"
    )
    data_evolucao = models.DateTimeField(_("Data da Evolução"), auto_now_add=True)
    profissional_responsavel = models.ForeignKey(
        "profissionais.Profissional", on_delete=models.SET_NULL, null=True
    )
    descricao = models.TextField(_("Descrição da Evolução"))

    class Meta:
        verbose_name = _("Evolução Clínica")
        verbose_name_plural = _("Evoluções Clínicas")

    def __str__(self):
        return f"Evolução em {self.data_evolucao} - Paciente: {self.prontuario.paciente.nome_completo}"


class DadosVitais(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="dados_vitais"
    )
    data_registro = models.DateTimeField(_("Data do Registro"), auto_now_add=True)
    pressao_arterial = models.CharField(
        _("Pressão Arterial"), max_length=50, blank=True
    )
    frequencia_cardiaca = models.CharField(
        _("Frequência Cardíaca"), max_length=50, blank=True
    )
    temperatura = models.DecimalField(
        _("Temperatura Corporal (°C)"),
        max_digits=4,
        decimal_places=1,
        blank=True,
        null=True,
    )
    saturacao_oxigenio = models.CharField(
        _("Saturação de Oxigênio (%)"), max_length=50, blank=True
    )
    peso = models.DecimalField(
        _("Peso (kg)"), max_digits=5, decimal_places=2, blank=True, null=True
    )
    altura = models.DecimalField(
        _("Altura (m)"), max_digits=4, decimal_places=2, blank=True, null=True
    )
    glicemia = models.DecimalField(
        _("Glicemia (mg/dL)"), max_digits=5, decimal_places=2, blank=True, null=True
    )
    colesterol_total = models.DecimalField(
        _("Colesterol Total (mg/dL)"),
        max_digits=5,
        decimal_places=2,
        blank=True,
        null=True,
    )
    triglicerides = models.DecimalField(
        _("Triglicérides (mg/dL)"),
        max_digits=5,
        decimal_places=2,
        blank=True,
        null=True,
    )

    class Meta:
        verbose_name = _("Dados Vitais")
        verbose_name_plural = _("Dados Vitais")

    def __str__(self):
        return f"Dados Vitais em {self.data_registro} - Paciente: {self.prontuario.paciente.nome_completo}"


class HistoricoAcessosProntuario(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="historico_acessos"
    )
    usuario = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True
    )
    data_acesso = models.DateTimeField(_("Data do Acesso"), auto_now_add=True)
    tipo_acesso = models.CharField(
        _("Tipo de Acesso"),
        max_length=50,
        choices=[("visualizacao", "Visualização"), ("alteracao", "Alteração")],
    )

    class Meta:
        verbose_name = _("Histórico de Acesso ao Prontuário")
        verbose_name_plural = _("Histórico de Acessos ao Prontuário")

    def __str__(self):
        return f"Acesso em {self.data_acesso} - Paciente: {self.prontuario.paciente.nome_completo} por {self.usuario}"


class ExameComplementar(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="exames_complementares"
    )
    tipo_exame = models.CharField(_("Tipo de Exame"), max_length=255)
    data_solicitacao = models.DateTimeField(_("Data da Solicitação"), auto_now_add=True)
    data_resultado = models.DateTimeField(_("Data do Resultado"), null=True, blank=True)
    resultado = models.TextField(_("Resultado do Exame"), blank=True)
    profissional_responsavel = models.ForeignKey(
        "profissionais.Profissional",
        on_delete=models.SET_NULL,
        null=True,
        related_name="exames_solicitados",
    )
    imagem_associada = models.ImageField(
        _("Imagem Associada"), upload_to="exames/imagens/", blank=True, null=True
    )

    class Meta:
        verbose_name = _("Exame Complementar")
        verbose_name_plural = _("Exames Complementares")

    def __str__(self):
        return f"Exame: {self.tipo_exame} - Paciente: {self.prontuario.paciente.nome_completo}"


class ProcedimentoRealizado(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="procedimentos_realizados"
    )
    tipo_procedimento = models.CharField(_("Tipo de Procedimento"), max_length=255)
    data_procedimento = models.DateTimeField(
        _("Data do Procedimento"), auto_now_add=True
    )
    profissional_responsavel = models.ForeignKey(
        "profissionais.Profissional",
        on_delete=models.SET_NULL,
        null=True,
        related_name="procedimentos_realizados",
    )
    observacoes = models.TextField(_("Observações"), blank=True)
    consentimento_associado = models.ForeignKey(
        "assinaturas.Assinatura",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="procedimentos_consentidos",
    )

    class Meta:
        verbose_name = _("Procedimento Realizado")
        verbose_name_plural = _("Procedimentos Realizados")

class Anamnese(models.Model):
    paciente = models.ForeignKey('pacientes.Paciente', on_delete=models.CASCADE, related_name='anamneses')
    profissional = models.ForeignKey('profissionais.Profissional', on_delete=models.CASCADE, related_name='anamneses')
    texto = models.TextField(verbose_name=_("Anamnese"))
    data_criacao = models.DateTimeField(auto_now_add=True, verbose_name=_("Criado em"))

    class Meta:
        verbose_name = _("Anamnese")
        verbose_name_plural = _("Anamneses")

    def __str__(self):
        return f"Anamnese de {self.paciente.nome_completo} - {self.data_criacao}"

### C:\ClinicaAI\backend\apps\prontuarios\serializers.py ###
# Módulo Prontuários - Serializers (serializers.py)

from rest_framework import serializers
from .models import (
    Prontuario,
    HistoricoMedicamentos,
    EvolucaoClinica,
    DadosVitais,
    HistoricoAcessosProntuario,
    ExameComplementar,
    Anamnese,
)


class ProntuarioSerializer(serializers.ModelSerializer):
    class Meta:
        model = Prontuario
        fields = "__all__"


class HistoricoMedicamentosSerializer(serializers.ModelSerializer):
    class Meta:
        model = HistoricoMedicamentos
        fields = "__all__"


class EvolucaoClinicaSerializer(serializers.ModelSerializer):
    class Meta:
        model = EvolucaoClinica
        fields = "__all__"


class DadosVitaisSerializer(serializers.ModelSerializer):
    class Meta:
        model = DadosVitais
        fields = "__all__"


class HistoricoAcessosProntuarioSerializer(serializers.ModelSerializer):
    class Meta:
        model = HistoricoAcessosProntuario
        fields = "__all__"


class ExameComplementarSerializer(serializers.ModelSerializer):
    class Meta:
        model = ExameComplementar
        fields = "__all__"


class AnamneseSerializer(serializers.ModelSerializer):
    class Meta:
        model = Anamnese
        fields = '__all__'

### C:\ClinicaAI\backend\apps\prontuarios\tests.py ###
from django.test import TestCase
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from django.contrib.auth.models import User, Group
from .models import (
    Prontuario,
    HistoricoMedicamentos,
    EvolucaoClinica,
    DadosVitais,
    HistoricoAcessosProntuario,
    ExameComplementar,
)


class ProntuarioAPITestCase(APITestCase):
    def setUp(self):
        # Criação de usuários e grupos para testar permissões
        self.admin_user = User.objects.create_superuser(
            "admin", "admin@example.com", "password123"
        )
        self.doctor_user = User.objects.create_user(
            "doctor", "doctor@example.com", "password123"
        )
        doctor_group, created = Group.objects.get_or_create(name="Doctor")
        self.doctor_user.groups.add(doctor_group)
        self.patient_user = User.objects.create_user(
            "patient", "patient@example.com", "password123"
        )

        # Criação de dados iniciais
        self.prontuario = Prontuario.objects.create(paciente_id=1)

    def test_create_prontuario_as_admin(self):
        self.client.force_authenticate(user=self.admin_user)
        data = {"paciente": 1, "queixa_principal": "Dor de cabeça persistente"}
        response = self.client.post(reverse("prontuarios-list"), data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

    def test_create_prontuario_as_patient(self):
        self.client.force_authenticate(user=self.patient_user)
        data = {"paciente": 1, "queixa_principal": "Dor de cabeça persistente"}
        response = self.client.post(reverse("prontuarios-list"), data)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_list_prontuarios_as_doctor(self):
        self.client.force_authenticate(user=self.doctor_user)
        response = self.client.get(reverse("prontuarios-list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)


class HistoricoMedicamentosAPITestCase(APITestCase):
    def setUp(self):
        self.admin_user = User.objects.create_superuser(
            "admin", "admin@example.com", "password123"
        )
        self.doctor_user = User.objects.create_user(
            "doctor", "doctor@example.com", "password123"
        )
        doctor_group, created = Group.objects.get_or_create(name="Doctor")
        self.doctor_user.groups.add(doctor_group)
        self.patient_user = User.objects.create_user(
            "patient", "patient@example.com", "password123"
        )

        # Criação de dados iniciais
        self.medicamento = HistoricoMedicamentos.objects.create(
            prontuario_id=1, medicamento="Paracetamol", dosagem="500mg"
        )

    def test_create_medicamento_as_doctor(self):
        self.client.force_authenticate(user=self.doctor_user)
        data = {"prontuario": 1, "medicamento": "Ibuprofeno", "dosagem": "400mg"}
        response = self.client.post(reverse("historico_medicamentos-list"), data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

    def test_update_medicamento_as_patient(self):
        self.client.force_authenticate(user=self.patient_user)
        data = {"medicamento": "Aspirina"}
        response = self.client.patch(
            reverse("historico_medicamentos-detail", args=[self.medicamento.id]), data
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)


class EvolucaoClinicaAPITestCase(APITestCase):
    def setUp(self):
        self.admin_user = User.objects.create_superuser(
            "admin", "admin@example.com", "password123"
        )
        self.doctor_user = User.objects.create_user(
            "doctor", "doctor@example.com", "password123"
        )
        doctor_group, created = Group.objects.get_or_create(name="Doctor")
        self.doctor_user.groups.add(doctor_group)

        # Criação de dados iniciais
        self.evolucao = EvolucaoClinica.objects.create(
            prontuario_id=1, descricao="Paciente com sintomas de gripe"
        )

    def test_update_evolucao_as_doctor(self):
        self.client.force_authenticate(user=self.doctor_user)
        data = {"descricao": "Paciente com febre alta e tosse"}
        response = self.client.patch(
            reverse("evolucoes_clinicas-detail", args=[self.evolucao.id]), data
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_update_evolucao_as_patient(self):
        self.client.force_authenticate(user=self.patient_user)
        data = {"descricao": "Tentativa de atualização não permitida"}
        response = self.client.patch(
            reverse("evolucoes_clinicas-detail", args=[self.evolucao.id]), data
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)


class DadosVitaisAPITestCase(APITestCase):
    def setUp(self):
        self.doctor_user = User.objects.create_user(
            "doctor", "doctor@example.com", "password123"
        )
        doctor_group, created = Group.objects.get_or_create(name="Doctor")
        self.doctor_user.groups.add(doctor_group)

        # Criação de dados iniciais
        self.dados_vitais = DadosVitais.objects.create(
            prontuario_id=1, pressao_arterial="120/80"
        )

    def test_create_dados_vitais_as_doctor(self):
        self.client.force_authenticate(user=self.doctor_user)
        data = {
            "prontuario": 1,
            "pressao_arterial": "130/85",
            "frequencia_cardiaca": "75",
        }
        response = self.client.post(reverse("dados_vitais-list"), data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

    def test_create_dados_vitais_as_unauthorized_user(self):
        unauthorized_user = User.objects.create_user(
            "unauthorized", "unauthorized@example.com", "password123"
        )
        self.client.force_authenticate(user=unauthorized_user)
        data = {"prontuario": 1, "pressao_arterial": "130/85"}
        response = self.client.post(reverse("dados_vitais-list"), data)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)


### C:\ClinicaAI\backend\apps\prontuarios\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'prontuarios', views.ProntuarioViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

### C:\ClinicaAI\backend\apps\prontuarios\views.py ###
# Módulo Prontuários - Views (views.py)

from . import views
# Módulo Prontuários - Views (views.py)

from rest_framework.routers import DefaultRouter
from django.urls import path, include
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.views import APIView

from .models import (
    Prontuario,
    HistoricoMedicamentos,
    EvolucaoClinica,
    DadosVitais,
    HistoricoAcessosProntuario,
    ExameComplementar,
    Anamnese,
)
from .serializers import (
    ProntuarioSerializer,
    HistoricoMedicamentosSerializer,
    EvolucaoClinicaSerializer,
    DadosVitaisSerializer,
    HistoricoAcessosProntuarioSerializer,
    ExameComplementarSerializer,
    AnamneseSerializer,
)
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from rest_framework.decorators import action
from rest_framework.permissions import BasePermission, SAFE_METHODS

# Custom permission to restrict read/write access based on user roles

class AnamneseViewSet(viewsets.ModelViewSet):
    queryset = Anamnese.objects.all()
    serializer_class = AnamneseSerializer

    @action(detail=True, methods=['post'])
    def sugerir_cid(self, request, pk=None):
        anamnese = self.get_object()
        texto = anamnese.texto

        # Simular integração com IA (NLP para análise)
        sugestoes = [
            {"codigo": "J18.0", "descricao": "Pneumonia", "relevancia": 0.85},
            {"codigo": "J20.9", "descricao": "Bronquite aguda", "relevancia": 0.75},
        ]
        return Response({"anamnese": texto, "sugestoes_cid": sugestoes}, status=status.HTTP_200_OK)
class IsAdminOrReadOnly(BasePermission):
    def has_permission(self, request, view):
        if request.method in SAFE_METHODS:
            return True
        return request.user and request.user.is_staff


class IsDoctorOrReadOnly(BasePermission):
    def has_permission(self, request, view):
        if request.method in SAFE_METHODS:
            return True
        return (
            request.user
            and request.user.groups.filter(name="Doctor").exists()
            or request.user.is_staff
        )


# Views


class ProntuarioViewSet(viewsets.ModelViewSet):
    queryset = Prontuario.objects.all()
    serializer_class = ProntuarioSerializer
    permission_classes = [IsAuthenticated]  # Exigir autenticação

    def create(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de criar
        data = request.data.copy()
        sensitive_fields = ["created_by", "updated_by", "uuid"]
        for field in sensitive_fields:
            data.pop(field, None)
        serializer = self.get_serializer(data=data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(
            serializer.data, status=status.HTTP_201_CREATED, headers=headers
        )

    def update(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de atualizar
        data = request.data.copy()
        sensitive_fields = ["created_by", "updated_by", "uuid"]
        for field in sensitive_fields:
            data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


class ProntuarioList(APIView):
    def get(self, request):
        prontuarios = Prontuario.objects.all()
        serializer = ProntuarioSerializer(prontuarios, many=True)
        return Response(serializer.data)


class HistoricoMedicamentosViewSet(viewsets.ModelViewSet):
    queryset = HistoricoMedicamentos.objects.all()
    serializer_class = HistoricoMedicamentosSerializer
    permission_classes = [IsAuthenticated, IsAdminOrReadOnly]

    def create(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de criar
        data = request.data.copy()
        sensitive_fields = ["prescrito_por"]
        for field in sensitive_fields:
            if not request.user.is_staff:
                data.pop(field, None)
        serializer = self.get_serializer(data=data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(
            serializer.data, status=status.HTTP_201_CREATED, headers=headers
        )

    def update(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de atualizar
        data = request.data.copy()
        sensitive_fields = ["prescrito_por"]
        for field in sensitive_fields:
            if not request.user.is_staff:
                data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


class EvolucaoClinicaViewSet(viewsets.ModelViewSet):
    queryset = EvolucaoClinica.objects.all()
    serializer_class = EvolucaoClinicaSerializer
    permission_classes = [IsAuthenticated, IsDoctorOrReadOnly]

    def update(self, request, *args, **kwargs):
        # Limitar campos que podem ser editados por diferentes tipos de
        # usuários
        data = request.data.copy()
        restricted_fields = ["data_evolucao", "profissional_responsavel"]
        if not request.user.is_staff:
            for field in restricted_fields:
                data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


class DadosVitaisViewSet(viewsets.ModelViewSet):
    queryset = DadosVitais.objects.all()
    serializer_class = DadosVitaisSerializer
    permission_classes = [IsAuthenticated, IsDoctorOrReadOnly]

    def create(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de criar
        data = request.data.copy()
        sensitive_fields = [
            "pressao_arterial",
            "frequencia_cardiaca",
            "temperatura",
            "saturacao_oxigenio",
            "glicemia",
            "colesterol_total",
            "triglicerides",
        ]
        if (
            not request.user.groups.filter(name="Doctor").exists()
            and not request.user.is_staff
        ):
            for field in sensitive_fields:
                data.pop(field, None)
        serializer = self.get_serializer(data=data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(
            serializer.data, status=status.HTTP_201_CREATED, headers=headers
        )

    def update(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de atualizar
        data = request.data.copy()
        sensitive_fields = [
            "pressao_arterial",
            "frequencia_cardiaca",
            "temperatura",
            "saturacao_oxigenio",
            "glicemia",
            "colesterol_total",
            "triglicerides",
        ]
        if (
            not request.user.groups.filter(name="Doctor").exists()
            and not request.user.is_staff
        ):
            for field in sensitive_fields:
                data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


class HistoricoAcessosProntuarioViewSet(viewsets.ModelViewSet):
    queryset = HistoricoAcessosProntuario.objects.all()
    serializer_class = HistoricoAcessosProntuarioSerializer
    permission_classes = [IsAuthenticated]

    def list(self, request, *args, **kwargs):
        # Restringir campos sensíveis durante a listagem
        if not request.user.is_staff:
            queryset = self.filter_queryset(self.get_queryset()).defer(
                "usuario", "tipo_acesso"
            )
        else:
            queryset = self.filter_queryset(self.get_queryset())
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)


class ExameComplementarViewSet(viewsets.ModelViewSet):
    queryset = ExameComplementar.objects.all()
    serializer_class = ExameComplementarSerializer
    permission_classes = [IsAuthenticated, IsDoctorOrReadOnly]

    def create(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de criar
        data = request.data.copy()
        sensitive_fields = ["resultado", "imagem_associada"]
        if (
            not request.user.groups.filter(name="Doctor").exists()
            and not request.user.is_staff
        ):
            for field in sensitive_fields:
                data.pop(field, None)
        serializer = self.get_serializer(data=data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(
            serializer.data, status=status.HTTP_201_CREATED, headers=headers
        )

    def update(self, request, *args, **kwargs):
        # Filtra campos sensíveis antes de atualizar
        data = request.data.copy()
        sensitive_fields = ["resultado", "imagem_associada"]
        if (
            not request.user.groups.filter(name="Doctor").exists()
            and not request.user.is_staff
        ):
            for field in sensitive_fields:
                data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


# URL Routing (urls.py)

router = DefaultRouter()
router.register(r"prontuarios", views.ProntuarioViewSet)
router.register(r"historico_medicamentos", views.HistoricoMedicamentosViewSet)
router.register(r"evolucoes_clinicas", views.EvolucaoClinicaViewSet)
router.register(r"dados_vitais", views.DadosVitaisViewSet)
router.register(r"historico_acessos", views.HistoricoAcessosProntuarioViewSet)
router.register(r"exames_complementares", views.ExameComplementarViewSet)
router.register(r'anamneses', AnamneseViewSet, basename='anamnese')

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\prontuarios\__init__.py ###


### C:\ClinicaAI\backend\apps\qualidade\admin.py ###
from django.contrib import admin
from .models import QualidadeModel


@admin.register(QualidadeModel)
class QualidadeAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\qualidade\apps.py ###
from django.apps import AppConfig


class QualidadeConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.qualidade"


### C:\ClinicaAI\backend\apps\qualidade\models.py ###
from django.db import models


class QualidadeModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\qualidade\serializers.py ###
from rest_framework import serializers
from .models import QualidadeModel


class QualidadeSerializer(serializers.ModelSerializer):
    class Meta:
        model = QualidadeModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\qualidade\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\qualidade\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import QualidadeViewSet

router = DefaultRouter()
router.register(r"qualidade", QualidadeViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\qualidade\views.py ###
from rest_framework import viewsets
from .models import QualidadeModel
from .serializers import QualidadeSerializer


class QualidadeViewSet(viewsets.ModelViewSet):
    queryset = QualidadeModel.objects.all()
    serializer_class = QualidadeSerializer


### C:\ClinicaAI\backend\apps\qualidade\__init__.py ###


### C:\ClinicaAI\backend\apps\recrutamento\admin.py ###
from django.contrib import admin
from .models import RecrutamentoModel


@admin.register(RecrutamentoModel)
class RecrutamentoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\recrutamento\apps.py ###
from django.apps import AppConfig


class RecrutamentoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.recrutamento"


### C:\ClinicaAI\backend\apps\recrutamento\models.py ###
from django.db import models


class RecrutamentoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\recrutamento\serializers.py ###
from rest_framework import serializers
from .models import RecrutamentoModel


class RecrutamentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = RecrutamentoModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\recrutamento\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\recrutamento\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import RecrutamentoViewSet

router = DefaultRouter()
router.register(r"recrutamento", RecrutamentoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\recrutamento\views.py ###
from rest_framework import viewsets
from .models import RecrutamentoModel
from .serializers import RecrutamentoSerializer


class RecrutamentoViewSet(viewsets.ModelViewSet):
    queryset = RecrutamentoModel.objects.all()
    serializer_class = RecrutamentoSerializer


### C:\ClinicaAI\backend\apps\recrutamento\__init__.py ###


### C:\ClinicaAI\backend\apps\recursos_humanos\admin.py ###
from django.contrib import admin
from .models import Recursos_humanosModel


@admin.register(Recursos_humanosModel)
class Recursos_humanosAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\recursos_humanos\apps.py ###
from django.apps import AppConfig


class Recursos_humanosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.recursos_humanos"


### C:\ClinicaAI\backend\apps\recursos_humanos\models.py ###
from django.db import models


class Recursos_humanosModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\recursos_humanos\serializers.py ###
from rest_framework import serializers
from .models import Recursos_humanosModel


class Recursos_humanosSerializer(serializers.ModelSerializer):
    class Meta:
        model = Recursos_humanosModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\recursos_humanos\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\recursos_humanos\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Recursos_humanosViewSet

router = DefaultRouter()
router.register(r"recursos_humanos", Recursos_humanosViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\recursos_humanos\views.py ###
from rest_framework import viewsets
from .models import Recursos_humanosModel
from .serializers import Recursos_humanosSerializer


class Recursos_humanosViewSet(viewsets.ModelViewSet):
    queryset = Recursos_humanosModel.objects.all()
    serializer_class = Recursos_humanosSerializer


### C:\ClinicaAI\backend\apps\recursos_humanos\__init__.py ###


### C:\ClinicaAI\backend\apps\redes_sociais\admin.py ###
from django.contrib import admin
from .models import Redes_sociaisModel


@admin.register(Redes_sociaisModel)
class Redes_sociaisAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\redes_sociais\apps.py ###
from django.apps import AppConfig


class Redes_sociaisConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.redes_sociais"


### C:\ClinicaAI\backend\apps\redes_sociais\models.py ###
from django.db import models


class Redes_sociaisModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\redes_sociais\serializers.py ###
from rest_framework import serializers
from .models import Redes_sociaisModel


class Redes_sociaisSerializer(serializers.ModelSerializer):
    class Meta:
        model = Redes_sociaisModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\redes_sociais\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\redes_sociais\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Redes_sociaisViewSet

router = DefaultRouter()
router.register(r"redes_sociais", Redes_sociaisViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\redes_sociais\views.py ###
from rest_framework import viewsets
from .models import Redes_sociaisModel
from .serializers import Redes_sociaisSerializer


class Redes_sociaisViewSet(viewsets.ModelViewSet):
    queryset = Redes_sociaisModel.objects.all()
    serializer_class = Redes_sociaisSerializer


### C:\ClinicaAI\backend\apps\redes_sociais\__init__.py ###


### C:\ClinicaAI\backend\apps\servico_campo\admin.py ###
from django.contrib import admin
from .models import Servico_campoModel


@admin.register(Servico_campoModel)
class Servico_campoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\servico_campo\apps.py ###
from django.apps import AppConfig


class Servico_campoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.servico_campo"


### C:\ClinicaAI\backend\apps\servico_campo\models.py ###
from django.db import models


class Servico_campoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\servico_campo\serializers.py ###
from rest_framework import serializers
from .models import Servico_campoModel


class Servico_campoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Servico_campoModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\servico_campo\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\servico_campo\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Servico_campoViewSet

router = DefaultRouter()
router.register(r"servico_campo", Servico_campoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\servico_campo\views.py ###
from rest_framework import viewsets
from .models import Servico_campoModel
from .serializers import Servico_campoSerializer


class Servico_campoViewSet(viewsets.ModelViewSet):
    queryset = Servico_campoModel.objects.all()
    serializer_class = Servico_campoSerializer


### C:\ClinicaAI\backend\apps\servico_campo\__init__.py ###


### C:\ClinicaAI\backend\apps\vendas\admin.py ###
from django.contrib import admin
from .models import VendasModel


@admin.register(VendasModel)
class VendasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")


### C:\ClinicaAI\backend\apps\vendas\apps.py ###
from django.apps import AppConfig


class VendasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.vendas"


### C:\ClinicaAI\backend\apps\vendas\models.py ###
from django.db import models


class VendasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome


### C:\ClinicaAI\backend\apps\vendas\serializers.py ###
from rest_framework import serializers
from .models import VendasModel


class VendasSerializer(serializers.ModelSerializer):
    class Meta:
        model = VendasModel
        fields = "__all__"


### C:\ClinicaAI\backend\apps\vendas\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\vendas\urls.py ###
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import VendasViewSet

router = DefaultRouter()
router.register(r"vendas", VendasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]


### C:\ClinicaAI\backend\apps\vendas\views.py ###
from rest_framework import viewsets
from .models import VendasModel
from .serializers import VendasSerializer


class VendasViewSet(viewsets.ModelViewSet):
    queryset = VendasModel.objects.all()
    serializer_class = VendasSerializer


### C:\ClinicaAI\backend\apps\vendas\__init__.py ###


### C:\ClinicaAI\backend\apps\voip\admin.py ###
from django.contrib import admin

# Register your models here.


### C:\ClinicaAI\backend\apps\voip\apps.py ###
from django.apps import AppConfig


class VoipConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.voip"


### C:\ClinicaAI\backend\apps\voip\models.py ###
from django.db import models

# Create your models here.


### C:\ClinicaAI\backend\apps\voip\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\voip\views.py ###
from django.shortcuts import render

# Create your views here.


### C:\ClinicaAI\backend\apps\voip\__init__.py ###


### C:\ClinicaAI\backend\apps\whatsapp\admin.py ###
from django.contrib import admin

# Register your models here.


### C:\ClinicaAI\backend\apps\whatsapp\apps.py ###
from django.apps import AppConfig


class WhatsappConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.whatsapp"


### C:\ClinicaAI\backend\apps\whatsapp\models.py ###
from django.db import models

# Create your models here.


### C:\ClinicaAI\backend\apps\whatsapp\tests.py ###
from django.test import TestCase

# Create your tests here.


### C:\ClinicaAI\backend\apps\whatsapp\views.py ###
from django.shortcuts import render

# Create your views here.


### C:\ClinicaAI\backend\apps\whatsapp\__init__.py ###


### C:\ClinicaAI\backend\ClinicaAI\asgi.py ###
"""
ASGI config for ClinicaAI project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'ClinicaAI.settings')

application = get_asgi_application()


### C:\ClinicaAI\backend\ClinicaAI\settings.py ###
"""
Django settings for ClinicaAI project.

Generated by 'django-admin startproject' using Django 4.2.16.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""

from pathlib import Path
from cryptography.fernet import Fernet
from datetime import timedelta

# Gere uma chave de criptografia
ENCRYPTION_KEY = 'IpmmvITSPLun5m6lOtUPHszQ7yTKRlmAHQ9JC47XMKg='

def decrypt(encrypted_text):
    # Adicione padding se necessário
    padding = len(encrypted_text) % 4
    if padding != 0:
        encrypted_text += '=' * (4 - padding)
    try:
        cipher_suite = Fernet(ENCRYPTION_KEY)
        decrypted_text = cipher_suite.decrypt(encrypted_text.encode()).decode()
        return decrypted_text
    except Exception as e:
        raise ValueError(f"Erro ao descriptografar o texto: {e}")

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = decrypt('gAAAAABncfHWNo6zmHaKhNfNchedvGqjsJbCVDVWMZRmWKTKCAjCesVQrZOuImCOiZG33ls__sm-o74_5w4_DPPaeOtdWfIhAA==')  # Substituido
# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'prometheus_client',
    'drf_yasg',
    'channels',
    'corsheaders',
    'rest_framework',
    'rest_framework_simplejwt',
    'apps.whatsapp',
    'apps.conhecimento',
    'apps.voip',
    'apps.iot',
    'apps.aprovacoes',
    'apps.mensagens',
    'apps.produtividade',
    'apps.compromissos',
    'apps.central_ajuda',
    'apps.servico_campo',
    'apps.planilhas_horas',
    'apps.projeto',
    'apps.pesquisas',
    'apps.automacao_marketing',
    'apps.eventos',
    'apps.marketing_sms',
    'apps.marketing_email',
    'apps.redes_sociais',
    'apps.frota',
    'apps.indicacoes',
    'apps.avaliacoes',
    'apps.folgas',
    'apps.recrutamento',
    'apps.recursos_humanos',
    'apps.qualidade',
    'apps.manutencao',
    'apps.compras',
    'apps.prontuarios',
    'apps.plm',
    'apps.fabricacao',
    'apps.inventario',
    'apps.elearning',
    'apps.chat_ao_vivo',
    'apps.forum',
    'apps.blog',
    'apps.ecommerce',
    'apps.criador_sites',
    'apps.locacao',
    'apps.assinaturas',
    'apps.crm',
    'apps.vendas',
    'apps.assinar_documentos',
    'apps.documentos',
    'apps.planilhas',
    'apps.despesas',
    'apps.faturamento',
    'apps.financeiro',
    'apps.agendamentos',
    'apps.pacientes',
    'apps.profissionais',
    'apps.authentication',
    'rest_framework_simplejwt.token_blacklist',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'ClinicaAI.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'ClinicaAI.wsgi.application'


# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'clinicaai',
        'USER': 'postgres',
        'PASSWORD': decrypt('gAAAAABncfHWNo6zmHaKhNfNchedvGqjsJbCVDVWMZRmWKTKCAjCesVQrZOuImCOiZG33ls__sm-o74_5w4_DPPaeOtdWfIhAA=='),  # Substitua pelo texto criptografado gerado para a senha do banco de dados
        'HOST': 'localhost',
        'PORT': '5432'
    },

}


# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Configurações de CORS
CORS_ALLOW_ALL_ORIGINS = True

# Ou permitir origens específicas
# CORS_ALLOWED_ORIGINS = [
#     'http://localhost:3000',
# ]

# Configurações do Django REST Framework
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',  # Exigir autenticação por padrão
    ),
}

# Configurações do Simple JWT
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=3),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'VERIFYING_KEY': None,
    'AUTH_HEADER_TYPES': ('Bearer',),
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'TOKEN_TYPE_CLAIM': 'token_type',
     'TOKEN_BLACKLIST_ENABLED': True, 
}

ASGI_APPLICATION = 'ClinicaAI.asgi.application'
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            'hosts': [('127.0.0.1', 6379)],
        },
    },
}
CELERY_BROKER_URL = 'redis://localhost:6379/0'
CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'file': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',
            'filename': BASE_DIR / 'debug.log',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file'],
            'level': 'DEBUG',
            'propagate': True,
        },
    },
}


### C:\ClinicaAI\backend\ClinicaAI\urls.py ###
"""
URL configuration for ClinicaAI project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/4.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
    TokenVerifyView,
)
from rest_framework import routers
from django.utils.log import DEFAULT_LOGGING
import logging

logger = logging.getLogger(__name__)

router = routers.DefaultRouter()

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/auth/', include('apps.authentication.urls')),  
    path('api/prontuarios/', include('apps.prontuarios.urls')),
    path('api/profissionais/', include('apps.profissionais.urls')),
    path('api/', include('apps.pacientes.urls')),
    path('api/', include(router.urls)),
    path('api/dashboard/', include('apps.dashboard.urls')),

]



### C:\ClinicaAI\backend\ClinicaAI\wsgi.py ###
"""
WSGI config for ClinicaAI project.

It exposes the WSI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'ClinicaAI.settings')

application = get_wsgi_application()


### C:\ClinicaAI\backend\ClinicaAI\__init__.py ###


### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\c.sh ###
#!/bin/bash

# Variáveis de configuração
DB_USER="diego"
DB_PASSWORD="Mouse2250@#86"
PROJETO_DIR="/mnt/dados/ClinicaAI"

# Verificar se Docker está instalado e iniciar Docker Compose
if ! command -v docker &> /dev/null; then
  echo "Docker não está instalado corretamente. Verifique a instalação do Docker antes de continuar."
  exit 1
fi
if ! command -v docker-compose &> /dev/null; then
  echo "Docker Compose não está instalado corretamente. Verifique a instalação do Docker Compose antes de continuar."
  exit 1
fi

# Voltar ao diretório do projeto
cd $PROJETO_DIR/docker || { echo "Erro ao acessar o diretório docker."; exit 1; }

# Criar docker-compose.yml
cat <<EOF > docker-compose.yml
version: '3.1'
services:
  db:
    image: postgres:13
    restart: always
    environment:
      POSTGRES_USER: $DB_USER
      POSTGRES_PASSWORD: $DB_PASSWORD
      POSTGRES_DB: clinicaai
    ports:
      - "5432:5432"
  redis:
    image: redis:6
    restart: always
    ports:
      - "6379:6379"
  web:
    image: python:3.9
    working_dir: /code
    volumes:
      - ../backend:/code
    command: bash -c "pip install -r requirements.txt && daphne -b 0.0.0.0 -p 8000 ClinicaAI.asgi:application"
    ports:
      - "8000:8000"
    depends_on:
      - db
      - redis
  worker:
    image: python:3.9
    working_dir: /code
    volumes:
      - ../backend:/code
    command: bash -c "pip install -r requirements.txt && celery -A ClinicaAI worker --loglevel=info"
    depends_on:
      - db
      - redis
  frontend:
    image: node:14
    working_dir: /app
    volumes:
      - ../frontend/clinicaai-frontend:/app
    command: npm start
    ports:
      - "3000:3000"
    depends_on:
      - web
EOF

# Inicializar Docker com timeout de 5 minutos
if ! timeout 300 docker-compose up -d; then
  echo "Erro ao inicializar os serviços Docker ou tempo limite excedido. Verifique o Docker Compose."
  exit 1
fi

# Verificar se os serviços estão sendo construídos corretamente
docker-compose logs -f &

# Aguardar os serviços estarem prontos
sleep 30

# Configurar Kubernetes para o projeto
cd $PROJETO_DIR/kubernetes || { echo "Erro ao acessar o diretório Kubernetes."; exit 1; }
cat <<EOF > clinicaai-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: clinicaai-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: clinicaai
  template:
    metadata:
      labels:
        app: clinicaai
    spec:
      containers:
      - name: clinicaai-web
        image: python:3.9
        ports:
        - containerPort: 8000
      - name: redis
        image: redis:6
        ports:
        - containerPort: 6379
      - name: postgres
        image: postgres:13
        env:
        - name: POSTGRES_USER
          value: "$DB_USER"
        - name: POSTGRES_PASSWORD
          value: "$DB_PASSWORD"
        - name: POSTGRES_DB
          value: "clinicaai"
EOF

# Aplicar configuração Kubernetes (necessita kubectl e acesso configurado ao cluster)
if ! kubectl apply -f clinicaai-deployment.yaml; then
  echo "Erro ao aplicar as configurações no Kubernetes. Verifique se o kubectl está configurado corretamente."
  exit 1
fi

# Configuração do Prometheus e Grafana
cd $PROJETO_DIR/monitoring || { echo "Erro ao acessar o diretório monitoring."; exit 1; }
cat <<EOF > prometheus.yml
scrape_configs:
  - job_name: 'django'
    static_configs:
      - targets: ['localhost:8000']
EOF

cat <<EOF > grafana-datasource.yml
apiVersion: 1
datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://localhost:9090
EOF

# Executar Prometheus e Grafana via Docker
if ! docker run -d -p 9090:9090 -v $PROJETO_DIR/monitoring/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus; then
  echo "Erro ao iniciar o Prometheus."
  exit 1
fi
if ! docker run -d -p 3000:3000 grafana/grafana; then
  echo "Erro ao iniciar o Grafana."
  exit 1
fi

# Mensagem de conclusão
echo "Configuração concluída. Todos os serviços devem estar em execução. Verifique o painel do Kubernetes e o Docker para confirmar."


### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\ClinicaAI.code-workspace ###
{
	"folders": [
		{
			"path": ".."
		}
	],
	"settings": {}
}

### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\codigo_fonte_apps_selecionados.txt ###
### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\corrigir_apps.py ###
import os

BASE_DIR = "/mnt/dados/ClinicaAI/backend/apps"  # Caminho base para seus apps

# Lista de todos os aplicativos que criamos
apps = [
    'whatsapp', 'conhecimento', 'voip', 'iot', 'aprovacoes', 'mensagens', 'produtividade', 
    'compromissos', 'central_ajuda', 'servico_campo', 'planilhas_horas', 'projeto', 'pesquisas',
    'automacao_marketing', 'eventos', 'marketing_sms', 'marketing_email', 'redes_sociais', 
    'frota', 'indicacoes', 'avaliacoes', 'folgas', 'recrutamento', 'recursos_humanos', 'qualidade',
    'manutencao', 'compras', 'plm', 'fabricacao', 'inventario', 'elearning', 'chat_ao_vivo',
    'forum', 'blog', 'ecommerce', 'criador_sites', 'locacao', 'assinaturas', 'crm', 'vendas',
    'assinar_documentos', 'documentos', 'planilhas', 'despesas', 'faturamento', 'financeiro',
    'agendamentos', 'pacientes'
]

# Corrigir o arquivo apps.py de cada módulo
for app in apps:
    app_dir = os.path.join(BASE_DIR, app)
    apps_file_path = os.path.join(app_dir, 'apps.py')

    # Verificar se o arquivo apps.py existe
    if os.path.exists(apps_file_path):
        # Reescrever o arquivo apps.py com o valor correto para name
        with open(apps_file_path, 'w') as f:
            f.write(f"from django.apps import AppConfig\n\n"
                    f"class {app.capitalize()}Config(AppConfig):\n"
                    f"    default_auto_field = 'django.db.models.BigAutoField'\n"
                    f"    name = 'apps.{app}'\n")

print("Correção dos arquivos apps.py concluída com sucesso.")


### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\criar_apps.py ###
import os

BASE_DIR = "/mnt/dados/ClinicaAI/backend/apps"  # Caminho base para seus apps
apps = [
    'whatsapp', 'conhecimento', 'voip', 'iot', 'aprovacoes', 'mensagens', 'produtividade', 
    'compromissos', 'central_ajuda', 'servico_campo', 'planilhas_horas', 'projeto', 'pesquisas',
    'automacao_marketing', 'eventos', 'marketing_sms', 'marketing_email', 'redes_sociais', 
    'frota', 'indicacoes', 'avaliacoes', 'folgas', 'recrutamento', 'recursos_humanos', 'qualidade',
    'manutencao', 'compras', 'plm', 'fabricacao', 'inventario', 'elearning', 'chat_ao_vivo',
    'forum', 'blog', 'ecommerce', 'criador_sites', 'locacao', 'assinaturas', 'crm', 'vendas',
    'assinar_documentos', 'documentos', 'planilhas', 'despesas', 'faturamento', 'financeiro',
    'agendamentos', 'pacientes'
]

for app in apps:
    app_dir = os.path.join(BASE_DIR, app)
    if not os.path.exists(app_dir):
        os.makedirs(app_dir)
        # Criando arquivos básicos em cada app
        with open(os.path.join(app_dir, 'models.py'), 'w') as f:
            f.write(f"from django.db import models\n\n"
                    f"class {app.capitalize()}(models.Model):\n"
                    f"    nome = models.CharField(max_length=100)\n\n"
                    f"    def __str__(self):\n"
                    f"        return self.nome\n")

        with open(os.path.join(app_dir, 'views.py'), 'w') as f:
            f.write(f"from rest_framework import viewsets\n"
                    f"from .models import {app.capitalize()}\n"
                    f"from .serializers import {app.capitalize()}Serializer\n\n"
                    f"class {app.capitalize()}ViewSet(viewsets.ModelViewSet):\n"
                    f"    queryset = {app.capitalize()}.objects.all()\n"
                    f"    serializer_class = {app.capitalize()}Serializer\n")

        with open(os.path.join(app_dir, 'serializers.py'), 'w') as f:
            f.write(f"from rest_framework import serializers\n"
                    f"from .models import {app.capitalize()}\n\n"
                    f"class {app.capitalize()}Serializer(serializers.ModelSerializer):\n"
                    f"    class Meta:\n"
                    f"        model = {app.capitalize()}\n"
                    f"        fields = '__all__'\n")

        with open(os.path.join(app_dir, 'admin.py'), 'w') as f:
            f.write(f"from django.contrib import admin\n"
                    f"from .models import {app.capitalize()}\n\n"
                    f"admin.site.register({app.capitalize()})\n")

        with open(os.path.join(app_dir, 'apps.py'), 'w') as f:
            f.write(f"from django.apps import AppConfig\n\n"
                    f"class {app.capitalize()}Config(AppConfig):\n"
                    f"    default_auto_field = 'django.db.models.BigAutoField'\n"
                    f"    name = 'apps.{app}'\n")

print("Estrutura básica dos módulos criada com sucesso.")


### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\encrypt_password.py ###
from cryptography.fernet import Fernet

ENCRYPTION_KEY = 'IpmmvITSPLun5m6lOtUPHszQ7yTKRlmAHQ9JC47XMKg='
cipher_suite = Fernet(ENCRYPTION_KEY)

# Substitua pelos valores reais
db_password = 'Mouse2250@#86'

encrypted_db_password = cipher_suite.encrypt(db_password.encode()).decode()

print(f'Encrypted DB_PASSWORD: {encrypted_db_password}')

### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\fix_migrations.sh ###
#!/bin/bash

# Ativando o ambiente virtual
source .venv/Scripts/activate

# Conectando ao banco de dados para limpar o histórico de migrações
echo "Limpando histórico de migrações no banco de dados..."
psql -U postgres -d clinicaai -h localhost -p 5432 <<EOF
DELETE FROM django_migrations WHERE app='prontuarios';
DELETE FROM django_migrations WHERE app='assinaturas';
DELETE FROM django_migrations WHERE app='pacientes';
DROP TABLE IF EXISTS prontuarios_prontuario;
DROP TABLE IF EXISTS assinaturas_assinatura;
DROP TABLE IF EXISTS pacientes_paciente;
EOF

# Recriando as migrações
echo "Recriando as migrações..."
python manage.py makemigrations assinaturas
python manage.py makemigrations prontuarios
python manage.py makemigrations pacientes

# Aplicando as migrações
echo "Aplicando as migrações..."
python manage.py migrate

# Iniciando o servidor para verificar se está tudo funcionando
echo "Iniciando o servidor..."
python manage.py runserver


### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\inicial.sh ###
#!/bin/bash

# Variáveis de configuração
PROJETO_DIR="/mnt/dados/ClinicaAI"
REPO_GIT="https://github.com/deutschcaicara/ClinicaAI"
DB_USER="diego"
DB_PASSWORD="Mouse2250@#86"

# Atualizando e instalando dependências essenciais
sudo apt update && sudo apt upgrade -y
# Corrigir pacotes quebrados, se houver
sudo apt --fix-broken install -y
if ! sudo apt install -y python3-pip python3-venv postgresql postgresql-contrib git git-lfs docker.io docker-compose nodejs npm curl build-essential libssl-dev libffi-dev python3-dev redis-tools prometheus containerd; then
  echo "Erro ao instalar dependências essenciais. Verifique a conexão e tente novamente."
  exit 1
fi

# Instalar pacotes via Snap
if ! command -v helm &> /dev/null; then
  sudo snap install helm --classic
fi
if ! command -v kubectl &> /dev/null; then
  sudo snap install kubectl --classic
fi
if ! command -v grafana &> /dev/null; then
  sudo snap install grafana
fi

# Verificar se Git LFS está instalado e configurado
if ! git lfs install; then
  echo "Erro ao instalar o Git LFS. Verifique o processo e tente novamente."
  exit 1
fi

# Criar pasta do projeto
mkdir -p $PROJETO_DIR
cd $PROJETO_DIR || { echo "Erro ao acessar o diretório do projeto."; exit 1; }

# Clonar repositório Git e iniciar do zero
if [ -d ".git" ]; then
  git checkout main
  git pull origin main
  git tag -a "backup-$(date +%Y%m%d-%H%M%S)" -m "Backup antes do reinício"
  git push origin --tags
  rm -rf *
fi

git init
git remote add origin $REPO_GIT
touch README.md

# Criar estrutura de pastas do projeto
mkdir -p backend frontend database docker docs tests logs config kubernetes services bi ml monitoring

# Configurar ambiente virtual do Django
cd backend || { echo "Erro ao acessar o diretório backend."; exit 1; }
if [ ! -d "venv" ]; then
  python3 -m venv venv
fi
source venv/bin/activate
pip install --upgrade pip
if ! pip install django djangorestframework psycopg2-binary django-cors-headers django-allauth django-environ channels celery django-rest-swagger djangorestframework-simplejwt drf-yasg scikit-learn pandas numpy matplotlib prometheus_client elastic-apm[django]; then
  echo "Erro ao instalar dependências Python."
  exit 1
fi

# Iniciar projeto Django, se não existir
if [ ! -f "manage.py" ]; then
  django-admin startproject ClinicaAI .
fi

# Criar pastas e módulos adicionais
mkdir -p apps
cd apps || { echo "Erro ao acessar o diretório apps."; exit 1; }
for app in pacientes agendamentos financeiro faturamento despesas planilhas documentos assinar_documentos vendas crm assinaturas locacao criador_sites ecommerce blog forum chat_ao_vivo elearning inventario fabricacao plm compras manutencao qualidade recursos_humanos recrutamento folgas avaliacoes indicacoes frota redes_sociais marketing_email marketing_sms eventos automacao_marketing pesquisas projeto planilhas_horas servico_campo central_ajuda compromissos produtividade mensagens aprovacoes iot voip conhecimento whatsapp; do
  if [ ! -d "$app" ]; then
    django-admin startapp $app
  fi
  # Adicionar módulo ao INSTALLED_APPS no settings.py
  if ! grep -q "'apps.${app}'," ../ClinicaAI/settings.py; then
    sed -i "/INSTALLED_APPS = \[/a \ \ \ \ 'apps.${app}'," ../ClinicaAI/settings.py
  fi
done
cd ..

# Adicionar bibliotecas ao settings.py
for lib in rest_framework corsheaders channels drf_yasg prometheus_client elastic_apm.contrib.django; do
  if ! grep -q "'${lib}'," ClinicaAI/settings.py; then
    sed -i "/INSTALLED_APPS = \[/a \ \ \ \ '${lib}'," ClinicaAI/settings.py
  fi
done

# Configurar CORS no settings.py
if ! grep -q "'corsheaders.middleware.CorsMiddleware'" ClinicaAI/settings.py; then
  sed -i "/MIDDLEWARE = \[/a \ \ \ \ 'corsheaders.middleware.CorsMiddleware'," ClinicaAI/settings.py
fi
if ! grep -q "CORS_ALLOWED_ORIGINS" ClinicaAI/settings.py; then
  echo -e "CORS_ALLOWED_ORIGINS = [\n    'http://localhost:3000'\n]" >> ClinicaAI/settings.py
fi

# Configurar banco de dados PostgreSQL no settings.py
sed -i "s/ENGINE': 'django.db.backends.sqlite3'/ENGINE': 'django.db.backends.postgresql'/" ClinicaAI/settings.py
sed -i "s/NAME': BASE_DIR .*/NAME': 'clinicaai',\n        'USER': '$DB_USER',\n        'PASSWORD': '$DB_PASSWORD',\n        'HOST': 'localhost',\n        'PORT': '5432'/" ClinicaAI/settings.py

# Configurar Channels para WebSockets
if ! grep -q "ASGI_APPLICATION" ClinicaAI/settings.py; then
  echo "ASGI_APPLICATION = 'ClinicaAI.asgi.application'" >> ClinicaAI/settings.py
fi
if ! grep -q "CHANNEL_LAYERS" ClinicaAI/settings.py; then
  echo -e "CHANNEL_LAYERS = {\n    'default': {\n        'BACKEND': 'channels_redis.core.RedisChannelLayer',\n        'CONFIG': {\n            'hosts': [('127.0.0.1', 6379)],\n        },\n    },\n}" >> ClinicaAI/settings.py
fi

# Configurar Celery para tarefas em segundo plano
if ! grep -q "CELERY_BROKER_URL" ClinicaAI/settings.py; then
  echo -e "CELERY_BROKER_URL = 'redis://localhost:6379/0'\nCELERY_RESULT_BACKEND = 'redis://localhost:6379/0'" >> ClinicaAI/settings.py
fi

# Configurar JWT para autenticação
if ! grep -q "DEFAULT_AUTHENTICATION_CLASSES" ClinicaAI/settings.py; then
  echo -e "REST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework_simplejwt.authentication.JWTAuthentication',\n    ),\n    'DEFAULT_PERMISSION_CLASSES': (\n        'rest_framework.permissions.IsAuthenticated',\n    ),\n}" >> ClinicaAI/settings.py
fi

# Criar banco de dados PostgreSQL
if ! sudo -u postgres psql -lqt | cut -d \| -f 1 | grep -qw clinicaai; then
  sudo -u postgres psql -c "CREATE DATABASE clinicaai;"
fi
if ! sudo -u postgres psql -c "\du" | cut -d \| -f 1 | grep -qw $DB_USER; then
  sudo -u postgres psql -c "CREATE USER $DB_USER WITH PASSWORD '$DB_PASSWORD';"
fi
sudo -u postgres psql -c "ALTER ROLE $DB_USER SET client_encoding TO 'utf8';"
sudo -u postgres psql -c "ALTER ROLE $DB_USER SET default_transaction_isolation TO 'read committed';"
sudo -u postgres psql -c "ALTER ROLE $DB_USER SET timezone TO 'UTC';"
sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE clinicaai TO $DB_USER;"

# Realizar migrações iniciais
python manage.py makemigrations
python manage.py migrate

# Criar superusuário Django (opcional: pode ser configurado manualmente depois)
if ! echo "from django.contrib.auth.models import User; User.objects.filter(username='admin').exists()" | python manage.py shell | grep -q 'True'; then
  echo "from django.contrib.auth.models import User; User.objects.create_superuser('admin', 'admin@example.com', 'admin')" | python manage.py shell
fi

# Instalar dependências do frontend
cd $PROJETO_DIR/frontend
if [ ! -d "clinicaai-frontend" ]; then
  npx create-react-app clinicaai-frontend
fi

# Inicializar Docker e Kubernetes
cd $PROJETO_DIR/docker
cat <<EOF > docker-compose.yml
version: '3.1'
services:
  db:
    image: postgres
    restart: always
    environment:
      POSTGRES_USER: $DB_USER
      POSTGRES_PASSWORD: $DB_PASSWORD
      POSTGRES_DB: clinicaai
    ports:
      - "5432:5432"
  redis:
    image: redis
    restart: always
    ports:
      - "6379:6379"
  web:
    build: ../backend
    command: daphne -b 0.0.0.0 -p 8000 ClinicaAI.asgi:application
    volumes:
      - ../backend:/code
    ports:
      - "8000:8000"
    depends_on:
      - db
      - redis
  worker:
    build: ../backend
    command: celery -A ClinicaAI worker --loglevel=info
    volumes:
      - ../backend:/code
    depends_on:
      - db
      - redis
  frontend:
    image: node
    working_dir: /app
    volumes:
      - ../frontend/clinicaai-frontend:/app
    command: npm start
    ports:
      - "3000:3000"
    depends_on:
      - web
EOF

# Criar configuração Kubernetes para o projeto
cd $PROJETO_DIR/kubernetes
cat <<EOF > clinicaai-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: clinicaai-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: clinicaai
  template:
    metadata:
      labels:
        app: clinicaai
EOF


### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\setup_agendamento_prontuario.py ###
import os
import subprocess

BASE_DIR = "/mnt/dados/ClinicaAI/backend/apps"
SETTINGS_FILE = "/mnt/dados/ClinicaAI/backend/ClinicaAI/settings.py"

def adicionar_ao_installed_apps(nome_modulo):
    # Verificar e adicionar o módulo ao INSTALLED_APPS se ainda não estiver lá
    with open(SETTINGS_FILE, 'r') as f:
        settings_content = f.readlines()

    installed_apps_index = None
    for i, line in enumerate(settings_content):
        if "INSTALLED_APPS" in line:
            installed_apps_index = i
            break

    if installed_apps_index is not None:
        modulo_entry = f"    'apps.{nome_modulo}',\n"
        if modulo_entry not in settings_content:
            # Adicionar após a linha "INSTALLED_APPS = ["
            settings_content.insert(installed_apps_index + 2, modulo_entry)
            with open(SETTINGS_FILE, 'w') as f:
                f.writelines(settings_content)
            print(f"Módulo 'apps.{nome_modulo}' adicionado ao INSTALLED_APPS.")

def criar_pasta_modulo(nome_modulo):
    app_dir = os.path.join(BASE_DIR, nome_modulo)
    if not os.path.exists(app_dir):
        os.makedirs(app_dir)
        print(f"Pasta {app_dir} criada com sucesso.")
    return app_dir

def criar_models_agendamento(app_dir):
    models_path = os.path.join(app_dir, 'models.py')
    with open(models_path, 'w') as f:
        f.write("""
from django.db import models
from apps.pacientes.models import Paciente

class Agendamento(models.Model):
    paciente = models.ForeignKey(Paciente, on_delete=models.CASCADE, related_name='agendamentos')
    data_horario = models.DateTimeField()
    tipo_consulta = models.CharField(max_length=50)
    status = models.CharField(max_length=20, choices=[
        ('agendado', 'Agendado'),
        ('cancelado', 'Cancelado'),
        ('realizado', 'Realizado'),
    ])
    observacoes = models.TextField(blank=True)

    def __str__(self):
        return f"Agendamento de {self.paciente.nome_completo} em {self.data_horario}"
""")
    print("Arquivo models.py para Agendamento criado com sucesso.")

def criar_models_prontuario(app_dir):
    models_path = os.path.join(app_dir, 'models.py')
    with open(models_path, 'w') as f:
        f.write("""
from django.db import models
from apps.pacientes.models import Paciente

class Prontuario(models.Model):
    paciente = models.ForeignKey(Paciente, on_delete=models.CASCADE, related_name='prontuarios')
    data_registro = models.DateTimeField(auto_now_add=True)
    descricao = models.TextField()
    medico_responsavel = models.CharField(max_length=100)

    def __str__(self):
        return f"Prontuário de {self.paciente.nome_completo} - {self.data_registro.strftime('%d/%m/%Y')}"
""")
    print("Arquivo models.py para Prontuário criado com sucesso.")

def criar_views_serializers_urls(nome_modulo):
    app_dir = os.path.join(BASE_DIR, nome_modulo)

    # Nome da classe do modelo no singular
    nome_classe = nome_modulo.capitalize()[:-1] if nome_modulo.endswith('s') else nome_modulo.capitalize()

    # Criar serializers.py
    serializers_path = os.path.join(app_dir, 'serializers.py')
    with open(serializers_path, 'w') as f:
        f.write(f"""
from rest_framework import serializers
from .models import {nome_classe}

class {nome_classe}Serializer(serializers.ModelSerializer):
    class Meta:
        model = {nome_classe}
        fields = '__all__'
""")
    print(f"Arquivo serializers.py para {nome_classe} criado com sucesso.")

    # Criar views.py
    views_path = os.path.join(app_dir, 'views.py')
    with open(views_path, 'w') as f:
        f.write(f"""
from rest_framework import viewsets
from .models import {nome_classe}
from .serializers import {nome_classe}Serializer

class {nome_classe}ViewSet(viewsets.ModelViewSet):
    queryset = {nome_classe}.objects.all()
    serializer_class = {nome_classe}Serializer
""")
    print(f"Arquivo views.py para {nome_classe} criado com sucesso.")

    # Criar urls.py
    urls_path = os.path.join(app_dir, 'urls.py')
    with open(urls_path, 'w') as f:
        f.write(f"""
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import {nome_classe}ViewSet

router = DefaultRouter()
router.register(r'{nome_modulo.lower()}', {nome_classe}ViewSet)

urlpatterns = [
    path('', include(router.urls)),
]
""")
    print(f"Arquivo urls.py para {nome_classe} criado com sucesso.")

def criar_admin(nome_modulo):
    app_dir = os.path.join(BASE_DIR, nome_modulo)

    # Nome da classe do modelo no singular
    nome_classe = nome_modulo.capitalize()[:-1] if nome_modulo.endswith('s') else nome_modulo.capitalize()

    admin_path = os.path.join(app_dir, 'admin.py')
    with open(admin_path, 'w') as f:
        f.write(f"""
from django.contrib import admin
from .models import {nome_classe}

admin.site.register({nome_classe})
""")
    print(f"Arquivo admin.py para {nome_classe} criado com sucesso.")

def rodar_migracoes():
    # Executar os comandos de makemigrations e migrate
    try:
        subprocess.run(["python", "manage.py", "makemigrations"], check=True)
        subprocess.run(["python", "manage.py", "migrate"], check=True)
        print("Migrações criadas e aplicadas com sucesso.")
    except subprocess.CalledProcessError as e:
        print(f"Erro ao rodar migrações: {e}")

if __name__ == "__main__":
    # Criar módulo Agendamentos
    agendamento_dir = criar_pasta_modulo('agendamentos')
    criar_models_agendamento(agendamento_dir)
    criar_views_serializers_urls('agendamentos')
    criar_admin('agendamentos')
    adicionar_ao_installed_apps('agendamentos')

    # Criar módulo Prontuário
    prontuario_dir = criar_pasta_modulo('prontuarios')
    criar_models_prontuario(prontuario_dir)
    criar_views_serializers_urls('prontuarios')
    criar_admin('prontuarios')
    adicionar_ao_installed_apps('prontuarios')

    # Rodar migrações
    rodar_migracoes()


### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\setup_pacientes_module.py ###
import os
import subprocess

BASE_DIR = "/mnt/dados/ClinicaAI/backend/apps/pacientes"

def criar_pasta_se_necessario():
    if not os.path.exists(BASE_DIR):
        os.makedirs(BASE_DIR)
        print(f"Pasta {BASE_DIR} criada com sucesso.")

def criar_models():
    models_path = os.path.join(BASE_DIR, 'models.py')
    with open(models_path, 'w') as f:
        f.write("""
from django.db import models
from django.utils.translation import gettext_lazy as _

class Paciente(models.Model):
    # Dados Pessoais
    nome_completo = models.CharField(_("Nome Completo"), max_length=255)
    cpf = models.CharField(_("CPF"), max_length=14, unique=True)
    rg = models.CharField(_("RG"), max_length=20, blank=True)
    data_nascimento = models.DateField(_("Data de Nascimento"))
    sexo = models.CharField(
        _("Sexo"),
        max_length=1,
        choices=[
            ('M', 'Masculino'),
            ('F', 'Feminino'),
            ('O', 'Outro'),
        ]
    )
    estado_civil = models.CharField(_("Estado Civil"), max_length=50, blank=True)
    profissao = models.CharField(_("Profissão"), max_length=100, blank=True)
    endereco = models.CharField(_("Endereço"), max_length=255)
    numero = models.CharField(_("Número"), max_length=10)
    complemento = models.CharField(_("Complemento"), max_length=100, blank=True)
    bairro = models.CharField(_("Bairro"), max_length=100)
    cidade = models.CharField(_("Cidade"), max_length=100)
    estado = models.CharField(_("Estado"), max_length=2)
    cep = models.CharField(_("CEP"), max_length=9)
    telefone_fixo = models.CharField(_("Telefone Fixo"), max_length=15, blank=True)
    telefone_celular = models.CharField(_("Telefone Celular"), max_length=15)
    email = models.EmailField(_("Email"), blank=True)
    convenio = models.CharField(_("Convênio"), max_length=100, blank=True)
    numero_carteirinha = models.CharField(_("Número da Carteirinha"), max_length=50, blank=True)
    validade_carteirinha = models.DateField(_("Validade da Carteirinha"), blank=True, null=True)
    responsavel_financeiro = models.CharField(_("Responsável Financeiro"), max_length=255, blank=True)
    parentesco_responsavel = models.CharField(_("Parentesco do Responsável"), max_length=50, blank=True)
    cpf_responsavel = models.CharField(_("CPF do Responsável"), max_length=14, blank=True)
    rg_responsavel = models.CharField(_("RG do Responsável"), max_length=20, blank=True)
    telefone_responsavel = models.CharField(_("Telefone do Responsável"), max_length=15, blank=True)
    consentimento_lgpd = models.BooleanField(_("Consentimento LGPD"), default=False)
    data_consentimento = models.DateTimeField(_("Data do Consentimento"), blank=True, null=True)
    observacoes = models.TextField(_("Observações"), blank=True)
    foto = models.ImageField(_("Foto"), upload_to='fotos_pacientes', blank=True)
    data_cadastro = models.DateTimeField(_("Data do Cadastro"), auto_now_add=True)
    data_atualizacao = models.DateTimeField(_("Data da Última Atualização"), auto_now=True)

    def __str__(self):
        return self.nome_completo

    class Meta:
        verbose_name = _("Paciente")
        verbose_name_plural = _("Pacientes")
""")
    print("Arquivo models.py criado com sucesso.")

def criar_serializers():
    serializers_path = os.path.join(BASE_DIR, 'serializers.py')
    with open(serializers_path, 'w') as f:
        f.write("""
from rest_framework import serializers
from .models import Paciente

class PacienteSerializer(serializers.ModelSerializer):
    class Meta:
        model = Paciente
        fields = '__all__'
""")
    print("Arquivo serializers.py criado com sucesso.")

def criar_views():
    views_path = os.path.join(BASE_DIR, 'views.py')
    with open(views_path, 'w') as f:
        f.write("""
from rest_framework import viewsets
from .models import Paciente
from .serializers import PacienteSerializer

class PacienteViewSet(viewsets.ModelViewSet):
    queryset = Paciente.objects.all()
    serializer_class = PacienteSerializer
""")
    print("Arquivo views.py criado com sucesso.")

def criar_urls():
    urls_path = os.path.join(BASE_DIR, 'urls.py')
    with open(urls_path, 'w') as f:
        f.write("""
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PacienteViewSet

router = DefaultRouter()
router.register(r'pacientes', PacienteViewSet)

urlpatterns = [
    path('', include(router.urls)),
]
""")
    print("Arquivo urls.py criado com sucesso.")

def criar_admin():
    admin_path = os.path.join(BASE_DIR, 'admin.py')
    with open(admin_path, 'w') as f:
        f.write("""
from django.contrib import admin
from .models import Paciente

admin.site.register(Paciente)
""")
    print("Arquivo admin.py criado com sucesso.")

def rodar_migracoes():
    # Executar os comandos de makemigrations e migrate
    try:
        subprocess.run(["python", "manage.py", "makemigrations", "pacientes"], check=True)
        subprocess.run(["python", "manage.py", "migrate"], check=True)
        print("Migrações criadas e aplicadas com sucesso.")
    except subprocess.CalledProcessError as e:
        print(f"Erro ao rodar migrações: {e}")

if __name__ == "__main__":
    criar_pasta_se_necessario()
    criar_models()
    criar_serializers()
    criar_views()
    criar_urls()
    criar_admin()
    rodar_migracoes()


### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\pacientesmodels\informacao_medica.py ###
from django.db import models
from .paciente import Paciente

class InformacaoMedica(models.Model):
    paciente = models.ForeignKey(Paciente, on_delete=models.CASCADE, related_name='informacoes_medicas')
    historico_medico = models.TextField(help_text="Histórico médico detalhado do paciente.")
    alergias = models.TextField(null=True, blank=True, help_text="Alergias que o paciente possui.")
    medicamentos_em_uso = models.TextField(null=True, blank=True, help_text="Medicamentos atualmente em uso pelo paciente.")
    doencas_preexistentes = models.TextField(null=True, blank=True, help_text="Doenças preexistentes do paciente.")
    tipo_dependencia = models.CharField(max_length=255, null=True, blank=True, help_text="Tipo de dependência, como álcool, drogas sintéticas.")
    comorbidades_psiquiatricas = models.TextField(null=True, blank=True, help_text="Comorbidades psiquiátricas do paciente.")

    class Meta:
        verbose_name = "Informação Médica"
        verbose_name_plural = "Informações Médicas"

    def __str__(self):
        return f"Informações médicas de {self.paciente.nome}"


### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\pacientesmodels\intervencao_ia.py ###
# Criar o arquivo intervencao_ia.py em /mnt/dados/clinicaai/pacientes/models/

from django.db import models
from .paciente import Paciente

class IntervencaoIA(models.Model):
    paciente = models.ForeignKey(Paciente, on_delete=models.CASCADE, related_name='intervencoes_ia')
    descricao_intervencao = models.TextField(help_text="Descrição da intervenção sugerida pela IA.")
    tipo_intervencao = models.CharField(max_length=50, choices=[
        ('ajuste_medicamento', 'Ajuste de Medicamento'),
        ('mudanca_tratamento', 'Mudança de Tratamento'),
        ('triagem_prioritaria', 'Triagem Prioritária'),
        ('risco_alto', 'Avaliação de Risco Alto')
    ])
    data_intervencao = models.DateTimeField(auto_now_add=True)
    responsavel_aprovacao = models.CharField(max_length=255, null=True, blank=True, help_text="Profissional que aprovou a intervenção.")
    status = models.CharField(max_length=50, choices=[
        ('pendente', 'Pendente'),
        ('aprovada', 'Aprovada'),
        ('rejeitada', 'Rejeitada')
    ], default='pendente')

    class Meta:
        verbose_name = "Intervenção de IA"
        verbose_name_plural = "Intervenções de IA"

    def __str__(self):
        return f"Intervenção IA - {self.paciente.nome} ({self.tipo_intervencao})"


### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\pacientesmodels\paciente.py ###
from django.db import models
from django.utils import timezone

class Paciente(models.Model):
    # Dados Pessoais
    nome = models.CharField(max_length=255)
    cpf = models.CharField(max_length=14, unique=True)
    rg = models.CharField(max_length=20, unique=True, null=True, blank=True)  # Permitindo nulo para evitar erro em registros existentes
    endereco = models.TextField(null=True, blank=True)
    telefone = models.CharField(max_length=20, null=True, blank=True)
    email = models.EmailField(max_length=255, unique=True, null=True, blank=True)
    data_nascimento = models.DateField(default=timezone.now, null=True, blank=True)  # Permitindo valor padrão e valores nulos
    contato_emergencia = models.CharField(max_length=255, default='Sem contato', null=True, blank=True)
    telefone_emergencia = models.CharField(max_length=20, null=True, blank=True)

    # Informações Médicas e de Saúde
    historico_medico = models.TextField(help_text="Histórico médico detalhado do paciente.", null=True, blank=True)
    alergias = models.TextField(null=True, blank=True)
    medicamentos_em_uso = models.TextField(null=True, blank=True)
    doencas_preexistentes = models.TextField(null=True, blank=True)
    tipo_dependencia = models.CharField(max_length=255, help_text="Ex: álcool, drogas sintéticas.", null=True, blank=True)
    comorbidades_psiquiatricas = models.TextField(null=True, blank=True)
    
    # Plano de Saúde e Documentos
    plano_saude = models.CharField(max_length=255, null=True, blank=True)
    numero_cartao_saude = models.CharField(max_length=50, null=True, blank=True)
    documentos_digitalizados = models.JSONField(null=True, blank=True, help_text="Armazena links para documentos digitalizados (RG, CPF, plano de saúde).")

    # Dados de Triagem e Acompanhamento Inicial
    etapa_triagem = models.CharField(max_length=50, choices=[
        ('entrevista_inicial', 'Entrevista Inicial'),
        ('exames', 'Exames Médicos'),
        ('analise_risco', 'Análise de Risco')
    ], default='entrevista_inicial')
    resultado_triagem = models.TextField(null=True, blank=True)
    data_triagem = models.DateField(null=True, blank=True)

    # Informações de Internação
    internacao = models.BooleanField(default=False)
    data_admissao = models.DateField(null=True, blank=True)
    data_alta = models.DateField(null=True, blank=True)
    leito = models.CharField(max_length=50, null=True, blank=True)
    observacoes_internacao = models.TextField(null=True, blank=True)

    # Evolução e Acompanhamento Terapêutico
    evolucao_terapeutica = models.TextField(help_text="Registro detalhado da evolução do paciente durante o tratamento.", null=True, blank=True)
    metas_tratamento = models.TextField(help_text="Metas específicas para o tratamento do paciente.", null=True, blank=True)
    questionarios_periodicos = models.JSONField(null=True, blank=True, help_text="Respostas dos questionários periódicos enviados ao paciente.")
    notas_profissionais = models.TextField(help_text="Notas adicionadas pelos profissionais de saúde.", null=True, blank=True)

    # Relatórios e Assinaturas Digitais
    relatorios_gerados = models.JSONField(null=True, blank=True, help_text="Lista de relatórios gerados automaticamente.")
    assinatura_digital_profissional = models.CharField(max_length=255, null=True, blank=True, help_text="ID da assinatura digital do profissional responsável.")

    # Informações Adicionais
    responsavel_legal = models.CharField(max_length=255, null=True, blank=True)
    consentimento_familiar = models.BooleanField(default=False)
    dados_familiares = models.TextField(null=True, blank=True, help_text="Informações sobre histórico familiar de dependência.")

    class Meta:
        verbose_name = 'Paciente'
        verbose_name_plural = 'Pacientes'

    def __str__(self):
        return f"{self.nome} - CPF: {self.cpf}"


### C:\ClinicaAI\backend\ClinicaAI\Scriptsavulsos\pacientesmodels\__init__.py ###
from .paciente import Paciente
from .informacao_medica import InformacaoMedica
from .intervencao_ia import IntervencaoIA


