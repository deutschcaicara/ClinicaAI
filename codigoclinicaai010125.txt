
# --- Início do arquivo: C:\ClinicaAI\backend\apps\agendamentos\admin.py ---

from django.contrib import admin
from .models import Agendamento

admin.site.register(Agendamento)

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\agendamentos\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\agendamentos\apps.py ---

from django.apps import AppConfig


class AgendamentosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.agendamentos"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\agendamentos\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\agendamentos\models.py ---

from django.db import models
from django.utils.translation import gettext_lazy as _
from django.conf import settings
from apps.profissionais.models import Profissional

from apps.pacientes.models import Paciente

import uuid


class Agendamento(models.Model):
    # Identificador Ãšnico Global
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    paciente = models.ForeignKey(
    'pacientes.Paciente', on_delete=models.CASCADE, related_name='agendamentos'
)




    profissional = models.ForeignKey(
        Profissional, on_delete=models.CASCADE, related_name="agendamentos_profissional"
    )

    # Dados do Agendamento
    data_agendamento = models.DateField(verbose_name=_("Data do Agendamento"))
    horario_inicio = models.TimeField(verbose_name=_("HorÃ¡rio de InÃ­cio"))
    horario_fim = models.TimeField(verbose_name=_("HorÃ¡rio de Fim"))
    tipo_consulta = models.CharField(
        max_length=50,
        choices=[
            ("Consulta Inicial", "Consulta Inicial"),
            ("Retorno", "Retorno"),
            ("Exame", "Exame"),
            ("Teleconsulta", "Teleconsulta"),
        ],
        default="Consulta Inicial",
        verbose_name=_("Tipo de Consulta"),
    )
    local_atendimento = models.CharField(
        max_length=50,
        choices=[
            ("Presencial", "Presencial"),
            ("Telemedicina", "Telemedicina"),
            ("Visita Domiciliar", "Visita Domiciliar"),
        ],
        default="Presencial",
        verbose_name=_("Local do Atendimento"),
    )
    status = models.CharField(
        max_length=20,
        choices=[
            ("Agendado", "Agendado"),
            ("Cancelado", "Cancelado"),
            ("ConcluÃ­do", "ConcluÃ­do"),
        ],
        default="Agendado",
        verbose_name=_("Status do Agendamento"),
    )
    motivo_cancelamento = models.TextField(
        blank=True, null=True, verbose_name=_("Motivo do Cancelamento")
    )
    confirmado_pelo_paciente = models.BooleanField(
        default=False, verbose_name=_("Confirmado pelo Paciente")
    )
    observacoes = models.TextField(blank=True, verbose_name=_("ObservaÃ§Ãµes"))
    sintomas_iniciais = models.TextField(
        blank=True, verbose_name=_("Sintomas Iniciais")
    )
    tipo_atendimento = models.CharField(
        max_length=20,
        choices=[("Emergencial", "Emergencial"), ("Rotina", "Rotina")],
        default="Rotina",
        verbose_name=_("Tipo de Atendimento"),
    )
    motivo_consulta = models.CharField(
        max_length=255, blank=True, verbose_name=_("Motivo da Consulta")
    )

    # Dados Financeiros
    meio_pagamento = models.CharField(
        max_length=50,
        choices=[
            ("CartÃ£o de CrÃ©dito", "CartÃ£o de CrÃ©dito"),
            ("ConvÃªnio", "ConvÃªnio"),
            ("Dinheiro", "Dinheiro"),
            ("PIX", "PIX"),
        ],
        blank=True,
        verbose_name=_("Meio de Pagamento"),
    )
    status_financeiro = models.CharField(
        max_length=20,
        choices=[("Pago", "Pago"), ("Pendente", "Pendente")],
        default="Pendente",
        verbose_name=_("Status Financeiro"),
    )

    # NotificaÃ§Ãµes e Lembretes
    canal_preferencial = models.CharField(
        max_length=20,
        choices=[("WhatsApp", "WhatsApp"), ("SMS", "SMS"), ("Email", "Email")],
        default="WhatsApp",
        verbose_name=_("Canal Preferencial de NotificaÃ§Ã£o"),
    )
    lembrete_enviado_em = models.DateTimeField(
        blank=True, null=True, verbose_name=_("Lembrete Enviado em")
    )
    status_notificacao = models.CharField(
        max_length=20,
        choices=[("Enviado", "Enviado"), ("Lido", "Lido"), ("Pendente", "Pendente")],
        default="Pendente",
        verbose_name=_("Status da NotificaÃ§Ã£o"),
    )

    # AutomaÃ§Ã£o e IntegraÃ§Ã£o IoT
    equipamentos_necessarios = models.CharField(
        max_length=255, blank=True, verbose_name=_("Equipamentos NecessÃ¡rios")
    )
    sala_atendimento = models.CharField(
        max_length=50, blank=True, verbose_name=_("Sala de Atendimento")
    )
    dispositivo_iot = models.CharField(
        max_length=100, blank=True, verbose_name=_("Dispositivo IoT NecessÃ¡rio")
    )

    # Dados para IA e Machine Learning
    probabilidade_cancelamento = models.DecimalField(
        max_digits=5,
        decimal_places=2,
        null=True,
        blank=True,
        verbose_name=_("Probabilidade de Cancelamento (%)"),
    )
    tempo_espera_estimado = models.DurationField(
        blank=True, null=True, verbose_name=_("Tempo de Espera Estimado")
    )
    preferencias_paciente = models.CharField(
        max_length=255, blank=True, verbose_name=_("PreferÃªncias do Paciente")
    )
    confirmar_atendimento_automatico = models.BooleanField(
        default=False, verbose_name=_("Confirmar Atendimento Automaticamente")
    )

    # HistÃ³rico de ModificaÃ§Ãµes
    log_modificacoes = models.TextField(
        blank=True, verbose_name=_("HistÃ³rico de ModificaÃ§Ãµes")
    )
    historico_cancelamentos = models.TextField(
        blank=True, verbose_name=_("HistÃ³rico de Cancelamentos")
    )

    # PrÃ©-Check-in
    pre_checkin_realizado = models.BooleanField(
        default=False, verbose_name=_("PrÃ©-Check-in Realizado")
    )

    # Dados de Controle
    criado_em = models.DateTimeField(auto_now_add=True, verbose_name=_("Criado em"))
    atualizado_em = models.DateTimeField(auto_now=True, verbose_name=_("Atualizado em"))

    class Meta:
        verbose_name = _("Agendamento")
        verbose_name_plural = _("Agendamentos")
        app_label = "agendamentos"
        unique_together = (("profissional", "data_agendamento", "horario_inicio"),)

    def __str__(self):
        return f"Agendamento de {self.paciente.nome_completo} com {self.profissional.nome_completo} em {self.data_agendamento} Ã s {self.horario_inicio}"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\agendamentos\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\agendamentos\serializers.py ---

# MÃ³dulo Agendamentos - Serializers (serializers.py)

from rest_framework import serializers
from django.utils import timezone
from .models import Agendamento
import uuid


class AgendamentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Agendamento
        fields = "__all__"

    def validate(self, data):
        # ValidaÃ§Ã£o para garantir que a data e horÃ¡rio do agendamento sejam
        # futuros
        if data["data_agendamento"] < timezone.now().date():
            raise serializers.ValidationError("A data do agendamento deve ser futura.")
        if (
            data["data_agendamento"] == timezone.now().date()
            and data["horario_inicio"] <= timezone.now().time()
        ):
            raise serializers.ValidationError("O horÃ¡rio de inÃ­cio deve ser no futuro.")

        # ValidaÃ§Ã£o para garantir que o horÃ¡rio de fim seja posterior ao
        # horÃ¡rio de inÃ­cio
        if data["horario_fim"] <= data["horario_inicio"]:
            raise serializers.ValidationError(
                "O horÃ¡rio de fim deve ser posterior ao horÃ¡rio de inÃ­cio."
            )

        # ValidaÃ§Ã£o para garantir que nÃ£o haja sobreposiÃ§Ã£o de agendamentos
        # para o mesmo profissional
        agendamentos_existentes = Agendamento.objects.filter(
            profissional=data["profissional"],
            data_agendamento=data["data_agendamento"],
            horario_inicio__lt=data["horario_fim"],
            horario_fim__gt=data["horario_inicio"],
        ).exclude(uuid=data.get("uuid"))
        if agendamentos_existentes.exists():
            raise serializers.ValidationError(
                "O horÃ¡rio do agendamento conflita com outro agendamento existente para este profissional."
            )

        # ValidaÃ§Ã£o para garantir que nÃ£o haja sobreposiÃ§Ã£o de agendamentos
        # para o mesmo paciente
        agendamentos_paciente = Agendamento.objects.filter(
            paciente=data["paciente"],
            data_agendamento=data["data_agendamento"],
            horario_inicio__lt=data["horario_fim"],
            horario_fim__gt=data["horario_inicio"],
        ).exclude(uuid=data.get("uuid"))
        if agendamentos_paciente.exists():
            raise serializers.ValidationError(
                "O paciente jÃ¡ possui um agendamento no mesmo horÃ¡rio."
            )

        # ValidaÃ§Ã£o para garantir que o status financeiro esteja correto se o
        # agendamento for concluÃ­do
        if data["status"] == "ConcluÃ­do" and data["status_financeiro"] != "Pago":
            raise serializers.ValidationError(
                "Agendamentos concluÃ­dos devem ter o status financeiro como 'Pago'."
            )

        # ValidaÃ§Ã£o para garantir que o motivo do cancelamento esteja
        # preenchido se o agendamento for cancelado
        if data["status"] == "Cancelado" and not data.get("motivo_cancelamento"):
            raise serializers.ValidationError(
                "O motivo do cancelamento deve ser informado quando o agendamento for cancelado."
            )

        # ValidaÃ§Ã£o para garantir que o canal preferencial de notificaÃ§Ã£o seja
        # consistente com as preferÃªncias do paciente
        if data["canal_preferencial"] not in ["WhatsApp", "SMS", "Email"]:
            raise serializers.ValidationError(
                "Canal preferencial de notificaÃ§Ã£o invÃ¡lido."
            )

        # ValidaÃ§Ã£o para garantir a disponibilidade dos equipamentos e sala de
        # atendimento
        if data.get("equipamentos_necessarios") or data.get("sala_atendimento"):
            conflitos = Agendamento.objects.filter(
                data_agendamento=data["data_agendamento"],
                horario_inicio__lt=data["horario_fim"],
                horario_fim__gt=data["horario_inicio"],
                sala_atendimento=data.get("sala_atendimento"),
            ).exclude(uuid=data.get("uuid"))
            if conflitos.exists():
                raise serializers.ValidationError(
                    "A sala de atendimento ou equipamentos necessÃ¡rios jÃ¡ estÃ£o reservados para outro agendamento no mesmo horÃ¡rio."
                )

        # ValidaÃ§Ã£o para garantir que o profissional nÃ£o esteja de fÃ©rias ou
        # ausente na data de agendamento
        if (
            hasattr(data["profissional"], "ferias")
            and data["profissional"]
            .ferias.filter(
                inicio__lte=data["data_agendamento"], fim__gte=data["data_agendamento"]
            )
            .exists()
        ):
            raise serializers.ValidationError(
                "O profissional estÃ¡ de fÃ©rias ou ausente na data selecionada."
            )

        # ValidaÃ§Ã£o para limitar o nÃºmero de agendamentos do mesmo paciente no
        # mesmo dia
        limite_agendamentos_paciente = Agendamento.objects.filter(
            paciente=data["paciente"], data_agendamento=data["data_agendamento"]
        ).count()
        if limite_agendamentos_paciente >= 3:
            raise serializers.ValidationError(
                "O paciente jÃ¡ possui muitos agendamentos para o mesmo dia."
            )

        # ValidaÃ§Ã£o de prÃ©-check-in
        if data.get("pre_checkin_realizado") and not data.get(
            "confirmado_pelo_paciente"
        ):
            raise serializers.ValidationError(
                "O prÃ©-check-in nÃ£o pode ser realizado sem a confirmaÃ§Ã£o do paciente."
            )

        # ValidaÃ§Ã£o para garantir que o agendamento nÃ£o ocorra em feriados ou
        # dias bloqueados
        if (
            hasattr(data["profissional"], "dias_bloqueados")
            and data["profissional"]
            .dias_bloqueados.filter(data=data["data_agendamento"])
            .exists()
        ):
            raise serializers.ValidationError(
                "O agendamento nÃ£o pode ser feito em um feriado ou dia bloqueado para este profissional."
            )

        # ValidaÃ§Ã£o para garantir que o status seja consistente com a
        # confirmaÃ§Ã£o do paciente
        if data["status"] == "ConcluÃ­do" and not data.get("confirmado_pelo_paciente"):
            raise serializers.ValidationError(
                "O agendamento nÃ£o pode ser concluÃ­do sem a confirmaÃ§Ã£o do paciente."
            )

        return data

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\agendamentos\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\agendamentos\urls.py ---

# MÃ³dulo Agendamentos - URLs (urls.py)

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import AgendamentoViewSet

router = DefaultRouter()
router.register(r"agendamentos", AgendamentoViewSet, basename="agendamento")

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\agendamentos\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\agendamentos\views.py ---

# MÃ³dulo Agendamentos - Views (views.py)

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Agendamento
from .serializers import AgendamentoSerializer
from django.utils import timezone
from django.core.mail import send_mail
from django.conf import settings
import logging
import threading
import uuid

logger = logging.getLogger(__name__)


class AgendamentoViewSet(viewsets.ModelViewSet):
    serializer_class = AgendamentoSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna os agendamentos futuros do usuÃ¡rio autenticado (paciente ou
        # profissional)
        user = self.request.user
        if hasattr(user, 'paciente'):
            return Agendamento.objects.filter(
    paciente=user.paciente,
     data_agendamento__gte=timezone.now().date())
        elif hasattr(user, 'profissional'):
            return Agendamento.objects.filter(
    profissional=user.profissional,
     data_agendamento__gte=timezone.now().date())
        return Agendamento.objects.none()

    @action(detail=True, methods=['post'],
            permission_classes=[IsAuthenticated])
    def confirmar(self, request, pk=None):
        # AÃ§Ã£o para confirmar o agendamento pelo paciente
        agendamento = self.get_object()
        if hasattr(
    request.user,
     'paciente') and agendamento.paciente != request.user.paciente:
            return Response(
    {
        'detail': 'VocÃª nÃ£o tem permissÃ£o para confirmar este agendamento.'},
         status=status.HTTP_403_FORBIDDEN)

        if agendamento.confirmado_pelo_paciente:
            return Response({'detail': 'Agendamento jÃ¡ foi confirmado.'},
                            status=status.HTTP_400_BAD_REQUEST)

        agendamento.confirmado_pelo_paciente = True
        agendamento.save()

       

    @ action(detail=True, methods=['post'],
             permission_classes=[IsAuthenticated])
    def cancelar(self, request, pk=None):
        # AÃ§Ã£o para cancelar um agendamento
        agendamento= self.get_object()
        motivo= request.data.get('motivo_cancelamento')
        if not motivo:
            return Response({'detail': 'Motivo do cancelamento deve ser informado.'},
                            status=status.HTTP_400_BAD_REQUEST)

        # Verificar permissÃµes de cancelamento
        if hasattr(
    request.user,
     'paciente') and agendamento.paciente != request.user.paciente:
            return Response(
    {
        'detail': 'VocÃª nÃ£o tem permissÃ£o para cancelar este agendamento.'},
         status = status.HTTP_403_FORBIDDEN)
        if hasattr(
    request.user,
     'profissional') and agendamento.profissional != request.user.profissional:
            return Response(
    {
        'detail': 'VocÃª nÃ£o tem permissÃ£o para cancelar este agendamento.'},
         status = status.HTTP_403_FORBIDDEN)

        agendamento.status= 'Cancelado'
        agendamento.motivo_cancelamento= motivo
        agendamento.save()

       

    @ action(detail=True, methods=['post'],
             permission_classes=[IsAuthenticated])
    def reagendar(self, request, pk=None):
        # AÃ§Ã£o para reagendar um agendamento
        agendamento= self.get_object()
        nova_data= request.data.get('data_agendamento')
        novo_horario_inicio= request.data.get('horario_inicio')
        novo_horario_fim= request.data.get('horario_fim')

        if not nova_data or not novo_horario_inicio or not novo_horario_fim:
            return Response({'detail': 'Dados de reagendamento incompletos.'},
                            status=status.HTTP_400_BAD_REQUEST)

        # ValidaÃ§Ã£o para garantir que a nova data e horÃ¡rio sejam futuros
        if nova_data < timezone.now().date() or (nova_data == timezone.now().date()
                                    and novo_horario_inicio <= timezone.now().time()):
            return Response({'detail': 'A nova data e horÃ¡rio devem ser no futuro.'},
                            status=status.HTTP_400_BAD_REQUEST)

        # ValidaÃ§Ã£o para garantir que a capacidade da sala nÃ£o seja excedida
        # (Exemplo para IoT)
        if agendamento.sala_atendimento:
            capacidade_sala= agendamento.sala_atendimento.capacidade  # Supondo que o modelo de sala tenha um campo 'capacidade'
            ocupacao_atual= Agendamento.objects.filter(
                data_agendamento=nova_data,
                horario_inicio__lt=novo_horario_fim,
                horario_fim__gt=novo_horario_inicio,
                sala_atendimento=agendamento.sala_atendimento
            ).count()
            if ocupacao_atual >= capacidade_sala:
                return Response(
    {
        'detail': 'A capacidade da sala de atendimento foi excedida.'},
         status=status.HTTP_400_BAD_REQUEST)

        # Atualizar o agendamento com a nova data e horÃ¡rio
        agendamento.data_agendamento= nova_data
        agendamento.horario_inicio= novo_horario_inicio
        agendamento.horario_fim= novo_horario_fim
        agendamento.status= 'Agendado'
        agendamento.motivo_cancelamento= ''  # Limpar motivo de cancelamento, se houver
        agendamento.save()

     

    @ action(detail=False, methods=['get'],
             permission_classes=[IsAuthenticated])
    def meus_agendamentos(self, request):
        # Retorna os agendamentos do paciente ou profissional autenticado
        if hasattr(request.user, 'paciente'):
            agendamentos= Agendamento.objects.filter(paciente=request.user.paciente)
        elif hasattr(request.user, 'profissional'):
            agendamentos= Agendamento.objects.filter(profissional=request.user.profissional)
        else:
            return Response(
    {
        'detail': 'VocÃª nÃ£o tem permissÃ£o para visualizar agendamentos.'},
         status=status.HTTP_403_FORBIDDEN)

        serializer= self.get_serializer(agendamentos, many=True)
        return Response(serializer.data)

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\agendamentos\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\aprovacoes\admin.py ---

from django.contrib import admin

# Register your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\aprovacoes\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\aprovacoes\apps.py ---

from django.apps import AppConfig


class AprovacoesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.aprovacoes"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\aprovacoes\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\aprovacoes\models.py ---

from django.db import models

# Create your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\aprovacoes\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\aprovacoes\views.py ---

from django.shortcuts import render

# Create your views here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\aprovacoes\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\assinar_documentos\admin.py ---

from django.contrib import admin
from .models import Assinar_documentosModel


@admin.register(Assinar_documentosModel)
class Assinar_documentosAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\assinar_documentos\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\assinar_documentos\apps.py ---

from django.apps import AppConfig


class Assinar_documentosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.assinar_documentos"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\assinar_documentos\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\assinar_documentos\models.py ---

from django.db import models


class Assinar_documentosModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\assinar_documentos\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\assinar_documentos\serializers.py ---

from rest_framework import serializers
from .models import Assinar_documentosModel


class Assinar_documentosSerializer(serializers.ModelSerializer):
    class Meta:
        model = Assinar_documentosModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\assinar_documentos\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\assinar_documentos\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Assinar_documentosViewSet

router = DefaultRouter()
router.register(r"assinar_documentos", Assinar_documentosViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\assinar_documentos\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\assinar_documentos\views.py ---

from rest_framework import viewsets
from .models import Assinar_documentosModel
from .serializers import Assinar_documentosSerializer


class Assinar_documentosViewSet(viewsets.ModelViewSet):
    queryset = Assinar_documentosModel.objects.all()
    serializer_class = Assinar_documentosSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\assinar_documentos\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\assinaturas\admin.py ---

from django.contrib import admin
from .models import Assinatura


@admin.register(Assinatura)
class AssinaturasAdmin(admin.ModelAdmin):
    list_display = ("documento", "assinante", "data_assinatura", "validade_assinatura")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\assinaturas\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\assinaturas\apps.py ---

from django.apps import AppConfig


class AssinaturasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.assinaturas"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\assinaturas\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\assinaturas\models.py ---

from django.db import models
from django.utils import timezone
import uuid
from apps.pacientes.models import Paciente

from apps.profissionais.models import Profissional
from django.core.validators import FileExtensionValidator
from django.conf import settings
import hashlib
from datetime import timedelta


class Documento(models.Model):
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    titulo = models.CharField(max_length=255, verbose_name="TÃ­tulo do Documento")
    descricao = models.TextField(
        verbose_name="DescriÃ§Ã£o do Documento", blank=True, null=True
    )
    data_criacao = models.DateTimeField(auto_now_add=True)
    data_atualizacao = models.DateTimeField(auto_now=True)
    autor = models.ForeignKey(
        Profissional,
        on_delete=models.SET_NULL,
        null=True,
        related_name="documentos_criados",
    )
    paciente = models.ForeignKey(
        Paciente,
        on_delete=models.CASCADE,
        related_name="documentos",
        blank=True,
        null=True,
    )
    arquivo = models.FileField(
        upload_to="documentos/",
        verbose_name="Arquivo do Documento",
        blank=True,
        null=True,
        validators=[FileExtensionValidator(allowed_extensions=["pdf"])],
    )
    status = models.CharField(
        max_length=20,
        choices=[("Pendente", "Pendente"), ("Assinado", "Assinado")],
        default="Pendente",
    )
    data_expiracao = models.DateField(
        blank=True, null=True, verbose_name="Data de ExpiraÃ§Ã£o do Documento"
    )
    hash_documento = models.CharField(
        max_length=256, verbose_name="Hash do Documento", blank=True, null=True
    )
    consentimento_informado = models.BooleanField(
        default=False, verbose_name="Consentimento Informado"
    )
    exigencias_legais = models.TextField(
        verbose_name="ExigÃªncias Legais", blank=True, null=True
    )
    versao = models.IntegerField(default=1, verbose_name="VersÃ£o do Documento")
    compliance_regulamentar = models.TextField(
        verbose_name="Conformidade Regulamentar", blank=True, null=True
    )
    associado_prontuario = models.BooleanField(
        default=False, verbose_name="Associado ao ProntuÃ¡rio"
    )
    analise_automatizada = models.TextField(
        verbose_name="AnÃ¡lise Automatizada de Risco", blank=True, null=True
    )

    class Meta:
        ordering = ["-data_criacao"]
        verbose_name = "Documento"
        verbose_name_plural = "Documentos"

    def __str__(self):
        return f"{self.titulo} - {self.get_status_display()}"

    def is_expired(self):
        # Verifica se o documento estÃ¡ expirado
        if self.data_expiracao:
            return timezone.now().date() > self.data_expiracao
        return False

    def gerar_hash_documento(self):
        # Gera o hash do documento para garantir integridade
        if self.arquivo:
            hasher = hashlib.sha256()
            with self.arquivo.open("rb") as f:
                buf = f.read()
                hasher.update(buf)
            self.hash_documento = hasher.hexdigest()
            self.save()

    def definir_expiracao_padrao(self):
        # Define uma data de expiraÃ§Ã£o padrÃ£o para o documento se nÃ£o estiver
        # definida
        if not self.data_expiracao:
            self.data_expiracao = timezone.now().date() + timedelta(days=365)
            self.save()


class Assinatura(models.Model):
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    documento = models.ForeignKey(
        Documento, on_delete=models.CASCADE, related_name="assinaturas"
    )
    assinante = models.ForeignKey(
        Profissional, on_delete=models.CASCADE, related_name="assinaturas_realizadas"
    )
    data_assinatura = models.DateTimeField(default=timezone.now)
    assinatura_eletronica = models.TextField(
        verbose_name="Assinatura EletrÃ´nica", blank=True, null=True
    )
    validade_assinatura = models.DateField(
        blank=True, null=True, verbose_name="Validade da Assinatura"
    )
    ip_assinatura = models.GenericIPAddressField(
        verbose_name="EndereÃ§o IP da Assinatura", blank=True, null=True
    )
    localizacao_assinatura = models.CharField(
        max_length=255, verbose_name="LocalizaÃ§Ã£o da Assinatura", blank=True, null=True
    )
    biometria_hash = models.CharField(
        max_length=256, verbose_name="Hash da Biometria", blank=True, null=True
    )
    dupla_autenticacao = models.BooleanField(
        default=False, verbose_name="AutenticaÃ§Ã£o em Duas Etapas"
    )
    ferramenta_dispositivo = models.CharField(
        max_length=100,
        verbose_name="Ferramenta/Dispositivo Utilizado",
        blank=True,
        null=True,
    )
    historico_eventos = models.TextField(
        verbose_name="HistÃ³rico de Eventos", blank=True, null=True
    )

    class Meta:
        ordering = ["-data_assinatura"]
        verbose_name = "Assinatura"
        verbose_name_plural = "Assinaturas"

    def __str__(self):
        return f"Assinatura de {self.assinante.nome_completo} no documento {self.documento.titulo}"

    def is_valid(self):
        # Verifica se a assinatura ainda Ã© vÃ¡lida
        if self.validade_assinatura:
            return timezone.now().date() <= self.validade_assinatura
        return True

    def gerar_assinatura_eletronica(self):
        # Gera uma assinatura eletrÃ´nica Ãºnica usando hash do documento,
        # informaÃ§Ãµes do assinante e autenticaÃ§Ã£o em duas etapas
        if self.documento and self.assinante:
            dados = f"{self.documento.hash_documento}{self.assinante.uuid}{self.data_assinatura}"
            if self.dupla_autenticacao:
                dados += "dupla_autenticacao"
            self.assinatura_eletronica = hashlib.sha256(dados.encode()).hexdigest()
            self.save()

    def validar_biometria(self, biometria_dados):
        # Valida a biometria fornecida comparando com o hash armazenado
        if biometria_dados:
            biometria_hash = hashlib.sha256(biometria_dados.encode()).hexdigest()
            return biometria_hash == self.biometria_hash
        return False

    def registrar_evento(self, evento):
        # Registra um evento no histÃ³rico de assinatura
        if self.historico_eventos:
            self.historico_eventos += f"\n{timezone.now()}: {evento}"
        else:
            self.historico_eventos = f"{timezone.now()}: {evento}"
        self.save()

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\assinaturas\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\assinaturas\serializers.py ---

# MÃ³dulo Assinaturas - Serializers (serializers.py)

from rest_framework import serializers
from .models import Documento, Assinatura
from django.utils import timezone


class DocumentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Documento
        fields = "__all__"
        read_only_fields = [
            "uuid",
            "data_criacao",
            "data_atualizacao",
            "hash_documento",
            "versao",
            "analise_automatizada",
        ]

    def validate(self, data):
        # ValidaÃ§Ã£o para garantir que a data de expiraÃ§Ã£o nÃ£o seja anterior Ã 
        # data atual
        if "data_expiracao" in data and data["data_expiracao"]:
            if data["data_expiracao"] < timezone.now().date():
                raise serializers.ValidationError(
                    "A data de expiraÃ§Ã£o nÃ£o pode ser anterior Ã  data atual."
                )
        # ValidaÃ§Ã£o de conformidade regulamentar
        if not data.get("compliance_regulamentar"):
            raise serializers.ValidationError(
                "Ã‰ necessÃ¡rio especificar a conformidade regulamentar para garantir que o documento atende aos padrÃµes legais."
            )
        # ValidaÃ§Ã£o de interoperabilidade
        if data.get("associado_prontuario") and not data.get("paciente"):
            raise serializers.ValidationError(
                "Documentos associados ao prontuÃ¡rio devem estar vinculados a um paciente."
            )
        return data

    def create(self, validated_data):
        # LÃ³gica adicional ao criar um documento, como definir a expiraÃ§Ã£o
        # padrÃ£o e gerar o hash
        documento = super().create(validated_data)
        documento.definir_expiracao_padrao()
        documento.gerar_hash_documento()
        return documento

    def update(self, instance, validated_data):
        # Atualiza a versÃ£o do documento ao fazer alteraÃ§Ãµes
        instance.versao += 1
        instance = super().update(instance, validated_data)
        instance.gerar_hash_documento()
        return instance


class AssinaturaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Assinatura
        fields = "__all__"
        read_only_fields = [
            "uuid",
            "data_assinatura",
            "assinatura_eletronica",
            "historico_eventos",
        ]

    def validate(self, data):
        # ValidaÃ§Ã£o para garantir que a assinatura eletrÃ´nica tenha integridade
        if data.get("documento") and data.get("assinante"):
            documento = data["documento"]
            if documento.is_expired():
                raise serializers.ValidationError(
                    "NÃ£o Ã© possÃ­vel assinar um documento expirado."
                )
            # ValidaÃ§Ã£o de dupla autenticaÃ§Ã£o
            if documento.consentimento_informado and not data.get("dupla_autenticacao"):
                raise serializers.ValidationError(
                    "Documentos que exigem consentimento informado precisam de autenticaÃ§Ã£o em duas etapas."
                )
        # VerificaÃ§Ã£o de integridade de assinatura com hash
        if data.get("assinatura_eletronica") and data.get("biometria_hash"):
            if not self.validar_integridade_assinatura(
                data["assinatura_eletronica"], data["biometria_hash"]
            ):
                raise serializers.ValidationError(
                    "A integridade da assinatura nÃ£o foi confirmada."
                )
        return data

    def create(self, validated_data):
        # LÃ³gica para gerar assinatura eletrÃ´nica ao criar uma assinatura
        assinatura = super().create(validated_data)
        assinatura.gerar_assinatura_eletronica()
        assinatura.registrar_evento("Assinatura criada.")
        return assinatura

    def update(self, instance, validated_data):
        # LÃ³gica adicional ao atualizar uma assinatura
        instance = super().update(instance, validated_data)
        instance.registrar_evento("Assinatura atualizada.")
        return instance

    def validar_integridade_assinatura(self, assinatura_eletronica, biometria_hash):
        # LÃ³gica simulada para validar a integridade da assinatura com base no hash armazenado
        # (Aqui pode ser feita uma validaÃ§Ã£o mais complexa em um serviÃ§o externo)
        return True

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\assinaturas\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\assinaturas\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import AssinaturaViewSet

router = DefaultRouter()
router.register(r"assinaturas", AssinaturaViewSet)


urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\assinaturas\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\assinaturas\views.py ---

# MÃ³dulo Assinaturas - Views (views.py)

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Documento, Assinatura
from .serializers import DocumentoSerializer, AssinaturaSerializer
from django.utils import timezone
import threading
from django.core.exceptions import ValidationError
import logging

logger = logging.getLogger(__name__)


def enviar_notificacao(titulo, mensagem, destinatarios):
    # FunÃ§Ã£o de envio de notificaÃ§Ã£o (placeholder)
    pass

class DocumentoViewSet(viewsets.ModelViewSet):
    queryset = Documento.objects.all()
    serializer_class = DocumentoSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna os documentos do paciente ou profissional autenticado
        user = self.request.user
        if hasattr(user, 'paciente'):
            return Documento.objects.filter(paciente=user.paciente)
        elif hasattr(user, 'profissional'):
            return Documento.objects.filter(autor=user.profissional)
        return Documento.objects.none()

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def assinar(self, request, pk=None):
        # AÃ§Ã£o para assinar um documento
        documento = self.get_object()
        if hasattr(request.user, 'profissional'):
            profissional = request.user.profissional

            # Verificar se o documento estÃ¡ expirado antes de permitir a assinatura
            if documento.is_expired():
                return Response(
                    {'detail': 'NÃ£o Ã© possÃ­vel assinar um documento expirado.'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            dados_assinatura = {
                'documento': documento.id,
                'assinante': profissional.id,
                'dupla_autenticacao': request.data.get('dupla_autenticacao', False),
                'biometria_hash': request.data.get('biometria_hash', None),
                'ip_assinatura': request.META.get('REMOTE_ADDR'),
                'localizacao_assinatura': request.data.get('localizacao_assinatura', None)
            }
            serializer = AssinaturaSerializer(data=dados_assinatura)
            try:
                serializer.is_valid(raise_exception=True)
                serializer.save()
            except ValidationError as e:
                logger.error(f"Erro ao validar assinatura: {e}")
                return Response({'detail': 'Erro ao validar assinatura.', 'errors': e.detail}, status=status.HTTP_400_BAD_REQUEST)

            # Atualiza o status do documento para "Assinado" se necessÃ¡rio
            documento.status = 'Assinado'
            documento.save()

            # Enviar notificaÃ§Ã£o para o paciente ou partes interessadas
            threading.Thread(target=enviar_notificacao, args=(
                'Documento Assinado',
                f'O documento "{documento.titulo}" foi assinado pelo profissional {profissional.nome_completo}.',
                [documento.paciente.usuario.email] if documento.paciente else []
            )).start()

            return Response({'detail': 'Documento assinado com sucesso.'}, status=status.HTTP_200_OK)
        return Response({'detail': 'PermissÃ£o negada.'}, status=status.HTTP_403_FORBIDDEN)


class AssinaturaViewSet(viewsets.ModelViewSet):
    queryset = Assinatura.objects.all()
    serializer_class = AssinaturaSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna as assinaturas do profissional autenticado
        user = self.request.user
        if hasattr(user, 'profissional'):
            return Assinatura.objects.filter(assinante=user.profissional)
        return Assinatura.objects.none()

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def validar_assinatura(self, request, pk=None):
        # AÃ§Ã£o para validar a integridade da assinatura
        assinatura = self.get_object()
        if assinatura.validar_biometria(request.data.get('biometria_dados', '')):
            return Response({'detail': 'A assinatura Ã© vÃ¡lida.'}, status=status.HTTP_200_OK)
        return Response({'detail': 'A integridade da assinatura nÃ£o foi confirmada.'}, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def cancelar_assinatura(self, request, pk=None):
        # AÃ§Ã£o para cancelar uma assinatura
        assinatura = self.get_object()
        if assinatura.assinante.usuario == request.user:
            assinatura.delete()
            assinatura.documento.status = 'Pendente'
            assinatura.documento.save()
            return Response({'detail': 'Assinatura cancelada com sucesso.'}, status=status.HTTP_200_OK)
        return Response({'detail': 'VocÃª nÃ£o tem permissÃ£o para cancelar esta assinatura.'}, status=status.HTTP_403_FORBIDDEN)

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\assinaturas\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\atendimentos\models.py ---

from django.db import models
from django.utils import timezone
from apps.pacientes.models import Paciente
from apps.profissionais.models import Profissional
from apps.agendamentos.models import Agendamento
from apps.documentos.models import DocumentosModel
from apps.financeiro.models import Transacao
from apps.assinaturas.models import Assinatura
from apps.prontuarios.models import ProcedimentoRealizado

# Ajuste o caminho conforme a localizaÃ§Ã£o do modelo
from apps.iot.models import DispositivoIoT


class Atendimento(models.Model):
    STATUS_CHOICES = [
        ("Pendente", "Pendente"),
        ("Em Andamento", "Em Andamento"),
        ("ConcluÃ­do", "ConcluÃ­do"),
        ("Cancelado", "Cancelado"),
        ("Aguardando DocumentaÃ§Ã£o", "Aguardando DocumentaÃ§Ã£o"),
        ("Aguardando Pagamento", "Aguardando Pagamento"),
    ]

    paciente = models.ForeignKey(
        Paciente, on_delete=models.CASCADE, related_name="atendimentos"
    )
    profissional = models.ForeignKey(
        Profissional, on_delete=models.CASCADE, related_name="atendimentos"
    )
    agendamento = models.OneToOneField(
        Agendamento,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="atendimento",
    )
    procedimentos = models.ManyToManyField(
        ProcedimentoRealizado, related_name="atendimentos", blank=True
    )
    dispositivos_iot = models.ManyToManyField(
        DispositivoIoT, related_name="atendimentos", blank=True
    )
    # seguro_saude = models.ForeignKey(SeguroSaude, on_delete=models.SET_NULL, null=True, blank=True, related_name='atendimentos')
    data_atendimento = models.DateField(default=timezone.now)
    horario_inicio = models.TimeField()
    horario_fim = models.TimeField()
    status = models.CharField(max_length=30, choices=STATUS_CHOICES, default="Pendente")
    diagnostico = models.TextField(null=True, blank=True)
    prescricao = models.TextField(null=True, blank=True)
    tratamento = models.TextField(null=True, blank=True)
    assinatura_profissional = models.ForeignKey(
        Assinatura,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="assinaturas_profissionais",
    )
    autorizacao_paciente = models.ForeignKey(
        Assinatura,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="autorizacoes_pacientes",
    )
    feedback_paciente = models.TextField(null=True, blank=True)
    valor = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    transacao_financeira = models.OneToOneField(
        Transacao,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="atendimento",
    )
    recomendacoes_ia = models.TextField(null=True, blank=True)
    recomendacoes_automaticas = models.TextField(null=True, blank=True)
    avaliacao_risco = models.DecimalField(
        max_digits=5, decimal_places=2, null=True, blank=True
    )
    consentimento_paciente = models.BooleanField(default=False)
    documentacao_completa = models.BooleanField(default=False)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Atendimento"
        verbose_name_plural = "Atendimentos"
        ordering = ["-data_atendimento", "-horario_inicio"]

    def __str__(self):
        return f"Atendimento de {self.paciente.nome_completo} com {self.profissional.nome_completo} em {self.data_atendimento}"

    def save(self, *args, **kwargs):
        # LÃ³gica adicional para integraÃ§Ã£o com IoT, IA e outros serviÃ§os
        if self.status == "ConcluÃ­do" and not self.transacao_financeira:
            # Cria uma transaÃ§Ã£o financeira se o atendimento for concluÃ­do
            self.transacao_financeira = Transacao.objects.create(
                paciente=self.paciente,
                valor=self.valor,
                descricao=f"Pagamento pelo atendimento em {self.data_atendimento}",
                status="Pendente",
            )

        # IntegraÃ§Ã£o com IA e Machine Learning para anÃ¡lise do atendimento
        # Exemplo: Enviar dados para serviÃ§o de IA para sugerir tratamentos ou
        # analisar feedback

        super().save(*args, **kwargs)

    def finalizar_atendimento(self):
        # MÃ©todo para finalizar o atendimento e garantir todas as validaÃ§Ãµes
        # necessÃ¡rias
        if self.status == "ConcluÃ­do":
            if not self.assinatura_profissional or not self.autorizacao_paciente:
                raise ValueError(
                    "Assinatura do profissional e autorizaÃ§Ã£o do paciente sÃ£o obrigatÃ³rias para concluir o atendimento."
                )
            if not self.diagnostico or not self.prescricao:
                raise ValueError(
                    "DiagnÃ³stico e prescriÃ§Ã£o sÃ£o obrigatÃ³rios para concluir o atendimento."
                )

        # Atualiza o status do agendamento associado
        if self.agendamento:
            self.agendamento.status = "ConcluÃ­do"
            self.agendamento.save()

        # Enviar notificaÃ§Ãµes para o paciente e profissional

        self.save()


class AuditoriaAtendimento(models.Model):
    atendimento = models.ForeignKey(
        Atendimento, on_delete=models.CASCADE, related_name="auditorias"
    )
    usuario = models.CharField(max_length=255)
    alteracoes = models.TextField()
    data_alteracao = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = "Auditoria de Atendimento"
        verbose_name_plural = "Auditorias de Atendimentos"
        ordering = ["-data_alteracao"]

    def __str__(self):
        return f"Auditoria do Atendimento {self.atendimento.id} por {self.usuario} em {self.data_alteracao}"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\atendimentos\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\atendimentos\serializers.py ---

from rest_framework import serializers
from django.utils import timezone
from .models import Atendimento
from apps.agendamentos.models import Agendamento
from apps.financeiro.models import Transacao
from apps.documentos.models import DocumentosModel


class AtendimentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Atendimento
        fields = '__all__'

    def validate(self, data):
        # ValidaÃ§Ã£o para garantir que a data e horÃ¡rio do atendimento sejam
        # futuros, caso o atendimento ainda esteja pendente
        if data['status'] == 'Pendente' and (data['data_atendimento'] < timezone.now().date() or (
            data['data_atendimento'] == timezone.now().date() and data['horario_inicio'] <= timezone.now().time())):
            raise serializers.ValidationError(
                "A data e o horÃ¡rio do atendimento pendente devem ser futuros.")

        # Garantir que a hora de fim do atendimento seja posterior Ã  hora de
        # inÃ­cio
        if data['horario_fim'] <= data['horario_inicio']:
            raise serializers.ValidationError(
                "O horÃ¡rio de fim deve ser posterior ao horÃ¡rio de inÃ­cio.")

        # ValidaÃ§Ã£o para garantir que o agendamento associado nÃ£o tenha sido
        # concluÃ­do antes do atendimento
        agendamento = data.get('agendamento')
        if agendamento and agendamento.status == 'ConcluÃ­do':
            raise serializers.ValidationError(
                "O agendamento associado jÃ¡ foi concluÃ­do e nÃ£o pode ser usado para um novo atendimento.")

        # Garantir que a assinatura do profissional e a autorizaÃ§Ã£o do paciente
        # estejam presentes ao concluir o atendimento
        if data['status'] == 'ConcluÃ­do':
            if not data.get('assinatura_profissional'):
                raise serializers.ValidationError(
                    "A assinatura do profissional Ã© obrigatÃ³ria para concluir o atendimento.")
            if not data.get('autorizacao_paciente'):
                raise serializers.ValidationError(
                    "A autorizaÃ§Ã£o do paciente Ã© obrigatÃ³ria para concluir o atendimento.")

        # Garantir que diagnÃ³stico e feedback estejam presentes ao concluir o
        # atendimento
        if data['status'] == 'ConcluÃ­do':
            if not data.get('diagnostico'):
                raise serializers.ValidationError(
                    "O diagnÃ³stico Ã© obrigatÃ³rio para concluir o atendimento.")
            if not data.get('feedback_paciente'):
                raise serializers.ValidationError(
                    "O feedback do paciente Ã© obrigatÃ³rio para concluir o atendimento.")

        return data

    def create(self, validated_data):
        # LÃ³gica adicional ao criar um atendimento, como atualizar o status do
        # agendamento relacionado
        agendamento = validated_data.get('agendamento')
        if agendamento:
            agendamento.status = 'ConcluÃ­do'
            agendamento.save()

        

        return super().create(validated_data)

    def update(self, instance, validated_data):
        # Atualizar a transaÃ§Ã£o financeira, se houver alteraÃ§Ã£o no status do
        # atendimento
        if 'status' in validated_data and validated_data[
            'status'] == 'ConcluÃ­do' and not instance.transacao_financeira:
            # Garantir que o valor do atendimento seja positivo
            valor= validated_data.get('valor', 0)
            if valor <= 0:
                raise serializers.ValidationError(
                    "O valor do atendimento deve ser positivo para criar uma transaÃ§Ã£o financeira.")

            # Criar uma transaÃ§Ã£o financeira relacionada
            transacao= Transacao.objects.create(
                paciente = instance.paciente,
                valor = valor,
                descricao = f'Pagamento pelo atendimento realizado em {instance.data_atendimento}',
                status = 'Pendente'
            )
            instance.transacao_financeira = transacao

        # Garantir que o status seja consistente com os campos obrigatÃ³rios
        if validated_data.get('status') == 'ConcluÃ­do':
            if not instance.tratamento or not instance.prescricao:
                raise serializers.ValidationError("O atendimento nÃ£o pode ser concluÃ­do sem um tratamento e uma prescriÃ§Ã£o adequados.")

       

        # Atualizar o status do agendamento para manter a consistÃªncia
        if instance.agendamento:
            instance.agendamento.status = 'ConcluÃ­do'
            instance.agendamento.save()

        return super().update(instance, validated_data)

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\atendimentos\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\atendimentos\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import AtendimentoViewSet

router = DefaultRouter()
router.register(r"atendimentos", AtendimentoViewSet, basename="atendimento")

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\atendimentos\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\atendimentos\views.py ---

# MÃ³dulo Atendimentos - Views (views.py)

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Atendimento
from .serializers import AtendimentoSerializer
from django.utils import timezone
import threading


class IsProfissional(IsAuthenticated):
    def has_permission(self, request, view):
        return super().has_permission(
    request, view) and hasattr(
        request.user, 'profissional')


class AtendimentoViewSet(viewsets.ModelViewSet):
    queryset = Atendimento.objects.all()
    serializer_class = AtendimentoSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna os atendimentos do usuÃ¡rio autenticado (paciente ou
        # profissional)
        user = self.request.user
        if hasattr(user, 'paciente'):
            return Atendimento.objects.filter(paciente=user.paciente)
        elif hasattr(user, 'profissional'):
            return Atendimento.objects.filter(profissional=user.profissional)
        return Atendimento.objects.none()

    @action(detail=True, methods=['post'], permission_classes=[IsProfissional])
    def concluir(self, request, pk=None):
        # AÃ§Ã£o para concluir um atendimento
        atendimento = self.get_object()
        if atendimento.profissional != request.user.profissional:
            return Response(
    {
        'detail': 'VocÃª nÃ£o tem permissÃ£o para concluir este atendimento.'},
         status=status.HTTP_403_FORBIDDEN)

        serializer = self.get_serializer(
    atendimento, data={
        'status': 'ConcluÃ­do'}, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        

        return Response(
            {'detail': 'Atendimento concluÃ­do com sucesso.'}, status=status.HTTP_200_OK)

    @ action(detail=False, methods=['get'],
             permission_classes=[IsAuthenticated])
    def meus_atendimentos(self, request):
        # Retorna os atendimentos do paciente ou profissional autenticado
        user= self.request.user
        if hasattr(user, 'paciente'):
            atendimentos= Atendimento.objects.filter(paciente=user.paciente)
        elif hasattr(user, 'profissional'):
            atendimentos= Atendimento.objects.filter(profissional=user.profissional)
        else:
            return Response(
    {
        'detail': 'VocÃª nÃ£o tem permissÃ£o para visualizar atendimentos.'},
         status = status.HTTP_403_FORBIDDEN)

        serializer= self.get_serializer(atendimentos, many=True)
        return Response(serializer.data)

    @ action(detail=True, methods=['post'],
             permission_classes=[IsProfissional])
    def cancelar(self, request, pk=None):
        # AÃ§Ã£o para cancelar um atendimento
        atendimento= self.get_object()
        if atendimento.profissional != request.user.profissional:
            return Response(
    {
        'detail': 'VocÃª nÃ£o tem permissÃ£o para cancelar este atendimento.'},
         status = status.HTTP_403_FORBIDDEN)

        motivo= request.data.get('motivo_cancelamento')
        if not motivo:
            return Response({'detail': 'Motivo do cancelamento deve ser informado.'},
                            status=status.HTTP_400_BAD_REQUEST)

        serializer= self.get_serializer(atendimento, data={'status': 'Cancelado'}, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

       

    @ action(detail=True, methods=['post'],
             permission_classes=[IsProfissional])
    def reagendar(self, request, pk=None):
        # AÃ§Ã£o para reagendar um atendimento
        atendimento= self.get_object()
        if atendimento.profissional != request.user.profissional:
            return Response(
    {
        'detail': 'VocÃª nÃ£o tem permissÃ£o para reagendar este atendimento.'},
         status=status.HTTP_403_FORBIDDEN)

        nova_data= request.data.get('data_atendimento')
        novo_horario_inicio= request.data.get('horario_inicio')
        novo_horario_fim= request.data.get('horario_fim')

        if not nova_data or not novo_horario_inicio or not novo_horario_fim:
            return Response({'detail': 'Dados de reagendamento incompletos.'},
                            status=status.HTTP_400_BAD_REQUEST)

        serializer= self.get_serializer(atendimento, data={
            'data_atendimento': nova_data,
            'horario_inicio': novo_horario_inicio,
            'horario_fim': novo_horario_fim,
            'status': 'Pendente'
        }, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

    #finalizzar o arquivo views.py
    

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\atendimentos\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\automacao_marketing\admin.py ---

from django.contrib import admin

# Register your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\automacao_marketing\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\automacao_marketing\apps.py ---

from django.apps import AppConfig


class Automacao_marketingConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.automacao_marketing"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\automacao_marketing\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\automacao_marketing\models.py ---

from django.db import models

# Create your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\automacao_marketing\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\automacao_marketing\views.py ---

from django.shortcuts import render

# Create your views here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\automacao_marketing\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\avaliacoes\admin.py ---

from django.contrib import admin
from .models import AvaliacoesModel


@admin.register(AvaliacoesModel)
class AvaliacoesAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\avaliacoes\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\avaliacoes\apps.py ---

from django.apps import AppConfig


class AvaliacoesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.avaliacoes"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\avaliacoes\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\avaliacoes\models.py ---

from django.db import models


class AvaliacoesModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\avaliacoes\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\avaliacoes\serializers.py ---

from rest_framework import serializers
from .models import AvaliacoesModel


class AvaliacoesSerializer(serializers.ModelSerializer):
    class Meta:
        model = AvaliacoesModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\avaliacoes\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\avaliacoes\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import AvaliacoesViewSet

router = DefaultRouter()
router.register(r"avaliacoes", AvaliacoesViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\avaliacoes\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\avaliacoes\views.py ---

from rest_framework import viewsets
from .models import AvaliacoesModel
from .serializers import AvaliacoesSerializer


class AvaliacoesViewSet(viewsets.ModelViewSet):
    queryset = AvaliacoesModel.objects.all()
    serializer_class = AvaliacoesSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\avaliacoes\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\blog\admin.py ---

from django.contrib import admin
from .models import BlogModel


@admin.register(BlogModel)
class BlogAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\blog\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\blog\apps.py ---

from django.apps import AppConfig


class BlogConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.blog"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\blog\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\blog\models.py ---

from django.db import models


class BlogModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\blog\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\blog\serializers.py ---

from rest_framework import serializers
from .models import BlogModel


class BlogSerializer(serializers.ModelSerializer):
    class Meta:
        model = BlogModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\blog\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\blog\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import BlogViewSet

router = DefaultRouter()
router.register(r"blog", BlogViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\blog\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\blog\views.py ---

from rest_framework import viewsets
from .models import BlogModel
from .serializers import BlogSerializer


class BlogViewSet(viewsets.ModelViewSet):
    queryset = BlogModel.objects.all()
    serializer_class = BlogSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\blog\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\central_ajuda\admin.py ---

from django.contrib import admin

# Register your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\central_ajuda\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\central_ajuda\apps.py ---

from django.apps import AppConfig


class Central_ajudaConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.central_ajuda"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\central_ajuda\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\central_ajuda\models.py ---

from django.db import models

# Create your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\central_ajuda\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\central_ajuda\views.py ---

from django.shortcuts import render

# Create your views here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\central_ajuda\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\chat_ao_vivo\admin.py ---

from django.contrib import admin
from .models import Chat_ao_vivoModel


@admin.register(Chat_ao_vivoModel)
class Chat_ao_vivoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\chat_ao_vivo\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\chat_ao_vivo\apps.py ---

from django.apps import AppConfig


class Chat_ao_vivoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.chat_ao_vivo"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\chat_ao_vivo\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\chat_ao_vivo\models.py ---

from django.db import models


class Chat_ao_vivoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\chat_ao_vivo\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\chat_ao_vivo\serializers.py ---

from rest_framework import serializers
from .models import Chat_ao_vivoModel


class Chat_ao_vivoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Chat_ao_vivoModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\chat_ao_vivo\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\chat_ao_vivo\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Chat_ao_vivoViewSet

router = DefaultRouter()
router.register(r"chat_ao_vivo", Chat_ao_vivoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\chat_ao_vivo\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\chat_ao_vivo\views.py ---

from rest_framework import viewsets
from .models import Chat_ao_vivoModel
from .serializers import Chat_ao_vivoSerializer


class Chat_ao_vivoViewSet(viewsets.ModelViewSet):
    queryset = Chat_ao_vivoModel.objects.all()
    serializer_class = Chat_ao_vivoSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\chat_ao_vivo\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\compras\admin.py ---

from django.contrib import admin
from .models import ComprasModel


@admin.register(ComprasModel)
class ComprasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\compras\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\compras\apps.py ---

from django.apps import AppConfig


class ComprasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.compras"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\compras\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\compras\models.py ---

from django.db import models


class ComprasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\compras\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\compras\serializers.py ---

from rest_framework import serializers
from .models import ComprasModel


class ComprasSerializer(serializers.ModelSerializer):
    class Meta:
        model = ComprasModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\compras\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\compras\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ComprasViewSet

router = DefaultRouter()
router.register(r"compras", ComprasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\compras\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\compras\views.py ---

from rest_framework import viewsets
from .models import ComprasModel
from .serializers import ComprasSerializer


class ComprasViewSet(viewsets.ModelViewSet):
    queryset = ComprasModel.objects.all()
    serializer_class = ComprasSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\compras\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\compromissos\admin.py ---

from django.contrib import admin
from .models import CompromissosModel


@admin.register(CompromissosModel)
class CompromissosAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\compromissos\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\compromissos\apps.py ---

from django.apps import AppConfig


class CompromissosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.compromissos"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\compromissos\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\compromissos\models.py ---

from django.db import models


class CompromissosModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\compromissos\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\compromissos\serializers.py ---

from rest_framework import serializers
from .models import CompromissosModel


class CompromissosSerializer(serializers.ModelSerializer):
    class Meta:
        model = CompromissosModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\compromissos\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\compromissos\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import CompromissosViewSet

router = DefaultRouter()
router.register(r"compromissos", CompromissosViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\compromissos\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\compromissos\views.py ---

from rest_framework import viewsets
from .models import CompromissosModel
from .serializers import CompromissosSerializer


class CompromissosViewSet(viewsets.ModelViewSet):
    queryset = CompromissosModel.objects.all()
    serializer_class = CompromissosSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\compromissos\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\conhecimento\admin.py ---

from django.contrib import admin

# Register your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\conhecimento\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\conhecimento\apps.py ---

from django.apps import AppConfig


class ConhecimentoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.conhecimento"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\conhecimento\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\conhecimento\models.py ---

from django.db import models

# Create your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\conhecimento\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\conhecimento\views.py ---

from django.shortcuts import render

# Create your views here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\conhecimento\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\criador_sites\admin.py ---

from django.contrib import admin
from .models import Criador_sitesModel


@admin.register(Criador_sitesModel)
class Criador_sitesAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\criador_sites\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\criador_sites\apps.py ---

from django.apps import AppConfig


class Criador_sitesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.criador_sites"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\criador_sites\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\criador_sites\models.py ---

from django.db import models


class Criador_sitesModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\criador_sites\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\criador_sites\serializers.py ---

from rest_framework import serializers
from .models import Criador_sitesModel


class Criador_sitesSerializer(serializers.ModelSerializer):
    class Meta:
        model = Criador_sitesModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\criador_sites\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\criador_sites\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Criador_sitesViewSet

router = DefaultRouter()
router.register(r"criador_sites", Criador_sitesViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\criador_sites\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\criador_sites\views.py ---

from rest_framework import viewsets
from .models import Criador_sitesModel
from .serializers import Criador_sitesSerializer


class Criador_sitesViewSet(viewsets.ModelViewSet):
    queryset = Criador_sitesModel.objects.all()
    serializer_class = Criador_sitesSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\criador_sites\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\crm\admin.py ---

from django.contrib import admin
from .models import CrmModel


@admin.register(CrmModel)
class CrmAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\crm\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\crm\apps.py ---

from django.apps import AppConfig


class CrmConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.crm"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\crm\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\crm\models.py ---

from django.db import models


class CrmModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\crm\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\crm\serializers.py ---

from rest_framework import serializers
from .models import CrmModel


class CrmSerializer(serializers.ModelSerializer):
    class Meta:
        model = CrmModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\crm\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\crm\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import CrmViewSet

router = DefaultRouter()
router.register(r"crm", CrmViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\crm\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\crm\views.py ---

from rest_framework import viewsets
from .models import CrmModel
from .serializers import CrmSerializer


class CrmViewSet(viewsets.ModelViewSet):
    queryset = CrmModel.objects.all()
    serializer_class = CrmSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\crm\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\despesas\admin.py ---

from django.contrib import admin
from .models import DespesasModel


@admin.register(DespesasModel)
class DespesasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\despesas\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\despesas\apps.py ---

from django.apps import AppConfig


class DespesasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.despesas"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\despesas\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\despesas\models.py ---

from django.db import models


class DespesasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\despesas\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\despesas\serializers.py ---

from rest_framework import serializers
from .models import DespesasModel


class DespesasSerializer(serializers.ModelSerializer):
    class Meta:
        model = DespesasModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\despesas\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\despesas\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import DespesasViewSet

router = DefaultRouter()
router.register(r"despesas", DespesasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\despesas\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\despesas\views.py ---

from rest_framework import viewsets
from .models import DespesasModel
from .serializers import DespesasSerializer


class DespesasViewSet(viewsets.ModelViewSet):
    queryset = DespesasModel.objects.all()
    serializer_class = DespesasSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\despesas\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\documentos\admin.py ---

from django.contrib import admin
from .models import DocumentosModel


@admin.register(DocumentosModel)
class DocumentosAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\documentos\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\documentos\apps.py ---

from django.apps import AppConfig


class DocumentosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.documentos"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\documentos\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\documentos\models.py ---

from django.db import models
from django.utils.translation import gettext_lazy as _


class DocumentosModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = _("Documento")
        verbose_name_plural = _("Documentos")
        app_label = "documentos"

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\documentos\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\documentos\serializers.py ---

from rest_framework import serializers
from .models import DocumentosModel


class DocumentosSerializer(serializers.ModelSerializer):
    class Meta:
        model = DocumentosModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\documentos\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\documentos\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import DocumentosViewSet

router = DefaultRouter()
router.register(r"documentos", DocumentosViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\documentos\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\documentos\views.py ---

from rest_framework import viewsets
from .models import DocumentosModel
from .serializers import DocumentosSerializer


class DocumentosViewSet(viewsets.ModelViewSet):
    queryset = DocumentosModel.objects.all()
    serializer_class = DocumentosSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\documentos\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\ecommerce\admin.py ---

from django.contrib import admin
from .models import EcommerceModel


@admin.register(EcommerceModel)
class EcommerceAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\ecommerce\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\ecommerce\apps.py ---

from django.apps import AppConfig


class EcommerceConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.ecommerce"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\ecommerce\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\ecommerce\models.py ---

from django.db import models


class EcommerceModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\ecommerce\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\ecommerce\serializers.py ---

from rest_framework import serializers
from .models import EcommerceModel


class EcommerceSerializer(serializers.ModelSerializer):
    class Meta:
        model = EcommerceModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\ecommerce\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\ecommerce\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import EcommerceViewSet

router = DefaultRouter()
router.register(r"ecommerce", EcommerceViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\ecommerce\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\ecommerce\views.py ---

from rest_framework import viewsets
from .models import EcommerceModel
from .serializers import EcommerceSerializer


class EcommerceViewSet(viewsets.ModelViewSet):
    queryset = EcommerceModel.objects.all()
    serializer_class = EcommerceSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\ecommerce\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\elearning\admin.py ---

from django.contrib import admin
from .models import ElearningModel


@admin.register(ElearningModel)
class ElearningAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\elearning\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\elearning\apps.py ---

from django.apps import AppConfig


class ElearningConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.elearning"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\elearning\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\elearning\models.py ---

from django.db import models


class ElearningModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\elearning\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\elearning\serializers.py ---

from rest_framework import serializers
from .models import ElearningModel


class ElearningSerializer(serializers.ModelSerializer):
    class Meta:
        model = ElearningModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\elearning\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\elearning\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ElearningViewSet

router = DefaultRouter()
router.register(r"elearning", ElearningViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\elearning\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\elearning\views.py ---

from rest_framework import viewsets
from .models import ElearningModel
from .serializers import ElearningSerializer


class ElearningViewSet(viewsets.ModelViewSet):
    queryset = ElearningModel.objects.all()
    serializer_class = ElearningSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\elearning\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\eventos\admin.py ---

from django.contrib import admin

# Register your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\eventos\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\eventos\apps.py ---

from django.apps import AppConfig


class EventosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.eventos"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\eventos\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\eventos\models.py ---

from django.db import models

# Create your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\eventos\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\eventos\views.py ---

from django.shortcuts import render

# Create your views here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\eventos\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\exames\models.py ---

# MÃ³dulo Exames - Models (models.py)

from django.db import models
from django.utils import timezone
import uuid
from apps.pacientes.models import Paciente
from apps.profissionais.models import Profissional
from apps.documentos.models import DocumentosModel


class Exame(models.Model):
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    paciente = models.ForeignKey(
        Paciente, on_delete=models.CASCADE, related_name="exames"
    )
    profissional_solicitante = models.ForeignKey(
    Profissional,
    on_delete=models.SET_NULL,
    null=True,
    related_name="exames_solicitados_exame",  # Alterar para um nome Ãºnico
    verbose_name="Profissional Solicitante",
)

    tipo_exame = models.CharField(max_length=100, verbose_name="Tipo de Exame")
    data_solicitacao = models.DateField(
        default=timezone.now, verbose_name="Data de SolicitaÃ§Ã£o"
    )
    data_realizacao = models.DateField(
        blank=True, null=True, verbose_name="Data de RealizaÃ§Ã£o"
    )
    resultados = models.TextField(
        verbose_name="Resultados do Exame", blank=True, null=True
    )
    documento_resultado = models.ForeignKey(
        DocumentosModel,
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
        related_name="exames_resultados",
        verbose_name="Documento do Resultado",
    )
    observacoes = models.TextField(verbose_name="ObservaÃ§Ãµes", blank=True, null=True)
    status = models.CharField(
        max_length=20,
        choices=[
            ("Solicitado", "Solicitado"),
            ("Realizado", "Realizado"),
            ("Cancelado", "Cancelado"),
        ],
        default="Solicitado",
    )
    data_criacao = models.DateTimeField(auto_now_add=True)
    data_atualizacao = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["-data_solicitacao"]
        verbose_name = "Exame"
        verbose_name_plural = "Exames"

    def __str__(self):
        return f"Exame {self.tipo_exame} de {self.paciente.nome_completo}"

    def is_realizado(self):
        return self.status == "Realizado"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\exames\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\exames\serializers.py ---

# MÃ³dulo Exames - Serializers (serializers.py)

from rest_framework import serializers
from .models import Exame


class ExameSerializer(serializers.ModelSerializer):
    class Meta:
        model = Exame
        fields = "__all__"
        read_only_fields = ["data_criacao", "data_atualizacao"]

    def validate(self, data):
        # ValidaÃ§Ã£o para garantir que a data de realizaÃ§Ã£o nÃ£o seja anterior Ã 
        # data de solicitaÃ§Ã£o
        if "data_realizacao" in data and data["data_realizacao"]:
            if data["data_realizacao"] < data["data_solicitacao"]:
                raise serializers.ValidationError(
                    "A data de realizaÃ§Ã£o nÃ£o pode ser anterior Ã  data de solicitaÃ§Ã£o do exame."
                )

        # ValidaÃ§Ã£o para garantir que se o exame estiver realizado, a data de
        # realizaÃ§Ã£o deve estar preenchida
        if data.get("status") == "Realizado" and not data.get("data_realizacao"):
            raise serializers.ValidationError(
                "A data de realizaÃ§Ã£o deve ser informada quando o status for 'Realizado'."
            )

        # ValidaÃ§Ã£o para garantir que se o exame estiver realizado, o documento
        # do resultado deve estar presente
        if data.get("status") == "Realizado" and not data.get("documento_resultado"):
            raise serializers.ValidationError(
                "O documento do resultado deve ser anexado quando o status for 'Realizado'."
            )

        return data

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\exames\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\exames\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ExameViewSet

router = DefaultRouter()
router.register(r"examess", ExameViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\exames\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\exames\views.py ---

# MÃ³dulo Exames - Views (views.py)

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Exame
from .serializers import ExameSerializer
from django.utils import timezone
import threading


class ExameViewSet(viewsets.ModelViewSet):
    queryset = Exame.objects.all()
    serializer_class = ExameSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        # Retorna os exames do paciente autenticado ou exames solicitados por
        # um profissional autenticado
        user = self.request.user
        if hasattr(user, 'paciente'):
            return Exame.objects.filter(paciente=user.paciente)
        elif hasattr(user, 'profissional'):
            return Exame.objects.filter(
    profissional_solicitante=user.profissional)
        return Exame.objects.none()

    @action(detail=True, methods=['post'],
            permission_classes=[IsAuthenticated])
    def registrar_resultado(self, request, pk=None):
        # AÃ§Ã£o para registrar o resultado de um exame
        exame = self.get_object()
        if hasattr(
    request.user,
     'profissional') and exame.profissional_solicitante != request.user.profissional:
            return Response(
    {
        'detail': 'VocÃª nÃ£o tem permissÃ£o para registrar o resultado deste exame.'},
         status=status.HTTP_403_FORBIDDEN)

        serializer = self.get_serializer(
    exame, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        # Adicionar integraÃ§Ã£o com Machine Learning para anÃ¡lise dos resultados
        self.analisar_resultados(exame)

        return Response(
            {'detail': 'Resultado do exame registrado com sucesso.'}, status=status.HTTP_200_OK)

    def analisar_resultados(self, exame):
        # IntegraÃ§Ã£o com Machine Learning para analisar resultados de exames
        # SimulaÃ§Ã£o de chamada para um serviÃ§o de IA que analisa os resultados
        # do exame
        if exame.resultados:
            threading.Thread(
    target=self.enviar_para_analise_ml, args=(
        exame,)).start()

    def enviar_para_analise_ml(self, exame):
        # SimulaÃ§Ã£o de envio dos resultados do exame para um serviÃ§o de Machine Learning
        # Aqui pode ser feita a integraÃ§Ã£o com um serviÃ§o externo de anÃ¡lise de
        # saÃºde
        print(
            f"Enviando resultados do exame {exame.tipo_exame} para anÃ¡lise de IA.")
        # Implementar a lÃ³gica real de integraÃ§Ã£o aqui

    @ action(detail=True, methods=['post'],
             permission_classes=[IsAuthenticated])
    def cancelar_exame(self, request, pk=None):
        # AÃ§Ã£o para cancelar um exame
        exame= self.get_object()
        if hasattr(
    request.user,
     'profissional') and exame.profissional_solicitante != request.user.profissional:
            return Response(
    {
        'detail': 'VocÃª nÃ£o tem permissÃ£o para cancelar este exame.'},
         status = status.HTTP_403_FORBIDDEN)

        exame.status= 'Cancelado'
        exame.save()

        
        return Response({'detail': 'Exame cancelado com sucesso.'},
                        status=status.HTTP_200_OK)

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\exames\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\fabricacao\admin.py ---

from django.contrib import admin
from .models import FabricacaoModel


@admin.register(FabricacaoModel)
class FabricacaoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\fabricacao\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\fabricacao\apps.py ---

from django.apps import AppConfig


class FabricacaoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.fabricacao"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\fabricacao\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\fabricacao\models.py ---

from django.db import models


class FabricacaoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\fabricacao\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\fabricacao\serializers.py ---

from rest_framework import serializers
from .models import FabricacaoModel


class FabricacaoSerializer(serializers.ModelSerializer):
    class Meta:
        model = FabricacaoModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\fabricacao\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\fabricacao\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import FabricacaoViewSet

router = DefaultRouter()
router.register(r"fabricacao", FabricacaoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\fabricacao\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\fabricacao\views.py ---

from rest_framework import viewsets
from .models import FabricacaoModel
from .serializers import FabricacaoSerializer


class FabricacaoViewSet(viewsets.ModelViewSet):
    queryset = FabricacaoModel.objects.all()
    serializer_class = FabricacaoSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\fabricacao\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\faturamento\admin.py ---

from django.contrib import admin
from .models import FaturamentoModel


@admin.register(FaturamentoModel)
class FaturamentoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\faturamento\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\faturamento\apps.py ---

from django.apps import AppConfig


class FaturamentoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.faturamento"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\faturamento\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\faturamento\models.py ---

from django.db import models


class FaturamentoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\faturamento\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\faturamento\serializers.py ---

from rest_framework import serializers
from .models import FaturamentoModel


class FaturamentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = FaturamentoModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\faturamento\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\faturamento\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import FaturamentoViewSet

router = DefaultRouter()
router.register(r"faturamento", FaturamentoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\faturamento\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\faturamento\views.py ---

from rest_framework import viewsets
from .models import FaturamentoModel
from .serializers import FaturamentoSerializer


class FaturamentoViewSet(viewsets.ModelViewSet):
    queryset = FaturamentoModel.objects.all()
    serializer_class = FaturamentoSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\faturamento\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\financeiro\admin.py ---

from django.contrib import admin
from .models import Transacao


@admin.register(Transacao)
class TransacaoAdmin(admin.ModelAdmin):
    list_display = ("descricao", "valor", "data", "categoria", "tipo")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\financeiro\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\financeiro\apps.py ---

from django.apps import AppConfig


class FinanceiroConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.financeiro"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\financeiro\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\financeiro\models.py ---

from django.db import models


class Transacao(models.Model):
    descricao = models.CharField(max_length=255)
    valor = models.DecimalField(max_digits=10, decimal_places=2)
    data = models.DateField()
    categoria = models.CharField(max_length=100)
    tipo = models.CharField(
        max_length=50, choices=[("receita", "Receita"), ("despesa", "Despesa")]
    )

    def __str__(self):
        return f"{self.descricao} - {self.valor}"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\financeiro\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\financeiro\serializers.py ---

from rest_framework import serializers
from .models import Transacao


class TransacaoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Transacao
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\financeiro\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\financeiro\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import TransacaoViewSet

router = DefaultRouter()
router.register(r"transacoes", TransacaoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\financeiro\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\financeiro\views.py ---

from rest_framework import viewsets
from .models import Transacao
from .serializers import TransacaoSerializer


class TransacaoViewSet(viewsets.ModelViewSet):
    queryset = Transacao.objects.all()
    serializer_class = TransacaoSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\financeiro\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\folgas\admin.py ---

from django.contrib import admin
from .models import FolgasModel


@admin.register(FolgasModel)
class FolgasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\folgas\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\folgas\apps.py ---

from django.apps import AppConfig


class FolgasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.folgas"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\folgas\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\folgas\models.py ---

from django.db import models


class FolgasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\folgas\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\folgas\serializers.py ---

from rest_framework import serializers
from .models import FolgasModel


class FolgasSerializer(serializers.ModelSerializer):
    class Meta:
        model = FolgasModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\folgas\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\folgas\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import FolgasViewSet

router = DefaultRouter()
router.register(r"folgas", FolgasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\folgas\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\folgas\views.py ---

from rest_framework import viewsets
from .models import FolgasModel
from .serializers import FolgasSerializer


class FolgasViewSet(viewsets.ModelViewSet):
    queryset = FolgasModel.objects.all()
    serializer_class = FolgasSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\folgas\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\forum\admin.py ---

from django.contrib import admin
from .models import ForumModel


@admin.register(ForumModel)
class ForumAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\forum\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\forum\apps.py ---

from django.apps import AppConfig


class ForumConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.forum"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\forum\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\forum\models.py ---

from django.db import models


class ForumModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\forum\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\forum\serializers.py ---

from rest_framework import serializers
from .models import ForumModel


class ForumSerializer(serializers.ModelSerializer):
    class Meta:
        model = ForumModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\forum\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\forum\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ForumViewSet

router = DefaultRouter()
router.register(r"forum", ForumViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\forum\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\forum\views.py ---

from rest_framework import viewsets
from .models import ForumModel
from .serializers import ForumSerializer


class ForumViewSet(viewsets.ModelViewSet):
    queryset = ForumModel.objects.all()
    serializer_class = ForumSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\forum\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\frota\admin.py ---

from django.contrib import admin
from .models import FrotaModel


@admin.register(FrotaModel)
class FrotaAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\frota\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\frota\apps.py ---

from django.apps import AppConfig


class FrotaConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.frota"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\frota\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\frota\models.py ---

from django.db import models


class FrotaModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\frota\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\frota\serializers.py ---

from rest_framework import serializers
from .models import FrotaModel


class FrotaSerializer(serializers.ModelSerializer):
    class Meta:
        model = FrotaModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\frota\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\frota\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import FrotaViewSet

router = DefaultRouter()
router.register(r"frota", FrotaViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\frota\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\frota\views.py ---

from rest_framework import viewsets
from .models import FrotaModel
from .serializers import FrotaSerializer


class FrotaViewSet(viewsets.ModelViewSet):
    queryset = FrotaModel.objects.all()
    serializer_class = FrotaSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\frota\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\indicacoes\admin.py ---

from django.contrib import admin
from .models import IndicacoesModel


@admin.register(IndicacoesModel)
class IndicacoesAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\indicacoes\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\indicacoes\apps.py ---

from django.apps import AppConfig


class IndicacoesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.indicacoes"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\indicacoes\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\indicacoes\models.py ---

from django.db import models


class IndicacoesModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\indicacoes\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\indicacoes\serializers.py ---

from rest_framework import serializers
from .models import IndicacoesModel


class IndicacoesSerializer(serializers.ModelSerializer):
    class Meta:
        model = IndicacoesModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\indicacoes\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\indicacoes\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import IndicacoesViewSet

router = DefaultRouter()
router.register(r"indicacoes", IndicacoesViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\indicacoes\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\indicacoes\views.py ---

from rest_framework import viewsets
from .models import IndicacoesModel
from .serializers import IndicacoesSerializer


class IndicacoesViewSet(viewsets.ModelViewSet):
    queryset = IndicacoesModel.objects.all()
    serializer_class = IndicacoesSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\indicacoes\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\inventario\admin.py ---

from django.contrib import admin
from .models import InventarioModel


@admin.register(InventarioModel)
class InventarioAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\inventario\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\inventario\apps.py ---

from django.apps import AppConfig


class InventarioConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.inventario"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\inventario\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\inventario\models.py ---

from django.db import models


class InventarioModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\inventario\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\inventario\serializers.py ---

from rest_framework import serializers
from .models import InventarioModel


class InventarioSerializer(serializers.ModelSerializer):
    class Meta:
        model = InventarioModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\inventario\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\inventario\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import InventarioViewSet

router = DefaultRouter()
router.register(r"inventario", InventarioViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\inventario\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\inventario\views.py ---

from rest_framework import viewsets
from .models import InventarioModel
from .serializers import InventarioSerializer


class InventarioViewSet(viewsets.ModelViewSet):
    queryset = InventarioModel.objects.all()
    serializer_class = InventarioSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\inventario\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\iot\admin.py ---

from django.contrib import admin

# Register your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\iot\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\iot\apps.py ---

from django.apps import AppConfig


class IotConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.iot"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\iot\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\iot\models.py ---

from django.db import models


class DispositivoIoT(models.Model):
    nome = models.CharField(max_length=255, verbose_name="Nome do Dispositivo")
    descricao = models.TextField(blank=True, verbose_name="DescriÃ§Ã£o")
    status = models.CharField(
        max_length=100,
        choices=[("ativo", "Ativo"), ("inativo", "Inativo")],
        default="ativo",
    )
    data_registro = models.DateTimeField(
        auto_now_add=True, verbose_name="Data de Registro"
    )
    ultima_comunicacao = models.DateTimeField(
        blank=True, null=True, verbose_name="Ãšltima ComunicaÃ§Ã£o"
    )

    class Meta:
        verbose_name = "Dispositivo IoT"
        verbose_name_plural = "Dispositivos IoT"

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\iot\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\iot\views.py ---

from django.shortcuts import render

# Create your views here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\iot\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\locacao\admin.py ---

from django.contrib import admin
from .models import LocacaoModel


@admin.register(LocacaoModel)
class LocacaoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\locacao\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\locacao\apps.py ---

from django.apps import AppConfig


class LocacaoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.locacao"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\locacao\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\locacao\models.py ---

from django.db import models


class LocacaoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\locacao\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\locacao\serializers.py ---

from rest_framework import serializers
from .models import LocacaoModel


class LocacaoSerializer(serializers.ModelSerializer):
    class Meta:
        model = LocacaoModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\locacao\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\locacao\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import LocacaoViewSet

router = DefaultRouter()
router.register(r"locacao", LocacaoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\locacao\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\locacao\views.py ---

from rest_framework import viewsets
from .models import LocacaoModel
from .serializers import LocacaoSerializer


class LocacaoViewSet(viewsets.ModelViewSet):
    queryset = LocacaoModel.objects.all()
    serializer_class = LocacaoSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\locacao\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\manutencao\admin.py ---

from django.contrib import admin
from .models import ManutencaoModel


@admin.register(ManutencaoModel)
class ManutencaoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\manutencao\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\manutencao\apps.py ---

from django.apps import AppConfig


class ManutencaoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.manutencao"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\manutencao\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\manutencao\models.py ---

from django.db import models


class ManutencaoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\manutencao\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\manutencao\serializers.py ---

from rest_framework import serializers
from .models import ManutencaoModel


class ManutencaoSerializer(serializers.ModelSerializer):
    class Meta:
        model = ManutencaoModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\manutencao\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\manutencao\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ManutencaoViewSet

router = DefaultRouter()
router.register(r"manutencao", ManutencaoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\manutencao\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\manutencao\views.py ---

from rest_framework import viewsets
from .models import ManutencaoModel
from .serializers import ManutencaoSerializer


class ManutencaoViewSet(viewsets.ModelViewSet):
    queryset = ManutencaoModel.objects.all()
    serializer_class = ManutencaoSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\manutencao\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\marketing_email\admin.py ---

from django.contrib import admin
from .models import Marketing_emailModel


@admin.register(Marketing_emailModel)
class Marketing_emailAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\marketing_email\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\marketing_email\apps.py ---

from django.apps import AppConfig


class Marketing_emailConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.marketing_email"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\marketing_email\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\marketing_email\models.py ---

from django.db import models


class Marketing_emailModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\marketing_email\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\marketing_email\serializers.py ---

from rest_framework import serializers
from .models import Marketing_emailModel


class Marketing_emailSerializer(serializers.ModelSerializer):
    class Meta:
        model = Marketing_emailModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\marketing_email\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\marketing_email\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Marketing_emailViewSet

router = DefaultRouter()
router.register(r"marketing_email", Marketing_emailViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\marketing_email\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\marketing_email\views.py ---

from rest_framework import viewsets
from .models import Marketing_emailModel
from .serializers import Marketing_emailSerializer


class Marketing_emailViewSet(viewsets.ModelViewSet):
    queryset = Marketing_emailModel.objects.all()
    serializer_class = Marketing_emailSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\marketing_email\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\marketing_sms\admin.py ---

from django.contrib import admin
from .models import Marketing_smsModel


@admin.register(Marketing_smsModel)
class Marketing_smsAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\marketing_sms\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\marketing_sms\apps.py ---

from django.apps import AppConfig


class Marketing_smsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.marketing_sms"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\marketing_sms\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\marketing_sms\models.py ---

from django.db import models


class Marketing_smsModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\marketing_sms\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\marketing_sms\serializers.py ---

from rest_framework import serializers
from .models import Marketing_smsModel


class Marketing_smsSerializer(serializers.ModelSerializer):
    class Meta:
        model = Marketing_smsModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\marketing_sms\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\marketing_sms\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Marketing_smsViewSet

router = DefaultRouter()
router.register(r"marketing_sms", Marketing_smsViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\marketing_sms\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\marketing_sms\views.py ---

from rest_framework import viewsets
from .models import Marketing_smsModel
from .serializers import Marketing_smsSerializer


class Marketing_smsViewSet(viewsets.ModelViewSet):
    queryset = Marketing_smsModel.objects.all()
    serializer_class = Marketing_smsSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\marketing_sms\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\mensagens\admin.py ---

from django.contrib import admin
from .models import MensagensModel


@admin.register(MensagensModel)
class MensagensAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\mensagens\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\mensagens\apps.py ---

from django.apps import AppConfig


class MensagensConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.mensagens"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\mensagens\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\mensagens\models.py ---

from django.db import models


class MensagensModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\mensagens\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\mensagens\serializers.py ---

from rest_framework import serializers
from .models import MensagensModel


class MensagensSerializer(serializers.ModelSerializer):
    class Meta:
        model = MensagensModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\mensagens\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\mensagens\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import MensagensViewSet

router = DefaultRouter()
router.register(r"mensagens", MensagensViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\mensagens\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\mensagens\views.py ---

from rest_framework import viewsets
from .models import MensagensModel
from .serializers import MensagensSerializer


class MensagensViewSet(viewsets.ModelViewSet):
    queryset = MensagensModel.objects.all()
    serializer_class = MensagensSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\mensagens\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\pacientes\admin.py ---

from django.contrib import admin
from .models import Paciente

admin.site.register(Paciente)

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\pacientes\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\pacientes\apps.py ---

from django.apps import AppConfig


class PacientesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.pacientes"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\pacientes\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\pacientes\models.py ---

from cryptography.fernet import Fernet
from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _
import uuid
from django.utils import timezone

# Gerar uma chave de criptografia para uso nos campos sensÃ­veis (a chave deve ser armazenada em um local seguro)
# Aqui estamos simulando a recuperaÃ§Ã£o da chave do arquivo de configuraÃ§Ãµes
cipher_suite = Fernet(settings.ENCRYPTION_KEY)


class Paciente(models.Model):
    # Identificador Ãšnico Global
    uuid = models.UUIDField(unique=True, editable=False, default=uuid.uuid4)


    # Dados Pessoais
    nome_completo = models.CharField(_("Nome Completo"), max_length=255)
    foto = models.ImageField(
        _("Foto"), upload_to="pacientes/fotos/", blank=True, null=True
    )
    cpf = models.CharField(_("CPF"), max_length=255, unique=True)
    rg = models.CharField(_("RG"), max_length=255, blank=True)
    data_nascimento = models.DateField(_("Data de Nascimento"))
    sexo = models.CharField(
        _("Sexo"),
        max_length=1,
        choices=[
            ("M", "Masculino"),
            ("F", "Feminino"),
            ("O", "Outro"),
        ],
    )
    estado_civil = models.CharField(_("Estado Civil"), max_length=50, blank=True)
    profissao = models.CharField(_("ProfissÃ£o"), max_length=100, blank=True)
    nacionalidade = models.CharField(_("Nacionalidade"), max_length=100, blank=True)
    naturalidade = models.CharField(_("Naturalidade"), max_length=100, blank=True)
    endereco = models.CharField(_("EndereÃ§o"), max_length=255)
    numero = models.CharField(_("NÃºmero"), max_length=10)
    complemento = models.CharField(_("Complemento"), max_length=100, blank=True)
    bairro = models.CharField(_("Bairro"), max_length=100)
    cidade = models.CharField(_("Cidade"), max_length=100)
    estado = models.CharField(_("Estado"), max_length=100)
    cep = models.CharField(_("CEP"), max_length=9, blank=True)
    telefone_residencial = models.CharField(
        _("Telefone Residencial"), max_length=20, blank=True
    )
    telefone_celular = models.CharField(
        _("Telefone Celular"), max_length=20, blank=True
    )
    email = models.EmailField(_("E-mail"), blank=True)
    contato_emergencia = models.CharField(
        _("Contato de EmergÃªncia"), max_length=255, blank=True
    )
    telefone_emergencia = models.CharField(
        _("Telefone de EmergÃªncia"), max_length=20, blank=True
    )

    # Dados Complementares
    nome_mae = models.CharField(_("Nome da MÃ£e"), max_length=255, blank=True)
    nome_pai = models.CharField(_("Nome do Pai"), max_length=255, blank=True)
    consentimento_lgpd = models.BooleanField(_("Consentimento LGPD"), default=False)
    observacoes = models.TextField(_("ObservaÃ§Ãµes"), blank=True)

    # Relacionamentos
    prontuario = models.OneToOneField(
    "prontuarios.Prontuario",
    on_delete=models.SET_NULL,
    null=True,
    blank=True,
    related_name="paciente_prontuario",  
)

    

    # Auditoria
    created_at = models.DateTimeField(_("Data de CriaÃ§Ã£o"), default=timezone.now)

    updated_at = models.DateTimeField(_("Ãšltima AtualizaÃ§Ã£o"), auto_now=True)

    class Meta:
        app_label = "pacientes"
        verbose_name = _("Paciente")
        verbose_name_plural = _("Pacientes")

    def __str__(self):
        return self.nome_completo

    def save(self, *args, **kwargs):
        # Criptografar CPF e RG antes de salvar
        if self.cpf:
            self.cpf = cipher_suite.encrypt(self.cpf.encode()).decode()
        if self.rg:
            self.rg = cipher_suite.encrypt(self.rg.encode()).decode()
        super().save(*args, **kwargs)

    def decrypt_cpf(self):
        # Descriptografar o CPF para uso
        if self.cpf:
            return cipher_suite.decrypt(self.cpf.encode()).decode()
        return None

    def decrypt_rg(self):
        # Descriptografar o RG para uso
        if self.rg:
            return cipher_suite.decrypt(self.rg.encode()).decode()
        return None

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\pacientes\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\pacientes\serializers.py ---

# Incremento 2: Melhorias no Serializador (serializers.py)

from rest_framework import serializers
from .models import Paciente
from django.core.validators import validate_email
import re


class PacienteSerializer(serializers.ModelSerializer):
    class Meta:
        model = Paciente
        fields = [
            "uuid",
            "nome_completo",
            "foto",
            "data_nascimento",
            "sexo",
            "estado_civil",
            "profissao",
            "nacionalidade",
            "naturalidade",
            "endereco",
            "numero",
            "complemento",
            "bairro",
            "cidade",
            "estado",
            "cep",
            "telefone_residencial",
            "telefone_celular",
            "email",
            "contato_emergencia",
            "telefone_emergencia",
            "nome_mae",
            "nome_pai",
            "consentimento_lgpd",
            "observacoes",
            "created_at",
            "updated_at",
        ]
        read_only_fields = ["created_at", "updated_at"]

    def validate_cpf(self, value):
        # ValidaÃ§Ã£o simples de CPF (apenas para garantir formato vÃ¡lido)
        if not re.match(r"\d{3}\.\d{3}\.\d{3}-\d{2}", value):
            raise serializers.ValidationError(
                "CPF deve estar no formato XXX.XXX.XXX-XX"
            )
        return value

    def validate_email(self, value):
        # ValidaÃ§Ã£o de e-mail
        try:
            validate_email(value)
        except BaseException:
            raise serializers.ValidationError("E-mail invÃ¡lido")
        return value

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\pacientes\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\pacientes\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PacienteViewSet

router = DefaultRouter()
router.register(r"pacientes", PacienteViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\pacientes\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\pacientes\views.py ---

# Incremento 3: Melhorias nas VisualizaÃ§Ãµes (views.py)

from rest_framework import viewsets, permissions, filters
from rest_framework.pagination import PageNumberPagination
from django_filters.rest_framework import DjangoFilterBackend
from .models import Paciente
from .serializers import PacienteSerializer


class PacientePagination(PageNumberPagination):
    page_size = 10
    page_size_query_param = "page_size"
    max_page_size = 100


class PacienteViewSet(viewsets.ModelViewSet):
    queryset = Paciente.objects.all()
    serializer_class = PacienteSerializer
    permission_classes = [permissions.IsAuthenticated]
    pagination_class = PacientePagination
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]
    filterset_fields = ["sexo", "estado_civil", "cidade", "estado"]
    search_fields = ["nome_completo", "cpf", "email"]
    ordering_fields = ["nome_completo", "data_nascimento", "created_at"]
    ordering = ["nome_completo"]

    def get_permissions(self):
        if self.action in ["list", "retrieve"]:
            return [permissions.IsAuthenticated()]
        return [permissions.IsAdminUser()]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\pacientes\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\pesquisas\admin.py ---

from django.contrib import admin

# Register your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\pesquisas\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\pesquisas\apps.py ---

from django.apps import AppConfig


class PesquisasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.pesquisas"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\pesquisas\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\pesquisas\models.py ---

from django.db import models

# Create your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\pesquisas\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\pesquisas\views.py ---

from django.shortcuts import render

# Create your views here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\pesquisas\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\planilhas\admin.py ---

from django.contrib import admin
from .models import PlanilhasModel


@admin.register(PlanilhasModel)
class PlanilhasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\planilhas\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\planilhas\apps.py ---

from django.apps import AppConfig


class PlanilhasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.planilhas"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\planilhas\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\planilhas\models.py ---

from django.db import models


class PlanilhasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\planilhas\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\planilhas\serializers.py ---

from rest_framework import serializers
from .models import PlanilhasModel


class PlanilhasSerializer(serializers.ModelSerializer):
    class Meta:
        model = PlanilhasModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\planilhas\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\planilhas\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PlanilhasViewSet

router = DefaultRouter()
router.register(r"planilhas", PlanilhasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\planilhas\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\planilhas\views.py ---

from rest_framework import viewsets
from .models import PlanilhasModel
from .serializers import PlanilhasSerializer


class PlanilhasViewSet(viewsets.ModelViewSet):
    queryset = PlanilhasModel.objects.all()
    serializer_class = PlanilhasSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\planilhas\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\planilhas_horas\admin.py ---

from django.contrib import admin
from .models import Planilhas_horasModel


@admin.register(Planilhas_horasModel)
class Planilhas_horasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\planilhas_horas\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\planilhas_horas\apps.py ---

from django.apps import AppConfig


class Planilhas_horasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.planilhas_horas"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\planilhas_horas\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\planilhas_horas\models.py ---

from django.db import models


class Planilhas_horasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\planilhas_horas\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\planilhas_horas\serializers.py ---

from rest_framework import serializers
from .models import Planilhas_horasModel


class Planilhas_horasSerializer(serializers.ModelSerializer):
    class Meta:
        model = Planilhas_horasModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\planilhas_horas\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\planilhas_horas\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Planilhas_horasViewSet

router = DefaultRouter()
router.register(r"planilhas_horas", Planilhas_horasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\planilhas_horas\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\planilhas_horas\views.py ---

from rest_framework import viewsets
from .models import Planilhas_horasModel
from .serializers import Planilhas_horasSerializer


class Planilhas_horasViewSet(viewsets.ModelViewSet):
    queryset = Planilhas_horasModel.objects.all()
    serializer_class = Planilhas_horasSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\planilhas_horas\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\plm\admin.py ---

from django.contrib import admin
from .models import PlmModel


@admin.register(PlmModel)
class PlmAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\plm\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\plm\apps.py ---

from django.apps import AppConfig


class PlmConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.plm"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\plm\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\plm\models.py ---

from django.db import models


class PlmModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\plm\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\plm\serializers.py ---

from rest_framework import serializers
from .models import PlmModel


class PlmSerializer(serializers.ModelSerializer):
    class Meta:
        model = PlmModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\plm\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\plm\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PlmViewSet

router = DefaultRouter()
router.register(r"plm", PlmViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\plm\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\plm\views.py ---

from rest_framework import viewsets
from .models import PlmModel
from .serializers import PlmSerializer


class PlmViewSet(viewsets.ModelViewSet):
    queryset = PlmModel.objects.all()
    serializer_class = PlmSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\plm\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\produtividade\admin.py ---

from django.contrib import admin

# Register your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\produtividade\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\produtividade\apps.py ---

from django.apps import AppConfig


class ProdutividadeConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.produtividade"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\produtividade\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\produtividade\models.py ---

from django.db import models

# Create your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\produtividade\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\produtividade\views.py ---

from django.shortcuts import render

# Create your views here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\produtividade\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\profissionais\admin.py ---

from django.contrib import admin
from .models import Profissional, Especialidade, Disponibilidade, RegistroHorasTrabalhadas

@admin.register(Profissional)
class ProfissionalAdmin(admin.ModelAdmin):
    list_display = ['nome_completo', 'registro_conselho', 'conselho', 'email']
    search_fields = ['nome_completo', 'registro_conselho']

@admin.register(Especialidade)
class EspecialidadeAdmin(admin.ModelAdmin):
    list_display = ['nome', 'descricao']
    search_fields = ['nome']

@admin.register(Disponibilidade)
class DisponibilidadeAdmin(admin.ModelAdmin):
    list_display = ['profissional', 'dia', 'horario_inicio', 'horario_fim']
    list_filter = ['dia', 'disponivel']

@admin.register(RegistroHorasTrabalhadas)
class RegistroHorasTrabalhadasAdmin(admin.ModelAdmin):
    list_display = ['profissional', 'dia', 'horas_trabalhadas']
    list_filter = ['dia']

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\profissionais\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\profissionais\apps.py ---

from django.apps import AppConfig


class ProfissionaisConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.profissionais"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\profissionais\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\profissionais\models.py ---

# MÃ³dulo Profissionais - CriaÃ§Ã£o do Modelo (models.py)

from django.db import models
from django.utils.translation import gettext_lazy as _
import uuid
from django.conf import settings


class Especialidade(models.Model):
    nome = models.CharField(
        max_length=100, unique=True, verbose_name=_("Nome da Especialidade")
    )
    descricao = models.TextField(blank=True, verbose_name=_("DescriÃ§Ã£o"))

    class Meta:
        verbose_name = _("Especialidade")
        verbose_name_plural = _("Especialidades")
        app_label = "profissionais"

    def __str__(self):
        return self.nome


class Profissional(models.Model):
    # Identificador Ãšnico Global
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    # Dados Pessoais
    usuario = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="profissional",
        verbose_name=_("UsuÃ¡rio"),
    )
    nome_completo = models.CharField(max_length=255, verbose_name=_("Nome Completo"))
    cpf = models.CharField(max_length=11, unique=True, verbose_name=_("CPF"))
    registro_conselho = models.CharField(
        max_length=50, unique=True, verbose_name=_("Registro no Conselho")
    )
    conselho = models.CharField(
        max_length=100, verbose_name=_("Conselho de Classe (CRM, CRO, etc.)")
    )
    especialidades = models.ManyToManyField(
        Especialidade, related_name="profissionais", verbose_name=_("Especialidades")
    )
    telefone = models.CharField(max_length=20, blank=True, verbose_name=_("Telefone"))
    email = models.EmailField(max_length=255, verbose_name=_("E-mail"))
    endereco = models.CharField(max_length=255, blank=True, verbose_name=_("EndereÃ§o"))
    tipo_contratacao = models.CharField(
        max_length=50,
        choices=[
            ("CLT", "CLT"),
            ("PJ", "Pessoa JurÃ­dica"),
            ("Freelancer", "Freelancer"),
        ],
        verbose_name=_("Tipo de ContrataÃ§Ã£o"),
    )
    documentos = models.FileField(
        upload_to="documentos_profissionais/", blank=True, verbose_name=_("Documentos")
    )

    # Dados Profissionais
    horario_atendimento_inicio = models.TimeField(
        verbose_name=_("HorÃ¡rio de InÃ­cio do Atendimento")
    )
    horario_atendimento_fim = models.TimeField(
        verbose_name=_("HorÃ¡rio de Fim do Atendimento")
    )
    dias_atendimento = models.CharField(
        max_length=50, verbose_name=_("Dias da Semana para Atendimento")
    )

    class Meta:
        verbose_name = _("Profissional")
        verbose_name_plural = _("Profissionais")

    def __str__(self):
        return f"{self.nome_completo} ({self.registro_conselho})"


class Disponibilidade(models.Model):
    profissional = models.ForeignKey(
        Profissional,
        on_delete=models.CASCADE,
        related_name="disponibilidades",
        verbose_name=_("Profissional"),
    )
    dia = models.DateField(verbose_name=_("Dia da Disponibilidade"))
    horario_inicio = models.TimeField(verbose_name=_("HorÃ¡rio de InÃ­cio"))
    horario_fim = models.TimeField(verbose_name=_("HorÃ¡rio de Fim"))
    disponivel = models.BooleanField(default=True, verbose_name=_("DisponÃ­vel"))

    class Meta:
        verbose_name = _("Disponibilidade")
        verbose_name_plural = _("Disponibilidades")
        unique_together = (("profissional", "dia", "horario_inicio", "horario_fim"),)

    def __str__(self):
        return f"Disponibilidade de {self.profissional.nome_completo} em {self.dia}"


class RegistroHorasTrabalhadas(models.Model):
    profissional = models.ForeignKey(
        Profissional,
        on_delete=models.CASCADE,
        related_name="horas_trabalhadas",
        verbose_name=_("Profissional"),
    )
    dia = models.DateField(verbose_name=_("Dia"))
    horas_trabalhadas = models.DecimalField(
        max_digits=4, decimal_places=2, verbose_name=_("Horas Trabalhadas")
    )

    class Meta:
        verbose_name = _("Registro de Horas Trabalhadas")
        verbose_name_plural = _("Registros de Horas Trabalhadas")

    def __str__(self):
        return f"Horas trabalhadas por {self.profissional.nome_completo} em {self.dia}"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\profissionais\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\profissionais\serializers.py ---

# MÃ³dulo Profissionais - Serializers (serializers.py)

from rest_framework import serializers
from apps.profissionais.models import (
    Especialidade,
    Profissional,
    Disponibilidade,
    RegistroHorasTrabalhadas,
)


class EspecialidadeSerializer(serializers.ModelSerializer):
    class Meta:
        model = Especialidade
        fields = "__all__"


class ProfissionalSerializer(serializers.ModelSerializer):
    class Meta:
        model = Profissional
        fields = "__all__"


class DisponibilidadeSerializer(serializers.ModelSerializer):
    class Meta:
        model = Disponibilidade
        fields = "__all__"


class RegistroHorasTrabalhadasSerializer(serializers.ModelSerializer):
    class Meta:
        model = RegistroHorasTrabalhadas
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\profissionais\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\profissionais\urls.py ---

# MÃ³dulo Profissionais - URLs (urls.py)

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'especialidades', views.EspecialidadeViewSet)
router.register(r'profissionais', views.ProfissionalViewSet)
router.register(r'disponibilidades', views.DisponibilidadeViewSet)
router.register(r'horas_trabalhadas', views.RegistroHorasTrabalhadasViewSet)

urlpatterns = [
    path('', include(router.urls)),
    path('list/', views.ProfissionalList.as_view(), name='profissional-list'),
    path('detail/<int:pk>/', views.ProfissionalDetail.as_view(), name='profissional-detail'),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\profissionais\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\profissionais\views.py ---

# MÃ³dulo Profissionais - Views (views.py)

from rest_framework import viewsets, status, generics
from apps.profissionais.models import (
    Especialidade,
    Profissional,
    Disponibilidade,
    RegistroHorasTrabalhadas,
)
from .serializers import (
    EspecialidadeSerializer,
    ProfissionalSerializer,
    DisponibilidadeSerializer,
    RegistroHorasTrabalhadasSerializer,
)
from rest_framework.permissions import IsAuthenticated, BasePermission, AllowAny
from rest_framework.response import Response
from rest_framework.decorators import action
from django.utils import timezone

# Custom Permissions


class IsAdminOrReadOnly(BasePermission):
    def has_permission(self, request, view):
        if request.method in ["GET"]:
            return True
        return request.user and request.user.is_staff


class IsProfissionalOrReadOnly(BasePermission):
    def has_object_permission(self, request, view, obj):
        if request.method in ["GET", "HEAD", "OPTIONS"]:
            return True
        return obj.usuario == request.user or request.user.is_staff


# Views


class EspecialidadeViewSet(viewsets.ModelViewSet):
    queryset = Especialidade.objects.all()
    serializer_class = EspecialidadeSerializer
    permission_classes = [IsAuthenticated, IsAdminOrReadOnly]


class ProfissionalViewSet(viewsets.ModelViewSet):
    queryset = Profissional.objects.all()
    serializer_class = ProfissionalSerializer
    permission_classes = [IsAuthenticated, IsAdminOrReadOnly]


class DisponibilidadeViewSet(viewsets.ModelViewSet):
    queryset = Disponibilidade.objects.all()
    serializer_class = DisponibilidadeSerializer
    permission_classes = [IsAuthenticated, IsProfissionalOrReadOnly]

    def create(self, request, *args, **kwargs):
        # Validar se a disponibilidade Ã© para uma data futura
        data = request.data.copy()
        dia = data.get("dia")
        if dia:
            dia = timezone.datetime.strptime(dia, "%Y-%m-%d").date()
            if dia < timezone.now().date():
                return Response(
                    {"detail": "A disponibilidade deve ser para uma data futura."},
                    status=status.HTTP_400_BAD_REQUEST,
                )
        return super().create(request, *args, **kwargs)


class RegistroHorasTrabalhadasViewSet(viewsets.ModelViewSet):
    queryset = RegistroHorasTrabalhadas.objects.all()
    serializer_class = RegistroHorasTrabalhadasSerializer
    permission_classes = [IsAuthenticated, IsProfissionalOrReadOnly]

    @action(detail=False, methods=["get"], permission_classes=[IsAuthenticated])
    def minhas_horas(self, request):
        # Retornar as horas trabalhadas do profissional autenticado
        if hasattr(request.user, "profissional"):
            profissional = request.user.profissional
            queryset = RegistroHorasTrabalhadas.objects.filter(
                profissional=profissional
            )
            serializer = self.get_serializer(queryset, many=True)
            return Response(serializer.data)
        return Response(
            {"detail": "UsuÃ¡rio nÃ£o Ã© um profissional."},
            status=status.HTTP_400_BAD_REQUEST,
        )


class ProfissionalList(generics.ListCreateAPIView):
    queryset = Profissional.objects.all()
    serializer_class = ProfissionalSerializer
    permission_classes = [IsAuthenticated]  # Exigir autenticaÃ§Ã£o


class ProfissionalDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = Profissional.objects.all()
    serializer_class = ProfissionalSerializer
    permission_classes = [IsAuthenticated]  # Exigir autenticaÃ§Ã£o

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\profissionais\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\projeto\admin.py ---

from django.contrib import admin
from .models import ProjetoModel


@admin.register(ProjetoModel)
class ProjetoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\projeto\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\projeto\apps.py ---

from django.apps import AppConfig


class ProjetoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.projeto"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\projeto\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\projeto\models.py ---

from django.db import models


class ProjetoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\projeto\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\projeto\serializers.py ---

from rest_framework import serializers
from .models import ProjetoModel


class ProjetoSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProjetoModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\projeto\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\projeto\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ProjetoViewSet

router = DefaultRouter()
router.register(r"projeto", ProjetoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\projeto\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\projeto\views.py ---

from rest_framework import viewsets
from .models import ProjetoModel
from .serializers import ProjetoSerializer


class ProjetoViewSet(viewsets.ModelViewSet):
    queryset = ProjetoModel.objects.all()
    serializer_class = ProjetoSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\projeto\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\prontuarios\admin.py ---

from django.contrib import admin
from .models import Prontuario

class ProntuarioAdmin(admin.ModelAdmin):
    list_display = ('paciente', 'data_atendimento', 'prescricao', 'profissional_responsavel')

admin.site.register(Prontuario, ProntuarioAdmin)

from .models import Anamnese

admin.site.register(Anamnese)

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\prontuarios\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\prontuarios\models.py ---

# MÃ³dulo ProntuÃ¡rios - CriaÃ§Ã£o do Modelo (models.py)

from django.db import models
from django.utils.translation import gettext_lazy as _
import uuid
from django.conf import settings


class Prontuario(models.Model):
    # Identificador Ãšnico Global
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    # Dados Relacionados ao Paciente
    paciente = models.ForeignKey(
    "pacientes.Paciente",
    on_delete=models.CASCADE,
    related_name="prontuarios",  # Alterar para evitar conflito com campo em Paciente
)

    # EvoluÃ§Ãµes ClÃ­nicas e Atendimentos
    data_atendimento = models.DateTimeField(_("Data do Atendimento"))
    profissional_responsavel = models.ForeignKey(
    "profissionais.Profissional",
    on_delete=models.SET_NULL,
    null=True,
    related_name="exames_solicitados_complementar",  # Alterar para um nome Ãºnico
)

    queixa_principal = models.TextField(_("Queixa Principal"), blank=True)
    historico_doenca_atual = models.TextField(
        _("HistÃ³rico da DoenÃ§a Atual"), blank=True
    )
    antecedentes_pessoais = models.TextField(_("Antecedentes Pessoais"), blank=True)
    exame_fisico_cabeca_pescoco = models.TextField(
        _("Exame FÃ­sico - CabeÃ§a e PescoÃ§o"), blank=True
    )
    exame_fisico_torax = models.TextField(_("Exame FÃ­sico - TÃ³rax"), blank=True)
    exame_fisico_abdomen = models.TextField(_("Exame FÃ­sico - AbdÃ´men"), blank=True)
    exame_fisico_membros = models.TextField(
        _("Exame FÃ­sico - Membros Superiores e Inferiores"), blank=True
    )
    hipotese_diagnostica = models.TextField(_("HipÃ³tese DiagnÃ³stica"), blank=True)
    conduta = models.TextField(_("Conduta/Plano"), blank=True)
    prescricao = models.TextField(_("PrescriÃ§Ã£o MÃ©dica"), blank=True)
    tratamentos_previos = models.TextField(_("Tratamentos PrÃ©vio(s)"), blank=True)

    # DiagnÃ³sticos
    diagnostico_final = models.CharField(
        _("DiagnÃ³stico Final"), max_length=255, blank=True
    )
    cid_10 = models.CharField(_("CID-10"), max_length=10, blank=True)

    # AnotaÃ§Ãµes de Outros Profissionais
    anotacoes_profissionais = models.TextField(
        _("AnotaÃ§Ãµes de Outros Profissionais"), blank=True
    )

    # ReferÃªncias e Encaminhamentos
    encaminhamentos = models.TextField(_("Encaminhamentos"), blank=True)
    referencias_especialidades = models.TextField(
        _("ReferÃªncias para Especialidades"), blank=True
    )

    # Consentimento e Termos
    consentimento_informado = models.BooleanField(
        _("Consentimento Informado Assinado"), default=False
    )

    # HistÃ³rico Familiar
    historico_familiar = models.TextField(_("HistÃ³rico Familiar"), blank=True)
    risco_genetico = models.TextField(_("Risco GenÃ©tico Identificado"), blank=True)

    # Dados PsicolÃ³gicos e Sociais
    dados_psicossociais = models.TextField(
        _("Dados PsicolÃ³gicos e Sociais"), blank=True
    )
    estado_emocional = models.TextField(_("Estado Emocional"), blank=True)
    transtornos_identificados = models.TextField(
        _("Transtornos Identificados"), blank=True
    )
    medicacoes_psiquiatricas = models.TextField(
        _("MedicaÃ§Ãµes PsiquiÃ¡tricas"), blank=True
    )

    # HistÃ³rico de HÃ¡bitos de Vida
    tabagismo = models.BooleanField(_("Tabagismo"), default=False)
    etilismo = models.BooleanField(_("Etilismo"), default=False)
    uso_drogas = models.BooleanField(_("Uso de Drogas"), default=False)
    atividade_fisica = models.CharField(
        _("Atividade FÃ­sica"), max_length=255, blank=True
    )
    alimentacao = models.CharField(_("AlimentaÃ§Ã£o"), max_length=255, blank=True)
    qualidade_sono = models.CharField(
        _("Qualidade do Sono"), max_length=255, blank=True
    )
    ocupacao = models.CharField(_("OcupaÃ§Ã£o"), max_length=255, blank=True)
    nivel_estresse = models.CharField(
        _("NÃ­vel de Estresse"), max_length=255, blank=True
    )
    medicacoes_nao_prescritas = models.TextField(
        _("MedicaÃ§Ãµes NÃ£o Prescritas"), blank=True
    )

    # HistÃ³rico de Cirurgias e InternaÃ§Ãµes
    historico_cirurgias = models.TextField(_("HistÃ³rico de Cirurgias"), blank=True)
    historico_internacoes = models.TextField(_("HistÃ³rico de InternaÃ§Ãµes"), blank=True)

    # HistÃ³rico de ImunizaÃ§Ãµes
    imunizacoes = models.TextField(_("HistÃ³rico de ImunizaÃ§Ãµes"), blank=True)

    # EstratificaÃ§Ã£o de Risco
    estratificacao_risco = models.CharField(
        _("EstratificaÃ§Ã£o de Risco"), max_length=255, blank=True
    )
    risco_quedas = models.CharField(_("Risco de Quedas"), max_length=255, blank=True)

    # Motivo do Atendimento
    motivo_atendimento = models.CharField(
        _("Motivo do Atendimento"), max_length=255, blank=True
    )

    # Acompanhamento de DoenÃ§as CrÃ´nicas
    diabetes_hemoglobina_glicada = models.DecimalField(
        _("Hemoglobina Glicada (%)"),
        max_digits=4,
        decimal_places=2,
        blank=True,
        null=True,
    )
    funcao_renal_taxa_filtracao = models.DecimalField(
        _("Taxa de FiltraÃ§Ã£o Glomerular (mL/min)"),
        max_digits=5,
        decimal_places=2,
        blank=True,
        null=True,
    )

    # AvaliaÃ§Ã£o Nutricional
    imc = models.DecimalField(
        _("Ãndice de Massa Corporal (IMC)"),
        max_digits=4,
        decimal_places=1,
        blank=True,
        null=True,
    )
    percentual_gordura_corporal = models.DecimalField(
        _("Percentual de Gordura Corporal (%)"),
        max_digits=4,
        decimal_places=1,
        blank=True,
        null=True,
    )
    dieta_recomendada = models.TextField(_("Dieta Recomendada"), blank=True)

    # Planos de SaÃºde e Seguros
    plano_saude = models.CharField(_("Plano de SaÃºde"), max_length=255, blank=True)
    numero_plano_saude = models.CharField(
        _("NÃºmero do Plano de SaÃºde"), max_length=255, blank=True
    )

    # Auditoria
    created_at = models.DateTimeField(_("Data de CriaÃ§Ã£o"), auto_now_add=True)
    updated_at = models.DateTimeField(_("Ãšltima AtualizaÃ§Ã£o"), auto_now=True)
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name="prontuarios_criados",
    )
    updated_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name="prontuarios_atualizados",
    )

    prescricao = models.TextField()

    class Meta:
        verbose_name = _("ProntuÃ¡rio")
        verbose_name_plural = _("ProntuÃ¡rios")

    def __str__(self):
        return self.prescricao


class HistoricoMedicamentos(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="historico_medicamentos"
    )
    medicamento = models.CharField(_("Medicamento"), max_length=255)
    dosagem = models.CharField(_("Dosagem"), max_length=255)
    frequencia = models.CharField(_("FrequÃªncia"), max_length=255)
    duracao = models.CharField(_("DuraÃ§Ã£o"), max_length=255)
    observacoes = models.TextField(_("ObservaÃ§Ãµes"), blank=True)
    prescrito_por = models.ForeignKey(
        "profissionais.Profissional", on_delete=models.SET_NULL, null=True
    )
    data_prescricao = models.DateTimeField(_("Data da PrescriÃ§Ã£o"), auto_now_add=True)

    class Meta:
        verbose_name = _("HistÃ³rico de Medicamento")
        verbose_name_plural = _("HistÃ³rico de Medicamentos")

    def __str__(self):
        return f"Medicamento: {self.medicamento} - Paciente: {self.prontuario.paciente.nome_completo}"


class EvolucaoClinica(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="evolucoes_clinicas"
    )
    data_evolucao = models.DateTimeField(_("Data da EvoluÃ§Ã£o"), auto_now_add=True)
    profissional_responsavel = models.ForeignKey(
        "profissionais.Profissional", on_delete=models.SET_NULL, null=True
    )
    descricao = models.TextField(_("DescriÃ§Ã£o da EvoluÃ§Ã£o"))

    class Meta:
        verbose_name = _("EvoluÃ§Ã£o ClÃ­nica")
        verbose_name_plural = _("EvoluÃ§Ãµes ClÃ­nicas")

    def __str__(self):
        return f"EvoluÃ§Ã£o em {self.data_evolucao} - Paciente: {self.prontuario.paciente.nome_completo}"


class DadosVitais(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="dados_vitais"
    )
    data_registro = models.DateTimeField(_("Data do Registro"), auto_now_add=True)
    pressao_arterial = models.CharField(
        _("PressÃ£o Arterial"), max_length=50, blank=True
    )
    frequencia_cardiaca = models.CharField(
        _("FrequÃªncia CardÃ­aca"), max_length=50, blank=True
    )
    temperatura = models.DecimalField(
        _("Temperatura Corporal (Â°C)"),
        max_digits=4,
        decimal_places=1,
        blank=True,
        null=True,
    )
    saturacao_oxigenio = models.CharField(
        _("SaturaÃ§Ã£o de OxigÃªnio (%)"), max_length=50, blank=True
    )
    peso = models.DecimalField(
        _("Peso (kg)"), max_digits=5, decimal_places=2, blank=True, null=True
    )
    altura = models.DecimalField(
        _("Altura (m)"), max_digits=4, decimal_places=2, blank=True, null=True
    )
    glicemia = models.DecimalField(
        _("Glicemia (mg/dL)"), max_digits=5, decimal_places=2, blank=True, null=True
    )
    colesterol_total = models.DecimalField(
        _("Colesterol Total (mg/dL)"),
        max_digits=5,
        decimal_places=2,
        blank=True,
        null=True,
    )
    triglicerides = models.DecimalField(
        _("TriglicÃ©rides (mg/dL)"),
        max_digits=5,
        decimal_places=2,
        blank=True,
        null=True,
    )

    class Meta:
        verbose_name = _("Dados Vitais")
        verbose_name_plural = _("Dados Vitais")

    def __str__(self):
        return f"Dados Vitais em {self.data_registro} - Paciente: {self.prontuario.paciente.nome_completo}"


class HistoricoAcessosProntuario(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="historico_acessos"
    )
    usuario = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True
    )
    data_acesso = models.DateTimeField(_("Data do Acesso"), auto_now_add=True)
    tipo_acesso = models.CharField(
        _("Tipo de Acesso"),
        max_length=50,
        choices=[("visualizacao", "VisualizaÃ§Ã£o"), ("alteracao", "AlteraÃ§Ã£o")],
    )

    class Meta:
        verbose_name = _("HistÃ³rico de Acesso ao ProntuÃ¡rio")
        verbose_name_plural = _("HistÃ³rico de Acessos ao ProntuÃ¡rio")

    def __str__(self):
        return f"Acesso em {self.data_acesso} - Paciente: {self.prontuario.paciente.nome_completo} por {self.usuario}"


class ExameComplementar(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="exames_complementares"
    )
    tipo_exame = models.CharField(_("Tipo de Exame"), max_length=255)
    data_solicitacao = models.DateTimeField(_("Data da SolicitaÃ§Ã£o"), auto_now_add=True)
    data_resultado = models.DateTimeField(_("Data do Resultado"), null=True, blank=True)
    resultado = models.TextField(_("Resultado do Exame"), blank=True)
    profissional_responsavel = models.ForeignKey(
        "profissionais.Profissional",
        on_delete=models.SET_NULL,
        null=True,
        related_name="exames_solicitados",
    )
    imagem_associada = models.ImageField(
        _("Imagem Associada"), upload_to="exames/imagens/", blank=True, null=True
    )

    class Meta:
        verbose_name = _("Exame Complementar")
        verbose_name_plural = _("Exames Complementares")

    def __str__(self):
        return f"Exame: {self.tipo_exame} - Paciente: {self.prontuario.paciente.nome_completo}"


class ProcedimentoRealizado(models.Model):
    prontuario = models.ForeignKey(
        Prontuario, on_delete=models.CASCADE, related_name="procedimentos_realizados"
    )
    tipo_procedimento = models.CharField(_("Tipo de Procedimento"), max_length=255)
    data_procedimento = models.DateTimeField(
        _("Data do Procedimento"), auto_now_add=True
    )
    profissional_responsavel = models.ForeignKey(
        "profissionais.Profissional",
        on_delete=models.SET_NULL,
        null=True,
        related_name="procedimentos_realizados",
    )
    observacoes = models.TextField(_("ObservaÃ§Ãµes"), blank=True)
    consentimento_associado = models.ForeignKey(
        "assinaturas.Assinatura",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="procedimentos_consentidos",
    )

    class Meta:
        verbose_name = _("Procedimento Realizado")
        verbose_name_plural = _("Procedimentos Realizados")

class Anamnese(models.Model):
    paciente = models.ForeignKey('pacientes.Paciente', on_delete=models.CASCADE, related_name='anamneses')
    profissional = models.ForeignKey('profissionais.Profissional', on_delete=models.CASCADE, related_name='anamneses')
    texto = models.TextField(verbose_name=_("Anamnese"))
    data_criacao = models.DateTimeField(auto_now_add=True, verbose_name=_("Criado em"))

    class Meta:
        verbose_name = _("Anamnese")
        verbose_name_plural = _("Anamneses")

    def __str__(self):
        return f"Anamnese de {self.paciente.nome_completo} - {self.data_criacao}"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\prontuarios\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\prontuarios\serializers.py ---

# MÃ³dulo ProntuÃ¡rios - Serializers (serializers.py)

from rest_framework import serializers
from .models import (
    Prontuario,
    HistoricoMedicamentos,
    EvolucaoClinica,
    DadosVitais,
    HistoricoAcessosProntuario,
    ExameComplementar,
    Anamnese,
)


class ProntuarioSerializer(serializers.ModelSerializer):
    class Meta:
        model = Prontuario
        fields = "__all__"


class HistoricoMedicamentosSerializer(serializers.ModelSerializer):
    class Meta:
        model = HistoricoMedicamentos
        fields = "__all__"


class EvolucaoClinicaSerializer(serializers.ModelSerializer):
    class Meta:
        model = EvolucaoClinica
        fields = "__all__"


class DadosVitaisSerializer(serializers.ModelSerializer):
    class Meta:
        model = DadosVitais
        fields = "__all__"


class HistoricoAcessosProntuarioSerializer(serializers.ModelSerializer):
    class Meta:
        model = HistoricoAcessosProntuario
        fields = "__all__"


class ExameComplementarSerializer(serializers.ModelSerializer):
    class Meta:
        model = ExameComplementar
        fields = "__all__"


class AnamneseSerializer(serializers.ModelSerializer):
    class Meta:
        model = Anamnese
        fields = '__all__'

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\prontuarios\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\prontuarios\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'prontuarios', views.ProntuarioViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\prontuarios\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\prontuarios\views.py ---

# MÃ³dulo ProntuÃ¡rios - Views (views.py)

from . import views
# MÃ³dulo ProntuÃ¡rios - Views (views.py)

from rest_framework.routers import DefaultRouter
from django.urls import path, include
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.views import APIView

from .models import (
    Prontuario,
    HistoricoMedicamentos,
    EvolucaoClinica,
    DadosVitais,
    HistoricoAcessosProntuario,
    ExameComplementar,
    Anamnese,
)
from .serializers import (
    ProntuarioSerializer,
    HistoricoMedicamentosSerializer,
    EvolucaoClinicaSerializer,
    DadosVitaisSerializer,
    HistoricoAcessosProntuarioSerializer,
    ExameComplementarSerializer,
    AnamneseSerializer,
)
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from rest_framework.decorators import action
from rest_framework.permissions import BasePermission, SAFE_METHODS

# Custom permission to restrict read/write access based on user roles

class AnamneseViewSet(viewsets.ModelViewSet):
    queryset = Anamnese.objects.all()
    serializer_class = AnamneseSerializer

    @action(detail=True, methods=['post'])
    def sugerir_cid(self, request, pk=None):
        anamnese = self.get_object()
        texto = anamnese.texto

        # Simular integraÃ§Ã£o com IA (NLP para anÃ¡lise)
        sugestoes = [
            {"codigo": "J18.0", "descricao": "Pneumonia", "relevancia": 0.85},
            {"codigo": "J20.9", "descricao": "Bronquite aguda", "relevancia": 0.75},
        ]
        return Response({"anamnese": texto, "sugestoes_cid": sugestoes}, status=status.HTTP_200_OK)
class IsAdminOrReadOnly(BasePermission):
    def has_permission(self, request, view):
        if request.method in SAFE_METHODS:
            return True
        return request.user and request.user.is_staff


class IsDoctorOrReadOnly(BasePermission):
    def has_permission(self, request, view):
        if request.method in SAFE_METHODS:
            return True
        return (
            request.user
            and request.user.groups.filter(name="Doctor").exists()
            or request.user.is_staff
        )


# Views


class ProntuarioViewSet(viewsets.ModelViewSet):
    queryset = Prontuario.objects.all()
    serializer_class = ProntuarioSerializer
    permission_classes = [IsAuthenticated]  # Exigir autenticaÃ§Ã£o

    def create(self, request, *args, **kwargs):
        # Filtra campos sensÃ­veis antes de criar
        data = request.data.copy()
        sensitive_fields = ["created_by", "updated_by", "uuid"]
        for field in sensitive_fields:
            data.pop(field, None)
        serializer = self.get_serializer(data=data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(
            serializer.data, status=status.HTTP_201_CREATED, headers=headers
        )

    def update(self, request, *args, **kwargs):
        # Filtra campos sensÃ­veis antes de atualizar
        data = request.data.copy()
        sensitive_fields = ["created_by", "updated_by", "uuid"]
        for field in sensitive_fields:
            data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


class ProntuarioList(APIView):
    def get(self, request):
        prontuarios = Prontuario.objects.all()
        serializer = ProntuarioSerializer(prontuarios, many=True)
        return Response(serializer.data)


class HistoricoMedicamentosViewSet(viewsets.ModelViewSet):
    queryset = HistoricoMedicamentos.objects.all()
    serializer_class = HistoricoMedicamentosSerializer
    permission_classes = [IsAuthenticated, IsAdminOrReadOnly]

    def create(self, request, *args, **kwargs):
        # Filtra campos sensÃ­veis antes de criar
        data = request.data.copy()
        sensitive_fields = ["prescrito_por"]
        for field in sensitive_fields:
            if not request.user.is_staff:
                data.pop(field, None)
        serializer = self.get_serializer(data=data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(
            serializer.data, status=status.HTTP_201_CREATED, headers=headers
        )

    def update(self, request, *args, **kwargs):
        # Filtra campos sensÃ­veis antes de atualizar
        data = request.data.copy()
        sensitive_fields = ["prescrito_por"]
        for field in sensitive_fields:
            if not request.user.is_staff:
                data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


class EvolucaoClinicaViewSet(viewsets.ModelViewSet):
    queryset = EvolucaoClinica.objects.all()
    serializer_class = EvolucaoClinicaSerializer
    permission_classes = [IsAuthenticated, IsDoctorOrReadOnly]

    def update(self, request, *args, **kwargs):
        # Limitar campos que podem ser editados por diferentes tipos de
        # usuÃ¡rios
        data = request.data.copy()
        restricted_fields = ["data_evolucao", "profissional_responsavel"]
        if not request.user.is_staff:
            for field in restricted_fields:
                data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


class DadosVitaisViewSet(viewsets.ModelViewSet):
    queryset = DadosVitais.objects.all()
    serializer_class = DadosVitaisSerializer
    permission_classes = [IsAuthenticated, IsDoctorOrReadOnly]

    def create(self, request, *args, **kwargs):
        # Filtra campos sensÃ­veis antes de criar
        data = request.data.copy()
        sensitive_fields = [
            "pressao_arterial",
            "frequencia_cardiaca",
            "temperatura",
            "saturacao_oxigenio",
            "glicemia",
            "colesterol_total",
            "triglicerides",
        ]
        if (
            not request.user.groups.filter(name="Doctor").exists()
            and not request.user.is_staff
        ):
            for field in sensitive_fields:
                data.pop(field, None)
        serializer = self.get_serializer(data=data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(
            serializer.data, status=status.HTTP_201_CREATED, headers=headers
        )

    def update(self, request, *args, **kwargs):
        # Filtra campos sensÃ­veis antes de atualizar
        data = request.data.copy()
        sensitive_fields = [
            "pressao_arterial",
            "frequencia_cardiaca",
            "temperatura",
            "saturacao_oxigenio",
            "glicemia",
            "colesterol_total",
            "triglicerides",
        ]
        if (
            not request.user.groups.filter(name="Doctor").exists()
            and not request.user.is_staff
        ):
            for field in sensitive_fields:
                data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


class HistoricoAcessosProntuarioViewSet(viewsets.ModelViewSet):
    queryset = HistoricoAcessosProntuario.objects.all()
    serializer_class = HistoricoAcessosProntuarioSerializer
    permission_classes = [IsAuthenticated]

    def list(self, request, *args, **kwargs):
        # Restringir campos sensÃ­veis durante a listagem
        if not request.user.is_staff:
            queryset = self.filter_queryset(self.get_queryset()).defer(
                "usuario", "tipo_acesso"
            )
        else:
            queryset = self.filter_queryset(self.get_queryset())
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)


class ExameComplementarViewSet(viewsets.ModelViewSet):
    queryset = ExameComplementar.objects.all()
    serializer_class = ExameComplementarSerializer
    permission_classes = [IsAuthenticated, IsDoctorOrReadOnly]

    def create(self, request, *args, **kwargs):
        # Filtra campos sensÃ­veis antes de criar
        data = request.data.copy()
        sensitive_fields = ["resultado", "imagem_associada"]
        if (
            not request.user.groups.filter(name="Doctor").exists()
            and not request.user.is_staff
        ):
            for field in sensitive_fields:
                data.pop(field, None)
        serializer = self.get_serializer(data=data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(
            serializer.data, status=status.HTTP_201_CREATED, headers=headers
        )

    def update(self, request, *args, **kwargs):
        # Filtra campos sensÃ­veis antes de atualizar
        data = request.data.copy()
        sensitive_fields = ["resultado", "imagem_associada"]
        if (
            not request.user.groups.filter(name="Doctor").exists()
            and not request.user.is_staff
        ):
            for field in sensitive_fields:
                data.pop(field, None)
        partial = kwargs.pop("partial", False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)


# URL Routing (urls.py)

router = DefaultRouter()
router.register(r"prontuarios", views.ProntuarioViewSet)
router.register(r"historico_medicamentos", views.HistoricoMedicamentosViewSet)
router.register(r"evolucoes_clinicas", views.EvolucaoClinicaViewSet)
router.register(r"dados_vitais", views.DadosVitaisViewSet)
router.register(r"historico_acessos", views.HistoricoAcessosProntuarioViewSet)
router.register(r"exames_complementares", views.ExameComplementarViewSet)
router.register(r'anamneses', AnamneseViewSet, basename='anamnese')

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\prontuarios\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\qualidade\admin.py ---

from django.contrib import admin
from .models import QualidadeModel


@admin.register(QualidadeModel)
class QualidadeAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\qualidade\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\qualidade\apps.py ---

from django.apps import AppConfig


class QualidadeConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.qualidade"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\qualidade\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\qualidade\models.py ---

from django.db import models


class QualidadeModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\qualidade\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\qualidade\serializers.py ---

from rest_framework import serializers
from .models import QualidadeModel


class QualidadeSerializer(serializers.ModelSerializer):
    class Meta:
        model = QualidadeModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\qualidade\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\qualidade\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import QualidadeViewSet

router = DefaultRouter()
router.register(r"qualidade", QualidadeViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\qualidade\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\qualidade\views.py ---

from rest_framework import viewsets
from .models import QualidadeModel
from .serializers import QualidadeSerializer


class QualidadeViewSet(viewsets.ModelViewSet):
    queryset = QualidadeModel.objects.all()
    serializer_class = QualidadeSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\qualidade\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\recrutamento\admin.py ---

from django.contrib import admin
from .models import RecrutamentoModel


@admin.register(RecrutamentoModel)
class RecrutamentoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\recrutamento\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\recrutamento\apps.py ---

from django.apps import AppConfig


class RecrutamentoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.recrutamento"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\recrutamento\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\recrutamento\models.py ---

from django.db import models


class RecrutamentoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\recrutamento\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\recrutamento\serializers.py ---

from rest_framework import serializers
from .models import RecrutamentoModel


class RecrutamentoSerializer(serializers.ModelSerializer):
    class Meta:
        model = RecrutamentoModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\recrutamento\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\recrutamento\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import RecrutamentoViewSet

router = DefaultRouter()
router.register(r"recrutamento", RecrutamentoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\recrutamento\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\recrutamento\views.py ---

from rest_framework import viewsets
from .models import RecrutamentoModel
from .serializers import RecrutamentoSerializer


class RecrutamentoViewSet(viewsets.ModelViewSet):
    queryset = RecrutamentoModel.objects.all()
    serializer_class = RecrutamentoSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\recrutamento\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\recursos_humanos\admin.py ---

from django.contrib import admin
from .models import Recursos_humanosModel


@admin.register(Recursos_humanosModel)
class Recursos_humanosAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\recursos_humanos\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\recursos_humanos\apps.py ---

from django.apps import AppConfig


class Recursos_humanosConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.recursos_humanos"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\recursos_humanos\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\recursos_humanos\models.py ---

from django.db import models


class Recursos_humanosModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\recursos_humanos\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\recursos_humanos\serializers.py ---

from rest_framework import serializers
from .models import Recursos_humanosModel


class Recursos_humanosSerializer(serializers.ModelSerializer):
    class Meta:
        model = Recursos_humanosModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\recursos_humanos\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\recursos_humanos\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Recursos_humanosViewSet

router = DefaultRouter()
router.register(r"recursos_humanos", Recursos_humanosViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\recursos_humanos\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\recursos_humanos\views.py ---

from rest_framework import viewsets
from .models import Recursos_humanosModel
from .serializers import Recursos_humanosSerializer


class Recursos_humanosViewSet(viewsets.ModelViewSet):
    queryset = Recursos_humanosModel.objects.all()
    serializer_class = Recursos_humanosSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\recursos_humanos\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\redes_sociais\admin.py ---

from django.contrib import admin
from .models import Redes_sociaisModel


@admin.register(Redes_sociaisModel)
class Redes_sociaisAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\redes_sociais\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\redes_sociais\apps.py ---

from django.apps import AppConfig


class Redes_sociaisConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.redes_sociais"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\redes_sociais\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\redes_sociais\models.py ---

from django.db import models


class Redes_sociaisModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\redes_sociais\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\redes_sociais\serializers.py ---

from rest_framework import serializers
from .models import Redes_sociaisModel


class Redes_sociaisSerializer(serializers.ModelSerializer):
    class Meta:
        model = Redes_sociaisModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\redes_sociais\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\redes_sociais\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Redes_sociaisViewSet

router = DefaultRouter()
router.register(r"redes_sociais", Redes_sociaisViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\redes_sociais\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\redes_sociais\views.py ---

from rest_framework import viewsets
from .models import Redes_sociaisModel
from .serializers import Redes_sociaisSerializer


class Redes_sociaisViewSet(viewsets.ModelViewSet):
    queryset = Redes_sociaisModel.objects.all()
    serializer_class = Redes_sociaisSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\redes_sociais\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\servico_campo\admin.py ---

from django.contrib import admin
from .models import Servico_campoModel


@admin.register(Servico_campoModel)
class Servico_campoAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\servico_campo\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\servico_campo\apps.py ---

from django.apps import AppConfig


class Servico_campoConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.servico_campo"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\servico_campo\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\servico_campo\models.py ---

from django.db import models


class Servico_campoModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\servico_campo\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\servico_campo\serializers.py ---

from rest_framework import serializers
from .models import Servico_campoModel


class Servico_campoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Servico_campoModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\servico_campo\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\servico_campo\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import Servico_campoViewSet

router = DefaultRouter()
router.register(r"servico_campo", Servico_campoViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\servico_campo\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\servico_campo\views.py ---

from rest_framework import viewsets
from .models import Servico_campoModel
from .serializers import Servico_campoSerializer


class Servico_campoViewSet(viewsets.ModelViewSet):
    queryset = Servico_campoModel.objects.all()
    serializer_class = Servico_campoSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\servico_campo\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\vendas\admin.py ---

from django.contrib import admin
from .models import VendasModel


@admin.register(VendasModel)
class VendasAdmin(admin.ModelAdmin):
    list_display = ("nome", "criado_em", "atualizado_em")

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\vendas\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\vendas\apps.py ---

from django.apps import AppConfig


class VendasConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.vendas"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\vendas\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\vendas\models.py ---

from django.db import models


class VendasModel(models.Model):
    nome = models.CharField(max_length=255)
    criado_em = models.DateTimeField(auto_now_add=True)
    atualizado_em = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.nome

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\vendas\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\vendas\serializers.py ---

from rest_framework import serializers
from .models import VendasModel


class VendasSerializer(serializers.ModelSerializer):
    class Meta:
        model = VendasModel
        fields = "__all__"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\vendas\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\vendas\urls.py ---

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import VendasViewSet

router = DefaultRouter()
router.register(r"vendas", VendasViewSet)

urlpatterns = [
    path("", include(router.urls)),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\vendas\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\vendas\views.py ---

from rest_framework import viewsets
from .models import VendasModel
from .serializers import VendasSerializer


class VendasViewSet(viewsets.ModelViewSet):
    queryset = VendasModel.objects.all()
    serializer_class = VendasSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\vendas\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\voip\admin.py ---

from django.contrib import admin

# Register your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\voip\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\voip\apps.py ---

from django.apps import AppConfig


class VoipConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.voip"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\voip\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\voip\models.py ---

from django.db import models

# Create your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\voip\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\voip\views.py ---

from django.shortcuts import render

# Create your views here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\voip\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\whatsapp\admin.py ---

from django.contrib import admin

# Register your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\whatsapp\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\whatsapp\apps.py ---

from django.apps import AppConfig


class WhatsappConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.whatsapp"

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\whatsapp\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\whatsapp\models.py ---

from django.db import models

# Create your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\whatsapp\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\apps\whatsapp\views.py ---

from django.shortcuts import render

# Create your views here.

# --- Fim do arquivo: C:\ClinicaAI\backend\apps\whatsapp\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\ClinicaAI\asgi.py ---

"""
ASGI config for ClinicaAI project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'ClinicaAI.settings')

application = get_asgi_application()

# --- Fim do arquivo: C:\ClinicaAI\backend\ClinicaAI\asgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\ClinicaAI\settings.py ---

"""
Django settings for ClinicaAI project.

Generated by 'django-admin startproject' using Django 4.2.16.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""

from pathlib import Path
from cryptography.fernet import Fernet
from datetime import timedelta

# Gere uma chave de criptografia
ENCRYPTION_KEY = 'IpmmvITSPLun5m6lOtUPHszQ7yTKRlmAHQ9JC47XMKg='

def decrypt(encrypted_text):
    # Adicione padding se necessÃ¡rio
    padding = len(encrypted_text) % 4
    if padding != 0:
        encrypted_text += '=' * (4 - padding)
    try:
        cipher_suite = Fernet(ENCRYPTION_KEY)
        decrypted_text = cipher_suite.decrypt(encrypted_text.encode()).decode()
        return decrypted_text
    except Exception as e:
        raise ValueError(f"Erro ao descriptografar o texto: {e}")

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = decrypt('gAAAAABncfHWNo6zmHaKhNfNchedvGqjsJbCVDVWMZRmWKTKCAjCesVQrZOuImCOiZG33ls__sm-o74_5w4_DPPaeOtdWfIhAA==')  # Substituido
# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'prometheus_client',
    'drf_yasg',
    'channels',
    'corsheaders',
    'rest_framework',
    'rest_framework_simplejwt',
    'apps.whatsapp',
    'apps.conhecimento',
    'apps.voip',
    'apps.iot',
    'apps.aprovacoes',
    'apps.mensagens',
    'apps.produtividade',
    'apps.compromissos',
    'apps.central_ajuda',
    'apps.servico_campo',
    'apps.planilhas_horas',
    'apps.projeto',
    'apps.pesquisas',
    'apps.automacao_marketing',
    'apps.eventos',
    'apps.marketing_sms',
    'apps.marketing_email',
    'apps.redes_sociais',
    'apps.frota',
    'apps.indicacoes',
    'apps.avaliacoes',
    'apps.folgas',
    'apps.recrutamento',
    'apps.recursos_humanos',
    'apps.qualidade',
    'apps.manutencao',
    'apps.compras',
    'apps.prontuarios',
    'apps.plm',
    'apps.fabricacao',
    'apps.inventario',
    'apps.elearning',
    'apps.chat_ao_vivo',
    'apps.forum',
    'apps.blog',
    'apps.ecommerce',
    'apps.criador_sites',
    'apps.locacao',
    'apps.assinaturas',
    'apps.crm',
    'apps.vendas',
    'apps.assinar_documentos',
    'apps.documentos',
    'apps.planilhas',
    'apps.despesas',
    'apps.faturamento',
    'apps.financeiro',
    'apps.agendamentos',
    'apps.pacientes',
    'apps.profissionais',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'ClinicaAI.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'ClinicaAI.wsgi.application'


# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'clinicaai',
        'USER': 'postgres',
        'PASSWORD': decrypt('gAAAAABncfHWNo6zmHaKhNfNchedvGqjsJbCVDVWMZRmWKTKCAjCesVQrZOuImCOiZG33ls__sm-o74_5w4_DPPaeOtdWfIhAA=='),  # Substitua pelo texto criptografado gerado para a senha do banco de dados
        'HOST': 'localhost',
        'PORT': '5432'
    },

}


# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# ConfiguraÃ§Ãµes de CORS
CORS_ALLOW_ALL_ORIGINS = True

# Ou permitir origens especÃ­ficas
# CORS_ALLOWED_ORIGINS = [
#     'http://localhost:3000',
# ]

# ConfiguraÃ§Ãµes do Django REST Framework
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',  # Exigir autenticaÃ§Ã£o por padrÃ£o
    ),
}

# ConfiguraÃ§Ãµes do Simple JWT
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'VERIFYING_KEY': None,
    'AUTH_HEADER_TYPES': ('Bearer',),
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'TOKEN_TYPE_CLAIM': 'token_type',
}

ASGI_APPLICATION = 'ClinicaAI.asgi.application'
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            'hosts': [('127.0.0.1', 6379)],
        },
    },
}
CELERY_BROKER_URL = 'redis://localhost:6379/0'
CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'

# --- Fim do arquivo: C:\ClinicaAI\backend\ClinicaAI\settings.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\ClinicaAI\urls.py ---

"""
URL configuration for ClinicaAI project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/4.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
    TokenVerifyView,
)
from rest_framework import routers
from django.utils.log import DEFAULT_LOGGING
import logging

logger = logging.getLogger(__name__)

router = routers.DefaultRouter()

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/auth/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/auth/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    path('api/auth/token/verify/', TokenVerifyView.as_view(), name='token_verify'),  # Adicione esta linha
    path('api/prontuarios/', include('apps.prontuarios.urls')),  # Inclua as URLs do aplicativo prontuarios
    path('api/profissionais/', include('apps.profissionais.urls')),  # Inclua as URLs do aplicativo profissionais
    path('api/', include(router.urls)),  # Adicione a raiz da API
]

# Remova a adiÃ§Ã£o dos middlewares daqui
# MIDDLEWARE.append('ClinicaAI.urls.LogErrorsMiddleware')
# MIDDLEWARE.append('ClinicaAI.urls.LogLoginAttemptsMiddleware')

# --- Fim do arquivo: C:\ClinicaAI\backend\ClinicaAI\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\ClinicaAI\wsgi.py ---

"""
WSGI config for ClinicaAI project.

It exposes the WSI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'ClinicaAI.settings')

application = get_wsgi_application()

# --- Fim do arquivo: C:\ClinicaAI\backend\ClinicaAI\wsgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\aiohttp\_websocket\models.py ---

"""Models for WebSocket protocol versions 13 and 8."""

import json
from enum import IntEnum
from typing import Any, Callable, Final, NamedTuple, Optional, cast

WS_DEFLATE_TRAILING: Final[bytes] = bytes([0x00, 0x00, 0xFF, 0xFF])


class WSCloseCode(IntEnum):
    OK = 1000
    GOING_AWAY = 1001
    PROTOCOL_ERROR = 1002
    UNSUPPORTED_DATA = 1003
    ABNORMAL_CLOSURE = 1006
    INVALID_TEXT = 1007
    POLICY_VIOLATION = 1008
    MESSAGE_TOO_BIG = 1009
    MANDATORY_EXTENSION = 1010
    INTERNAL_ERROR = 1011
    SERVICE_RESTART = 1012
    TRY_AGAIN_LATER = 1013
    BAD_GATEWAY = 1014


class WSMsgType(IntEnum):
    # websocket spec types
    CONTINUATION = 0x0
    TEXT = 0x1
    BINARY = 0x2
    PING = 0x9
    PONG = 0xA
    CLOSE = 0x8

    # aiohttp specific types
    CLOSING = 0x100
    CLOSED = 0x101
    ERROR = 0x102

    text = TEXT
    binary = BINARY
    ping = PING
    pong = PONG
    close = CLOSE
    closing = CLOSING
    closed = CLOSED
    error = ERROR


class WSMessage(NamedTuple):
    type: WSMsgType
    # To type correctly, this would need some kind of tagged union for each type.
    data: Any
    extra: Optional[str]

    def json(self, *, loads: Callable[[Any], Any] = json.loads) -> Any:
        """Return parsed JSON data.

        .. versionadded:: 0.22
        """
        return loads(self.data)


# Constructing the tuple directly to avoid the overhead of
# the lambda and arg processing since NamedTuples are constructed
# with a run time built lambda
# https://github.com/python/cpython/blob/d83fcf8371f2f33c7797bc8f5423a8bca8c46e5c/Lib/collections/__init__.py#L441
WS_CLOSED_MESSAGE = tuple.__new__(WSMessage, (WSMsgType.CLOSED, None, None))
WS_CLOSING_MESSAGE = tuple.__new__(WSMessage, (WSMsgType.CLOSING, None, None))


class WebSocketError(Exception):
    """WebSocket protocol parser error."""

    def __init__(self, code: int, message: str) -> None:
        self.code = code
        super().__init__(code, message)

    def __str__(self) -> str:
        return cast(str, self.args[1])


class WSHandshakeError(Exception):
    """WebSocket protocol handshake error."""

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\aiohttp\_websocket\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\account\admin.py ---

from django.contrib import admin

from . import app_settings
from .adapter import get_adapter
from .models import EmailAddress, EmailConfirmation


class EmailAddressAdmin(admin.ModelAdmin):
    list_display = ("email", "user", "primary", "verified")
    list_filter = ("primary", "verified")
    search_fields = []
    raw_id_fields = ("user",)
    actions = ["make_verified"]

    def get_search_fields(self, request):
        base_fields = get_adapter(request).get_user_search_fields()
        return ["email"] + list(map(lambda a: "user__" + a, base_fields))

    def make_verified(self, request, queryset):
        queryset.update(verified=True)

    make_verified.short_description = "Mark selected email addresses as verified"


class EmailConfirmationAdmin(admin.ModelAdmin):
    list_display = ("email_address", "created", "sent", "key")
    list_filter = ("sent",)
    raw_id_fields = ("email_address",)


if not app_settings.EMAIL_CONFIRMATION_HMAC:
    admin.site.register(EmailConfirmation, EmailConfirmationAdmin)
admin.site.register(EmailAddress, EmailAddressAdmin)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\account\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\account\apps.py ---

from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _


class AccountConfig(AppConfig):
    name = "allauth.account"
    verbose_name = _("Accounts")
    default_auto_field = "django.db.models.AutoField"

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\account\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\account\models.py ---

import datetime

from django.core import signing
from django.db import models
from django.db.models import Q
from django.db.models.constraints import UniqueConstraint
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from .. import app_settings as allauth_app_settings
from . import app_settings, signals
from .adapter import get_adapter
from .managers import EmailAddressManager, EmailConfirmationManager
from .utils import user_email


class EmailAddress(models.Model):
    user = models.ForeignKey(
        allauth_app_settings.USER_MODEL,
        verbose_name=_("user"),
        on_delete=models.CASCADE,
    )
    email = models.EmailField(
        max_length=app_settings.EMAIL_MAX_LENGTH,
        verbose_name=_("email address"),
    )
    verified = models.BooleanField(verbose_name=_("verified"), default=False)
    primary = models.BooleanField(verbose_name=_("primary"), default=False)

    objects = EmailAddressManager()

    class Meta:
        verbose_name = _("email address")
        verbose_name_plural = _("email addresses")
        unique_together = [("user", "email")]
        if app_settings.UNIQUE_EMAIL:
            constraints = [
                UniqueConstraint(
                    fields=["email"],
                    name="unique_verified_email",
                    condition=Q(verified=True),
                )
            ]

    def __str__(self):
        return self.email

    def can_set_verified(self):
        if self.verified:
            return True
        conflict = False
        if app_settings.UNIQUE_EMAIL:
            conflict = (
                EmailAddress.objects.exclude(pk=self.pk)
                .filter(verified=True, email__iexact=self.email)
                .exists()
            )
        return not conflict

    def set_verified(self, commit=True):
        if self.verified:
            return True
        if self.can_set_verified():
            self.verified = True
            if commit:
                self.save(update_fields=["verified"])
        return self.verified

    def set_as_primary(self, conditional=False):
        """Marks the email address as primary. In case of `conditional`, it is
        only marked as primary if there is no other primary email address set.
        """
        old_primary = EmailAddress.objects.get_primary(self.user)
        if old_primary:
            if conditional:
                return False
            old_primary.primary = False
            old_primary.save()
        self.primary = True
        self.save()
        user_email(self.user, self.email, commit=True)
        return True

    def send_confirmation(self, request=None, signup=False):
        if app_settings.EMAIL_CONFIRMATION_HMAC:
            confirmation = EmailConfirmationHMAC(self)
        else:
            confirmation = EmailConfirmation.create(self)
        confirmation.send(request, signup=signup)
        return confirmation

    def remove(self):
        self.delete()
        if user_email(self.user) == self.email:
            alt = (
                EmailAddress.objects.filter(user=self.user)
                .order_by("-verified")
                .first()
            )
            alt_email = ""
            if alt:
                alt_email = alt.email
            user_email(self.user, alt_email, commit=True)


class EmailConfirmationMixin:
    def confirm(self, request):
        email_address = self.email_address
        if not email_address.verified:
            confirmed = get_adapter(request).confirm_email(request, email_address)
            if confirmed:
                signals.email_confirmed.send(
                    sender=self.__class__,
                    request=request,
                    email_address=email_address,
                )
                return email_address

    def send(self, request=None, signup=False):
        get_adapter(request).send_confirmation_mail(request, self, signup)
        signals.email_confirmation_sent.send(
            sender=self.__class__,
            request=request,
            confirmation=self,
            signup=signup,
        )


class EmailConfirmation(EmailConfirmationMixin, models.Model):
    email_address = models.ForeignKey(
        EmailAddress,
        verbose_name=_("email address"),
        on_delete=models.CASCADE,
    )
    created = models.DateTimeField(verbose_name=_("created"), default=timezone.now)
    sent = models.DateTimeField(verbose_name=_("sent"), null=True)
    key = models.CharField(verbose_name=_("key"), max_length=64, unique=True)

    objects = EmailConfirmationManager()

    class Meta:
        verbose_name = _("email confirmation")
        verbose_name_plural = _("email confirmations")

    def __str__(self):
        return "confirmation for %s" % self.email_address

    @classmethod
    def create(cls, email_address):
        key = get_adapter().generate_emailconfirmation_key(email_address.email)
        return cls._default_manager.create(email_address=email_address, key=key)

    def key_expired(self):
        expiration_date = self.sent + datetime.timedelta(
            days=app_settings.EMAIL_CONFIRMATION_EXPIRE_DAYS
        )
        return expiration_date <= timezone.now()

    key_expired.boolean = True

    def confirm(self, request):
        if not self.key_expired():
            return super().confirm(request)

    def send(self, request=None, signup=False):
        super().send(request=request, signup=signup)
        self.sent = timezone.now()
        self.save()


class EmailConfirmationHMAC(EmailConfirmationMixin, object):
    def __init__(self, email_address):
        self.email_address = email_address

    @property
    def key(self):
        return signing.dumps(obj=self.email_address.pk, salt=app_settings.SALT)

    @classmethod
    def from_key(cls, key):
        try:
            max_age = 60 * 60 * 24 * app_settings.EMAIL_CONFIRMATION_EXPIRE_DAYS
            pk = signing.loads(key, max_age=max_age, salt=app_settings.SALT)
            ret = EmailConfirmationHMAC(EmailAddress.objects.get(pk=pk, verified=False))
        except (
            signing.SignatureExpired,
            signing.BadSignature,
            EmailAddress.DoesNotExist,
        ):
            ret = None
        return ret

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\account\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\account\urls.py ---

from django.urls import path, re_path

from . import views


urlpatterns = [
    path("signup/", views.signup, name="account_signup"),
    path("login/", views.login, name="account_login"),
    path("logout/", views.logout, name="account_logout"),
    path(
        "password/change/",
        views.password_change,
        name="account_change_password",
    ),
    path("password/set/", views.password_set, name="account_set_password"),
    path("inactive/", views.account_inactive, name="account_inactive"),
    # Email
    path("email/", views.email, name="account_email"),
    path(
        "confirm-email/",
        views.email_verification_sent,
        name="account_email_verification_sent",
    ),
    re_path(
        r"^confirm-email/(?P<key>[-:\w]+)/$",
        views.confirm_email,
        name="account_confirm_email",
    ),
    # password reset
    path("password/reset/", views.password_reset, name="account_reset_password"),
    path(
        "password/reset/done/",
        views.password_reset_done,
        name="account_reset_password_done",
    ),
    re_path(
        r"^password/reset/key/(?P<uidb36>[0-9A-Za-z]+)-(?P<key>.+)/$",
        views.password_reset_from_key,
        name="account_reset_password_from_key",
    ),
    path(
        "password/reset/key/done/",
        views.password_reset_from_key_done,
        name="account_reset_password_from_key_done",
    ),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\account\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\account\views.py ---

from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.contrib.sites.shortcuts import get_current_site
from django.http import (
    Http404,
    HttpResponsePermanentRedirect,
    HttpResponseRedirect,
)
from django.shortcuts import redirect
from django.urls import reverse, reverse_lazy
from django.utils.decorators import method_decorator
from django.views.decorators.debug import sensitive_post_parameters
from django.views.generic.base import TemplateResponseMixin, TemplateView, View
from django.views.generic.edit import FormView

from allauth import ratelimit
from allauth.decorators import rate_limit
from allauth.exceptions import ImmediateHttpResponse
from allauth.utils import get_form_class, get_request_param

from . import app_settings, signals
from .adapter import get_adapter
from .forms import (
    AddEmailForm,
    ChangePasswordForm,
    LoginForm,
    ResetPasswordForm,
    ResetPasswordKeyForm,
    SetPasswordForm,
    SignupForm,
    UserTokenForm,
)
from .models import EmailAddress, EmailConfirmation, EmailConfirmationHMAC
from .utils import (
    complete_signup,
    get_login_redirect_url,
    get_next_redirect_url,
    logout_on_password_change,
    passthrough_next_redirect_url,
    perform_login,
    send_email_confirmation,
    sync_user_email_addresses,
    url_str_to_user_pk,
)


INTERNAL_RESET_SESSION_KEY = "_password_reset_key"


sensitive_post_parameters_m = method_decorator(
    sensitive_post_parameters("oldpassword", "password", "password1", "password2")
)


def _ajax_response(request, response, form=None, data=None):
    adapter = get_adapter(request)
    if adapter.is_ajax(request):
        if isinstance(response, HttpResponseRedirect) or isinstance(
            response, HttpResponsePermanentRedirect
        ):
            redirect_to = response["Location"]
        else:
            redirect_to = None
        response = adapter.ajax_response(
            request, response, form=form, data=data, redirect_to=redirect_to
        )
    return response


class RedirectAuthenticatedUserMixin(object):
    def dispatch(self, request, *args, **kwargs):
        if request.user.is_authenticated and app_settings.AUTHENTICATED_LOGIN_REDIRECTS:
            redirect_to = self.get_authenticated_redirect_url()
            response = HttpResponseRedirect(redirect_to)
            return _ajax_response(request, response)
        else:
            response = super(RedirectAuthenticatedUserMixin, self).dispatch(
                request, *args, **kwargs
            )
        return response

    def get_authenticated_redirect_url(self):
        redirect_field_name = self.redirect_field_name
        return get_login_redirect_url(
            self.request,
            url=self.get_success_url(),
            redirect_field_name=redirect_field_name,
        )


class AjaxCapableProcessFormViewMixin(object):
    def get(self, request, *args, **kwargs):
        response = super(AjaxCapableProcessFormViewMixin, self).get(
            request, *args, **kwargs
        )
        form = self.get_form()
        return _ajax_response(
            self.request, response, form=form, data=self._get_ajax_data_if()
        )

    def post(self, request, *args, **kwargs):
        form_class = self.get_form_class()
        form = self.get_form(form_class)
        if form.is_valid():
            response = self.form_valid(form)
        else:
            response = self.form_invalid(form)
        return _ajax_response(
            self.request, response, form=form, data=self._get_ajax_data_if()
        )

    def get_form(self, form_class=None):
        form = getattr(self, "_cached_form", None)
        if form is None:
            form = super(AjaxCapableProcessFormViewMixin, self).get_form(form_class)
            self._cached_form = form
        return form

    def _get_ajax_data_if(self):
        return (
            self.get_ajax_data()
            if get_adapter(self.request).is_ajax(self.request)
            else None
        )

    def get_ajax_data(self):
        return None


class LogoutFunctionalityMixin(object):
    def logout(self):
        adapter = get_adapter(self.request)
        adapter.add_message(
            self.request, messages.SUCCESS, "account/messages/logged_out.txt"
        )
        adapter.logout(self.request)


class LoginView(
    RedirectAuthenticatedUserMixin, AjaxCapableProcessFormViewMixin, FormView
):
    form_class = LoginForm
    template_name = "account/login." + app_settings.TEMPLATE_EXTENSION
    success_url = None
    redirect_field_name = "next"

    @sensitive_post_parameters_m
    def dispatch(self, request, *args, **kwargs):
        return super(LoginView, self).dispatch(request, *args, **kwargs)

    def get_form_kwargs(self):
        kwargs = super(LoginView, self).get_form_kwargs()
        kwargs["request"] = self.request
        return kwargs

    def get_form_class(self):
        return get_form_class(app_settings.FORMS, "login", self.form_class)

    def form_valid(self, form):
        success_url = self.get_success_url()
        try:
            return form.login(self.request, redirect_url=success_url)
        except ImmediateHttpResponse as e:
            return e.response

    def get_success_url(self):
        # Explicitly passed ?next= URL takes precedence
        ret = (
            get_next_redirect_url(self.request, self.redirect_field_name)
            or self.success_url
        )
        return ret

    def get_context_data(self, **kwargs):
        ret = super(LoginView, self).get_context_data(**kwargs)
        signup_url = passthrough_next_redirect_url(
            self.request, reverse("account_signup"), self.redirect_field_name
        )
        redirect_field_value = get_request_param(self.request, self.redirect_field_name)
        site = get_current_site(self.request)

        ret.update(
            {
                "signup_url": signup_url,
                "site": site,
                "redirect_field_name": self.redirect_field_name,
                "redirect_field_value": redirect_field_value,
            }
        )
        return ret


login = LoginView.as_view()


class CloseableSignupMixin(object):
    template_name_signup_closed = (
        "account/signup_closed." + app_settings.TEMPLATE_EXTENSION
    )

    def dispatch(self, request, *args, **kwargs):
        try:
            if not self.is_open():
                return self.closed()
        except ImmediateHttpResponse as e:
            return e.response
        return super(CloseableSignupMixin, self).dispatch(request, *args, **kwargs)

    def is_open(self):
        return get_adapter(self.request).is_open_for_signup(self.request)

    def closed(self):
        response_kwargs = {
            "request": self.request,
            "template": self.template_name_signup_closed,
        }
        return self.response_class(**response_kwargs)


@method_decorator(rate_limit(action="signup"), name="dispatch")
class SignupView(
    RedirectAuthenticatedUserMixin,
    CloseableSignupMixin,
    AjaxCapableProcessFormViewMixin,
    FormView,
):
    template_name = "account/signup." + app_settings.TEMPLATE_EXTENSION
    form_class = SignupForm
    redirect_field_name = "next"
    success_url = None

    @sensitive_post_parameters_m
    def dispatch(self, request, *args, **kwargs):
        return super(SignupView, self).dispatch(request, *args, **kwargs)

    def get_form_class(self):
        return get_form_class(app_settings.FORMS, "signup", self.form_class)

    def get_success_url(self):
        # Explicitly passed ?next= URL takes precedence
        ret = (
            get_next_redirect_url(self.request, self.redirect_field_name)
            or self.success_url
        )
        return ret

    def form_valid(self, form):
        self.user, resp = form.try_save(self.request)
        if resp:
            return resp
        try:
            return complete_signup(
                self.request,
                self.user,
                app_settings.EMAIL_VERIFICATION,
                self.get_success_url(),
            )
        except ImmediateHttpResponse as e:
            return e.response

    def get_context_data(self, **kwargs):
        ret = super(SignupView, self).get_context_data(**kwargs)
        form = ret["form"]
        email = self.request.session.get("account_verified_email")
        if email:
            email_keys = ["email"]
            if app_settings.SIGNUP_EMAIL_ENTER_TWICE:
                email_keys.append("email2")
            for email_key in email_keys:
                form.fields[email_key].initial = email
        login_url = passthrough_next_redirect_url(
            self.request, reverse("account_login"), self.redirect_field_name
        )
        redirect_field_name = self.redirect_field_name
        site = get_current_site(self.request)
        redirect_field_value = get_request_param(self.request, redirect_field_name)
        ret.update(
            {
                "login_url": login_url,
                "redirect_field_name": redirect_field_name,
                "redirect_field_value": redirect_field_value,
                "site": site,
            }
        )
        return ret


signup = SignupView.as_view()


class ConfirmEmailView(TemplateResponseMixin, LogoutFunctionalityMixin, View):
    template_name = "account/email_confirm." + app_settings.TEMPLATE_EXTENSION

    def get(self, *args, **kwargs):
        try:
            self.object = self.get_object()
            if app_settings.CONFIRM_EMAIL_ON_GET:
                return self.post(*args, **kwargs)
        except Http404:
            self.object = None
        ctx = self.get_context_data()
        return self.render_to_response(ctx)

    def post(self, *args, **kwargs):
        self.object = confirmation = self.get_object()
        email_address = confirmation.confirm(self.request)
        if not email_address:
            get_adapter(self.request).add_message(
                self.request,
                messages.ERROR,
                "account/messages/email_confirmation_failed.txt",
                {"email": confirmation.email_address.email},
            )
            return self.respond(False)

        # In the event someone clicks on an email confirmation link
        # for one account while logged into another account,
        # logout of the currently logged in account.
        if (
            self.request.user.is_authenticated
            and self.request.user.pk != confirmation.email_address.user_id
        ):
            self.logout()

        get_adapter(self.request).add_message(
            self.request,
            messages.SUCCESS,
            "account/messages/email_confirmed.txt",
            {"email": confirmation.email_address.email},
        )
        if app_settings.LOGIN_ON_EMAIL_CONFIRMATION:
            resp = self.login_on_confirm(confirmation)
            if resp is not None:
                return resp
        # Don't -- allauth doesn't touch is_active so that sys admin can
        # use it to block users et al
        #
        # user = confirmation.email_address.user
        # user.is_active = True
        # user.save()
        return self.respond(True)

    def respond(self, success):
        redirect_url = self.get_redirect_url()
        if not redirect_url:
            ctx = self.get_context_data()
            return self.render_to_response(ctx)
        return redirect(redirect_url)

    def login_on_confirm(self, confirmation):
        """
        Simply logging in the user may become a security issue. If you
        do not take proper care (e.g. don't purge used email
        confirmations), a malicious person that got hold of the link
        will be able to login over and over again and the user is
        unable to do anything about it. Even restoring their own mailbox
        security will not help, as the links will still work. For
        password reset this is different, this mechanism works only as
        long as the attacker has access to the mailbox. If they no
        longer has access they cannot issue a password request and
        intercept it. Furthermore, all places where the links are
        listed (log files, but even Google Analytics) all of a sudden
        need to be secured. Purging the email confirmation once
        confirmed changes the behavior -- users will not be able to
        repeatedly confirm (in case they forgot that they already
        clicked the mail).

        All in all, opted for storing the user that is in the process
        of signing up in the session to avoid all of the above.  This
        may not 100% work in case the user closes the browser (and the
        session gets lost), but at least we're secure.
        """
        user_pk = None
        user_pk_str = get_adapter(self.request).unstash_user(self.request)
        if user_pk_str:
            user_pk = url_str_to_user_pk(user_pk_str)
        user = confirmation.email_address.user
        if user_pk == user.pk and self.request.user.is_anonymous:
            return perform_login(
                self.request,
                user,
                app_settings.EmailVerificationMethod.NONE,
                # passed as callable, as this method
                # depends on the authenticated state
                redirect_url=self.get_redirect_url,
            )

        return None

    def get_object(self, queryset=None):
        key = self.kwargs["key"]
        emailconfirmation = EmailConfirmationHMAC.from_key(key)
        if not emailconfirmation:
            if queryset is None:
                queryset = self.get_queryset()
            try:
                emailconfirmation = queryset.get(key=key.lower())
            except EmailConfirmation.DoesNotExist:
                raise Http404()
        return emailconfirmation

    def get_queryset(self):
        qs = EmailConfirmation.objects.all_valid()
        qs = qs.select_related("email_address__user")
        return qs

    def get_context_data(self, **kwargs):
        ctx = kwargs
        site = get_current_site(self.request)
        ctx.update(
            {
                "site": site,
                "confirmation": self.object,
                "can_confirm": self.object.email_address.can_set_verified(),
                "email": self.object.email_address.email,
            }
        )
        return ctx

    def get_redirect_url(self):
        return get_adapter(self.request).get_email_confirmation_redirect_url(
            self.request
        )


confirm_email = ConfirmEmailView.as_view()


@method_decorator(rate_limit(action="manage_email"), name="dispatch")
class EmailView(AjaxCapableProcessFormViewMixin, FormView):
    template_name = (
        "account/email_change." if app_settings.CHANGE_EMAIL else "account/email."
    ) + app_settings.TEMPLATE_EXTENSION
    form_class = AddEmailForm
    success_url = reverse_lazy("account_email")

    def get_form_class(self):
        return get_form_class(app_settings.FORMS, "add_email", self.form_class)

    def dispatch(self, request, *args, **kwargs):
        sync_user_email_addresses(request.user)
        return super(EmailView, self).dispatch(request, *args, **kwargs)

    def get_form_kwargs(self):
        kwargs = super(EmailView, self).get_form_kwargs()
        kwargs["user"] = self.request.user
        return kwargs

    def form_valid(self, form):
        email_address = form.save(self.request)
        get_adapter(self.request).add_message(
            self.request,
            messages.INFO,
            "account/messages/email_confirmation_sent.txt",
            {"email": form.cleaned_data["email"]},
        )
        signals.email_added.send(
            sender=self.request.user.__class__,
            request=self.request,
            user=self.request.user,
            email_address=email_address,
        )
        return super(EmailView, self).form_valid(form)

    def post(self, request, *args, **kwargs):
        res = None
        if "action_add" in request.POST:
            res = super(EmailView, self).post(request, *args, **kwargs)
        elif request.POST.get("email"):
            if "action_send" in request.POST:
                res = self._action_send(request)
            elif "action_remove" in request.POST:
                res = self._action_remove(request)
            elif "action_primary" in request.POST:
                res = self._action_primary(request)
            res = res or HttpResponseRedirect(self.get_success_url())
            # Given that we bypassed AjaxCapableProcessFormViewMixin,
            # we'll have to call invoke it manually...
            res = _ajax_response(request, res, data=self._get_ajax_data_if())
        else:
            # No email address selected
            res = HttpResponseRedirect(self.success_url)
            res = _ajax_response(request, res, data=self._get_ajax_data_if())
        return res

    def _get_email_address(self, request):
        email = request.POST["email"]
        try:
            return EmailAddress.objects.get_for_user(user=request.user, email=email)
        except EmailAddress.DoesNotExist:
            pass

    def _action_send(self, request, *args, **kwargs):
        email_address = self._get_email_address(request)
        if email_address:
            send_email_confirmation(
                self.request, request.user, email=email_address.email
            )

    def _action_remove(self, request, *args, **kwargs):
        email_address = self._get_email_address(request)
        if email_address:
            if email_address.primary:
                get_adapter(request).add_message(
                    request,
                    messages.ERROR,
                    "account/messages/cannot_delete_primary_email.txt",
                    {"email": email_address.email},
                )
            else:
                email_address.remove()
                signals.email_removed.send(
                    sender=request.user.__class__,
                    request=request,
                    user=request.user,
                    email_address=email_address,
                )
                get_adapter(request).add_message(
                    request,
                    messages.SUCCESS,
                    "account/messages/email_deleted.txt",
                    {"email": email_address.email},
                )
                return HttpResponseRedirect(self.get_success_url())

    def _action_primary(self, request, *args, **kwargs):
        email_address = self._get_email_address(request)
        if email_address:
            # Not primary=True -- Slightly different variation, don't
            # require verified unless moving from a verified
            # address. Ignore constraint if previous primary email
            # address is not verified.
            if (
                not email_address.verified
                and EmailAddress.objects.filter(
                    user=request.user, verified=True
                ).exists()
            ):
                get_adapter(request).add_message(
                    request,
                    messages.ERROR,
                    "account/messages/unverified_primary_email.txt",
                )
            else:
                # Sending the old primary address to the signal
                # adds a db query.
                try:
                    from_email_address = EmailAddress.objects.get(
                        user=request.user, primary=True
                    )
                except EmailAddress.DoesNotExist:
                    from_email_address = None
                email_address.set_as_primary()
                get_adapter(request).add_message(
                    request,
                    messages.SUCCESS,
                    "account/messages/primary_email_set.txt",
                )
                signals.email_changed.send(
                    sender=request.user.__class__,
                    request=request,
                    user=request.user,
                    from_email_address=from_email_address,
                    to_email_address=email_address,
                )
                return HttpResponseRedirect(self.get_success_url())

    def get_context_data(self, **kwargs):
        ret = super(EmailView, self).get_context_data(**kwargs)
        ret.update(
            {
                "emailaddresses": list(
                    EmailAddress.objects.filter(user=self.request.user).order_by(
                        "email"
                    )
                ),
                "add_email_form": ret.get("form"),
                "can_add_email": EmailAddress.objects.can_add_email(self.request.user),
            }
        )
        if app_settings.CHANGE_EMAIL:
            ret.update(
                {
                    "new_emailaddress": EmailAddress.objects.get_new(self.request.user),
                    "current_emailaddress": EmailAddress.objects.get_verified(
                        self.request.user
                    ),
                }
            )
        return ret

    def get_ajax_data(self):
        data = []
        for emailaddress in self.request.user.emailaddress_set.all():
            data.append(
                {
                    "id": emailaddress.pk,
                    "email": emailaddress.email,
                    "verified": emailaddress.verified,
                    "primary": emailaddress.primary,
                }
            )
        return data


email = login_required(EmailView.as_view())


@method_decorator(rate_limit(action="change_password"), name="dispatch")
class PasswordChangeView(AjaxCapableProcessFormViewMixin, FormView):
    template_name = "account/password_change." + app_settings.TEMPLATE_EXTENSION
    form_class = ChangePasswordForm
    success_url = reverse_lazy("account_change_password")

    def get_form_class(self):
        return get_form_class(app_settings.FORMS, "change_password", self.form_class)

    @sensitive_post_parameters_m
    def dispatch(self, request, *args, **kwargs):
        return super(PasswordChangeView, self).dispatch(request, *args, **kwargs)

    def render_to_response(self, context, **response_kwargs):
        if self.request.user.is_anonymous:
            # We end up here when `ACCOUNT_LOGOUT_ON_PASSWORD_CHANGE = True`.
            redirect_url = get_adapter(self.request).get_logout_redirect_url(
                self.request
            )
            return HttpResponseRedirect(redirect_url)
        elif not self.request.user.has_usable_password():
            return HttpResponseRedirect(reverse("account_set_password"))
        return super(PasswordChangeView, self).render_to_response(
            context, **response_kwargs
        )

    def get_form_kwargs(self):
        kwargs = super(PasswordChangeView, self).get_form_kwargs()
        kwargs["user"] = self.request.user
        return kwargs

    def form_valid(self, form):
        form.save()
        logout_on_password_change(self.request, form.user)
        get_adapter(self.request).add_message(
            self.request,
            messages.SUCCESS,
            "account/messages/password_changed.txt",
        )
        signals.password_changed.send(
            sender=self.request.user.__class__,
            request=self.request,
            user=self.request.user,
        )
        return super(PasswordChangeView, self).form_valid(form)

    def get_context_data(self, **kwargs):
        ret = super(PasswordChangeView, self).get_context_data(**kwargs)
        # NOTE: For backwards compatibility
        ret["password_change_form"] = ret.get("form")
        # (end NOTE)
        return ret


password_change = login_required(PasswordChangeView.as_view())


@method_decorator(
    # NOTE: 'change_password' (iso 'set_') is intentional, there is no need to
    # differentiate between set and change.
    rate_limit(action="change_password"),
    name="dispatch",
)
class PasswordSetView(AjaxCapableProcessFormViewMixin, FormView):
    template_name = "account/password_set." + app_settings.TEMPLATE_EXTENSION
    form_class = SetPasswordForm
    success_url = reverse_lazy("account_set_password")

    def get_form_class(self):
        return get_form_class(app_settings.FORMS, "set_password", self.form_class)

    @sensitive_post_parameters_m
    def dispatch(self, request, *args, **kwargs):
        if self.request.user.has_usable_password():
            return HttpResponseRedirect(reverse("account_change_password"))
        return super(PasswordSetView, self).dispatch(request, *args, **kwargs)

    def render_to_response(self, context, **response_kwargs):
        return super(PasswordSetView, self).render_to_response(
            context, **response_kwargs
        )

    def get_form_kwargs(self):
        kwargs = super(PasswordSetView, self).get_form_kwargs()
        kwargs["user"] = self.request.user
        return kwargs

    def form_valid(self, form):
        form.save()
        logout_on_password_change(self.request, form.user)
        get_adapter(self.request).add_message(
            self.request, messages.SUCCESS, "account/messages/password_set.txt"
        )
        signals.password_set.send(
            sender=self.request.user.__class__,
            request=self.request,
            user=self.request.user,
        )
        return super(PasswordSetView, self).form_valid(form)

    def get_context_data(self, **kwargs):
        ret = super(PasswordSetView, self).get_context_data(**kwargs)
        # NOTE: For backwards compatibility
        ret["password_set_form"] = ret.get("form")
        # (end NOTE)
        return ret


password_set = login_required(PasswordSetView.as_view())


@method_decorator(rate_limit(action="reset_password"), name="dispatch")
class PasswordResetView(AjaxCapableProcessFormViewMixin, FormView):
    template_name = "account/password_reset." + app_settings.TEMPLATE_EXTENSION
    form_class = ResetPasswordForm
    success_url = reverse_lazy("account_reset_password_done")
    redirect_field_name = "next"

    def get_form_class(self):
        return get_form_class(app_settings.FORMS, "reset_password", self.form_class)

    def form_valid(self, form):
        r429 = ratelimit.consume_or_429(
            self.request,
            action="reset_password_email",
            key=form.cleaned_data["email"].lower(),
        )
        if r429:
            return r429
        form.save(self.request)
        return super(PasswordResetView, self).form_valid(form)

    def get_context_data(self, **kwargs):
        ret = super(PasswordResetView, self).get_context_data(**kwargs)
        login_url = passthrough_next_redirect_url(
            self.request, reverse("account_login"), self.redirect_field_name
        )
        # NOTE: For backwards compatibility
        ret["password_reset_form"] = ret.get("form")
        # (end NOTE)
        ret.update({"login_url": login_url})
        return ret


password_reset = PasswordResetView.as_view()


class PasswordResetDoneView(TemplateView):
    template_name = "account/password_reset_done." + app_settings.TEMPLATE_EXTENSION


password_reset_done = PasswordResetDoneView.as_view()


@method_decorator(rate_limit(action="reset_password_from_key"), name="dispatch")
class PasswordResetFromKeyView(
    AjaxCapableProcessFormViewMixin, LogoutFunctionalityMixin, FormView
):
    template_name = "account/password_reset_from_key." + app_settings.TEMPLATE_EXTENSION
    form_class = ResetPasswordKeyForm
    success_url = reverse_lazy("account_reset_password_from_key_done")
    reset_url_key = "set-password"

    def get_form_class(self):
        return get_form_class(
            app_settings.FORMS, "reset_password_from_key", self.form_class
        )

    def dispatch(self, request, uidb36, key, **kwargs):
        self.request = request
        self.key = key

        user_token_form_class = get_form_class(
            app_settings.FORMS, "user_token", UserTokenForm
        )
        if self.key == self.reset_url_key:
            self.key = self.request.session.get(INTERNAL_RESET_SESSION_KEY, "")
            # (Ab)using forms here to be able to handle errors in XHR #890
            token_form = user_token_form_class(data={"uidb36": uidb36, "key": self.key})
            if token_form.is_valid():
                self.reset_user = token_form.reset_user

                # In the event someone clicks on a password reset link
                # for one account while logged into another account,
                # logout of the currently logged in account.
                if (
                    self.request.user.is_authenticated
                    and self.request.user.pk != self.reset_user.pk
                ):
                    self.logout()
                    self.request.session[INTERNAL_RESET_SESSION_KEY] = self.key

                return super(PasswordResetFromKeyView, self).dispatch(
                    request, uidb36, self.key, **kwargs
                )
        else:
            token_form = user_token_form_class(data={"uidb36": uidb36, "key": self.key})
            if token_form.is_valid():
                # Store the key in the session and redirect to the
                # password reset form at a URL without the key. That
                # avoids the possibility of leaking the key in the
                # HTTP Referer header.
                self.request.session[INTERNAL_RESET_SESSION_KEY] = self.key
                redirect_url = self.request.path.replace(self.key, self.reset_url_key)
                return redirect(redirect_url)

        self.reset_user = None
        response = self.render_to_response(self.get_context_data(token_fail=True))
        return _ajax_response(self.request, response, form=token_form)

    def get_context_data(self, **kwargs):
        ret = super(PasswordResetFromKeyView, self).get_context_data(**kwargs)
        ret["action_url"] = reverse(
            "account_reset_password_from_key",
            kwargs={
                "uidb36": self.kwargs["uidb36"],
                "key": self.kwargs["key"],
            },
        )
        return ret

    def get_form_kwargs(self):
        kwargs = super(PasswordResetFromKeyView, self).get_form_kwargs()
        kwargs["user"] = self.reset_user
        kwargs["temp_key"] = self.key
        return kwargs

    def form_valid(self, form):
        form.save()
        adapter = get_adapter(self.request)

        if self.reset_user and app_settings.LOGIN_ATTEMPTS_LIMIT:
            # User successfully reset the password, clear any
            # possible cache entries for all email addresses.
            for email in self.reset_user.emailaddress_set.all():
                adapter._delete_login_attempts_cached_email(
                    self.request, email=email.email
                )

        adapter.add_message(
            self.request,
            messages.SUCCESS,
            "account/messages/password_changed.txt",
        )
        signals.password_reset.send(
            sender=self.reset_user.__class__,
            request=self.request,
            user=self.reset_user,
        )

        if app_settings.LOGIN_ON_PASSWORD_RESET:
            return perform_login(
                self.request,
                self.reset_user,
                email_verification=app_settings.EMAIL_VERIFICATION,
            )

        return super(PasswordResetFromKeyView, self).form_valid(form)


password_reset_from_key = PasswordResetFromKeyView.as_view()


class PasswordResetFromKeyDoneView(TemplateView):
    template_name = (
        "account/password_reset_from_key_done." + app_settings.TEMPLATE_EXTENSION
    )


password_reset_from_key_done = PasswordResetFromKeyDoneView.as_view()


class LogoutView(TemplateResponseMixin, LogoutFunctionalityMixin, View):
    template_name = "account/logout." + app_settings.TEMPLATE_EXTENSION
    redirect_field_name = "next"

    def get(self, *args, **kwargs):
        if app_settings.LOGOUT_ON_GET:
            return self.post(*args, **kwargs)
        if not self.request.user.is_authenticated:
            response = redirect(self.get_redirect_url())
            return _ajax_response(self.request, response)
        ctx = self.get_context_data()
        response = self.render_to_response(ctx)
        return _ajax_response(self.request, response)

    def post(self, *args, **kwargs):
        url = self.get_redirect_url()
        if self.request.user.is_authenticated:
            self.logout()
        response = redirect(url)
        return _ajax_response(self.request, response)

    def get_context_data(self, **kwargs):
        ctx = kwargs
        redirect_field_value = get_request_param(self.request, self.redirect_field_name)
        ctx.update(
            {
                "redirect_field_name": self.redirect_field_name,
                "redirect_field_value": redirect_field_value,
            }
        )
        return ctx

    def get_redirect_url(self):
        return get_next_redirect_url(
            self.request, self.redirect_field_name
        ) or get_adapter(self.request).get_logout_redirect_url(self.request)


logout = LogoutView.as_view()


class AccountInactiveView(TemplateView):
    template_name = "account/account_inactive." + app_settings.TEMPLATE_EXTENSION


account_inactive = AccountInactiveView.as_view()


class EmailVerificationSentView(TemplateView):
    template_name = "account/verification_sent." + app_settings.TEMPLATE_EXTENSION


email_verification_sent = EmailVerificationSentView.as_view()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\account\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\agave\urls.py ---

from allauth.socialaccount.providers.agave.provider import AgaveProvider
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns


urlpatterns = default_urlpatterns(AgaveProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\agave\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\agave\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.agave.provider import AgaveProvider
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)


class AgaveAdapter(OAuth2Adapter):
    provider_id = AgaveProvider.id

    settings = app_settings.PROVIDERS.get(provider_id, {})
    provider_base_url = settings.get("API_URL", "https://public.agaveapi.co")

    access_token_url = "{0}/token".format(provider_base_url)
    authorize_url = "{0}/authorize".format(provider_base_url)
    profile_url = "{0}/profiles/v2/me".format(provider_base_url)

    def complete_login(self, request, app, token, response):
        extra_data = requests.get(
            self.profile_url,
            params={"access_token": token.token},
            headers={
                "Authorization": "Bearer " + token.token,
            },
        )

        user_profile = (
            extra_data.json()["result"] if "result" in extra_data.json() else {}
        )

        return self.get_provider().sociallogin_from_response(request, user_profile)


oauth2_login = OAuth2LoginView.adapter_view(AgaveAdapter)
oauth2_callback = OAuth2CallbackView.adapter_view(AgaveAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\agave\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\amazon\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import AmazonProvider


urlpatterns = default_urlpatterns(AmazonProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\amazon\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\amazon\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import AmazonProvider


class AmazonOAuth2Adapter(OAuth2Adapter):
    provider_id = AmazonProvider.id
    access_token_url = "https://api.amazon.com/auth/o2/token"
    authorize_url = "http://www.amazon.com/ap/oa"
    profile_url = "https://api.amazon.com/user/profile"
    supports_state = False

    def complete_login(self, request, app, token, **kwargs):
        response = requests.get(self.profile_url, params={"access_token": token})
        extra_data = response.json()
        if "Profile" in extra_data:
            extra_data = {
                "user_id": extra_data["Profile"]["CustomerId"],
                "name": extra_data["Profile"]["Name"],
                "email": extra_data["Profile"]["PrimaryEmail"],
            }
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(AmazonOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(AmazonOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\amazon\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\amazon_cognito\urls.py ---

from allauth.socialaccount.providers.amazon_cognito.provider import (
    AmazonCognitoProvider,
)
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns


urlpatterns = default_urlpatterns(AmazonCognitoProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\amazon_cognito\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\amazon_cognito\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.amazon_cognito.provider import (
    AmazonCognitoProvider,
)
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)


class AmazonCognitoOAuth2Adapter(OAuth2Adapter):
    provider_id = AmazonCognitoProvider.id

    DOMAIN_KEY_MISSING_ERROR = (
        '"DOMAIN" key is missing in Amazon Cognito configuration.'
    )

    @property
    def settings(self):
        return app_settings.PROVIDERS.get(self.provider_id, {})

    @property
    def domain(self):
        domain = self.settings.get("DOMAIN")

        if domain is None:
            raise ValueError(self.DOMAIN_KEY_MISSING_ERROR)

        return domain

    @property
    def access_token_url(self):
        return "{}/oauth2/token".format(self.domain)

    @property
    def authorize_url(self):
        return "{}/oauth2/authorize".format(self.domain)

    @property
    def profile_url(self):
        return "{}/oauth2/userInfo".format(self.domain)

    def complete_login(self, request, app, access_token, **kwargs):
        headers = {
            "Authorization": "Bearer {}".format(access_token),
        }
        extra_data = requests.get(self.profile_url, headers=headers)
        extra_data.raise_for_status()

        return self.get_provider().sociallogin_from_response(request, extra_data.json())


oauth2_login = OAuth2LoginView.adapter_view(AmazonCognitoOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(AmazonCognitoOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\amazon_cognito\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\angellist\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import AngelListProvider


urlpatterns = default_urlpatterns(AngelListProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\angellist\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\angellist\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import AngelListProvider


class AngelListOAuth2Adapter(OAuth2Adapter):
    provider_id = AngelListProvider.id
    access_token_url = "https://angel.co/api/oauth/token/"
    authorize_url = "https://angel.co/api/oauth/authorize/"
    profile_url = "https://api.angel.co/1/me/"
    supports_state = False

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(self.profile_url, params={"access_token": token.token})
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(AngelListOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(AngelListOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\angellist\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\apple\urls.py ---

from django.urls import path

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import AppleProvider
from .views import oauth2_finish_login


urlpatterns = default_urlpatterns(AppleProvider)
urlpatterns += [
    path(
        AppleProvider.get_slug() + "/login/callback/finish/",
        oauth2_finish_login,
        name="apple_finish_callback",
    ),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\apple\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\apple\views.py ---

import json
import requests
from datetime import timedelta

from django.http import HttpResponseNotAllowed, HttpResponseRedirect
from django.urls import reverse
from django.utils import timezone
from django.utils.http import urlencode
from django.views.decorators.csrf import csrf_exempt

import jwt

from allauth.socialaccount.adapter import get_adapter
from allauth.socialaccount.models import SocialToken
from allauth.socialaccount.providers.oauth2.client import OAuth2Error
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)
from allauth.utils import build_absolute_uri, get_request_param

from .apple_session import get_apple_session
from .client import AppleOAuth2Client
from .provider import AppleProvider


class AppleOAuth2Adapter(OAuth2Adapter):
    client_class = AppleOAuth2Client
    provider_id = AppleProvider.id
    access_token_url = "https://appleid.apple.com/auth/token"
    authorize_url = "https://appleid.apple.com/auth/authorize"
    public_key_url = "https://appleid.apple.com/auth/keys"

    def _get_apple_public_key(self, kid):
        response = requests.get(self.public_key_url)
        response.raise_for_status()
        try:
            data = response.json()
        except json.JSONDecodeError as e:
            raise OAuth2Error("Error retrieving apple public key.") from e

        for d in data["keys"]:
            if d["kid"] == kid:
                return d

    def get_public_key(self, id_token):
        """
        Get the public key which matches the `kid` in the id_token header.
        """
        kid = jwt.get_unverified_header(id_token)["kid"]
        apple_public_key = self._get_apple_public_key(kid=kid)

        public_key = jwt.algorithms.RSAAlgorithm.from_jwk(json.dumps(apple_public_key))
        return public_key

    def get_client_id(self, provider):
        app = get_adapter().get_app(request=None, provider=self.provider_id)
        return [aud.strip() for aud in app.client_id.split(",")]

    def get_verified_identity_data(self, id_token):
        provider = self.get_provider()
        allowed_auds = self.get_client_id(provider)

        try:
            public_key = self.get_public_key(id_token)
            identity_data = jwt.decode(
                id_token,
                public_key,
                algorithms=["RS256"],
                audience=allowed_auds,
                issuer="https://appleid.apple.com",
            )
            return identity_data

        except jwt.PyJWTError as e:
            raise OAuth2Error("Invalid id_token") from e

    def parse_token(self, data):
        token = SocialToken(
            token=data["access_token"],
        )
        token.token_secret = data.get("refresh_token", "")

        expires_in = data.get(self.expires_in_key)
        if expires_in:
            token.expires_at = timezone.now() + timedelta(seconds=int(expires_in))

        # `user_data` is a big flat dictionary with the parsed JWT claims
        # access_tokens, and user info from the apple post.
        identity_data = self.get_verified_identity_data(data["id_token"])
        token.user_data = {**data, **identity_data}

        return token

    def complete_login(self, request, app, token, **kwargs):
        extra_data = token.user_data
        login = self.get_provider().sociallogin_from_response(
            request=request, response=extra_data
        )
        login.state["id_token"] = token.user_data

        # We can safely remove the apple login session now
        # Note: The cookie will remain, but it's set to delete on browser close
        get_apple_session(request).delete()
        return login

    def get_user_scope_data(self, request):
        user_scope_data = request.apple_login_session.get("user", "")
        try:
            return json.loads(user_scope_data)
        except json.JSONDecodeError:
            # We do not care much about user scope data as it maybe blank
            # so return blank dictionary instead
            return {}

    def get_access_token_data(self, request, app, client):
        """We need to gather the info from the apple specific login"""
        apple_session = get_apple_session(request)

        # Exchange `code`
        code = get_request_param(request, "code")
        pkce_code_verifier = request.session.pop("pkce_code_verifier", None)
        access_token_data = client.get_access_token(
            code, pkce_code_verifier=pkce_code_verifier
        )

        id_token = access_token_data.get("id_token", None)
        # In case of missing id_token in access_token_data
        if id_token is None:
            id_token = apple_session.store.get("id_token")

        return {
            **access_token_data,
            **self.get_user_scope_data(request),
            "id_token": id_token,
        }


@csrf_exempt
def apple_post_callback(request, finish_endpoint_name="apple_finish_callback"):
    """
    Apple uses a `form_post` response type, which due to
    CORS/Samesite-cookie rules means this request cannot access
    the request since the session cookie is unavailable.

    We work around this by storing the apple response in a
    separate, temporary session and redirecting to a more normal
    oauth flow.

    args:
        finish_endpoint_name (str): The name of a defined URL, which can be
            overridden in your url configuration if you have more than one
            callback endpoint.
    """
    if request.method != "POST":
        return HttpResponseNotAllowed(["POST"])
    apple_session = get_apple_session(request)

    # Add regular OAuth2 params to the URL - reduces the overrides required
    keys_to_put_in_url = ["code", "state", "error"]
    url_params = {}
    for key in keys_to_put_in_url:
        value = get_request_param(request, key, "")
        if value:
            url_params[key] = value

    # Add other params to the apple_login_session
    keys_to_save_to_session = ["user", "id_token"]
    for key in keys_to_save_to_session:
        apple_session.store[key] = get_request_param(request, key, "")

    url = build_absolute_uri(request, reverse(finish_endpoint_name))
    response = HttpResponseRedirect(
        "{url}?{query}".format(url=url, query=urlencode(url_params))
    )
    apple_session.save(response)
    return response


oauth2_login = OAuth2LoginView.adapter_view(AppleOAuth2Adapter)
oauth2_callback = apple_post_callback
oauth2_finish_login = OAuth2CallbackView.adapter_view(AppleOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\apple\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\asana\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\asana\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\asana\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import AsanaProvider


urlpatterns = default_urlpatterns(AsanaProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\asana\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\asana\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import AsanaProvider


class AsanaOAuth2Adapter(OAuth2Adapter):
    provider_id = AsanaProvider.id
    access_token_url = "https://app.asana.com/-/oauth_token"
    authorize_url = "https://app.asana.com/-/oauth_authorize"
    profile_url = "https://app.asana.com/api/1.0/users/me"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(self.profile_url, params={"access_token": token.token})
        extra_data = resp.json()["data"]
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(AsanaOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(AsanaOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\asana\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\auth0\urls.py ---

# -*- coding: utf-8 -*-
from allauth.socialaccount.providers.auth0.provider import Auth0Provider
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns


urlpatterns = default_urlpatterns(Auth0Provider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\auth0\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\auth0\views.py ---

# -*- coding: utf-8 -*-
import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.auth0.provider import Auth0Provider
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)


class Auth0OAuth2Adapter(OAuth2Adapter):
    provider_id = Auth0Provider.id
    supports_state = True

    settings = app_settings.PROVIDERS.get(provider_id, {})
    provider_base_url = settings.get("AUTH0_URL")

    access_token_url = "{0}/oauth/token".format(provider_base_url)
    authorize_url = "{0}/authorize".format(provider_base_url)
    profile_url = "{0}/userinfo".format(provider_base_url)

    def complete_login(self, request, app, token, response):
        extra_data = requests.get(
            self.profile_url, params={"access_token": token.token}
        ).json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(Auth0OAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(Auth0OAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\auth0\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\authentiq\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import AuthentiqProvider


urlpatterns = default_urlpatterns(AuthentiqProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\authentiq\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\authentiq\views.py ---

import requests
from urllib.parse import urljoin

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import AuthentiqProvider


class AuthentiqOAuth2Adapter(OAuth2Adapter):
    provider_id = AuthentiqProvider.id

    settings = app_settings.PROVIDERS.get(provider_id, {})

    provider_url = settings.get("PROVIDER_URL", "https://connect.authentiq.io/")
    if not provider_url.endswith("/"):
        provider_url += "/"

    access_token_url = urljoin(provider_url, "token")
    authorize_url = urljoin(provider_url, "authorize")
    profile_url = urljoin(provider_url, "userinfo")

    def complete_login(self, request, app, token, **kwargs):
        auth = {"Authorization": "Bearer " + token.token}
        resp = requests.get(self.profile_url, headers=auth)
        resp.raise_for_status()
        extra_data = resp.json()
        login = self.get_provider().sociallogin_from_response(request, extra_data)
        return login


oauth2_login = OAuth2LoginView.adapter_view(AuthentiqOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(AuthentiqOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\authentiq\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\azure\models.py ---

# Create your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\azure\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\azure\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import AzureProvider


urlpatterns = default_urlpatterns(AzureProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\azure\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\azure\views.py ---

from __future__ import unicode_literals

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import AzureProvider


LOGIN_URL = "https://login.microsoftonline.com/common/oauth2/v2.0"
GRAPH_URL = "https://graph.microsoft.com/v1.0"


class AzureOAuth2Adapter(OAuth2Adapter):
    """
    Docs available at:
    https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-v2-protocols
    """

    provider_id = AzureProvider.id
    access_token_url = LOGIN_URL + "/token"
    authorize_url = LOGIN_URL + "/authorize"
    profile_url = "https://graph.microsoft.com/v1.0/me"
    # Can be used later to obtain group data. Needs 'Group.Read.All' or
    # similar.
    #
    # See https://developer.microsoft.com/en-us/graph/docs/api-reference/beta/api/user_list_memberof  # noqa
    groups_url = GRAPH_URL + "/me/memberOf?$select=displayName"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        extra_data = {}

        resp = requests.get(self.profile_url, headers=headers)

        # See:
        #
        # https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/user_get  # noqa
        #
        # example of what's returned (in python format)
        #
        # {u'displayName': u'John Smith', u'mobilePhone': None,
        #  u'preferredLanguage': u'en-US', u'jobTitle': u'Director',
        #  u'userPrincipalName': u'john@smith.com',
        #  u'@odata.context':
        #  u'https://graph.microsoft.com/v1.0/$metadata#users/$entity',
        #  u'officeLocation': u'Paris', u'businessPhones': [],
        #  u'mail': u'john@smith.com', u'surname': u'Smith',
        #  u'givenName': u'John', u'id': u'aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee'}

        profile_data = resp.json()
        extra_data.update(profile_data)

        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(AzureOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(AzureOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\azure\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\baidu\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import BaiduProvider


urlpatterns = default_urlpatterns(BaiduProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\baidu\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\baidu\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import BaiduProvider


class BaiduOAuth2Adapter(OAuth2Adapter):
    provider_id = BaiduProvider.id
    access_token_url = "https://openapi.baidu.com/oauth/2.0/token"
    authorize_url = "https://openapi.baidu.com/oauth/2.0/authorize"
    profile_url = (
        "https://openapi.baidu.com/rest/2.0/passport/users/getLoggedInUser"  # noqa
    )

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(self.profile_url, params={"access_token": token.token})
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(BaiduOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(BaiduOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\baidu\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\basecamp\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import BasecampProvider


urlpatterns = default_urlpatterns(BasecampProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\basecamp\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\basecamp\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import BasecampProvider


class BasecampOAuth2Adapter(OAuth2Adapter):
    provider_id = BasecampProvider.id
    access_token_url = (
        "https://launchpad.37signals.com/authorization/token?type=web_server"  # noqa
    )
    authorize_url = "https://launchpad.37signals.com/authorization/new"
    profile_url = "https://launchpad.37signals.com/authorization.json"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(BasecampOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(BasecampOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\basecamp\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\battlenet\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\battlenet\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\battlenet\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import BattleNetProvider


urlpatterns = default_urlpatterns(BattleNetProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\battlenet\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\battlenet\views.py ---

"""
OAuth2 Adapter for Battle.net

Resources:

* Battle.net OAuth2 documentation:
    https://dev.battle.net/docs/read/oauth
* Battle.net API documentation:
    https://dev.battle.net/io-docs
* Original announcement:
    https://us.battle.net/en/forum/topic/13979297799
* The Battle.net API forum:
    https://us.battle.net/en/forum/15051532/
"""
import requests

from django.conf import settings

from allauth.socialaccount.providers.oauth2.client import OAuth2Error
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import BattleNetProvider


class Region:
    APAC = "apac"
    CN = "cn"
    EU = "eu"
    KR = "kr"
    SEA = "sea"
    TW = "tw"
    US = "us"


def _check_errors(response):
    try:
        data = response.json()
    except ValueError:  # JSONDecodeError on py3
        raise OAuth2Error("Invalid JSON from Battle.net API: %r" % (response.text))

    if response.status_code >= 400 or "error" in data:
        # For errors, we expect the following format:
        # {"error": "error_name", "error_description": "Oops!"}
        # For example, if the token is not valid, we will get:
        # {
        #   "error": "invalid_token",
        #   "error_description": "Invalid access token: abcdef123456"
        # }
        # For the profile API, this may also look like the following:
        # {"code": 403, "type": "Forbidden", "detail": "Account Inactive"}
        error = data.get("error", "") or data.get("type", "")
        desc = data.get("error_description", "") or data.get("detail", "")

        raise OAuth2Error("Battle.net error: %s (%s)" % (error, desc))

    # The expected output from the API follows this format:
    # {"id": 12345, "battletag": "Example#12345"}
    # The battletag is optional.
    if "id" not in data:
        # If the id is not present, the output is not usable (no UID)
        raise OAuth2Error("Invalid data from Battle.net API: %r" % (data))

    return data


class BattleNetOAuth2Adapter(OAuth2Adapter):
    """
    OAuth2 adapter for Battle.net
    https://dev.battle.net/docs/read/oauth

    Region is set to us by default, but can be overridden with the
    `region` GET parameter when performing a login.
    Can be any of eu, us, kr, sea, tw or cn
    """

    provider_id = BattleNetProvider.id
    valid_regions = (
        Region.APAC,
        Region.CN,
        Region.EU,
        Region.KR,
        Region.SEA,
        Region.TW,
        Region.US,
    )

    @property
    def battlenet_region(self):
        # Check by URI query parameter first.
        region = self.request.GET.get("region", "").lower()
        if region == Region.SEA:
            # South-East Asia uses the same region as US everywhere
            return Region.US
        if region in self.valid_regions:
            return region

        # Second, check the provider settings.
        region = (
            getattr(settings, "SOCIALACCOUNT_PROVIDERS", {})
            .get("battlenet", {})
            .get("REGION", "us")
        )

        if region in self.valid_regions:
            return region

        return Region.US

    @property
    def battlenet_base_url(self):
        region = self.battlenet_region
        if region == Region.CN:
            return "https://www.battlenet.com.cn"
        return "https://%s.battle.net" % (region)

    @property
    def access_token_url(self):
        return self.battlenet_base_url + "/oauth/token"

    @property
    def authorize_url(self):
        return self.battlenet_base_url + "/oauth/authorize"

    @property
    def profile_url(self):
        return self.battlenet_base_url + "/oauth/userinfo"

    def complete_login(self, request, app, token, **kwargs):
        params = {"access_token": token.token}
        response = requests.get(self.profile_url, params=params)
        data = _check_errors(response)

        # Add the region to the data so that we can have it in `extra_data`.
        data["region"] = self.battlenet_region

        return self.get_provider().sociallogin_from_response(request, data)

    def get_callback_url(self, request, app):
        r = super(BattleNetOAuth2Adapter, self).get_callback_url(request, app)
        region = request.GET.get("region", "").lower()
        # Pass the region down to the callback URL if we specified it
        if region and region in self.valid_regions:
            r += "?region=%s" % (region)
        return r


oauth2_login = OAuth2LoginView.adapter_view(BattleNetOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(BattleNetOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\battlenet\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\bitbucket\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import BitbucketProvider


urlpatterns = default_urlpatterns(BitbucketProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\bitbucket\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\bitbucket\views.py ---

import json

from allauth.socialaccount.providers.oauth.client import OAuth
from allauth.socialaccount.providers.oauth.views import (
    OAuthAdapter,
    OAuthCallbackView,
    OAuthLoginView,
)

from .provider import BitbucketProvider


class BitbucketAPI(OAuth):
    emails_url = "https://bitbucket.org/api/1.0/emails/"
    users_url = "https://bitbucket.org/api/1.0/users/"

    def get_user_info(self):
        # TODO: Actually turn these into EmailAddress
        emails = json.loads(self.query(self.emails_url))
        for address in reversed(emails):
            if address["active"]:
                email = address["email"]
                if address["primary"]:
                    break
        data = json.loads(self.query(self.users_url + email))
        user = data["user"]
        return user


class BitbucketOAuthAdapter(OAuthAdapter):
    provider_id = BitbucketProvider.id
    request_token_url = "https://bitbucket.org/api/1.0/oauth/request_token"
    access_token_url = "https://bitbucket.org/api/1.0/oauth/access_token"
    authorize_url = "https://bitbucket.org/api/1.0/oauth/authenticate"

    def complete_login(self, request, app, token, response):
        client = BitbucketAPI(
            request, app.client_id, app.secret, self.request_token_url
        )
        extra_data = client.get_user_info()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth_login = OAuthLoginView.adapter_view(BitbucketOAuthAdapter)
oauth_callback = OAuthCallbackView.adapter_view(BitbucketOAuthAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\bitbucket\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\bitbucket_oauth2\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import BitbucketOAuth2Provider


urlpatterns = default_urlpatterns(BitbucketOAuth2Provider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\bitbucket_oauth2\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\bitbucket_oauth2\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import BitbucketOAuth2Provider


class BitbucketOAuth2Adapter(OAuth2Adapter):
    provider_id = BitbucketOAuth2Provider.id
    access_token_url = "https://bitbucket.org/site/oauth2/access_token"
    authorize_url = "https://bitbucket.org/site/oauth2/authorize"
    profile_url = "https://api.bitbucket.org/2.0/user"
    emails_url = "https://api.bitbucket.org/2.0/user/emails"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(self.profile_url, params={"access_token": token.token})
        extra_data = resp.json()
        if app_settings.QUERY_EMAIL and not extra_data.get("email"):
            extra_data["email"] = self.get_email(token)
        return self.get_provider().sociallogin_from_response(request, extra_data)

    def get_email(self, token):
        """Fetches email address from email API endpoint"""
        resp = requests.get(self.emails_url, params={"access_token": token.token})
        emails = resp.json().get("values", [])
        email = ""
        try:
            email = emails[0].get("email")
            primary_emails = [e for e in emails if e.get("is_primary", False)]
            email = primary_emails[0].get("email")
        except (IndexError, TypeError, KeyError):
            return ""
        finally:
            return email


oauth_login = OAuth2LoginView.adapter_view(BitbucketOAuth2Adapter)
oauth_callback = OAuth2CallbackView.adapter_view(BitbucketOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\bitbucket_oauth2\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\bitly\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import BitlyProvider


urlpatterns = default_urlpatterns(BitlyProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\bitly\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\bitly\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import BitlyProvider


class BitlyOAuth2Adapter(OAuth2Adapter):
    provider_id = BitlyProvider.id
    access_token_url = "https://api-ssl.bitly.com/oauth/access_token"
    authorize_url = "https://bitly.com/oauth/authorize"
    profile_url = "https://api-ssl.bitly.com/v3/user/info"
    supports_state = False

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(self.profile_url, params={"access_token": token.token})
        extra_data = resp.json()["data"]
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(BitlyOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(BitlyOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\bitly\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\box\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import BoxOAuth2Provider


urlpatterns = default_urlpatterns(BoxOAuth2Provider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\box\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\box\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import BoxOAuth2Provider


class BoxOAuth2Adapter(OAuth2Adapter):
    provider_id = BoxOAuth2Provider.id
    access_token_url = "https://api.box.com/oauth2/token"
    authorize_url = "https://account.box.com/api/oauth2/authorize"
    profile_url = "https://api.box.com/2.0/users/me"
    redirect_uri_protocol = None

    def complete_login(self, request, app, token, **kwargs):
        extra_data = requests.get(
            self.profile_url, params={"access_token": token.token}
        )

        # This only here because of weird response from the test suite
        if isinstance(extra_data, list):
            extra_data = extra_data[0]

        return self.get_provider().sociallogin_from_response(request, extra_data.json())


oauth_login = OAuth2LoginView.adapter_view(BoxOAuth2Adapter)
oauth_callback = OAuth2CallbackView.adapter_view(BoxOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\box\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\cern\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import CernProvider


urlpatterns = default_urlpatterns(CernProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\cern\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\cern\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import CernProvider


class CernOAuth2Adapter(OAuth2Adapter):
    provider_id = CernProvider.id
    access_token_url = "https://oauth.web.cern.ch/OAuth/Token"
    authorize_url = "https://oauth.web.cern.ch/OAuth/Authorize"
    profile_url = "https://oauthresource.web.cern.ch/api/User"
    groups_url = "https://oauthresource.web.cern.ch/api/Groups"

    supports_state = False
    redirect_uri_protocol = "https"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        user_response = requests.get(self.profile_url, headers=headers)
        groups_response = requests.get(self.groups_url, headers=headers)
        extra_data = user_response.json()
        extra_data.update(groups_response.json())
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(CernOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(CernOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\cern\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\cilogon\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import CILogonProvider


urlpatterns = default_urlpatterns(CILogonProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\cilogon\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\cilogon\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import CILogonProvider


class CILogonOAuth2Adapter(OAuth2Adapter):
    provider_id = CILogonProvider.id
    access_token_url = "https://cilogon.org/oauth2/token"
    authorize_url = "https://cilogon.org/authorize"
    profile_url = "https://cilogon.org/oauth2/userinfo"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.profile_url,
            params={"access_token": token.token, "alt": "json"},
        )
        resp.raise_for_status()
        extra_data = resp.json()
        login = self.get_provider().sociallogin_from_response(request, extra_data)
        return login


oauth2_login = OAuth2LoginView.adapter_view(CILogonOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(CILogonOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\cilogon\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\clever\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import CleverProvider


urlpatterns = default_urlpatterns(CleverProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\clever\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\clever\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.client import OAuth2Error
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import CleverProvider


class CleverOAuth2Adapter(OAuth2Adapter):
    provider_id = CleverProvider.id

    access_token_url = "https://clever.com/oauth/tokens"
    authorize_url = "https://clever.com/oauth/authorize"
    identity_url = "https://api.clever.com/v3.0/me"
    user_details_url = "https://api.clever.com/v3.0/users"

    supports_state = True

    def complete_login(self, request, app, token, **kwargs):
        extra_data = self.get_data(token.token)
        return self.get_provider().sociallogin_from_response(request, extra_data)

    def get_data(self, token):
        # Verify the user first
        resp = requests.get(
            self.identity_url, headers={"Authorization": "Bearer {}".format(token)}
        )
        if resp.status_code != 200:
            raise OAuth2Error()
        resp = resp.json()
        user_id = resp["data"]["id"]
        user_details = requests.get(
            "{}/{}".format(self.user_details_url, user_id),
            headers={"Authorization": "Bearer {}".format(token)},
        )
        user_details.raise_for_status()
        user_details = user_details.json()
        return user_details


oauth2_login = OAuth2LoginView.adapter_view(CleverOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(CleverOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\clever\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\coinbase\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import CoinbaseProvider


urlpatterns = default_urlpatterns(CoinbaseProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\coinbase\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\coinbase\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import CoinbaseProvider


class CoinbaseOAuth2Adapter(OAuth2Adapter):
    provider_id = CoinbaseProvider.id

    @property
    def authorize_url(self):
        return "https://www.coinbase.com/oauth/authorize"

    @property
    def access_token_url(self):
        return "https://www.coinbase.com/oauth/token"

    @property
    def profile_url(self):
        return "https://api.coinbase.com/v2/user"

    def complete_login(self, request, app, token, **kwargs):
        response = requests.get(self.profile_url, params={"access_token": token})
        extra_data = response.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(CoinbaseOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(CoinbaseOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\coinbase\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dataporten\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dataporten\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dataporten\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import DataportenProvider


urlpatterns = default_urlpatterns(DataportenProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dataporten\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dataporten\views.py ---

import requests

from allauth.socialaccount.providers.base import ProviderException
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import DataportenProvider


class DataportenAdapter(OAuth2Adapter):
    provider_id = DataportenProvider.id
    access_token_url = "https://auth.dataporten.no/oauth/token"
    authorize_url = "https://auth.dataporten.no/oauth/authorization"
    profile_url = "https://auth.dataporten.no/userinfo"
    groups_url = "https://groups-api.dataporten.no/groups/"

    def complete_login(self, request, app, token, **kwargs):
        """
        Arguments:
            request - The get request to the callback URL
                        /accounts/dataporten/login/callback.
            app - The corresponding SocialApp model instance
            token - A token object with access token given in token.token
        Returns:
            Should return a dict with user information intended for parsing
            by the methods of the DataportenProvider view, i.e.
            extract_uid(), extract_extra_data(), and extract_common_fields()
        """
        # The authentication header
        headers = {"Authorization": "Bearer " + token.token}

        # Userinfo endpoint, for documentation see:
        # https://docs.dataporten.no/docs/oauth-authentication/
        userinfo_response = requests.get(
            self.profile_url,
            headers=headers,
        )
        # Raise exception for 4xx and 5xx response codes
        userinfo_response.raise_for_status()

        # The endpoint returns json-data and it needs to be decoded
        extra_data = userinfo_response.json()["user"]

        # Finally test that the audience property matches the client id
        # for validification reasons, as instructed by the Dataporten docs
        # if the userinfo-response is used for authentication
        if userinfo_response.json()["audience"] != app.client_id:
            raise ProviderException(
                "Dataporten returned a user with an audience field \
                 which does not correspond to the client id of the \
                 application."
            )

        return self.get_provider().sociallogin_from_response(
            request,
            extra_data,
        )


oauth2_login = OAuth2LoginView.adapter_view(DataportenAdapter)
oauth2_callback = OAuth2CallbackView.adapter_view(DataportenAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dataporten\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\daum\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\daum\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\daum\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import DaumProvider


urlpatterns = default_urlpatterns(DaumProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\daum\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\daum\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import DaumProvider


class DaumOAuth2Adapter(OAuth2Adapter):
    provider_id = DaumProvider.id
    access_token_url = "https://apis.daum.net/oauth2/token"
    authorize_url = "https://apis.daum.net/oauth2/authorize"
    profile_url = "https://apis.daum.net/user/v1/show.json"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(self.profile_url, params={"access_token": token.token})
        extra_data = resp.json().get("result")
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(DaumOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(DaumOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\daum\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\digitalocean\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import DigitalOceanProvider


urlpatterns = default_urlpatterns(DigitalOceanProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\digitalocean\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\digitalocean\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import DigitalOceanProvider


class DigitalOceanOAuth2Adapter(OAuth2Adapter):
    provider_id = DigitalOceanProvider.id
    access_token_url = "https://cloud.digitalocean.com/v1/oauth/token"
    authorize_url = "https://cloud.digitalocean.com/v1/oauth/authorize"
    profile_url = "https://api.digitalocean.com/v2/account"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(DigitalOceanOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(DigitalOceanOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\digitalocean\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dingtalk\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import DingTalkProvider


urlpatterns = default_urlpatterns(DingTalkProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dingtalk\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dingtalk\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .client import DingTalkOAuth2Client
from .provider import DingTalkProvider


class DingTalkOAuth2Adapter(OAuth2Adapter):
    provider_id = DingTalkProvider.id
    access_token_url = "https://api.dingtalk.com/v1.0/oauth2/userAccessToken"
    authorize_url = "https://login.dingtalk.com/oauth2/auth"
    profile_url = "https://api.dingtalk.com/v1.0/contact/users/me"
    client_class = DingTalkOAuth2Client

    def __init__(self, request):
        # dingtalk set "authCode" instead of "code" in callback url
        if "authCode" in request.GET:
            request.GET._mutable = True
            request.GET["code"] = request.GET["authCode"]
            request.GET._mutable = False

        super(DingTalkOAuth2Adapter, self).__init__(request)

    def complete_login(self, request, app, token, **kwargs):
        headers = {"x-acs-dingtalk-access-token": token.token}
        resp = requests.get(self.profile_url, headers=headers)
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(DingTalkOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(DingTalkOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dingtalk\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\discord\urls.py ---

from allauth.socialaccount.providers.discord.provider import DiscordProvider
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns


urlpatterns = default_urlpatterns(DiscordProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\discord\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\discord\views.py ---

import requests

from allauth.socialaccount.providers.discord.provider import DiscordProvider
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)


class DiscordOAuth2Adapter(OAuth2Adapter):
    provider_id = DiscordProvider.id
    access_token_url = "https://discord.com/api/oauth2/token"
    authorize_url = "https://discord.com/api/oauth2/authorize"
    profile_url = "https://discord.com/api/users/@me"

    def complete_login(self, request, app, token, **kwargs):
        headers = {
            "Authorization": "Bearer {0}".format(token.token),
            "Content-Type": "application/json",
        }
        extra_data = requests.get(self.profile_url, headers=headers)

        return self.get_provider().sociallogin_from_response(request, extra_data.json())


oauth2_login = OAuth2LoginView.adapter_view(DiscordOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(DiscordOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\discord\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\disqus\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import DisqusProvider


urlpatterns = default_urlpatterns(DisqusProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\disqus\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\disqus\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import DisqusProvider


class DisqusOAuth2Adapter(OAuth2Adapter):
    provider_id = DisqusProvider.id
    access_token_url = "https://disqus.com/api/oauth/2.0/access_token/"
    authorize_url = "https://disqus.com/api/oauth/2.0/authorize/"
    profile_url = "https://disqus.com/api/3.0/users/details.json"
    scope_delimiter = ","

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.profile_url,
            params={
                "access_token": token.token,
                "api_key": app.client_id,
                "api_secret": app.secret,
            },
        )
        resp.raise_for_status()

        extra_data = resp.json().get("response")

        login = self.get_provider().sociallogin_from_response(request, extra_data)
        return login


oauth2_login = OAuth2LoginView.adapter_view(DisqusOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(DisqusOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\disqus\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\douban\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import DoubanProvider


urlpatterns = default_urlpatterns(DoubanProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\douban\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\douban\views.py ---

import requests

from django.utils.translation import gettext_lazy as _

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from ..base import ProviderException
from .provider import DoubanProvider


class DoubanOAuth2Adapter(OAuth2Adapter):
    provider_id = DoubanProvider.id
    access_token_url = "https://www.douban.com/service/auth2/token"
    authorize_url = "https://www.douban.com/service/auth2/auth"
    profile_url = "https://api.douban.com/v2/user/~me"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer %s" % token.token}
        resp = requests.get(self.profile_url, headers=headers)
        extra_data = resp.json()
        """
        Douban may return data like this:

            {
                'code': 128,
                'request': 'GET /v2/user/~me',
                'msg': 'user_is_locked:53358092'
            }

        """
        if "id" not in extra_data:
            msg = extra_data.get("msg", _("Invalid profile data"))
            raise ProviderException(msg)
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(DoubanOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(DoubanOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\douban\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\doximity\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import DoximityProvider


urlpatterns = default_urlpatterns(DoximityProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\doximity\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\doximity\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import DoximityProvider


class DoximityOAuth2Adapter(OAuth2Adapter):
    provider_id = DoximityProvider.id
    access_token_url = "https://auth.doximity.com/oauth/token"
    authorize_url = "https://auth.doximity.com/oauth/authorize"
    profile_url = "https://www.doximity.com/api/v1/users/current"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer %s" % token.token}
        resp = requests.get(self.profile_url, headers=headers)
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(DoximityOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(DoximityOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\doximity\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\draugiem\urls.py ---

from django.urls import path

from . import views


urlpatterns = [
    path("draugiem/login/", views.login, name="draugiem_login"),
    path("draugiem/callback/", views.callback, name="draugiem_callback"),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\draugiem\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\draugiem\views.py ---

import requests
from hashlib import md5

from django.http import HttpResponseRedirect
from django.urls import reverse
from django.utils.http import urlencode
from django.views.decorators.csrf import csrf_exempt

from allauth.socialaccount.adapter import get_adapter
from allauth.socialaccount.helpers import (
    complete_social_login,
    render_authentication_error,
)
from allauth.socialaccount.models import SocialLogin, SocialToken

from ..base import AuthError
from .provider import DraugiemProvider


class DraugiemApiError(Exception):
    pass


ACCESS_TOKEN_URL = "http://api.draugiem.lv/json"
AUTHORIZE_URL = "http://api.draugiem.lv/authorize"


def login(request):
    app = get_adapter(request).get_app(request, DraugiemProvider.id)
    redirect_url = request.build_absolute_uri(reverse(callback))
    redirect_url_hash = md5((app.secret + redirect_url).encode("utf-8")).hexdigest()
    params = {
        "app": app.client_id,
        "hash": redirect_url_hash,
        "redirect": redirect_url,
    }
    SocialLogin.stash_state(request)
    return HttpResponseRedirect("%s?%s" % (AUTHORIZE_URL, urlencode(params)))


@csrf_exempt
def callback(request):
    if "dr_auth_status" not in request.GET:
        return render_authentication_error(
            request, DraugiemProvider.id, error=AuthError.UNKNOWN
        )

    if request.GET["dr_auth_status"] != "ok":
        return render_authentication_error(
            request, DraugiemProvider.id, error=AuthError.DENIED
        )

    if "dr_auth_code" not in request.GET:
        return render_authentication_error(
            request, DraugiemProvider.id, error=AuthError.UNKNOWN
        )

    ret = None
    auth_exception = None
    try:
        app = get_adapter(request).get_app(request, DraugiemProvider.id)
        login = draugiem_complete_login(request, app, request.GET["dr_auth_code"])
        login.state = SocialLogin.unstash_state(request)

        ret = complete_social_login(request, login)
    except (requests.RequestException, DraugiemApiError) as e:
        auth_exception = e

    if not ret:
        ret = render_authentication_error(
            request, DraugiemProvider.id, exception=auth_exception
        )

    return ret


def draugiem_complete_login(request, app, code):
    provider = get_adapter(request).get_provider(request, DraugiemProvider.id)
    response = requests.get(
        ACCESS_TOKEN_URL,
        {"action": "authorize", "app": app.secret, "code": code},
    )
    response.raise_for_status()
    response_json = response.json()

    if "error" in response_json:
        raise DraugiemApiError(response_json["error"])

    token = SocialToken(app=app, token=response_json["apikey"])

    login = provider.sociallogin_from_response(request, response_json)
    login.token = token
    return login

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\draugiem\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\drip\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import DripProvider


urlpatterns = default_urlpatterns(DripProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\drip\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\drip\views.py ---

"""Views for Drip API."""
import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import DripProvider


class DripOAuth2Adapter(OAuth2Adapter):

    """OAuth2Adapter for Drip API v3."""

    provider_id = DripProvider.id

    authorize_url = "https://www.getdrip.com/oauth/authorize"
    access_token_url = "https://www.getdrip.com/oauth/token"
    profile_url = "https://api.getdrip.com/v2/user"

    def complete_login(self, request, app, token, **kwargs):
        """Complete login, ensuring correct OAuth header."""
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        response = requests.get(self.profile_url, headers=headers)
        response.raise_for_status()
        extra_data = response.json()["users"][0]
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(DripOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(DripOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\drip\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dropbox\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import DropboxOAuth2Provider


urlpatterns = default_urlpatterns(DropboxOAuth2Provider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dropbox\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dropbox\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import DropboxOAuth2Provider


class DropboxOAuth2Adapter(OAuth2Adapter):
    provider_id = DropboxOAuth2Provider.id
    access_token_url = "https://api.dropbox.com/oauth2/token"
    authorize_url = "https://www.dropbox.com/oauth2/authorize"
    profile_url = "https://api.dropbox.com/2/users/get_current_account"

    def complete_login(self, request, app, token, **kwargs):
        response = requests.post(
            self.profile_url,
            headers={"Authorization": "Bearer %s" % (token.token,)},
        )
        response.raise_for_status()
        return self.get_provider().sociallogin_from_response(request, response.json())


oauth_login = OAuth2LoginView.adapter_view(DropboxOAuth2Adapter)
oauth_callback = OAuth2CallbackView.adapter_view(DropboxOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dropbox\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dwolla\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dwolla\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dwolla\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import DwollaProvider


urlpatterns = default_urlpatterns(DwollaProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dwolla\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dwolla\views.py ---

import requests

from django.conf import settings

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import DwollaProvider


ENVIRONMENTS = {
    "production": {
        "auth_url": "https://www.dwolla.com/oauth/v2/authenticate",
        "token_url": "https://www.dwolla.com/oauth/v2/token",
    },
    "sandbox": {
        "auth_url": "https://uat.dwolla.com/oauth/v2/authenticate",
        "token_url": "https://uat.dwolla.com/oauth/v2/token",
    },
}

ENV = (
    getattr(settings, "SOCIALACCOUNT_PROVIDERS", {})
    .get("dwolla", {})
    .get("ENVIRONMENT", "production")
)

AUTH_URL = ENVIRONMENTS[ENV]["auth_url"]
TOKEN_URL = ENVIRONMENTS[ENV]["token_url"]


class DwollaOAuth2Adapter(OAuth2Adapter):
    """Dwolla Views Adapter"""

    scope_delimiter = "|"

    provider_id = DwollaProvider.id
    access_token_url = TOKEN_URL
    authorize_url = AUTH_URL

    def complete_login(self, request, app, token, response, **kwargs):
        resp = requests.get(
            response["_links"]["account"]["href"],
            headers={
                "authorization": "Bearer %s" % token.token,
                "accept": "application/vnd.dwolla.v1.hal+json",
            },
        )

        extra_data = resp.json()

        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(DwollaOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(DwollaOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\dwolla\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\edmodo\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import EdmodoProvider


urlpatterns = default_urlpatterns(EdmodoProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\edmodo\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\edmodo\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import EdmodoProvider


class EdmodoOAuth2Adapter(OAuth2Adapter):
    provider_id = EdmodoProvider.id
    access_token_url = "https://api.edmodo.com/oauth/token"
    authorize_url = "https://api.edmodo.com/oauth/authorize"
    profile_url = "https://api.edmodo.com/users/me"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(self.profile_url, params={"access_token": token.token})
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(EdmodoOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(EdmodoOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\edmodo\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\edx\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import EdxProvider


urlpatterns = default_urlpatterns(EdxProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\edx\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\edx\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import EdxProvider


class EdxOAuth2Adapter(OAuth2Adapter):
    provider_id = EdxProvider.id
    provider_default_url = "https://edx.org"

    settings = app_settings.PROVIDERS.get(provider_id, {})
    provider_base_url = settings.get("EDX_URL", provider_default_url)

    access_token_url = "{0}/oauth2/access_token".format(provider_base_url)
    authorize_url = "{0}/oauth2/authorize/".format(provider_base_url)
    profile_url = "{0}/api/user/v1/me".format(provider_base_url)
    account_url = "{0}/api/user/v1/accounts/{1}"
    supports_state = False
    redirect_uri_protocol = "https"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        response = requests.get(self.profile_url, headers=headers)
        extra_data = response.json()

        if extra_data.get("email", None) is None:
            response = requests.get(
                self.account_url.format(self.provider_base_url, extra_data["username"]),
                headers=headers,
            )
            extra_data = response.json()

        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(EdxOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(EdxOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\edx\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\eventbrite\urls.py ---

"""Register urls for EventbriteProvider"""
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import EventbriteProvider


urlpatterns = default_urlpatterns(EventbriteProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\eventbrite\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\eventbrite\views.py ---

"""Views for Eventbrite API v3."""
import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import EventbriteProvider


class EventbriteOAuth2Adapter(OAuth2Adapter):

    """OAuth2Adapter for Eventbrite API v3."""

    provider_id = EventbriteProvider.id

    authorize_url = "https://www.eventbrite.com/oauth/authorize"
    access_token_url = "https://www.eventbrite.com/oauth/token"
    profile_url = "https://www.eventbriteapi.com/v3/users/me/"

    def complete_login(self, request, app, token, **kwargs):
        """Complete login."""
        resp = requests.get(self.profile_url, params={"token": token.token})
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(EventbriteOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(EventbriteOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\eventbrite\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\eveonline\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import EveOnlineProvider


urlpatterns = default_urlpatterns(EveOnlineProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\eveonline\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\eveonline\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import EveOnlineProvider


class EveOnlineOAuth2Adapter(OAuth2Adapter):
    provider_id = EveOnlineProvider.id
    access_token_url = "https://login.eveonline.com/oauth/token"
    authorize_url = "https://login.eveonline.com/oauth/authorize"
    profile_url = "https://login.eveonline.com/oauth/verify"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.profile_url,
            headers={"Authorization": "Bearer " + token.token},
        )
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(EveOnlineOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(EveOnlineOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\eveonline\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\evernote\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import EvernoteProvider


urlpatterns = default_urlpatterns(EvernoteProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\evernote\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\evernote\views.py ---

from __future__ import absolute_import

from datetime import datetime

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth.views import (
    OAuthAdapter,
    OAuthCallbackView,
    OAuthLoginView,
)

from .provider import EvernoteProvider


class EvernoteOAuthAdapter(OAuthAdapter):
    provider_id = EvernoteProvider.id
    settings = app_settings.PROVIDERS.get(provider_id, {})
    request_token_url = "https://%s/oauth" % (
        settings.get("EVERNOTE_HOSTNAME", "sandbox.evernote.com")
    )
    access_token_url = "https://%s/oauth" % (
        settings.get("EVERNOTE_HOSTNAME", "sandbox.evernote.com")
    )
    authorize_url = "https://%s/OAuth.action" % (
        settings.get("EVERNOTE_HOSTNAME", "sandbox.evernote.com")
    )

    def complete_login(self, request, app, token, response):
        token.expires_at = datetime.fromtimestamp(
            int(response["edam_expires"]) / 1000.0
        )
        extra_data = response
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth_login = OAuthLoginView.adapter_view(EvernoteOAuthAdapter)
oauth_callback = OAuthCallbackView.adapter_view(EvernoteOAuthAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\evernote\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\exist\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import ExistProvider


urlpatterns = default_urlpatterns(ExistProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\exist\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\exist\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import ExistProvider


class ExistOAuth2Adapter(OAuth2Adapter):
    provider_id = ExistProvider.id
    access_token_url = "https://exist.io/oauth2/access_token"
    authorize_url = "https://exist.io/oauth2/authorize"
    profile_url = "https://exist.io/api/2/accounts/profile/"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(ExistOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(ExistOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\exist\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\facebook\urls.py ---

from django.urls import path

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from . import views
from .provider import FacebookProvider


urlpatterns = default_urlpatterns(FacebookProvider)

urlpatterns += [
    path(
        "facebook/login/token/",
        views.login_by_token,
        name="facebook_login_by_token",
    ),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\facebook\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\facebook\views.py ---

import hashlib
import hmac
import logging
import requests
from datetime import timedelta

from django.utils import timezone

from allauth.socialaccount import app_settings
from allauth.socialaccount.adapter import get_adapter
from allauth.socialaccount.helpers import (
    complete_social_login,
    render_authentication_error,
)
from allauth.socialaccount.models import SocialLogin, SocialToken
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .forms import FacebookConnectForm
from .provider import GRAPH_API_URL, GRAPH_API_VERSION, FacebookProvider


logger = logging.getLogger(__name__)


def compute_appsecret_proof(app, token):
    # Generate an appsecret_proof parameter to secure the Graph API call
    # see https://developers.facebook.com/docs/graph-api/securing-requests
    msg = token.token.encode("utf-8")
    key = app.secret.encode("utf-8")
    appsecret_proof = hmac.new(key, msg, digestmod=hashlib.sha256).hexdigest()
    return appsecret_proof


def fb_complete_login(request, app, token):
    provider = app.get_provider(request)
    resp = requests.get(
        GRAPH_API_URL + "/me",
        params={
            "fields": ",".join(provider.get_fields()),
            "access_token": token.token,
            "appsecret_proof": compute_appsecret_proof(app, token),
        },
    )
    resp.raise_for_status()
    extra_data = resp.json()
    login = provider.sociallogin_from_response(request, extra_data)
    return login


class FacebookOAuth2Adapter(OAuth2Adapter):
    provider_id = FacebookProvider.id
    provider_default_auth_url = "https://www.facebook.com/{}/dialog/oauth".format(
        GRAPH_API_VERSION
    )

    settings = app_settings.PROVIDERS.get(provider_id, {})
    scope_delimiter = ","
    authorize_url = settings.get("AUTHORIZE_URL", provider_default_auth_url)
    access_token_url = GRAPH_API_URL + "/oauth/access_token"
    access_token_method = "GET"
    expires_in_key = "expires_in"

    def complete_login(self, request, app, access_token, **kwargs):
        return fb_complete_login(request, app, access_token)


oauth2_login = OAuth2LoginView.adapter_view(FacebookOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(FacebookOAuth2Adapter)


def login_by_token(request):
    ret = None
    auth_exception = None
    if request.method == "POST":
        form = FacebookConnectForm(request.POST)
        if form.is_valid():
            try:
                adapter = get_adapter(request)
                provider = adapter.get_provider(request, FacebookProvider.id)
                login_options = provider.get_fb_login_options(request)
                app = provider.app
                access_token = form.cleaned_data["access_token"]
                expires_at = None
                if login_options.get("auth_type") == "reauthenticate":
                    info = requests.get(
                        GRAPH_API_URL + "/oauth/access_token_info",
                        params={
                            "client_id": app.client_id,
                            "access_token": access_token,
                        },
                    ).json()
                    nonce = provider.get_nonce(request, pop=True)
                    ok = nonce and nonce == info.get("auth_nonce")
                else:
                    ok = True
                if ok and provider.get_settings().get("EXCHANGE_TOKEN"):
                    resp = requests.get(
                        GRAPH_API_URL + "/oauth/access_token",
                        params={
                            "grant_type": "fb_exchange_token",
                            "client_id": app.client_id,
                            "client_secret": app.secret,
                            "fb_exchange_token": access_token,
                        },
                    ).json()
                    access_token = resp["access_token"]
                    expires_in = resp.get("expires_in")
                    if expires_in:
                        expires_at = timezone.now() + timedelta(seconds=int(expires_in))
                if ok:
                    token = SocialToken(
                        app=app, token=access_token, expires_at=expires_at
                    )
                    login = fb_complete_login(request, app, token)
                    login.token = token
                    login.state = SocialLogin.state_from_request(request)
                    ret = complete_social_login(request, login)
            except requests.RequestException as e:
                logger.exception("Error accessing FB user profile")
                auth_exception = e
    if not ret:
        ret = render_authentication_error(
            request, FacebookProvider.id, exception=auth_exception
        )
    return ret

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\facebook\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\feedly\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import FeedlyProvider


urlpatterns = default_urlpatterns(FeedlyProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\feedly\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\feedly\views.py ---

from __future__ import unicode_literals

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import FeedlyProvider


class FeedlyOAuth2Adapter(OAuth2Adapter):
    provider_id = FeedlyProvider.id
    host = app_settings.PROVIDERS.get(provider_id, {}).get("HOST", "cloud.feedly.com")
    access_token_url = "https://%s/v3/auth/token" % host
    authorize_url = "https://%s/v3/auth/auth" % host
    profile_url = "https://%s/v3/profile" % host

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "OAuth {0}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(FeedlyOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(FeedlyOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\feedly\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\feishu\urls.py ---

# -*- coding: utf-8 -*-

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import FeishuProvider


urlpatterns = default_urlpatterns(FeishuProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\feishu\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\feishu\views.py ---

# -*- coding: utf-8 -*-

import requests

from django.urls import reverse

from allauth.account import app_settings
from allauth.socialaccount.providers.oauth2.client import OAuth2Error
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)
from allauth.utils import build_absolute_uri

from .client import FeishuOAuth2Client
from .provider import FeishuProvider


class FeishuOAuth2Adapter(OAuth2Adapter):
    provider_id = FeishuProvider.id

    authorization_url = "https://open.feishu.cn/open-apis/authen/v1/index"
    access_token_url = "https://open.feishu.cn/open-apis/authen/v1/access_token"
    app_access_token_url = (
        "https://open.feishu.cn/open-apis/auth/v3/app_access_token/internal/"
    )
    user_info_url = "https://open.feishu.cn/open-apis/authen/v1/user_info"

    @property
    def authorize_url(self):
        settings = self.get_provider().get_settings()
        url = settings.get("AUTHORIZE_URL", self.authorization_url)
        return url

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.user_info_url,
            headers={
                "Content-Type": "application/json",
                "Authorization": "Bearer " + token.token,
            },
        )
        resp.raise_for_status()
        extra_data = resp.json()
        if extra_data["code"] != 0:
            raise OAuth2Error("Error retrieving code: %s" % resp.content)
        extra_data = extra_data["data"]

        return self.get_provider().sociallogin_from_response(request, extra_data)


class FeishuOAuth2ClientMixin(object):
    def get_client(self, request, app):
        callback_url = reverse(self.adapter.provider_id + "_callback")
        protocol = (
            self.adapter.redirect_uri_protocol or app_settings.DEFAULT_HTTP_PROTOCOL
        )
        callback_url = build_absolute_uri(request, callback_url, protocol=protocol)
        provider = self.adapter.get_provider()
        scope = provider.get_scope(request)
        client = FeishuOAuth2Client(
            request,
            app.client_id,
            app.secret,
            self.adapter.access_token_method,
            self.adapter.access_token_url,
            callback_url,
            scope,
        )
        return client


class FeishuOAuth2LoginView(FeishuOAuth2ClientMixin, OAuth2LoginView):
    pass


class FeishuOAuth2CallbackView(FeishuOAuth2ClientMixin, OAuth2CallbackView):
    pass


oauth2_login = FeishuOAuth2LoginView.adapter_view(FeishuOAuth2Adapter)
oauth2_callback = FeishuOAuth2CallbackView.adapter_view(FeishuOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\feishu\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\figma\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import FigmaProvider


urlpatterns = default_urlpatterns(FigmaProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\figma\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\figma\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import FigmaProvider


class FigmaOAuth2Adapter(OAuth2Adapter):
    provider_id = FigmaProvider.id

    authorize_url = "https://www.figma.com/oauth"
    access_token_url = "https://www.figma.com/api/oauth/token"
    userinfo_url = "https://api.figma.com/v1/me"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.userinfo_url,
            headers={"Authorization": "Bearer {0}".format(token.token)},
        )
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(FigmaOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(FigmaOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\figma\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\fivehundredpx\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\fivehundredpx\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\fivehundredpx\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import FiveHundredPxProvider


urlpatterns = default_urlpatterns(FiveHundredPxProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\fivehundredpx\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\fivehundredpx\views.py ---

import json

from allauth.socialaccount.providers.oauth.client import OAuth
from allauth.socialaccount.providers.oauth.views import (
    OAuthAdapter,
    OAuthCallbackView,
    OAuthLoginView,
)

from .provider import FiveHundredPxProvider


API_BASE = "https://api.500px.com/v1"


class FiveHundredPxAPI(OAuth):
    """
    Verifying 500px credentials
    """

    url = API_BASE + "/users"

    def get_user_info(self):
        return json.loads(self.query(self.url))["user"]


class FiveHundredPxOAuthAdapter(OAuthAdapter):
    provider_id = FiveHundredPxProvider.id
    request_token_url = API_BASE + "/oauth/request_token"
    access_token_url = API_BASE + "/oauth/access_token"
    authorize_url = API_BASE + "/oauth/authorize"

    def complete_login(self, request, app, token, response):
        client = FiveHundredPxAPI(
            request, app.client_id, app.secret, self.request_token_url
        )
        extra_data = client.get_user_info()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth_login = OAuthLoginView.adapter_view(FiveHundredPxOAuthAdapter)
oauth_callback = OAuthCallbackView.adapter_view(FiveHundredPxOAuthAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\fivehundredpx\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\flickr\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import FlickrProvider


urlpatterns = default_urlpatterns(FlickrProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\flickr\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\flickr\views.py ---

import json

from django.utils.http import urlencode

from allauth.socialaccount.providers.oauth.client import OAuth
from allauth.socialaccount.providers.oauth.views import (
    OAuthAdapter,
    OAuthCallbackView,
    OAuthLoginView,
)

from .provider import FlickrProvider


class FlickrAPI(OAuth):
    api_url = "https://api.flickr.com/services/rest"

    def get_user_info(self):
        default_params = {"nojsoncallback": "1", "format": "json"}
        p = dict({"method": "flickr.test.login"}, **default_params)
        u = json.loads(self.query(self.api_url + "?" + urlencode(p)))

        p = dict(
            {"method": "flickr.people.getInfo", "user_id": u["user"]["id"]},
            **default_params,
        )
        user = json.loads(self.query(self.api_url + "?" + urlencode(p)))
        return user


class FlickrOAuthAdapter(OAuthAdapter):
    provider_id = FlickrProvider.id
    request_token_url = "http://www.flickr.com/services/oauth/request_token"
    access_token_url = "http://www.flickr.com/services/oauth/access_token"
    authorize_url = "http://www.flickr.com/services/oauth/authorize"

    def complete_login(self, request, app, token, response):
        client = FlickrAPI(request, app.client_id, app.secret, self.request_token_url)
        extra_data = client.get_user_info()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth_login = OAuthLoginView.adapter_view(FlickrOAuthAdapter)
oauth_callback = OAuthCallbackView.adapter_view(FlickrOAuthAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\flickr\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\foursquare\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import FoursquareProvider


urlpatterns = default_urlpatterns(FoursquareProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\foursquare\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\foursquare\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import FoursquareProvider


class FoursquareOAuth2Adapter(OAuth2Adapter):
    provider_id = FoursquareProvider.id
    access_token_url = "https://foursquare.com/oauth2/access_token"
    # Issue ?? -- this one authenticates over and over again...
    # authorize_url = 'https://foursquare.com/oauth2/authorize'
    authorize_url = "https://foursquare.com/oauth2/authenticate"
    profile_url = "https://api.foursquare.com/v2/users/self"

    def complete_login(self, request, app, token, **kwargs):
        # Foursquare needs a version number for their API requests as
        # documented here
        # https://developer.foursquare.com/overview/versioning
        resp = requests.get(
            self.profile_url,
            params={"oauth_token": token.token, "v": "20140116"},
        )
        extra_data = resp.json()["response"]["user"]
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(FoursquareOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(FoursquareOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\foursquare\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\frontier\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import FrontierProvider


urlpatterns = default_urlpatterns(FrontierProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\frontier\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\frontier\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import FrontierProvider


class FrontierOAuth2Adapter(OAuth2Adapter):
    provider_id = FrontierProvider.id
    AUTH_API = "https://auth.frontierstore.net"
    access_token_url = AUTH_API + "/token"
    authorize_url = AUTH_API + "/auth"
    profile_url = AUTH_API + "/me"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.profile_url,
            headers={"Authorization": "Bearer " + token.token},
        )
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(FrontierOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(FrontierOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\frontier\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\fxa\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\fxa\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\fxa\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import FirefoxAccountsProvider


urlpatterns = default_urlpatterns(FirefoxAccountsProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\fxa\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\fxa\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import (
    FXA_OAUTH_ENDPOINT,
    FXA_PROFILE_ENDPOINT,
    FirefoxAccountsProvider,
)


class FirefoxAccountsOAuth2Adapter(OAuth2Adapter):
    provider_id = FirefoxAccountsProvider.id
    access_token_url = FXA_OAUTH_ENDPOINT + "/token"
    authorize_url = FXA_OAUTH_ENDPOINT + "/authorization"
    profile_url = FXA_PROFILE_ENDPOINT + "/profile"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(FirefoxAccountsOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(FirefoxAccountsOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\fxa\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\gitea\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import GiteaProvider


urlpatterns = default_urlpatterns(GiteaProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\gitea\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\gitea\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.gitea.provider import GiteaProvider
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)


class GiteaOAuth2Adapter(OAuth2Adapter):
    provider_id = GiteaProvider.id
    settings = app_settings.PROVIDERS.get(provider_id, {})

    if "GITEA_URL" in settings:
        web_url = settings.get("GITEA_URL").rstrip("/")
    else:
        web_url = "https://gitea.com"
    api_url = "{0}/api/v1".format(web_url)

    access_token_url = "{0}/login/oauth/access_token".format(web_url)
    authorize_url = "{0}/login/oauth/authorize".format(web_url)
    profile_url = "{0}/user".format(api_url)

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "token {}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(GiteaOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(GiteaOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\gitea\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\github\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import GitHubProvider


urlpatterns = default_urlpatterns(GitHubProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\github\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\github\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.github.provider import GitHubProvider
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)


class GitHubOAuth2Adapter(OAuth2Adapter):
    provider_id = GitHubProvider.id
    settings = app_settings.PROVIDERS.get(provider_id, {})

    if "GITHUB_URL" in settings:
        web_url = settings.get("GITHUB_URL").rstrip("/")
        api_url = "{0}/api/v3".format(web_url)
    else:
        web_url = "https://github.com"
        api_url = "https://api.github.com"

    access_token_url = "{0}/login/oauth/access_token".format(web_url)
    authorize_url = "{0}/login/oauth/authorize".format(web_url)
    profile_url = "{0}/user".format(api_url)
    emails_url = "{0}/user/emails".format(api_url)

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "token {}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)
        resp.raise_for_status()
        extra_data = resp.json()
        if app_settings.QUERY_EMAIL and not extra_data.get("email"):
            extra_data["email"] = self.get_email(headers)
        return self.get_provider().sociallogin_from_response(request, extra_data)

    def get_email(self, headers):
        email = None
        resp = requests.get(self.emails_url, headers=headers)
        resp.raise_for_status()
        emails = resp.json()
        if resp.status_code == 200 and emails:
            email = emails[0]
            primary_emails = [
                e for e in emails if not isinstance(e, dict) or e.get("primary")
            ]
            if primary_emails:
                email = primary_emails[0]
            if isinstance(email, dict):
                email = email.get("email", "")
        return email


oauth2_login = OAuth2LoginView.adapter_view(GitHubOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(GitHubOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\github\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\gitlab\urls.py ---

# -*- coding: utf-8 -*-
from allauth.socialaccount.providers.gitlab.provider import GitLabProvider
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns


urlpatterns = default_urlpatterns(GitLabProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\gitlab\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\gitlab\views.py ---

# -*- coding: utf-8 -*-
import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.gitlab.provider import GitLabProvider
from allauth.socialaccount.providers.oauth2.client import OAuth2Error
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)


def _check_errors(response):
    #  403 error's are presented as user-facing errors
    if response.status_code == 403:
        msg = response.content
        raise OAuth2Error("Invalid data from GitLab API: %r" % (msg))

    try:
        data = response.json()
    except ValueError:  # JSONDecodeError on py3
        raise OAuth2Error("Invalid JSON from GitLab API: %r" % (response.text))

    if response.status_code >= 400 or "error" in data:
        # For errors, we expect the following format:
        # {"error": "error_name", "error_description": "Oops!"}
        # For example, if the token is not valid, we will get:
        # {"message": "status_code - message"}
        error = data.get("error", "") or response.status_code
        desc = data.get("error_description", "") or data.get("message", "")

        raise OAuth2Error("GitLab error: %s (%s)" % (error, desc))

    # The expected output from the API follows this format:
    # {"id": 12345, ...}
    if "id" not in data:
        # If the id is not present, the output is not usable (no UID)
        raise OAuth2Error("Invalid data from GitLab API: %r" % (data))

    return data


class GitLabOAuth2Adapter(OAuth2Adapter):
    provider_id = GitLabProvider.id
    provider_default_url = "https://gitlab.com"
    provider_api_version = "v4"

    settings = app_settings.PROVIDERS.get(provider_id, {})
    provider_base_url = settings.get("GITLAB_URL", provider_default_url)

    access_token_url = "{0}/oauth/token".format(provider_base_url)
    authorize_url = "{0}/oauth/authorize".format(provider_base_url)
    profile_url = "{0}/api/{1}/user".format(provider_base_url, provider_api_version)

    def complete_login(self, request, app, token, response):
        response = requests.get(self.profile_url, params={"access_token": token.token})
        data = _check_errors(response)
        return self.get_provider().sociallogin_from_response(request, data)


oauth2_login = OAuth2LoginView.adapter_view(GitLabOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(GitLabOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\gitlab\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\globus\urls.py ---

from allauth.socialaccount.providers.globus.provider import GlobusProvider
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns


urlpatterns = default_urlpatterns(GlobusProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\globus\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\globus\views.py ---

import requests

from allauth.socialaccount.providers.globus.provider import GlobusProvider
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)


class GlobusAdapter(OAuth2Adapter):
    provider_id = GlobusProvider.id
    provider_default_url = "https://auth.globus.org/v2/oauth2"

    provider_base_url = "https://auth.globus.org/v2/oauth2"

    access_token_url = "{0}/token".format(provider_base_url)
    authorize_url = "{0}/authorize".format(provider_base_url)
    profile_url = "{0}/userinfo".format(provider_base_url)

    def complete_login(self, request, app, token, response):
        extra_data = requests.get(
            self.profile_url,
            params={"access_token": token.token},
            headers={
                "Authorization": "Bearer " + token.token,
            },
        )

        return self.get_provider().sociallogin_from_response(request, extra_data.json())


oauth2_login = OAuth2LoginView.adapter_view(GlobusAdapter)
oauth2_callback = OAuth2CallbackView.adapter_view(GlobusAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\globus\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\google\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import GoogleProvider


urlpatterns = default_urlpatterns(GoogleProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\google\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\google\views.py ---

from django.conf import settings

import jwt

from allauth.socialaccount.providers.oauth2.client import OAuth2Error
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import GoogleProvider


ACCESS_TOKEN_URL = (
    getattr(settings, "SOCIALACCOUNT_PROVIDERS", {})
    .get("google", {})
    .get("ACCESS_TOKEN_URL", "https://oauth2.googleapis.com/token")
)

AUTHORIZE_URL = (
    getattr(settings, "SOCIALACCOUNT_PROVIDERS", {})
    .get("google", {})
    .get("AUTHORIZE_URL", "https://accounts.google.com/o/oauth2/v2/auth")
)

ID_TOKEN_ISSUER = (
    getattr(settings, "SOCIALACCOUNT_PROVIDERS", {})
    .get("google", {})
    .get("ID_TOKEN_ISSUER", "https://accounts.google.com")
)


class GoogleOAuth2Adapter(OAuth2Adapter):
    provider_id = GoogleProvider.id
    access_token_url = ACCESS_TOKEN_URL
    authorize_url = AUTHORIZE_URL
    id_token_issuer = ID_TOKEN_ISSUER

    def complete_login(self, request, app, token, response, **kwargs):
        try:
            identity_data = jwt.decode(
                response["id_token"],
                # Since the token was received by direct communication
                # protected by TLS between this library and Google, we
                # are allowed to skip checking the token signature
                # according to the OpenID Connect Core 1.0
                # specification.
                # https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation
                options={
                    "verify_signature": False,
                    "verify_iss": True,
                    "verify_aud": True,
                    "verify_exp": True,
                },
                issuer=self.id_token_issuer,
                audience=app.client_id,
            )
        except jwt.PyJWTError as e:
            raise OAuth2Error("Invalid id_token") from e
        login = self.get_provider().sociallogin_from_response(request, identity_data)
        return login


oauth2_login = OAuth2LoginView.adapter_view(GoogleOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(GoogleOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\google\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\gumroad\urls.py ---

# -*- coding: utf-8 -*-
from allauth.socialaccount.providers.gumroad.provider import GumroadProvider
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns


urlpatterns = default_urlpatterns(GumroadProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\gumroad\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\gumroad\views.py ---

# -*- coding: utf-8 -*-
import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.gumroad.provider import GumroadProvider
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)


class GumroadOauth2Adapter(OAuth2Adapter):
    provider_id = GumroadProvider.id
    supports_state = True

    settings = app_settings.PROVIDERS.get(provider_id, {})
    provider_base_url = settings.get("GUMROAD_URL")
    access_token_url = "{0}/oauth/token".format(provider_base_url)
    authorize_url = "{0}/oauth/authorize".format(provider_base_url)
    profile_url = "https://api.gumroad.com/v2/user"

    def complete_login(self, request, app, token, response):
        resp = requests.get(self.profile_url, params={"access_token": token.token})
        resp.raise_for_status()
        extra_data = resp.json()

        return self.get_provider().sociallogin_from_response(
            request, extra_data["user"]
        )


oauth2_login = OAuth2LoginView.adapter_view(GumroadOauth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(GumroadOauth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\gumroad\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\hubic\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import HubicProvider


urlpatterns = default_urlpatterns(HubicProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\hubic\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\hubic\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import HubicProvider


class HubicOAuth2Adapter(OAuth2Adapter):
    provider_id = HubicProvider.id
    access_token_url = "https://api.hubic.com/oauth/token"
    authorize_url = "https://api.hubic.com/oauth/auth"
    profile_url = "https://api.hubic.com/1.0/account"
    redirect_uri_protocol = "https"

    def complete_login(self, request, app, token, **kwargs):
        token_type = kwargs["response"]["token_type"]
        resp = requests.get(
            self.profile_url,
            headers={"Authorization": "%s %s" % (token_type, token.token)},
        )
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(HubicOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(HubicOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\hubic\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\hubspot\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import HubspotProvider


urlpatterns = default_urlpatterns(HubspotProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\hubspot\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\hubspot\views.py ---

"""Views for Hubspot API."""
import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import HubspotProvider


class HubspotOAuth2Adapter(OAuth2Adapter):
    """OAuth2Adapter for Hubspot API v3."""

    provider_id = HubspotProvider.id

    authorize_url = "https://app.hubspot.com/oauth/authorize"
    access_token_url = "https://api.hubapi.com/oauth/v1/token"
    profile_url = "https://api.hubapi.com/oauth/v1/access-tokens"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Content-Type": "application/json"}
        response = requests.get(
            "{0}/{1}".format(self.profile_url, token.token), headers=headers
        )
        response.raise_for_status()
        extra_data = response.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(HubspotOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(HubspotOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\hubspot\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\instagram\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import InstagramProvider


urlpatterns = default_urlpatterns(InstagramProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\instagram\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\instagram\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import InstagramProvider


class InstagramOAuth2Adapter(OAuth2Adapter):
    provider_id = InstagramProvider.id
    access_token_url = "https://api.instagram.com/oauth/access_token"
    authorize_url = "https://api.instagram.com/oauth/authorize"
    profile_url = "https://graph.instagram.com/me"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.profile_url,
            params={"access_token": token.token, "fields": ["id", "username"]},
        )
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(InstagramOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(InstagramOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\instagram\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\jupyterhub\urls.py ---

from allauth.socialaccount.providers.jupyterhub.provider import (
    JupyterHubProvider,
)
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns


urlpatterns = default_urlpatterns(JupyterHubProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\jupyterhub\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\jupyterhub\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.jupyterhub.provider import (
    JupyterHubProvider,
)
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)


class JupyterHubAdapter(OAuth2Adapter):
    provider_id = JupyterHubProvider.id

    settings = app_settings.PROVIDERS.get(provider_id, {})
    provider_base_url = settings.get("API_URL", "")

    access_token_url = "{0}/hub/api/oauth2/token".format(provider_base_url)
    authorize_url = "{0}/hub/api/oauth2/authorize".format(provider_base_url)
    profile_url = "{0}/hub/api/user".format(provider_base_url)

    def complete_login(self, request, app, access_token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(access_token)}

        extra_data = requests.get(self.profile_url, headers=headers)

        user_profile = extra_data.json()

        return self.get_provider().sociallogin_from_response(request, user_profile)


oauth2_login = OAuth2LoginView.adapter_view(JupyterHubAdapter)
oauth2_callback = OAuth2CallbackView.adapter_view(JupyterHubAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\jupyterhub\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\kakao\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\kakao\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\kakao\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import KakaoProvider


urlpatterns = default_urlpatterns(KakaoProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\kakao\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\kakao\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import KakaoProvider


class KakaoOAuth2Adapter(OAuth2Adapter):
    provider_id = KakaoProvider.id
    access_token_url = "https://kauth.kakao.com/oauth/token"
    authorize_url = "https://kauth.kakao.com/oauth/authorize"
    profile_url = "https://kapi.kakao.com/v2/user/me"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(KakaoOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(KakaoOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\kakao\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\keycloak\urls.py ---

# -*- coding: utf-8 -*-
from allauth.socialaccount.providers.keycloak.provider import KeycloakProvider
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns


urlpatterns = default_urlpatterns(KeycloakProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\keycloak\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\keycloak\views.py ---

# -*- coding: utf-8 -*-

from allauth.socialaccount.providers.keycloak.provider import KeycloakProvider
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2CallbackView,
    OAuth2LoginView,
)
from allauth.socialaccount.providers.openid_connect.views import (
    OpenIDConnectAdapter,
)


class KeycloakOAuth2Adapter(OpenIDConnectAdapter):
    provider_id = KeycloakProvider.id

    @property
    def authorize_url(self):
        return "{0}/protocol/openid-connect/auth".format(
            self.get_provider().provider_base_url
        )

    @property
    def access_token_url(self):
        return "{0}/protocol/openid-connect/token".format(
            self.get_provider().base_server_url
        )

    @property
    def profile_url(self):
        return "{0}/protocol/openid-connect/userinfo".format(
            self.get_provider().base_server_url
        )


def oauth2_login(request):
    view = OAuth2LoginView.adapter_view(
        KeycloakOAuth2Adapter(request, KeycloakProvider.id)
    )
    return view(request)


def oauth2_callback(request):
    view = OAuth2CallbackView.adapter_view(
        KeycloakOAuth2Adapter(request, KeycloakProvider.id)
    )
    return view(request)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\keycloak\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\lemonldap\urls.py ---

# -*- coding: utf-8 -*-
from allauth.socialaccount.providers.lemonldap.provider import (
    LemonLDAPProvider,
)
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns


urlpatterns = default_urlpatterns(LemonLDAPProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\lemonldap\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\lemonldap\views.py ---

# -*- coding: utf-8 -*-
import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.lemonldap.provider import (
    LemonLDAPProvider,
)
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)


class LemonLDAPOAuth2Adapter(OAuth2Adapter):
    provider_id = LemonLDAPProvider.id
    supports_state = True

    settings = app_settings.PROVIDERS.get(provider_id, {})
    provider_base_url = settings.get("LEMONLDAP_URL")

    access_token_url = "{0}/oauth2/token".format(provider_base_url)
    authorize_url = "{0}/oauth2/authorize".format(provider_base_url)
    profile_url = "{0}/oauth2/userinfo".format(provider_base_url)

    def complete_login(self, request, app, token, response):
        response = requests.post(
            self.profile_url, headers={"Authorization": "Bearer " + str(token)}
        )
        response.raise_for_status()
        extra_data = response.json()
        extra_data["id"] = extra_data["sub"]
        del extra_data["sub"]

        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(LemonLDAPOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(LemonLDAPOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\lemonldap\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\line\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\line\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\line\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import LineProvider


urlpatterns = default_urlpatterns(LineProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\line\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\line\views.py ---

import requests
from datetime import timedelta

from django.utils import timezone

from allauth.socialaccount import app_settings
from allauth.socialaccount.models import SocialToken
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import LineProvider


class LineOAuth2Adapter(OAuth2Adapter):
    provider_id = LineProvider.id
    access_token_url = "https://api.line.me/oauth2/v2.1/token"
    authorize_url = "https://access.line.me/oauth2/v2.1/authorize"
    profile_url = "https://api.line.me/v2/profile"  # https://developers.line.biz/en/reference/line-login/#get-user-profile
    id_token_url = "https://api.line.me/oauth2/v2.1/verify"  # https://developers.line.biz/en/reference/line-login/#verify-id-token

    def parse_token(self, data):
        """
        data: access_token data from line
        """
        settings = app_settings.PROVIDERS.get(self.provider_id, {})
        if "email" in settings.get("SCOPE", ""):
            token = SocialToken(token=data["id_token"])
        else:
            token = SocialToken(token=data["access_token"])
        token.token_secret = data.get("refresh_token", "")
        expires_in = data.get(self.expires_in_key, None)
        if expires_in:
            token.expires_at = timezone.now() + timedelta(seconds=int(expires_in))

        return token

    def complete_login(self, request, app, token, **kwargs):
        settings = app_settings.PROVIDERS.get(self.provider_id, {})
        if "email" in settings.get("SCOPE", ""):
            payload = {"client_id": app.client_id, "id_token": token.token}
            resp = requests.post(self.id_token_url, payload)
        else:
            headers = {"Authorization": "Bearer {0}".format(token.token)}
            resp = requests.get(self.profile_url, headers=headers)
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(LineOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(LineOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\line\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\linkedin\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import LinkedInProvider


urlpatterns = default_urlpatterns(LinkedInProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\linkedin\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\linkedin\views.py ---

from xml.etree import ElementTree
from xml.parsers.expat import ExpatError

from allauth.socialaccount.adapter import get_adapter
from allauth.socialaccount.providers.oauth.client import OAuth
from allauth.socialaccount.providers.oauth.views import (
    OAuthAdapter,
    OAuthCallbackView,
    OAuthLoginView,
)

from .provider import LinkedInProvider


class LinkedInAPI(OAuth):
    url = "https://api.linkedin.com/v1/people/~"

    def get_user_info(self):
        adapter = get_adapter(self.request)
        provider = adapter.get_provider(self.request, LinkedInProvider.id)
        fields = provider.get_profile_fields()
        url = self.url + ":(%s)" % ",".join(fields)
        raw_xml = self.query(url)
        try:
            return self.to_dict(ElementTree.fromstring(raw_xml))
        except (ExpatError, KeyError, IndexError):
            return None

    def to_dict(self, xml):
        """
        Convert XML structure to dict recursively, repeated keys
        entries are returned as in list containers.
        """
        children = list(xml)
        if not children:
            return xml.text
        else:
            out = {}
            for node in list(xml):
                if node.tag in out:
                    if not isinstance(out[node.tag], list):
                        out[node.tag] = [out[node.tag]]
                    out[node.tag].append(self.to_dict(node))
                else:
                    out[node.tag] = self.to_dict(node)
            return out


class LinkedInOAuthAdapter(OAuthAdapter):
    provider_id = LinkedInProvider.id
    request_token_url = "https://api.linkedin.com/uas/oauth/requestToken"
    access_token_url = "https://api.linkedin.com/uas/oauth/accessToken"
    authorize_url = "https://www.linkedin.com/uas/oauth/authenticate"

    def complete_login(self, request, app, token, response):
        client = LinkedInAPI(request, app.client_id, app.secret, self.request_token_url)
        extra_data = client.get_user_info()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth_login = OAuthLoginView.adapter_view(LinkedInOAuthAdapter)
oauth_callback = OAuthCallbackView.adapter_view(LinkedInOAuthAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\linkedin\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\linkedin_oauth2\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import LinkedInOAuth2Provider


urlpatterns = default_urlpatterns(LinkedInOAuth2Provider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\linkedin_oauth2\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\linkedin_oauth2\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import LinkedInOAuth2Provider


class LinkedInOAuth2Adapter(OAuth2Adapter):
    provider_id = LinkedInOAuth2Provider.id
    access_token_url = "https://www.linkedin.com/oauth/v2/accessToken"
    authorize_url = "https://www.linkedin.com/oauth/v2/authorization"
    profile_url = "https://api.linkedin.com/v2/me"
    email_url = "https://api.linkedin.com/v2/emailAddress?q=members&projection=(elements*(handle~))"  # noqa
    # See:
    # http://developer.linkedin.com/forum/unauthorized-invalid-or-expired-token-immediately-after-receiving-oauth2-token?page=1 # noqa
    access_token_method = "GET"

    def complete_login(self, request, app, token, **kwargs):
        extra_data = self.get_user_info(token)
        return self.get_provider().sociallogin_from_response(request, extra_data)

    def get_user_info(self, token):
        fields = self.get_provider().get_profile_fields()

        headers = {}
        headers.update(self.get_provider().get_settings().get("HEADERS", {}))
        headers["Authorization"] = " ".join(["Bearer", token.token])

        info = {}
        if app_settings.QUERY_EMAIL:
            resp = requests.get(self.email_url, headers=headers)
            # If this response goes wrong, that is not a blocker in order to
            # continue.
            if resp.ok:
                info = resp.json()

        url = self.profile_url + "?projection=(%s)" % ",".join(fields)
        resp = requests.get(url, headers=headers)
        resp.raise_for_status()
        info.update(resp.json())
        return info


oauth2_login = OAuth2LoginView.adapter_view(LinkedInOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(LinkedInOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\linkedin_oauth2\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\mailchimp\urls.py ---

"""Register urls for MailChimpProvider"""
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import MailChimpProvider


urlpatterns = default_urlpatterns(MailChimpProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\mailchimp\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\mailchimp\views.py ---

"""Views for MailChimp API v3."""
import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import MailChimpProvider


class MailChimpOAuth2Adapter(OAuth2Adapter):

    """OAuth2Adapter for MailChimp API v3."""

    provider_id = MailChimpProvider.id

    authorize_url = "https://login.mailchimp.com/oauth2/authorize"
    access_token_url = "https://login.mailchimp.com/oauth2/token"
    profile_url = "https://login.mailchimp.com/oauth2/metadata"

    def complete_login(self, request, app, token, **kwargs):
        """Complete login, ensuring correct OAuth header."""
        headers = {"Authorization": "OAuth {0}".format(token.token)}
        metadata = requests.get(self.profile_url, headers=headers)
        extra_data = metadata.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(MailChimpOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(MailChimpOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\mailchimp\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\mailru\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import MailRuProvider


urlpatterns = default_urlpatterns(MailRuProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\mailru\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\mailru\views.py ---

import requests
from hashlib import md5

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import MailRuProvider


class MailRuOAuth2Adapter(OAuth2Adapter):
    provider_id = MailRuProvider.id
    access_token_url = "https://connect.mail.ru/oauth/token"
    authorize_url = "https://connect.mail.ru/oauth/authorize"
    profile_url = "http://www.appsmail.ru/platform/api"

    def complete_login(self, request, app, token, **kwargs):
        uid = kwargs["response"]["x_mailru_vid"]
        data = {
            "method": "users.getInfo",
            "app_id": app.client_id,
            "secure": "1",
            "uids": uid,
        }
        param_list = sorted([item + "=" + data[item] for item in data])
        data["sig"] = md5(
            ("".join(param_list) + app.secret).encode("utf-8")
        ).hexdigest()
        response = requests.get(self.profile_url, params=data)
        extra_data = response.json()[0]
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(MailRuOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(MailRuOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\mailru\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\mediawiki\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import MediaWikiProvider


urlpatterns = default_urlpatterns(MediaWikiProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\mediawiki\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\mediawiki\views.py ---

import requests

from django.conf import settings

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import MediaWikiProvider


settings = getattr(settings, "SOCIALACCOUNT_PROVIDERS", {}).get("mediawiki", {})


class MediaWikiOAuth2Adapter(OAuth2Adapter):
    provider_id = MediaWikiProvider.id
    REST_API = settings.get("REST_API", "https://meta.wikimedia.org/w/rest.php")
    access_token_url = REST_API + "/oauth2/access_token"
    authorize_url = REST_API + "/oauth2/authorize"
    profile_url = REST_API + "/oauth2/resource/profile"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.profile_url,
            headers={"Authorization": "Bearer {token}".format(token=token.token)},
        )
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(MediaWikiOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(MediaWikiOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\mediawiki\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\meetup\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\meetup\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\meetup\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import MeetupProvider


urlpatterns = default_urlpatterns(MeetupProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\meetup\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\meetup\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import MeetupProvider


class MeetupOAuth2Adapter(OAuth2Adapter):
    provider_id = MeetupProvider.id
    access_token_url = "https://secure.meetup.com/oauth2/access"
    authorize_url = "https://secure.meetup.com/oauth2/authorize"
    profile_url = "https://api.meetup.com/2/member/self"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(self.profile_url, params={"access_token": token.token})
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(MeetupOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(MeetupOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\meetup\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\microsoft\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import MicrosoftGraphProvider


urlpatterns = default_urlpatterns(MicrosoftGraphProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\microsoft\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\microsoft\views.py ---

from __future__ import unicode_literals

import json
import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.client import OAuth2Error
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import MicrosoftGraphProvider


def _check_errors(response):
    try:
        data = response.json()
    except json.decoder.JSONDecodeError:
        raise OAuth2Error(
            "Invalid JSON from Microsoft Graph API: {}".format(response.text)
        )

    if "id" not in data:
        error_message = "Error retrieving Microsoft profile"
        microsoft_error_message = data.get("error", {}).get("message")
        if microsoft_error_message:
            error_message = ": ".join((error_message, microsoft_error_message))
        raise OAuth2Error(error_message)

    return data


class MicrosoftGraphOAuth2Adapter(OAuth2Adapter):
    provider_id = MicrosoftGraphProvider.id

    settings = app_settings.PROVIDERS.get(provider_id, {})
    # Lower case "tenant" for backwards compatibility
    tenant = settings.get("TENANT", settings.get("tenant", "common"))

    provider_base_url = "https://login.microsoftonline.com/{0}".format(tenant)
    access_token_url = "{0}/oauth2/v2.0/token".format(provider_base_url)
    authorize_url = "{0}/oauth2/v2.0/authorize".format(provider_base_url)
    profile_url = "https://graph.microsoft.com/v1.0/me"

    user_properties = (
        "businessPhones",
        "displayName",
        "givenName",
        "id",
        "jobTitle",
        "mail",
        "mobilePhone",
        "officeLocation",
        "preferredLanguage",
        "surname",
        "userPrincipalName",
        "mailNickname",
        "companyName",
    )
    profile_url_params = {"$select": ",".join(user_properties)}

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        response = requests.get(
            self.profile_url,
            params=self.profile_url_params,
            headers=headers,
        )
        extra_data = _check_errors(response)
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(MicrosoftGraphOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(MicrosoftGraphOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\microsoft\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\miro\urls.py ---

from allauth.socialaccount.providers.miro.provider import MiroProvider
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns


urlpatterns = default_urlpatterns(MiroProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\miro\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\miro\views.py ---

import requests

from allauth.socialaccount.providers.miro.provider import MiroProvider
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)


class MiroOAuth2Adapter(OAuth2Adapter):
    provider_id = MiroProvider.id
    access_token_url = "https://api.miro.com/v1/oauth/token"
    authorize_url = "https://miro.com/oauth/authorize"
    profile_url = "https://api.miro.com/v1/users/me"

    def complete_login(self, request, app, token, response):
        headers = {
            "Authorization": f"Bearer {token.token}",
            "Content-Type": "application/json",
        }
        extra_data = requests.get(self.profile_url, headers=headers)
        extra_data.raise_for_status()
        return self.get_provider().sociallogin_from_response(request, extra_data.json())


oauth2_login = OAuth2LoginView.adapter_view(MiroOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(MiroOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\miro\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\naver\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\naver\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\naver\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import NaverProvider


urlpatterns = default_urlpatterns(NaverProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\naver\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\naver\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import NaverProvider


class NaverOAuth2Adapter(OAuth2Adapter):
    provider_id = NaverProvider.id
    access_token_url = "https://nid.naver.com/oauth2.0/token"
    authorize_url = "https://nid.naver.com/oauth2.0/authorize"
    profile_url = "https://openapi.naver.com/v1/nid/me"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)
        resp.raise_for_status()
        extra_data = resp.json().get("response")
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(NaverOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(NaverOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\naver\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\netiq\urls.py ---

# -*- coding: utf-8 -*-
from allauth.socialaccount.providers.netiq.provider import NetIQProvider
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns


urlpatterns = default_urlpatterns(NetIQProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\netiq\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\netiq\views.py ---

# -*- coding: utf-8 -*-
import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.netiq.provider import NetIQProvider
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)


class NetIQOAuth2Adapter(OAuth2Adapter):
    provider_id = NetIQProvider.id
    supports_state = True

    settings = app_settings.PROVIDERS.get(provider_id, {})
    provider_base_url = settings.get("NETIQ_URL")

    @property
    def access_token_url(self):
        return "{}/nidp/oauth/nam/token".format(self.provider_base_url)

    @property
    def authorize_url(self):
        return "{}/nidp/oauth/nam/authz".format(self.provider_base_url)

    @property
    def userinfo_url(self):
        return "{}/nidp/oauth/nam/userinfo".format(self.provider_base_url)

    def complete_login(self, request, app, token, **kwargs):
        """
        Get the user info from userinfo endpoint and return a
        A populated instance of the `SocialLogin` model (unsaved)
        :param request:
        :param app:
        :param token:
        :param kwargs:
        :return:
        """

        resp = requests.get(
            self.userinfo_url,
            headers={"Authorization": "Bearer {}".format(token.token)},
        )

        resp.raise_for_status()
        extra_data = resp.json()
        login = self.get_provider().sociallogin_from_response(request, extra_data)
        return login


oauth2_login = OAuth2LoginView.adapter_view(NetIQOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(NetIQOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\netiq\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\nextcloud\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import NextCloudProvider


urlpatterns = default_urlpatterns(NextCloudProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\nextcloud\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\nextcloud\views.py ---

import requests
import xml.etree.ElementTree as ET

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import NextCloudProvider


class NextCloudAdapter(OAuth2Adapter):
    provider_id = NextCloudProvider.id
    settings = app_settings.PROVIDERS.get(provider_id, {})
    server = settings.get("SERVER", "https://nextcloud.example.org")
    access_token_url = "{0}/apps/oauth2/api/v1/token".format(server)
    authorize_url = "{0}/apps/oauth2/authorize".format(server)
    profile_url = "{0}/ocs/v1.php/cloud/users/".format(server)

    def complete_login(self, request, app, token, **kwargs):
        extra_data = self.get_user_info(token, kwargs["response"]["user_id"])
        return self.get_provider().sociallogin_from_response(request, extra_data)

    def get_user_info(self, token, user_id):
        headers = {"Authorization": "Bearer {0}".format(token)}
        resp = requests.get(self.profile_url + user_id, headers=headers)
        resp.raise_for_status()
        data = ET.fromstring(resp.content.decode())[1]
        return {d.tag: d.text.strip() for d in data if d.text is not None}


oauth2_login = OAuth2LoginView.adapter_view(NextCloudAdapter)
oauth2_callback = OAuth2CallbackView.adapter_view(NextCloudAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\nextcloud\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\notion\urls.py ---

from allauth.socialaccount.providers.notion.provider import NotionProvider
from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns


urlpatterns = default_urlpatterns(NotionProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\notion\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\notion\views.py ---

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .client import NotionOAuth2Client
from .provider import NotionProvider


class NotionOAuth2Adapter(OAuth2Adapter):
    provider_id = NotionProvider.id
    basic_auth = True
    client_class = NotionOAuth2Client

    authorize_url = "https://api.notion.com/v1/oauth/authorize"
    access_token_url = "https://api.notion.com/v1/oauth/token"

    def complete_login(self, request, app, token, **kwargs):
        return self.get_provider().sociallogin_from_response(
            request, kwargs["response"]
        )


oauth2_login = OAuth2LoginView.adapter_view(NotionOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(NotionOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\notion\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\oauth\urls.py ---

from django.urls import include, path

from allauth.utils import import_attribute


def default_urlpatterns(provider):
    login_view = import_attribute(provider.get_package() + ".views.oauth_login")
    callback_view = import_attribute(provider.get_package() + ".views.oauth_callback")

    urlpatterns = [
        path("login/", login_view, name=provider.id + "_login"),
        path("login/callback/", callback_view, name=provider.id + "_callback"),
    ]

    return [path(provider.get_slug() + "/", include(urlpatterns))]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\oauth\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\oauth\views.py ---

from __future__ import absolute_import

from django.urls import reverse

from allauth.socialaccount.adapter import get_adapter
from allauth.socialaccount.helpers import (
    complete_social_login,
    render_authentication_error,
)
from allauth.socialaccount.models import SocialLogin, SocialToken
from allauth.socialaccount.providers.base.constants import (
    AuthAction,
    AuthError,
)
from allauth.socialaccount.providers.base.mixins import OAuthLoginMixin
from allauth.socialaccount.providers.oauth.client import (
    OAuthClient,
    OAuthError,
)


class OAuthAdapter(object):
    def __init__(self, request):
        self.request = request

    def complete_login(self, request, app):
        """
        Returns a SocialLogin instance
        """
        raise NotImplementedError

    def get_provider(self):
        adapter = get_adapter(self.request)
        app = adapter.get_app(self.request, provider=self.provider_id)
        return app.get_provider(self.request)


class OAuthView(object):
    @classmethod
    def adapter_view(cls, adapter):
        def view(request, *args, **kwargs):
            self = cls()
            self.request = request
            self.adapter = adapter(request)
            return self.dispatch(request, *args, **kwargs)

        return view

    def _get_client(self, request, callback_url):
        provider = self.adapter.get_provider()
        app = provider.app
        scope = " ".join(provider.get_scope(request))
        parameters = {}
        if scope:
            parameters["scope"] = scope
        client = OAuthClient(
            request,
            app.client_id,
            app.secret,
            self.adapter.request_token_url,
            self.adapter.access_token_url,
            callback_url,
            parameters=parameters,
            provider=provider,
        )
        return client


class OAuthLoginView(OAuthLoginMixin, OAuthView):
    def login(self, request, *args, **kwargs):
        callback_url = reverse(self.adapter.provider_id + "_callback")
        SocialLogin.stash_state(request)
        action = request.GET.get("action", AuthAction.AUTHENTICATE)
        provider = self.adapter.get_provider()
        auth_url = provider.get_auth_url(request, action) or self.adapter.authorize_url
        auth_params = provider.get_auth_params(request, action)
        client = self._get_client(request, callback_url)
        try:
            return client.get_redirect(auth_url, auth_params)
        except OAuthError as e:
            return render_authentication_error(
                request, self.adapter.provider_id, exception=e
            )


class OAuthCallbackView(OAuthView):
    def dispatch(self, request):
        """
        View to handle final steps of OAuth based authentication where the user
        gets redirected back to from the service provider
        """
        login_done_url = reverse(self.adapter.provider_id + "_callback")
        client = self._get_client(request, login_done_url)
        if not client.is_valid():
            if "denied" in request.GET:
                error = AuthError.CANCELLED
            else:
                error = AuthError.UNKNOWN
            extra_context = dict(oauth_client=client)
            return render_authentication_error(
                request,
                self.adapter.provider_id,
                error=error,
                extra_context=extra_context,
            )
        app = self.adapter.get_provider().app
        try:
            access_token = client.get_access_token()
            token = SocialToken(
                app=app,
                token=access_token["oauth_token"],
                # .get() -- e.g. Evernote does not feature a secret
                token_secret=access_token.get("oauth_token_secret", ""),
            )
            login = self.adapter.complete_login(
                request, app, token, response=access_token
            )
            login.token = token
            login.state = SocialLogin.unstash_state(request)
            return complete_social_login(request, login)
        except OAuthError as e:
            return render_authentication_error(
                request, self.adapter.provider_id, exception=e
            )

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\oauth\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\oauth2\urls.py ---

from django.urls import include, path

from allauth.utils import import_attribute


def default_urlpatterns(provider):
    login_view = import_attribute(provider.get_package() + ".views.oauth2_login")
    callback_view = import_attribute(provider.get_package() + ".views.oauth2_callback")

    urlpatterns = [
        path("login/", login_view, name=provider.id + "_login"),
        path("login/callback/", callback_view, name=provider.id + "_callback"),
    ]

    return [path(provider.get_slug() + "/", include(urlpatterns))]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\oauth2\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\oauth2\views.py ---

from __future__ import absolute_import

from datetime import timedelta
from requests import RequestException

from django.core.exceptions import PermissionDenied
from django.http import HttpResponseRedirect
from django.urls import reverse
from django.utils import timezone

from allauth.exceptions import ImmediateHttpResponse
from allauth.socialaccount.adapter import get_adapter
from allauth.socialaccount.helpers import (
    complete_social_login,
    render_authentication_error,
)
from allauth.socialaccount.models import SocialLogin, SocialToken
from allauth.socialaccount.providers.base import ProviderException
from allauth.socialaccount.providers.base.constants import (
    AuthAction,
    AuthError,
)
from allauth.socialaccount.providers.base.mixins import OAuthLoginMixin
from allauth.socialaccount.providers.oauth2.client import (
    OAuth2Client,
    OAuth2Error,
)
from allauth.utils import build_absolute_uri, get_request_param


class OAuth2Adapter(object):
    expires_in_key = "expires_in"
    client_class = OAuth2Client
    supports_state = True
    redirect_uri_protocol = None
    access_token_method = "POST"
    login_cancelled_error = "access_denied"
    scope_delimiter = " "
    basic_auth = False
    headers = None

    def __init__(self, request):
        self.request = request

    def get_provider(self):
        return get_adapter(self.request).get_provider(
            self.request, provider=self.provider_id
        )

    def complete_login(self, request, app, access_token, **kwargs):
        """
        Returns a SocialLogin instance
        """
        raise NotImplementedError

    def get_callback_url(self, request, app):
        callback_url = reverse(self.provider_id + "_callback")
        protocol = self.redirect_uri_protocol
        return build_absolute_uri(request, callback_url, protocol)

    def parse_token(self, data):
        token = SocialToken(token=data["access_token"])
        token.token_secret = data.get("refresh_token", "")
        expires_in = data.get(self.expires_in_key, None)
        if expires_in:
            token.expires_at = timezone.now() + timedelta(seconds=int(expires_in))
        return token

    def get_access_token_data(self, request, app, client):
        code = get_request_param(self.request, "code")
        pkce_code_verifier = request.session.pop("pkce_code_verifier", None)
        return client.get_access_token(code, pkce_code_verifier=pkce_code_verifier)


class OAuth2View(object):
    @classmethod
    def adapter_view(cls, adapter):
        def view(request, *args, **kwargs):
            self = cls()
            self.request = request
            if not isinstance(adapter, OAuth2Adapter):
                self.adapter = adapter(request)
            else:
                self.adapter = adapter
            try:
                return self.dispatch(request, *args, **kwargs)
            except ImmediateHttpResponse as e:
                return e.response

        return view

    def get_client(self, request, app):
        callback_url = self.adapter.get_callback_url(request, app)
        provider = self.adapter.get_provider()
        scope = provider.get_scope(request)
        client = self.adapter.client_class(
            self.request,
            app.client_id,
            app.secret,
            self.adapter.access_token_method,
            self.adapter.access_token_url,
            callback_url,
            scope,
            scope_delimiter=self.adapter.scope_delimiter,
            headers=self.adapter.headers,
            basic_auth=self.adapter.basic_auth,
        )
        return client


class OAuth2LoginView(OAuthLoginMixin, OAuth2View):
    def login(self, request, *args, **kwargs):
        provider = self.adapter.get_provider()
        app = provider.app
        client = self.get_client(request, app)
        action = request.GET.get("action", AuthAction.AUTHENTICATE)
        auth_url = self.adapter.authorize_url
        auth_params = provider.get_auth_params(request, action)

        pkce_params = provider.get_pkce_params()
        code_verifier = pkce_params.pop("code_verifier", None)
        auth_params.update(pkce_params)
        if code_verifier:
            request.session["pkce_code_verifier"] = code_verifier

        client.state = SocialLogin.stash_state(request)
        try:
            return HttpResponseRedirect(client.get_redirect_url(auth_url, auth_params))
        except OAuth2Error as e:
            return render_authentication_error(request, provider.id, exception=e)


class OAuth2CallbackView(OAuth2View):
    def dispatch(self, request, *args, **kwargs):
        if "error" in request.GET or "code" not in request.GET:
            # Distinguish cancel from error
            auth_error = request.GET.get("error", None)
            if auth_error == self.adapter.login_cancelled_error:
                error = AuthError.CANCELLED
            else:
                error = AuthError.UNKNOWN
            return render_authentication_error(
                request, self.adapter.provider_id, error=error
            )
        app = self.adapter.get_provider().app
        client = self.get_client(self.request, app)

        try:
            access_token = self.adapter.get_access_token_data(request, app, client)
            token = self.adapter.parse_token(access_token)
            token.app = app
            login = self.adapter.complete_login(
                request, app, token, response=access_token
            )
            login.token = token
            if self.adapter.supports_state:
                login.state = SocialLogin.verify_and_unstash_state(
                    request, get_request_param(request, "state")
                )
            else:
                login.state = SocialLogin.unstash_state(request)

            return complete_social_login(request, login)
        except (
            PermissionDenied,
            OAuth2Error,
            RequestException,
            ProviderException,
        ) as e:
            return render_authentication_error(
                request, self.adapter.provider_id, exception=e
            )

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\oauth2\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\odnoklassniki\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import OdnoklassnikiProvider


urlpatterns = default_urlpatterns(OdnoklassnikiProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\odnoklassniki\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\odnoklassniki\views.py ---

import requests
from hashlib import md5

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import OdnoklassnikiProvider


USER_FIELDS = [
    "age",
    "birthday",
    "current_status",
    "current_status_date",
    "current_status_id",
    "email",
    "first_name",
    "gender",
    "has_email",
    "last_name",
    "locale",
    "location",
    "name",
    "online",
    "photo_id",
    "pic1024x768",  # big
    "pic190x190",  # small
    "pic640x480",  # medium
    "pic_1",  # aka pic50x50
    "pic_2",  # aka pic128max
    "uid",
]


class OdnoklassnikiOAuth2Adapter(OAuth2Adapter):
    provider_id = OdnoklassnikiProvider.id
    access_token_url = "https://api.odnoklassniki.ru/oauth/token.do"
    authorize_url = "https://www.odnoklassniki.ru/oauth/authorize"
    profile_url = "https://api.odnoklassniki.ru/fb.do"
    access_token_method = "POST"

    def complete_login(self, request, app, token, **kwargs):
        data = {
            "method": "users.getCurrentUser",
            "access_token": token.token,
            "fields": ",".join(USER_FIELDS),
            "format": "JSON",
            "application_key": app.key,
        }
        suffix = md5(
            "{0:s}{1:s}".format(data["access_token"], app.secret).encode("utf-8")
        ).hexdigest()
        check_list = sorted(
            ["{0:s}={1:s}".format(k, v) for k, v in data.items() if k != "access_token"]
        )
        data["sig"] = md5(("".join(check_list) + suffix).encode("utf-8")).hexdigest()

        response = requests.get(self.profile_url, params=data)
        extra_data = response.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(OdnoklassnikiOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(OdnoklassnikiOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\odnoklassniki\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\okta\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import OktaProvider


urlpatterns = default_urlpatterns(OktaProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\okta\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\okta\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import OktaProvider


class OktaOAuth2Adapter(OAuth2Adapter):
    provider_id = OktaProvider.id

    settings = app_settings.PROVIDERS.get(provider_id, {})
    okta_base_url = settings.get("OKTA_BASE_URL")

    @property
    def access_token_url(self):
        return "https://{}/oauth2/v1/token".format(self.okta_base_url)

    @property
    def authorize_url(self):
        return "https://{}/oauth2/v1/authorize".format(self.okta_base_url)

    @property
    def userinfo_url(self):
        return "https://{}/oauth2/v1/userinfo".format(self.okta_base_url)

    @property
    def access_token_method(self):
        return "POST"

    def complete_login(self, request, app, token, **kwargs):
        """
        Get the user info from userinfo endpoint and return a
        A populated instance of the `SocialLogin` model (unsaved)

        :param request:
        :param app:
        :param token:
        :param kwargs:
        :return:
        """

        resp = requests.get(
            self.userinfo_url,
            headers={"Authorization": "Bearer {}".format(token.token)},
        )

        resp.raise_for_status()
        extra_data = resp.json()
        login = self.get_provider().sociallogin_from_response(request, extra_data)
        return login


oauth2_login = OAuth2LoginView.adapter_view(OktaOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(OktaOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\okta\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openid\admin.py ---

from django.contrib import admin

from .models import OpenIDNonce, OpenIDStore


class OpenIDStoreAdmin(admin.ModelAdmin):
    pass


class OpenIDNonceAdmin(admin.ModelAdmin):
    pass


admin.site.register(OpenIDStore, OpenIDStoreAdmin)
admin.site.register(OpenIDNonce, OpenIDNonceAdmin)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openid\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openid\models.py ---

from django.db import models


class OpenIDStore(models.Model):
    server_url = models.CharField(max_length=255)
    handle = models.CharField(max_length=255)
    secret = models.TextField()
    issued = models.IntegerField()
    lifetime = models.IntegerField()
    assoc_type = models.TextField()

    def __str__(self):
        return self.server_url


class OpenIDNonce(models.Model):
    server_url = models.CharField(max_length=255)
    timestamp = models.IntegerField()
    salt = models.CharField(max_length=255)
    date_created = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.server_url

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openid\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openid\urls.py ---

from django.urls import path

from . import views


urlpatterns = [
    path("openid/login/", views.login, name="openid_login"),
    path("openid/callback/", views.callback, name="openid_callback"),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openid\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openid\views.py ---

from django.http import HttpResponseRedirect
from django.shortcuts import render
from django.urls import reverse
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from openid.consumer import consumer
from openid.consumer.discover import DiscoveryFailure
from openid.extensions.ax import AttrInfo, FetchRequest
from openid.extensions.sreg import SRegRequest

from allauth.socialaccount.app_settings import QUERY_EMAIL
from allauth.socialaccount.helpers import (
    complete_social_login,
    render_authentication_error,
)
from allauth.socialaccount.models import SocialLogin

from ..base import AuthError
from .forms import LoginForm
from .provider import OpenIDProvider
from .utils import AXAttributes, DBOpenIDStore, JSONSafeSession, SRegFields


def _openid_consumer(request, provider, endpoint):
    server_settings = provider.get_server_settings(endpoint)
    stateless = server_settings.get("stateless", False)
    store = None if stateless else DBOpenIDStore()
    client = consumer.Consumer(JSONSafeSession(request.session), store)
    return client


class OpenIDLoginView(View):
    template_name = "openid/login.html"
    form_class = LoginForm
    provider = OpenIDProvider

    def get(self, request):
        form = self.get_form()
        if not form.is_valid():
            return render(request, self.template_name, {"form": form})

        try:
            return self.perform_openid_auth(form)
        except (UnicodeDecodeError, DiscoveryFailure) as e:
            # UnicodeDecodeError: necaris/python3-openid#1
            return render_authentication_error(request, self.provider.id, exception=e)

    def post(self, request):
        form = self.get_form()
        if form.is_valid():
            try:
                return self.perform_openid_auth(form)
            except (UnicodeDecodeError, DiscoveryFailure) as e:
                form._errors["openid"] = form.error_class([e])

        return render(request, self.template_name, {"form": form})

    def get_form(self):
        if self.request.method == "GET" and "openid" not in self.request.GET:
            return self.form_class(
                initial={
                    "next": self.request.GET.get("next"),
                    "process": self.request.GET.get("process"),
                }
            )

        return self.form_class(
            dict(list(self.request.GET.items()) + list(self.request.POST.items()))
        )

    def get_client(self, provider, endpoint):
        return _openid_consumer(self.request, provider, endpoint)

    def get_realm(self, provider):
        return provider.get_settings().get(
            "REALM", self.request.build_absolute_uri("/")
        )

    def get_callback_url(self):
        return reverse(callback)

    def perform_openid_auth(self, form):
        if not form.is_valid():
            return form

        request = self.request
        provider = self.provider(request)
        endpoint = form.cleaned_data["openid"]
        client = self.get_client(provider, endpoint)
        realm = self.get_realm(provider)

        auth_request = client.begin(endpoint)
        if QUERY_EMAIL:
            sreg = SRegRequest()
            for name in SRegFields:
                sreg.requestField(field_name=name, required=True)
            auth_request.addExtension(sreg)
            ax = FetchRequest()
            for name in AXAttributes:
                ax.add(AttrInfo(name, required=True))
            provider = OpenIDProvider(request)
            server_settings = provider.get_server_settings(request.GET.get("openid"))
            extra_attributes = server_settings.get("extra_attributes", [])
            for _, name, required in extra_attributes:
                ax.add(AttrInfo(name, required=required))
            auth_request.addExtension(ax)

        SocialLogin.stash_state(request)

        # Fix for issues 1523 and 2072 (github django-allauth)
        if "next" in form.cleaned_data and form.cleaned_data["next"]:
            auth_request.return_to_args["next"] = form.cleaned_data["next"]
        redirect_url = auth_request.redirectURL(
            realm, request.build_absolute_uri(self.get_callback_url())
        )
        return HttpResponseRedirect(redirect_url)


login = OpenIDLoginView.as_view()


class OpenIDCallbackView(View):
    provider = OpenIDProvider

    def get(self, request):
        provider = self.provider(request)
        endpoint = request.GET.get("openid.op_endpoint", "")
        client = self.get_client(provider, endpoint)
        response = self.get_openid_response(client)

        if response.status == consumer.SUCCESS:
            login = provider.sociallogin_from_response(request, response)
            login.state = SocialLogin.unstash_state(request)
            return self.complete_login(login)
        else:
            if response.status == consumer.CANCEL:
                error = AuthError.CANCELLED
            else:
                error = AuthError.UNKNOWN
            return self.render_error(error)

    post = get

    def complete_login(self, login):
        return complete_social_login(self.request, login)

    def render_error(self, error):
        return render_authentication_error(self.request, self.provider.id, error=error)

    def get_client(self, provider, endpoint):
        return _openid_consumer(self.request, provider, endpoint)

    def get_openid_response(self, client):
        return client.complete(
            dict(list(self.request.GET.items()) + list(self.request.POST.items())),
            self.request.build_absolute_uri(self.request.path),
        )


callback = csrf_exempt(OpenIDCallbackView.as_view())

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openid\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openid_connect\urls.py ---

from django.urls import include, path, re_path

from . import views


urlpatterns = [
    re_path(
        r"^(?P<provider_id>[^/]+)/",
        include(
            [
                path(
                    "login/",
                    views.login,
                    name="openid_connect_login",
                ),
                path(
                    "login/callback/",
                    views.callback,
                    name="openid_connect_callback",
                ),
            ]
        ),
    )
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openid_connect\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openid_connect\views.py ---

import requests

from django.urls import reverse

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)
from allauth.utils import build_absolute_uri


class OpenIDConnectAdapter(OAuth2Adapter):
    supports_state = True

    def __init__(self, request, provider_id):
        self.provider_id = provider_id
        super().__init__(request)

    @property
    def openid_config(self):
        if not hasattr(self, "_openid_config"):
            server_url = self.get_provider().server_url
            resp = requests.get(server_url)
            resp.raise_for_status()
            self._openid_config = resp.json()
        return self._openid_config

    @property
    def basic_auth(self):
        token_auth_method = self.get_provider().app.settings.get("token_auth_method")
        if token_auth_method:
            return token_auth_method == "client_secret_basic"
        return "client_secret_basic" in self.openid_config.get(
            "token_endpoint_auth_methods_supported", []
        )

    @property
    def access_token_url(self):
        return self.openid_config["token_endpoint"]

    @property
    def authorize_url(self):
        return self.openid_config["authorization_endpoint"]

    @property
    def profile_url(self):
        return self.openid_config["userinfo_endpoint"]

    def complete_login(self, request, app, token, response):
        response = requests.get(
            self.profile_url, headers={"Authorization": "Bearer " + str(token)}
        )
        response.raise_for_status()
        extra_data = response.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)

    def get_callback_url(self, request, app):
        callback_url = reverse(
            "openid_connect_callback", kwargs={"provider_id": self.provider_id}
        )
        protocol = self.redirect_uri_protocol
        return build_absolute_uri(request, callback_url, protocol)


def login(request, provider_id):
    view = OAuth2LoginView.adapter_view(OpenIDConnectAdapter(request, provider_id))
    return view(request)


def callback(request, provider_id):
    view = OAuth2CallbackView.adapter_view(OpenIDConnectAdapter(request, provider_id))
    return view(request)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openid_connect\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openstreetmap\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import OpenStreetMapProvider


urlpatterns = default_urlpatterns(OpenStreetMapProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openstreetmap\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openstreetmap\views.py ---

from xml.etree import ElementTree
from xml.parsers.expat import ExpatError

from allauth.socialaccount.providers.oauth.client import OAuth
from allauth.socialaccount.providers.oauth.views import (
    OAuthAdapter,
    OAuthCallbackView,
    OAuthLoginView,
)

from .provider import OpenStreetMapProvider


class OpenStreetMapAPI(OAuth):
    url = "https://www.openstreetmap.org/api/0.6/user/details"

    def get_user_info(self):
        raw_xml = self.query(self.url)
        try:
            user_element = ElementTree.fromstring(raw_xml).find("user")
            user_info = user_element.attrib
            user_avatar = user_element.find("img")
            if user_avatar is not None:
                user_info.update({"avatar": user_avatar.attrib.get("href")})
            return user_info
        except (ExpatError, KeyError, IndexError):
            return None


class OpenStreetMapOAuthAdapter(OAuthAdapter):
    provider_id = OpenStreetMapProvider.id
    request_token_url = "https://www.openstreetmap.org/oauth/request_token"
    access_token_url = "https://www.openstreetmap.org/oauth/access_token"
    authorize_url = "https://www.openstreetmap.org/oauth/authorize"

    def complete_login(self, request, app, token, response):
        client = OpenStreetMapAPI(
            request, app.client_id, app.secret, self.request_token_url
        )
        extra_data = client.get_user_info()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth_login = OAuthLoginView.adapter_view(OpenStreetMapOAuthAdapter)
oauth_callback = OAuthCallbackView.adapter_view(OpenStreetMapOAuthAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\openstreetmap\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\orcid\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import OrcidProvider


urlpatterns = default_urlpatterns(OrcidProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\orcid\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\orcid\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import OrcidProvider


class OrcidOAuth2Adapter(OAuth2Adapter):
    provider_id = OrcidProvider.id
    # http://support.orcid.org/knowledgebase/articles/335483-the-public-
    # client-orcid-api

    member_api_default = False
    base_domain_default = "orcid.org"

    settings = app_settings.PROVIDERS.get(provider_id, {})

    base_domain = settings.get("BASE_DOMAIN", base_domain_default)
    member_api = settings.get("MEMBER_API", member_api_default)

    api_domain = "{0}.{1}".format("api" if member_api else "pub", base_domain)

    authorize_url = "https://{0}/oauth/authorize".format(base_domain)
    access_token_url = "https://{0}/oauth/token".format(api_domain)
    profile_url = "https://{0}/v2.1/%s/record".format(api_domain)

    def complete_login(self, request, app, token, **kwargs):
        params = {}
        if self.member_api:
            params["access_token"] = token.token

        resp = requests.get(
            self.profile_url % kwargs["response"]["orcid"],
            params=params,
            headers={"accept": "application/orcid+json"},
        )
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(OrcidOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(OrcidOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\orcid\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\patreon\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\patreon\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\patreon\urls.py ---

"""URLs for Patreon Provider"""

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import PatreonProvider


urlpatterns = default_urlpatterns(PatreonProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\patreon\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\patreon\views.py ---

"""
Views for PatreonProvider
https://www.patreon.com/platform/documentation/oauth
"""

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import API_URL, USE_API_V2, PatreonProvider


class PatreonOAuth2Adapter(OAuth2Adapter):
    provider_id = PatreonProvider.id
    access_token_url = "https://www.patreon.com/api/oauth2/token"
    authorize_url = "https://www.patreon.com/oauth2/authorize"
    profile_url = "{0}/{1}".format(
        API_URL,
        "identity?include=memberships&fields%5Buser%5D=email,first_name,"
        "full_name,image_url,last_name,social_connections,"
        "thumb_url,url,vanity"
        if USE_API_V2
        else "current_user",
    )

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.profile_url,
            headers={"Authorization": "Bearer " + token.token},
        )
        extra_data = resp.json().get("data")

        if USE_API_V2:
            # Extract tier/pledge level for Patreon API v2:
            try:
                member_id = extra_data["relationships"]["memberships"]["data"][0]["id"]
                member_url = (
                    "{0}/members/{1}?include="
                    "currently_entitled_tiers&fields%5Btier%5D=title"
                ).format(API_URL, member_id)
                resp_member = requests.get(
                    member_url,
                    headers={"Authorization": "Bearer " + token.token},
                )
                pledge_title = resp_member.json()["included"][0]["attributes"]["title"]
                extra_data["pledge_level"] = pledge_title
            except (KeyError, IndexError):
                extra_data["pledge_level"] = None
                pass

        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(PatreonOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(PatreonOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\patreon\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\paypal\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import PaypalProvider


urlpatterns = default_urlpatterns(PaypalProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\paypal\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\paypal\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import PaypalProvider


class PaypalOAuth2Adapter(OAuth2Adapter):
    provider_id = PaypalProvider.id
    supports_state = False

    @property
    def authorize_url(self):
        path = "webapps/auth/protocol/openidconnect/v1/authorize"
        return "https://www.{0}/{1}".format(self._get_endpoint(), path)

    @property
    def access_token_url(self):
        path = "v1/identity/openidconnect/tokenservice"
        return "https://api.{0}/{1}".format(self._get_endpoint(), path)

    @property
    def profile_url(self):
        path = "v1/identity/openidconnect/userinfo"
        return "https://api.{0}/{1}".format(self._get_endpoint(), path)

    def _get_endpoint(self):
        settings = self.get_provider().get_settings()
        if settings.get("MODE") == "live":
            return "paypal.com"
        else:
            return "sandbox.paypal.com"

    def complete_login(self, request, app, token, **kwargs):
        response = requests.post(
            self.profile_url,
            params={"schema": "openid", "access_token": token},
        )
        extra_data = response.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(PaypalOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(PaypalOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\paypal\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\pinterest\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import PinterestProvider


urlpatterns = default_urlpatterns(PinterestProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\pinterest\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\pinterest\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import PinterestProvider


class PinterestOAuth2Adapter(OAuth2Adapter):
    provider_id = PinterestProvider.id

    provider_default_url = "api.pinterest.com"
    provider_default_api_version = "v1"

    settings = app_settings.PROVIDERS.get(provider_id, {})

    provider_base_url = settings.get("PINTEREST_URL", provider_default_url)
    provider_api_version = settings.get("API_VERSION", provider_default_api_version)

    authorize_url = "https://www.pinterest.com/oauth/"
    access_token_url = "https://{0}/{1}/oauth/token".format(
        provider_base_url, provider_api_version
    )
    basic_auth = True
    if provider_api_version == "v5":
        profile_url = "https://{0}/{1}/user_account".format(
            provider_base_url, provider_api_version
        )
    elif provider_api_version == "v3":
        profile_url = "https://{0}/{1}/users/me".format(
            provider_base_url, provider_api_version
        )
    else:
        profile_url = "https://{0}/{1}/me".format(
            provider_base_url, provider_api_version
        )

    if provider_api_version == "v3":
        access_token_method = "PUT"

    def complete_login(self, request, app, token, **kwargs):
        response = requests.get(
            self.profile_url, headers={"Authorization": "Bearer " + token.token}
        )
        extra_data = response.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(PinterestOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(PinterestOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\pinterest\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\pocket\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\pocket\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\pocket\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import PocketProvider


urlpatterns = default_urlpatterns(PocketProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\pocket\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\pocket\views.py ---

from ..oauth.views import OAuthAdapter, OAuthCallbackView, OAuthLoginView
from .client import PocketOAuthClient
from .provider import PocketProvider


class PocketOAuthAdapter(OAuthAdapter):
    provider_id = PocketProvider.id
    request_token_url = "https://getpocket.com/v3/oauth/request"
    access_token_url = "https://getpocket.com/v3/oauth/authorize"
    authorize_url = "https://getpocket.com/auth/authorize"

    def complete_login(self, request, app, token, response):
        return self.get_provider().sociallogin_from_response(request, response)


class PocketOAuthLoginView(OAuthLoginView):
    def _get_client(self, request, callback_url):
        provider = self.adapter.get_provider()
        app = provider.app
        scope = " ".join(provider.get_scope(request))
        parameters = {}
        if scope:
            parameters["scope"] = scope
        client = PocketOAuthClient(
            request,
            app.client_id,
            app.secret,
            self.adapter.request_token_url,
            self.adapter.access_token_url,
            callback_url,
            parameters=parameters,
            provider=provider,
        )
        return client


class PocketOAuthCallbackView(OAuthCallbackView):
    def _get_client(self, request, callback_url):
        provider = self.adapter.get_provider()
        app = provider.app
        scope = " ".join(provider.get_scope(request))
        parameters = {}
        if scope:
            parameters["scope"] = scope
        client = PocketOAuthClient(
            request,
            app.client_id,
            app.secret,
            self.adapter.request_token_url,
            self.adapter.access_token_url,
            callback_url,
            parameters=parameters,
            provider=provider,
        )
        return client


oauth_login = PocketOAuthLoginView.adapter_view(PocketOAuthAdapter)
oauth_callback = PocketOAuthCallbackView.adapter_view(PocketOAuthAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\pocket\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\questrade\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import QuestradeProvider


urlpatterns = default_urlpatterns(QuestradeProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\questrade\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\questrade\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import QuestradeProvider


class QuestradeOAuth2Adapter(OAuth2Adapter):
    provider_id = QuestradeProvider.id
    access_token_url = "https://login.questrade.com/oauth2/token"
    authorize_url = "https://login.questrade.com/oauth2/authorize"
    supports_state = False

    def complete_login(self, request, app, token, **kwargs):
        api_server = kwargs.get("response", {}).get(
            "api_server", "https://api01.iq.questrade.com/"
        )
        resp = requests.get(
            "{}v1/accounts".format(api_server),
            headers={"Authorization": "Bearer {}".format(token.token)},
        )
        resp.raise_for_status()
        data = resp.json()
        data.update(kwargs)
        return self.get_provider().sociallogin_from_response(request, data)


oauth2_login = OAuth2LoginView.adapter_view(QuestradeOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(QuestradeOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\questrade\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\quickbooks\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\quickbooks\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\quickbooks\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import QuickBooksOAuth2Provider


urlpatterns = default_urlpatterns(QuickBooksOAuth2Provider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\quickbooks\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\quickbooks\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import QuickBooksOAuth2Provider


class QuickBooksOAuth2Adapter(OAuth2Adapter):
    provider_id = QuickBooksOAuth2Provider.id
    access_token_url = "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer"
    authorize_url = "https://appcenter.intuit.com/connect/oauth2"
    profile_test = "https://sandbox-accounts.platform.intuit.com/v1/openid_connect/userinfo"  # NOQA
    profile_url = "https://accounts.platform.intuit.com/v1/openid_connect/userinfo"
    profile_url_method = "GET"
    access_token_method = "POST"

    def complete_login(self, request, app, token, **kwargs):
        realm_id = request.GET.get("realmId")
        extra_data = self.get_user_info(token)
        if realm_id:
            extra_data["realmId"] = realm_id
        return self.get_provider().sociallogin_from_response(request, extra_data)

    def get_user_info(self, token):
        auth_header = "Bearer " + token.token
        headers = {
            "Accept": "application/json",
            "Authorization": auth_header,
            "accept": "application/json",
        }
        is_sandbox = self.get_provider().get_settings().get("SANDBOX", False)
        url = self.profile_test if is_sandbox else self.profile_url
        resp = requests.get(url, headers=headers)
        resp.raise_for_status()
        return resp.json()


oauth2_login = OAuth2LoginView.adapter_view(QuickBooksOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(QuickBooksOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\quickbooks\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\reddit\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import RedditProvider


urlpatterns = default_urlpatterns(RedditProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\reddit\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\reddit\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import RedditProvider


class RedditAdapter(OAuth2Adapter):
    provider_id = RedditProvider.id
    access_token_url = "https://www.reddit.com/api/v1/access_token"
    authorize_url = "https://www.reddit.com/api/v1/authorize"
    profile_url = "https://oauth.reddit.com/api/v1/me"
    basic_auth = True

    settings = app_settings.PROVIDERS.get(provider_id, {})
    # Allow custom User Agent to comply with reddit API limits
    headers = {"User-Agent": settings.get("USER_AGENT", "django-allauth-header")}

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "bearer " + token.token}
        headers.update(self.headers)
        extra_data = requests.get(self.profile_url, headers=headers)

        # This only here because of weird response from the test suite
        if isinstance(extra_data, list):
            extra_data = extra_data[0]

        return self.get_provider().sociallogin_from_response(request, extra_data.json())


oauth2_login = OAuth2LoginView.adapter_view(RedditAdapter)
oauth2_callback = OAuth2CallbackView.adapter_view(RedditAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\reddit\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\robinhood\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import RobinhoodProvider


urlpatterns = default_urlpatterns(RobinhoodProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\robinhood\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\robinhood\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import RobinhoodProvider


class RobinhoodOAuth2Adapter(OAuth2Adapter):
    provider_id = RobinhoodProvider.id

    @property
    def authorize_url(self):
        return "https://www.robinhood.com/oauth2/authorize/"

    @property
    def access_token_url(self):
        return "https://api.robinhood.com/oauth2/token/"

    @property
    def profile_url(self):
        return "https://api.robinhood.com/user/id/"

    def complete_login(self, request, app, token, **kwargs):
        response = requests.get(
            self.profile_url,
            headers={"Authorization": "Bearer %s" % token.token},
        )
        extra_data = response.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(RobinhoodOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(RobinhoodOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\robinhood\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\salesforce\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import SalesforceProvider


urlpatterns = default_urlpatterns(SalesforceProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\salesforce\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\salesforce\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import SalesforceProvider


class SalesforceOAuth2Adapter(OAuth2Adapter):
    provider_id = SalesforceProvider.id

    @property
    def base_url(self):
        return self.get_provider().app.key

    @property
    def authorize_url(self):
        return "{}/services/oauth2/authorize".format(self.base_url)

    @property
    def access_token_url(self):
        return "{}/services/oauth2/token".format(self.base_url)

    @property
    def userinfo_url(self):
        return "{}/services/oauth2/userinfo".format(self.base_url)

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(self.userinfo_url, params={"oauth_token": token})
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(SalesforceOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(SalesforceOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\salesforce\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\saml\urls.py ---

from django.urls import include, path, re_path

from . import views


urlpatterns = [
    re_path(
        r"^saml/(?P<organization_slug>[^/]+)/",
        include(
            [
                path(
                    "acs/",
                    views.acs,
                    name="saml_acs",
                ),
                path(
                    "acs/finish/",
                    views.finish_acs,
                    name="saml_finish_acs",
                ),
                path(
                    "sls/",
                    views.sls,
                    name="saml_sls",
                ),
                path(
                    "metadata/",
                    views.metadata,
                    name="saml_metadata",
                ),
                path(
                    "login/",
                    views.login,
                    name="saml_login",
                ),
            ]
        ),
    )
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\saml\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\saml\views.py ---

import binascii
import logging

from django.http import HttpResponse, HttpResponseRedirect, JsonResponse
from django.urls import reverse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from onelogin.saml2.auth import OneLogin_Saml2_Auth, OneLogin_Saml2_Settings

from allauth.account.adapter import get_adapter as get_account_adapter
from allauth.socialaccount.helpers import (
    complete_social_login,
    render_authentication_error,
)
from allauth.socialaccount.models import SocialLogin
from allauth.socialaccount.providers.base.constants import (
    AuthError,
    AuthProcess,
)
from allauth.socialaccount.sessions import LoginSession

from .utils import build_saml_config, get_app_or_404, prepare_django_request


logger = logging.getLogger(__name__)


class SAMLViewMixin:
    def build_auth(self, provider, organization_slug):
        req = prepare_django_request(self.request)
        config = build_saml_config(
            self.request, provider.app.settings, organization_slug
        )
        auth = OneLogin_Saml2_Auth(req, config)
        return auth

    def get_app(self, organization_slug):
        app = get_app_or_404(self.request, organization_slug)
        return app

    def get_provider(self, organization_slug):
        app = self.get_app(organization_slug)
        return app.get_provider(self.request)


@method_decorator(csrf_exempt, name="dispatch")
class ACSView(SAMLViewMixin, View):
    def dispatch(self, request, organization_slug):
        provider = self.get_provider(organization_slug)
        auth = self.build_auth(provider, organization_slug)
        try:
            auth.process_response()
        except binascii.Error:
            errors = ["invalid_response"]
        else:
            errors = auth.get_errors()
        if errors:
            # e.g. ['invalid_response']
            logger.error(
                "Error processing SAML response: %s: %s"
                % (", ".join(errors), auth.get_last_error_reason())
            )
            return render_authentication_error(
                request,
                provider.id,
                extra_context={
                    "saml_errors": errors,
                    "saml_last_error_reason": auth.get_last_error_reason(),
                },
            )
        if not auth.is_authenticated():
            return render_authentication_error(
                request, provider.id, error=AuthError.CANCELLED
            )

        relay_state = request.POST.get("RelayState")
        login = provider.sociallogin_from_response(request, auth)
        if relay_state == request.build_absolute_uri(
            reverse("socialaccount_connections")
        ):
            login.state["process"] = AuthProcess.CONNECT

        acs_session = LoginSession(request, "saml_acs_session", "saml-acs-session")
        acs_session.store["login"] = login.serialize()
        url = reverse(
            "saml_finish_acs",
            kwargs={"organization_slug": organization_slug},
        )
        response = HttpResponseRedirect(url)
        acs_session.save(response)
        return response


acs = ACSView.as_view()


class FinishACSView(SAMLViewMixin, View):
    def dispatch(self, request, organization_slug):
        provider = self.get_provider(organization_slug)
        acs_session = LoginSession(request, "saml_acs_session", "saml-acs-session")
        serialized_login = acs_session.store.get("login")
        if not serialized_login:
            logger.error("Unable to finish login, SAML ACS session missing")
            return render_authentication_error(request, provider.id)
        acs_session.delete()
        login = SocialLogin.deserialize(serialized_login)
        return complete_social_login(request, login)


finish_acs = FinishACSView.as_view()


@method_decorator(csrf_exempt, name="dispatch")
class SLSView(SAMLViewMixin, View):
    def dispatch(self, request, organization_slug):
        provider = self.get_provider(organization_slug)
        auth = self.build_auth(provider, organization_slug)
        should_logout = request.user.is_authenticated
        account_adapter = get_account_adapter(request)

        def force_logout():
            account_adapter.logout(request)

        redirect_to = auth.process_slo(
            delete_session_cb=force_logout, keep_local_session=not should_logout
        )
        if not redirect_to:
            redirect_to = account_adapter.get_logout_redirect_url(request)
        return HttpResponseRedirect(redirect_to)


sls = SLSView.as_view()


class MetadataView(SAMLViewMixin, View):
    def dispatch(self, request, organization_slug):
        provider = self.get_provider(organization_slug)
        config = build_saml_config(
            self.request, provider.app.settings, organization_slug
        )
        saml_settings = OneLogin_Saml2_Settings(
            settings=config, sp_validation_only=True
        )
        metadata = saml_settings.get_sp_metadata()
        errors = saml_settings.validate_metadata(metadata)

        if len(errors) > 0:
            resp = JsonResponse({"errors": errors})
            resp.status_code = 500
            return resp

        return HttpResponse(content=metadata, content_type="text/xml")


metadata = MetadataView.as_view()


class LoginView(SAMLViewMixin, View):
    def dispatch(self, request, organization_slug):
        provider = self.get_provider(organization_slug)
        auth = self.build_auth(provider, organization_slug)
        process = self.request.GET.get("process")
        return_to = None
        if process == AuthProcess.CONNECT:
            return_to = request.build_absolute_uri(reverse("socialaccount_connections"))
        redirect = auth.login(return_to=return_to)
        return HttpResponseRedirect(redirect)


login = LoginView.as_view()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\saml\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\sharefile\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import ShareFileProvider


urlpatterns = default_urlpatterns(ShareFileProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\sharefile\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\sharefile\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import ShareFileProvider


class ShareFileOAuth2Adapter(OAuth2Adapter):
    provider_id = ShareFileProvider.id
    settings = app_settings.PROVIDERS.get(provider_id, {})
    subdomain = settings.get("SUBDOMAIN", "secure")
    apicp = settings.get("APICP", "sharefile.com")

    provider_default_url = settings.get("DEFAULT_URL", "https://secure.sharefile.com")
    provider_default_api_url = "https://{}.sf-api.com".format(subdomain)
    provider_api_version = "v3"

    access_token_url = "https://{}.{}/oauth/token".format(subdomain, apicp)
    refresh_token_url = "https://{}.{}/oauth/token".format(subdomain, apicp)
    authorize_url = "{}/oauth/authorize".format(provider_default_url)
    profile_url = "{}/sf/{}/Users".format(
        provider_default_api_url, provider_api_version
    )

    def complete_login(self, request, app, token, response):
        headers = {"Authorization": "Bearer {}".format(token.token)}
        extra_data = requests.get(self.profile_url, headers=headers).json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(ShareFileOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(ShareFileOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\sharefile\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\shopify\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import ShopifyProvider


urlpatterns = default_urlpatterns(ShopifyProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\shopify\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\shopify\views.py ---

import re
import requests

from django.conf import settings
from django.http import HttpResponse, HttpResponseBadRequest

from allauth.exceptions import ImmediateHttpResponse
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import ShopifyProvider


class ShopifyOAuth2Adapter(OAuth2Adapter):
    provider_id = ShopifyProvider.id
    supports_state = False
    scope_delimiter = ","

    def _shop_domain(self):
        shop = self.request.GET.get("shop", "")
        if "." not in shop:
            shop = "{}.myshopify.com".format(shop)
        # Ensure the provided hostname parameter is a valid hostname,
        # ends with myshopify.com, and does not contain characters
        # other than letters (a-z), numbers (0-9), dots, and hyphens.
        if not re.match(r"^[a-z0-9-]+\.myshopify\.com$", shop):
            raise ImmediateHttpResponse(
                HttpResponseBadRequest("Invalid `shop` parameter")
            )
        return shop

    def _shop_url(self, path):
        shop = self._shop_domain()
        return "https://{}{}".format(shop, path)

    @property
    def access_token_url(self):
        return self._shop_url("/admin/oauth/access_token")

    @property
    def authorize_url(self):
        return self._shop_url("/admin/oauth/authorize")

    @property
    def profile_url(self):
        return self._shop_url("/admin/shop.json")

    def complete_login(self, request, app, token, **kwargs):
        headers = {"X-Shopify-Access-Token": "{token}".format(token=token.token)}
        response = requests.get(self.profile_url, headers=headers)
        extra_data = response.json()
        associated_user = kwargs["response"].get("associated_user")
        if associated_user:
            extra_data["associated_user"] = associated_user
        return self.get_provider().sociallogin_from_response(request, extra_data)


class ShopifyOAuth2LoginView(OAuth2LoginView):
    def dispatch(self, request, *args, **kwargs):
        is_embedded = (
            getattr(settings, "SOCIALACCOUNT_PROVIDERS", {})
            .get("shopify", {})
            .get("IS_EMBEDDED", False)
        )
        if is_embedded:
            # TODO: This bypasses LOGIN_ON_GET, but:
            #
            #     The Embedded App SDK (EASDK) and backwards compatibility layer
            #     are being removed from Shopify on January 1, 2022.
            #
            # So this needs to be dropped/revisitted anyway.
            response = super().login(request, *args, **kwargs)
            """
            Shopify embedded apps (that run within an iFrame) require a JS
            (not server) redirect for starting the oauth2 process.

            See Also:
            https://help.shopify.com/api/sdks/embedded-app-sdk/getting-started#oauth
            """
            js = "".join(
                (
                    "<!DOCTYPE html><html><head>" '<script type="text/javascript">',
                    'window.top.location.href = "{url}";'.format(url=response.url),
                    "</script></head><body></body></html>",
                )
            )
            response = HttpResponse(content=js)
            # Because this view will be within shopify's iframe
            response.xframe_options_exempt = True
            return response
        return super().dispatch(request, *args, **kwargs)


oauth2_login = ShopifyOAuth2LoginView.adapter_view(ShopifyOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(ShopifyOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\shopify\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\slack\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\slack\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\slack\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import SlackProvider


urlpatterns = default_urlpatterns(SlackProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\slack\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\slack\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.client import OAuth2Error
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import SlackProvider


class SlackOAuth2Adapter(OAuth2Adapter):
    provider_id = SlackProvider.id

    access_token_url = "https://slack.com/api/oauth.access"
    authorize_url = "https://slack.com/oauth/authorize"
    identity_url = "https://slack.com/api/users.identity"

    def complete_login(self, request, app, token, **kwargs):
        extra_data = self.get_data(token.token)
        return self.get_provider().sociallogin_from_response(request, extra_data)

    def get_data(self, token):
        # Verify the user first
        hed = {"Authorization": "Bearer " + token}
        resp = requests.get(self.identity_url, headers=hed)
        resp = resp.json()

        if not resp.get("ok"):
            raise OAuth2Error()

        return resp


oauth2_login = OAuth2LoginView.adapter_view(SlackOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(SlackOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\slack\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\snapchat\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\snapchat\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\snapchat\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import SnapchatProvider


urlpatterns = default_urlpatterns(SnapchatProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\snapchat\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\snapchat\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.client import OAuth2Error
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import Scope, SnapchatProvider


class SnapchatOAuth2Adapter(OAuth2Adapter):
    provider_id = SnapchatProvider.id

    access_token_url = "https://accounts.snapchat.com/accounts/oauth2/token"
    authorize_url = "https://accounts.snapchat.com/accounts/oauth2/auth"
    identity_url = "https://api.snapkit.com/v1/me"

    def complete_login(self, request, app, token, **kwargs):
        extra_data = self.get_data(token.token)
        return self.get_provider().sociallogin_from_response(request, extra_data)

    def get_data(self, token):
        provider_id = SnapchatProvider.id
        settings = app_settings.PROVIDERS.get(provider_id, {})
        provider_scope = settings.get(
            "SCOPE",
            "['https://auth.snapchat.com/oauth2/api/user.external_id', 'https://auth.snapchat.com/oauth2/api/user.display_name']",
        )

        hed = {
            "Authorization": "Bearer " + token,
            "Content-Type": "application/json;charset=UTF-8",
        }
        if Scope.BITMOJI in provider_scope:
            data = {"query": "{ me { externalId displayName bitmoji { avatar id } } }"}
        else:
            data = {"query": "{ me { externalId displayName } }"}
        resp = requests.post(self.identity_url, headers=hed, json=data)
        resp.raise_for_status()
        resp = resp.json()

        if not resp.get("data"):
            raise OAuth2Error()

        return resp


oauth2_login = OAuth2LoginView.adapter_view(SnapchatOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(SnapchatOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\snapchat\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\soundcloud\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import SoundCloudProvider


urlpatterns = default_urlpatterns(SoundCloudProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\soundcloud\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\soundcloud\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import SoundCloudProvider


class SoundCloudOAuth2Adapter(OAuth2Adapter):
    provider_id = SoundCloudProvider.id
    access_token_url = "https://api.soundcloud.com/oauth2/token"
    authorize_url = "https://soundcloud.com/connect"
    profile_url = "https://api.soundcloud.com/me.json"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(self.profile_url, params={"oauth_token": token.token})
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(SoundCloudOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(SoundCloudOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\soundcloud\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\spotify\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import SpotifyOAuth2Provider


urlpatterns = default_urlpatterns(SpotifyOAuth2Provider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\spotify\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\spotify\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import SpotifyOAuth2Provider


class SpotifyOAuth2Adapter(OAuth2Adapter):
    provider_id = SpotifyOAuth2Provider.id
    access_token_url = "https://accounts.spotify.com/api/token"
    authorize_url = "https://accounts.spotify.com/authorize"
    profile_url = "https://api.spotify.com/v1/me"

    def complete_login(self, request, app, token, **kwargs):
        extra_data = requests.get(
            self.profile_url, params={"access_token": token.token}
        )

        return self.get_provider().sociallogin_from_response(request, extra_data.json())


oauth_login = OAuth2LoginView.adapter_view(SpotifyOAuth2Adapter)
oauth_callback = OAuth2CallbackView.adapter_view(SpotifyOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\spotify\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\stackexchange\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import StackExchangeProvider


urlpatterns = default_urlpatterns(StackExchangeProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\stackexchange\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\stackexchange\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import StackExchangeProvider


class StackExchangeOAuth2Adapter(OAuth2Adapter):
    provider_id = StackExchangeProvider.id
    access_token_url = "https://stackexchange.com/oauth/access_token"
    authorize_url = "https://stackexchange.com/oauth"
    profile_url = "https://api.stackexchange.com/2.1/me"

    def complete_login(self, request, app, token, **kwargs):
        provider = self.get_provider()
        site = provider.get_site()
        resp = requests.get(
            self.profile_url,
            params={"access_token": token.token, "key": app.key, "site": site},
        )
        resp.raise_for_status()
        extra_data = resp.json()["items"][0]
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(StackExchangeOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(StackExchangeOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\stackexchange\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\steam\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\steam\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\steam\urls.py ---

from django.urls import path

from . import views


urlpatterns = [
    path("steam/login/", views.steam_login, name="steam_login"),
    path("steam/callback/", views.steam_callback, name="steam_callback"),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\steam\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\steam\views.py ---

"""
OpenID Adapter for Steam

The Steam login API is simple OpenID but requires extra API calls
for basic resources such as usernames.

Resources:

* Steam Web API Documentation
    https://steamcommunity.com/dev

* Steam Partner API documentation
    https://partner.steamgames.com/doc/features/auth#website
"""
from django.urls import reverse

from allauth.socialaccount.providers.openid.views import (
    OpenIDCallbackView,
    OpenIDLoginView,
)

from .provider import SteamOpenIDProvider


STEAM_OPENID_URL = "https://steamcommunity.com/openid"


class SteamOpenIDLoginView(OpenIDLoginView):
    provider = SteamOpenIDProvider

    def get_form(self):
        items = dict(list(self.request.GET.items()) + list(self.request.POST.items()))
        items["openid"] = STEAM_OPENID_URL
        return self.form_class(items)

    def get_callback_url(self):
        return reverse(steam_callback)


class SteamOpenIDCallbackView(OpenIDCallbackView):
    provider = SteamOpenIDProvider


steam_login = SteamOpenIDLoginView.as_view()
steam_callback = SteamOpenIDCallbackView.as_view()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\steam\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\stocktwits\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import StocktwitsProvider


urlpatterns = default_urlpatterns(StocktwitsProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\stocktwits\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\stocktwits\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import StocktwitsProvider


class StocktwitsOAuth2Adapter(OAuth2Adapter):
    provider_id = StocktwitsProvider.id
    access_token_url = "https://api.stocktwits.com/api/2/oauth/token"
    authorize_url = "https://api.stocktwits.com/api/2/oauth/authorize"
    profile_url = "https://api.stocktwits.com/api/2/streams/user/{user}.json"
    scope_delimiter = ","

    def complete_login(self, request, app, token, **kwargs):
        user_id = kwargs.get("response").get("user_id")
        resp = requests.get(self.profile_url.format(user=user_id))
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(StocktwitsOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(StocktwitsOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\stocktwits\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\strava\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import StravaProvider


urlpatterns = default_urlpatterns(StravaProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\strava\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\strava\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import StravaProvider


class StravaOauth2Adapter(OAuth2Adapter):
    provider_id = StravaProvider.id
    access_token_url = "https://www.strava.com/oauth/token"
    authorize_url = "https://www.strava.com/oauth/authorize"
    profile_url = "https://www.strava.com/api/v3/athlete"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(StravaOauth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(StravaOauth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\strava\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\stripe\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import StripeProvider


urlpatterns = default_urlpatterns(StripeProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\stripe\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\stripe\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import StripeProvider


class StripeOAuth2Adapter(OAuth2Adapter):
    provider_id = StripeProvider.id
    access_token_url = "https://connect.stripe.com/oauth/token"
    authorize_url = "https://connect.stripe.com/oauth/authorize"
    profile_url = "https://api.stripe.com/v1/accounts/%s"

    def complete_login(self, request, app, token, response, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        resp = requests.get(
            self.profile_url % response.get("stripe_user_id"), headers=headers
        )
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(StripeOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(StripeOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\stripe\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\telegram\urls.py ---

from django.urls import path

from . import views


urlpatterns = [
    path("telegram/login/", views.login, name="telegram_login"),
    path("telegram/login/callback/", views.callback, name="telegram_callback"),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\telegram\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\telegram\views.py ---

import base64
import hashlib
import hmac
import json
import time

from django.http import HttpResponseRedirect
from django.shortcuts import render
from django.urls import reverse
from django.utils.decorators import method_decorator
from django.utils.http import urlencode
from django.views import View
from django.views.decorators.csrf import csrf_exempt

from allauth.socialaccount.adapter import get_adapter
from allauth.socialaccount.helpers import (
    complete_social_login,
    render_authentication_error,
)

from .provider import TelegramProvider


class LoginView(View):
    def dispatch(self, request):
        provider = get_adapter(request).get_provider(request, TelegramProvider.id)
        return_to = request.build_absolute_uri(
            reverse("telegram_callback") + "?" + request.GET.urlencode()
        )

        url = "https://oauth.telegram.org/auth?" + urlencode(
            {
                "origin": request.build_absolute_uri("/"),
                "bot_id": provider.app.client_id,
                "request_access": "write",
                "embed": "0",
                "return_to": return_to,
            }
        )
        return HttpResponseRedirect(url)


login = LoginView.as_view()


@method_decorator(csrf_exempt, name="dispatch")
class CallbackView(View):
    def get(self, request):
        return render(request, "telegram/callback.html")

    def post(self, request):
        result = request.POST.get("tgAuthResult")
        padding = "=" * (4 - (len(result) % 4))
        data = json.loads(base64.b64decode(result + padding))
        adapter = get_adapter(request)
        provider = adapter.get_provider(request, TelegramProvider.id)
        hash = data.pop("hash")
        payload = "\n".join(sorted(["{}={}".format(k, v) for k, v in data.items()]))
        token = provider.app.secret
        token_sha256 = hashlib.sha256(token.encode()).digest()
        expected_hash = hmac.new(
            token_sha256, payload.encode(), hashlib.sha256
        ).hexdigest()
        auth_date = int(data.pop("auth_date"))
        auth_date_validity = provider.get_auth_date_validity()
        if hash != expected_hash or time.time() - auth_date > auth_date_validity:
            return render_authentication_error(
                request, provider_id=provider.id, extra_context={"response": data}
            )

        login = provider.sociallogin_from_response(request, data)
        process = request.GET.get("process")
        if process:
            login.state["process"] = process
        return complete_social_login(request, login)


callback = CallbackView.as_view()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\telegram\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\trainingpeaks\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import TrainingPeaksProvider


urlpatterns = default_urlpatterns(TrainingPeaksProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\trainingpeaks\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\trainingpeaks\views.py ---

import requests

from allauth.socialaccount import app_settings
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import TrainingPeaksProvider


class TrainingPeaksOAuth2Adapter(OAuth2Adapter):
    # https://github.com/TrainingPeaks/PartnersAPI/wiki/OAuth
    provider_id = TrainingPeaksProvider.id

    def get_settings(self):
        """Provider settings"""
        return app_settings.PROVIDERS.get(self.provider_id, {})

    def get_hostname(self):
        """Return hostname depending on sandbox setting"""
        settings = self.get_settings()
        if settings.get("USE_PRODUCTION"):
            return "trainingpeaks.com"
        return "sandbox.trainingpeaks.com"

    @property
    def access_token_url(self):
        return "https://oauth." + self.get_hostname() + "/oauth/token"

    @property
    def authorize_url(self):
        return "https://oauth." + self.get_hostname() + "/OAuth/Authorize"

    @property
    def profile_url(self):
        return "https://api." + self.get_hostname() + "/v1/athlete/profile"

    @property
    def api_hostname(self):
        """Return https://api.hostname.tld"""
        return "https://api." + self.get_hostname()

    # https://oauth.sandbox.trainingpeaks.com/oauth/deauthorize

    scope_delimiter = " "

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        response = requests.get(self.profile_url, headers=headers)
        response.raise_for_status()
        extra_data = response.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(TrainingPeaksOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(TrainingPeaksOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\trainingpeaks\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\trello\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import TrelloProvider


urlpatterns = default_urlpatterns(TrelloProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\trello\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\trello\views.py ---

import requests

from django.utils.http import urlencode

from allauth.socialaccount.providers.oauth.views import (
    OAuthAdapter,
    OAuthCallbackView,
    OAuthLoginView,
)

from .provider import TrelloProvider


class TrelloOAuthAdapter(OAuthAdapter):
    provider_id = TrelloProvider.id
    request_token_url = "https://trello.com/1/OAuthGetRequestToken"
    authorize_url = "https://trello.com/1/OAuthAuthorizeToken"
    access_token_url = "https://trello.com/1/OAuthGetAccessToken"

    def complete_login(self, request, app, token, response):
        # we need to get the member id and the other information
        info_url = "{base}?{query}".format(
            base="https://api.trello.com/1/members/me",
            query=urlencode({"key": app.key, "token": response.get("oauth_token")}),
        )
        resp = requests.get(info_url)
        resp.raise_for_status()
        extra_data = resp.json()
        result = self.get_provider().sociallogin_from_response(request, extra_data)
        return result


oauth_login = OAuthLoginView.adapter_view(TrelloOAuthAdapter)
oauth_callback = OAuthCallbackView.adapter_view(TrelloOAuthAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\trello\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\tumblr\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import TumblrProvider


urlpatterns = default_urlpatterns(TumblrProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\tumblr\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\tumblr\views.py ---

import json

from allauth.socialaccount.providers.oauth.client import OAuth
from allauth.socialaccount.providers.oauth.views import (
    OAuthAdapter,
    OAuthCallbackView,
    OAuthLoginView,
)

from .provider import TumblrProvider


class TumblrAPI(OAuth):
    url = "http://api.tumblr.com/v2/user/info"

    def get_user_info(self):
        data = json.loads(self.query(self.url))
        return data["response"]["user"]


class TumblrOAuthAdapter(OAuthAdapter):
    provider_id = TumblrProvider.id
    request_token_url = "https://www.tumblr.com/oauth/request_token"
    access_token_url = "https://www.tumblr.com/oauth/access_token"
    authorize_url = "https://www.tumblr.com/oauth/authorize"

    def complete_login(self, request, app, token, response):
        client = TumblrAPI(request, app.client_id, app.secret, self.request_token_url)
        extra_data = client.get_user_info()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth_login = OAuthLoginView.adapter_view(TumblrOAuthAdapter)
oauth_callback = OAuthCallbackView.adapter_view(TumblrOAuthAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\tumblr\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twentythreeandme\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import TwentyThreeAndMeProvider


urlpatterns = default_urlpatterns(TwentyThreeAndMeProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twentythreeandme\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twentythreeandme\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import TwentyThreeAndMeProvider


class TwentyTreeAndMeOAuth2Adapter(OAuth2Adapter):
    provider_id = TwentyThreeAndMeProvider.id
    access_token_url = "https://api.23andme.com/token"
    authorize_url = "https://api.23andme.com/authorize"
    profile_url = "https://api.23andme.com/1/user/"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(TwentyTreeAndMeOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(TwentyTreeAndMeOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twentythreeandme\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twitch\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import TwitchProvider


urlpatterns = default_urlpatterns(TwitchProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twitch\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twitch\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.client import OAuth2Error
from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import TwitchProvider


class TwitchOAuth2Adapter(OAuth2Adapter):
    provider_id = TwitchProvider.id
    access_token_url = "https://id.twitch.tv/oauth2/token"
    authorize_url = "https://id.twitch.tv/oauth2/authorize"
    profile_url = "https://api.twitch.tv/helix/users"

    def complete_login(self, request, app, token, **kwargs):
        headers = {
            "Authorization": "Bearer {}".format(token.token),
            "Client-ID": app.client_id,
        }
        response = requests.get(self.profile_url, headers=headers)

        data = response.json()
        if response.status_code >= 400:
            error = data.get("error", "")
            message = data.get("message", "")
            raise OAuth2Error("Twitch API Error: %s (%s)" % (error, message))

        try:
            user_info = data.get("data", [])[0]
        except IndexError:
            raise OAuth2Error("Invalid data from Twitch API: %s" % (data))

        if "id" not in user_info:
            raise OAuth2Error("Invalid data from Twitch API: %s" % (user_info))

        return self.get_provider().sociallogin_from_response(request, user_info)


oauth2_login = OAuth2LoginView.adapter_view(TwitchOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(TwitchOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twitch\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twitter\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import TwitterProvider


urlpatterns = default_urlpatterns(TwitterProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twitter\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twitter\views.py ---

import json

from allauth.socialaccount.app_settings import QUERY_EMAIL
from allauth.socialaccount.providers.oauth.client import OAuth
from allauth.socialaccount.providers.oauth.views import (
    OAuthAdapter,
    OAuthCallbackView,
    OAuthLoginView,
)

from .provider import TwitterProvider


class TwitterAPI(OAuth):
    """
    Verifying twitter credentials
    """

    _base_url = "https://api.twitter.com/1.1/account/verify_credentials.json"
    url = _base_url + "?include_email=true" if QUERY_EMAIL else _base_url

    def get_user_info(self):
        user = json.loads(self.query(self.url))
        return user


class TwitterOAuthAdapter(OAuthAdapter):
    provider_id = TwitterProvider.id
    request_token_url = "https://api.twitter.com/oauth/request_token"
    access_token_url = "https://api.twitter.com/oauth/access_token"
    # Issue #42 -- this one authenticates over and over again...
    # authorize_url = 'https://api.twitter.com/oauth/authorize'
    authorize_url = "https://api.twitter.com/oauth/authenticate"

    def complete_login(self, request, app, token, response):
        client = TwitterAPI(request, app.client_id, app.secret, self.request_token_url)
        extra_data = client.get_user_info()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth_login = OAuthLoginView.adapter_view(TwitterOAuthAdapter)
oauth_callback = OAuthCallbackView.adapter_view(TwitterOAuthAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twitter\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twitter_oauth2\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import TwitterOAuth2Provider


urlpatterns = default_urlpatterns(TwitterOAuth2Provider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twitter_oauth2\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twitter_oauth2\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import TwitterOAuth2Provider


class TwitterOAuth2Adapter(OAuth2Adapter):
    provider_id = TwitterOAuth2Provider.id
    access_token_url = "https://api.twitter.com/2/oauth2/token"
    authorize_url = "https://twitter.com/i/oauth2/authorize"
    profile_url = "https://api.twitter.com/2/users/me"
    basic_auth = True

    def complete_login(self, request, app, access_token, **kwargs):
        extra_data = self.get_user_info(access_token)
        return self.get_provider().sociallogin_from_response(request, extra_data)

    def get_user_info(self, token):
        fields = self.get_provider().get_fields()
        headers = {}
        headers.update(self.get_provider().get_settings().get("HEADERS", {}))
        headers["Authorization"] = " ".join(["Bearer", token.token])

        resp = requests.get(
            url=self.profile_url,
            params={"user.fields": ",".join(fields)},
            headers=headers,
        )
        resp.raise_for_status()
        data = resp.json()["data"]
        return data


oauth2_login = OAuth2LoginView.adapter_view(TwitterOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(TwitterOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\twitter_oauth2\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\untappd\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import UntappdProvider


urlpatterns = default_urlpatterns(UntappdProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\untappd\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\untappd\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .client import UntappdOAuth2Client
from .provider import UntappdProvider


class UntappdOAuth2Adapter(OAuth2Adapter):
    client_class = UntappdOAuth2Client
    provider_id = UntappdProvider.id
    access_token_url = "https://untappd.com/oauth/authorize/"
    access_token_method = "GET"
    authorize_url = "https://untappd.com/oauth/authenticate/"
    user_info_url = "https://api.untappd.com/v4/user/info/"
    supports_state = False

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(self.user_info_url, params={"access_token": token.token})
        extra_data = resp.json()
        # TODO: get and store the email from the user info json
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(UntappdOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(UntappdOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\untappd\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vimeo\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import VimeoProvider


urlpatterns = default_urlpatterns(VimeoProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vimeo\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vimeo\views.py ---

import json

from allauth.socialaccount.providers.oauth.client import OAuth
from allauth.socialaccount.providers.oauth.views import (
    OAuthAdapter,
    OAuthCallbackView,
    OAuthLoginView,
)

from .provider import VimeoProvider


class VimeoAPI(OAuth):
    url = "http://vimeo.com/api/rest/v2?method=vimeo.people.getInfo"

    def get_user_info(self):
        url = self.url
        data = json.loads(self.query(url, params=dict(format="json")))
        return data["person"]


class VimeoOAuthAdapter(OAuthAdapter):
    provider_id = VimeoProvider.id
    request_token_url = "https://vimeo.com/oauth/request_token"
    access_token_url = "https://vimeo.com/oauth/access_token"
    authorize_url = "https://vimeo.com/oauth/authorize"

    def complete_login(self, request, app, token, response):
        client = VimeoAPI(request, app.client_id, app.secret, self.request_token_url)
        extra_data = client.get_user_info()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth_login = OAuthLoginView.adapter_view(VimeoOAuthAdapter)
oauth_callback = OAuthCallbackView.adapter_view(VimeoOAuthAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vimeo\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vimeo_oauth2\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vimeo_oauth2\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vimeo_oauth2\urls.py ---

"""URLs for Patreon Provider"""

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import VimeoOAuth2Provider


urlpatterns = default_urlpatterns(VimeoOAuth2Provider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vimeo_oauth2\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vimeo_oauth2\views.py ---

"""
Views for PatreonProvider
https://www.patreon.com/platform/documentation/oauth
"""

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import VimeoOAuth2Provider


class VimeoOAuth2Adapter(OAuth2Adapter):
    provider_id = VimeoOAuth2Provider.id
    access_token_url = "https://api.vimeo.com/oauth/access_token"
    authorize_url = "https://api.vimeo.com/oauth/authorize"
    profile_url = "https://api.vimeo.com/me/"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.profile_url,
            headers={"Authorization": "Bearer " + token.token},
        )
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(VimeoOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(VimeoOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vimeo_oauth2\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vk\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import VKProvider


urlpatterns = default_urlpatterns(VKProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vk\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vk\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import VKProvider


USER_FIELDS = [
    "first_name",
    "last_name",
    "nickname",
    "screen_name",
    "sex",
    "bdate",
    "city",
    "country",
    "timezone",
    "photo",
    "photo_medium",
    "photo_big",
    "photo_max_orig",
    "has_mobile",
    "contacts",
    "education",
    "online",
    "counters",
    "relation",
    "last_seen",
    "activity",
    "universities",
]


class VKOAuth2Adapter(OAuth2Adapter):
    provider_id = VKProvider.id
    access_token_url = "https://oauth.vk.com/access_token"
    authorize_url = "https://oauth.vk.com/authorize"
    profile_url = "https://api.vk.com/method/users.get"

    def complete_login(self, request, app, token, **kwargs):
        uid = kwargs["response"].get("user_id")
        params = {
            "v": "5.95",
            "access_token": token.token,
            "fields": ",".join(USER_FIELDS),
        }
        if uid:
            params["user_ids"] = uid
        resp = requests.get(self.profile_url, params=params)
        resp.raise_for_status()
        extra_data = resp.json()["response"][0]
        email = kwargs["response"].get("email")
        if email:
            extra_data["email"] = email
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(VKOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(VKOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\vk\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\wahoo\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import WahooProvider


urlpatterns = default_urlpatterns(WahooProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\wahoo\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\wahoo\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import WahooProvider


class WahooOauth2Adapter(OAuth2Adapter):
    provider_id = WahooProvider.id
    access_token_url = "https://api.wahooligan.com/oauth/token"
    authorize_url = "https://api.wahooligan.com/oauth/authorize"
    profile_url = "https://api.wahooligan.com/v1/user"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(WahooOauth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(WahooOauth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\wahoo\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\weibo\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import WeiboProvider


urlpatterns = default_urlpatterns(WeiboProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\weibo\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\weibo\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import WeiboProvider


class WeiboOAuth2Adapter(OAuth2Adapter):
    provider_id = WeiboProvider.id
    access_token_url = "https://api.weibo.com/oauth2/access_token"
    authorize_url = "https://api.weibo.com/oauth2/authorize"
    profile_url = "https://api.weibo.com/2/users/show.json"

    def complete_login(self, request, app, token, **kwargs):
        uid = kwargs.get("response", {}).get("uid")
        resp = requests.get(
            self.profile_url, params={"access_token": token.token, "uid": uid}
        )
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(WeiboOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(WeiboOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\weibo\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\weixin\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import WeixinProvider


urlpatterns = default_urlpatterns(WeixinProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\weixin\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\weixin\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .client import WeixinOAuth2Client
from .provider import WeixinProvider


class WeixinOAuth2Adapter(OAuth2Adapter):
    provider_id = WeixinProvider.id
    access_token_url = "https://api.weixin.qq.com/sns/oauth2/access_token"
    profile_url = "https://api.weixin.qq.com/sns/userinfo"
    client_class = WeixinOAuth2Client

    @property
    def authorize_url(self):
        settings = self.get_provider().get_settings()
        url = settings.get(
            "AUTHORIZE_URL", "https://open.weixin.qq.com/connect/qrconnect"
        )
        return url

    def complete_login(self, request, app, token, **kwargs):
        openid = kwargs.get("response", {}).get("openid")
        resp = requests.get(
            self.profile_url,
            params={"access_token": token.token, "openid": openid},
        )
        resp.raise_for_status()
        extra_data = resp.json()
        nickname = extra_data.get("nickname")
        if nickname:
            extra_data["nickname"] = nickname.encode("raw_unicode_escape").decode(
                "utf-8"
            )
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(WeixinOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(WeixinOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\weixin\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\windowslive\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import WindowsLiveProvider


urlpatterns = default_urlpatterns(WindowsLiveProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\windowslive\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\windowslive\views.py ---

from __future__ import unicode_literals

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import WindowsLiveProvider


class WindowsLiveOAuth2Adapter(OAuth2Adapter):
    provider_id = WindowsLiveProvider.id
    access_token_url = "https://login.live.com/oauth20_token.srf"
    authorize_url = "https://login.live.com/oauth20_authorize.srf"
    profile_url = "https://apis.live.net/v5.0/me"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)

        # example of what's returned (in python format):
        # {'first_name': 'James', 'last_name': 'Smith',
        #  'name': 'James Smith', 'locale': 'en_US', 'gender': None,
        #  'emails': {'personal': None, 'account': 'jsmith@example.com',
        #  'business': None, 'preferred': 'jsmith@example.com'},
        #  'link': 'https://profile.live.com/',
        #  'updated_time': '2014-02-07T00:35:27+0000',
        #  'id': '83605e110af6ff98'}

        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(WindowsLiveOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(WindowsLiveOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\windowslive\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\xing\urls.py ---

from allauth.socialaccount.providers.oauth.urls import default_urlpatterns

from .provider import XingProvider


urlpatterns = default_urlpatterns(XingProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\xing\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\xing\views.py ---

import json

from allauth.socialaccount.providers.oauth.client import OAuth
from allauth.socialaccount.providers.oauth.views import (
    OAuthAdapter,
    OAuthCallbackView,
    OAuthLoginView,
)

from .provider import XingProvider


class XingAPI(OAuth):
    url = "https://api.xing.com/v1/users/me.json"

    def get_user_info(self):
        user = json.loads(self.query(self.url))
        return user


class XingOAuthAdapter(OAuthAdapter):
    provider_id = XingProvider.id
    request_token_url = "https://api.xing.com/v1/request_token"
    access_token_url = "https://api.xing.com/v1/access_token"
    authorize_url = "https://www.xing.com/v1/authorize"

    def complete_login(self, request, app, token, response):
        client = XingAPI(request, app.client_id, app.secret, self.request_token_url)
        extra_data = client.get_user_info()["users"][0]
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth_login = OAuthLoginView.adapter_view(XingOAuthAdapter)
oauth_callback = OAuthCallbackView.adapter_view(XingOAuthAdapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\xing\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\yahoo\models.py ---

# Create your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\yahoo\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\yahoo\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import YahooProvider


urlpatterns = default_urlpatterns(YahooProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\yahoo\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\yahoo\views.py ---

from __future__ import unicode_literals

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import YahooProvider


class YahooOAuth2Adapter(OAuth2Adapter):
    provider_id = YahooProvider.id
    access_token_url = "https://api.login.yahoo.com/oauth2/get_token"
    authorize_url = "https://api.login.yahoo.com/oauth2/request_auth"
    profile_url = "https://api.login.yahoo.com/openid/v1/userinfo"

    def complete_login(self, request, app, token, **kwargs):
        headers = {"Authorization": "Bearer {0}".format(token.token)}
        resp = requests.get(self.profile_url, headers=headers)
        resp.raise_for_status()

        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(YahooOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(YahooOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\yahoo\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\yandex\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import YandexProvider


urlpatterns = default_urlpatterns(YandexProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\yandex\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\yandex\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import YandexProvider


class YandexAuth2Adapter(OAuth2Adapter):
    provider_id = YandexProvider.id
    access_token_url = "https://oauth.yandex.ru/token"
    authorize_url = "https://oauth.yandex.com/authorize"
    profile_url = "https://login.yandex.ru/info"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.profile_url,
            params={"format": "json"},
            headers={"Authorization": f"OAuth {token.token}"},
        )
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(YandexAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(YandexAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\yandex\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\ynab\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import YNABProvider


urlpatterns = default_urlpatterns(YNABProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\ynab\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\ynab\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import YNABProvider


class YNABOAuth2Adapter(OAuth2Adapter):
    provider_id = YNABProvider.id
    access_token_url = "https://app.youneedabudget.com/oauth/token"
    authorize_url = "https://app.youneedabudget.com/oauth/authorize"
    profile_url = "https://api.youneedabudget.com/v1/user"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.profile_url,
            headers={"Authorization": "Bearer {}".format(token.token)},
        )
        resp.raise_for_status()
        extra_data = resp.json()
        login = self.get_provider().sociallogin_from_response(request, extra_data)
        return login


oauth2_login = OAuth2LoginView.adapter_view(YNABOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(YNABOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\ynab\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\zoho\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import ZohoProvider


urlpatterns = default_urlpatterns(ZohoProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\zoho\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\zoho\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import ZohoProvider


class ZohoOAuth2Adapter(OAuth2Adapter):
    provider_id = ZohoProvider.id
    access_token_url = "https://accounts.zoho.com/oauth/v2/token"
    authorize_url = "https://accounts.zoho.com/oauth/v2/auth"
    profile_url = "https://accounts.zoho.com/oauth/user/info"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.profile_url,
            headers={"Authorization": "Bearer {}".format(token.token)},
        )
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(ZohoOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(ZohoOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\zoho\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\zoom\urls.py ---

from allauth.socialaccount.providers.oauth2.urls import default_urlpatterns

from .provider import ZoomProvider


urlpatterns = default_urlpatterns(ZoomProvider)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\zoom\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\zoom\views.py ---

import requests

from allauth.socialaccount.providers.oauth2.views import (
    OAuth2Adapter,
    OAuth2CallbackView,
    OAuth2LoginView,
)

from .provider import ZoomProvider


class ZoomOAuth2Adapter(OAuth2Adapter):
    provider_id = ZoomProvider.id
    access_token_url = "https://zoom.us/oauth/token"
    authorize_url = "https://zoom.us/oauth/authorize"
    profile_url = "https://api.zoom.us/v2/users/me"

    def complete_login(self, request, app, token, **kwargs):
        resp = requests.get(
            self.profile_url,
            headers={"Authorization": "Bearer {}".format(token.token)},
        )
        resp.raise_for_status()
        extra_data = resp.json()
        return self.get_provider().sociallogin_from_response(request, extra_data)


oauth2_login = OAuth2LoginView.adapter_view(ZoomOAuth2Adapter)
oauth2_callback = OAuth2CallbackView.adapter_view(ZoomOAuth2Adapter)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\providers\zoom\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\admin.py ---

from django import forms
from django.contrib import admin

from allauth import app_settings
from allauth.account.adapter import get_adapter

from .models import SocialAccount, SocialApp, SocialToken


class SocialAppForm(forms.ModelForm):
    class Meta:
        model = SocialApp
        exclude = []
        widgets = {
            "client_id": forms.TextInput(attrs={"size": "100"}),
            "key": forms.TextInput(attrs={"size": "100"}),
            "secret": forms.TextInput(attrs={"size": "100"}),
        }


class SocialAppAdmin(admin.ModelAdmin):
    form = SocialAppForm
    list_display = (
        "name",
        "provider",
    )
    filter_horizontal = ("sites",) if app_settings.SITES_ENABLED else ()


class SocialAccountAdmin(admin.ModelAdmin):
    search_fields = []
    raw_id_fields = ("user",)
    list_display = ("user", "uid", "provider")
    list_filter = ("provider",)

    def get_search_fields(self, request):
        base_fields = get_adapter().get_user_search_fields()
        return list(map(lambda a: "user__" + a, base_fields))


class SocialTokenAdmin(admin.ModelAdmin):
    raw_id_fields = (
        "app",
        "account",
    )
    list_display = ("app", "account", "truncated_token", "expires_at")
    list_filter = ("app", "app__provider", "expires_at")

    def truncated_token(self, token):
        max_chars = 40
        ret = token.token
        if len(ret) > max_chars:
            ret = ret[0:max_chars] + "...(truncated)"
        return ret

    truncated_token.short_description = "Token"


admin.site.register(SocialApp, SocialAppAdmin)
admin.site.register(SocialToken, SocialTokenAdmin)
admin.site.register(SocialAccount, SocialAccountAdmin)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\apps.py ---

from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _


class SocialAccountConfig(AppConfig):
    name = "allauth.socialaccount"
    verbose_name = _("Social Accounts")
    default_auto_field = "django.db.models.AutoField"

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\models.py ---

from __future__ import absolute_import

from django.contrib.auth import authenticate
from django.contrib.sites.shortcuts import get_current_site
from django.core.exceptions import PermissionDenied
from django.db import models
from django.utils.crypto import get_random_string
from django.utils.translation import gettext_lazy as _

import allauth.app_settings
from allauth.account.models import EmailAddress
from allauth.account.utils import get_next_redirect_url, setup_user_email
from allauth.utils import get_user_model

from ..utils import get_request_param
from . import app_settings, providers
from .adapter import get_adapter
from .fields import JSONField


class SocialAppManager(models.Manager):
    def on_site(self, request):
        if allauth.app_settings.SITES_ENABLED:
            site = get_current_site(request)
            return self.filter(sites__id=site.id)
        return self.all()


class SocialApp(models.Model):
    objects = SocialAppManager()

    # The provider type, e.g. "google", "telegram", "saml".
    provider = models.CharField(
        verbose_name=_("provider"),
        max_length=30,
        choices=providers.registry.as_choices(),
    )
    # For providers that support subproviders, such as OpenID Connect and SAML,
    # this ID identifies that instance. SocialAccount's originating from app
    # will have their `provider` field set to the `provider_id` if available,
    # else `provider`.
    provider_id = models.CharField(
        verbose_name=_("provider ID"),
        max_length=200,
        blank=True,
    )
    name = models.CharField(verbose_name=_("name"), max_length=40)
    client_id = models.CharField(
        verbose_name=_("client id"),
        max_length=191,
        help_text=_("App ID, or consumer key"),
    )
    secret = models.CharField(
        verbose_name=_("secret key"),
        max_length=191,
        blank=True,
        help_text=_("API secret, client secret, or consumer secret"),
    )
    key = models.CharField(
        verbose_name=_("key"), max_length=191, blank=True, help_text=_("Key")
    )
    settings = models.JSONField(default=dict, blank=True)

    if allauth.app_settings.SITES_ENABLED:
        # Most apps can be used across multiple domains, therefore we use
        # a ManyToManyField. Note that Facebook requires an app per domain
        # (unless the domains share a common base name).
        # blank=True allows for disabling apps without removing them
        sites = models.ManyToManyField("sites.Site", blank=True)

    # We want to move away from storing secrets in the database. So, we're
    # putting a halt towards adding more fields for additional secrets, such as
    # the certificate some providers need. Therefore, the certificate is not a
    # DB backed field and can only be set using the ``APP`` configuration key
    # in the provider settings.
    certificate_key = None

    class Meta:
        verbose_name = _("social application")
        verbose_name_plural = _("social applications")

    def __str__(self):
        return self.name

    def get_provider(self, request):
        provider_class = providers.registry.get_class(self.provider)
        return provider_class(request=request, app=self)


class SocialAccount(models.Model):
    user = models.ForeignKey(allauth.app_settings.USER_MODEL, on_delete=models.CASCADE)
    # Given a `SocialApp` from which this account originates, this field equals
    # the app's `app.provider_id` if available, `app.provider` otherwise.
    provider = models.CharField(
        verbose_name=_("provider"),
        max_length=200,
    )
    # Just in case you're wondering if an OpenID identity URL is going
    # to fit in a 'uid':
    #
    # Ideally, URLField(max_length=1024, unique=True) would be used
    # for identity.  However, MySQL has a max_length limitation of 191
    # for URLField (in case of utf8mb4). How about
    # models.TextField(unique=True) then?  Well, that won't work
    # either for MySQL due to another bug[1]. So the only way out
    # would be to drop the unique constraint, or switch to shorter
    # identity URLs. Opted for the latter, as [2] suggests that
    # identity URLs are supposed to be short anyway, at least for the
    # old spec.
    #
    # [1] http://code.djangoproject.com/ticket/2495.
    # [2] http://openid.net/specs/openid-authentication-1_1.html#limits

    uid = models.CharField(
        verbose_name=_("uid"), max_length=app_settings.UID_MAX_LENGTH
    )
    last_login = models.DateTimeField(verbose_name=_("last login"), auto_now=True)
    date_joined = models.DateTimeField(verbose_name=_("date joined"), auto_now_add=True)
    extra_data = JSONField(verbose_name=_("extra data"), default=dict)

    class Meta:
        unique_together = ("provider", "uid")
        verbose_name = _("social account")
        verbose_name_plural = _("social accounts")

    def authenticate(self):
        return authenticate(account=self)

    def __str__(self):
        from .helpers import socialaccount_user_display

        return socialaccount_user_display(self)

    def get_profile_url(self):
        return self.get_provider_account().get_profile_url()

    def get_avatar_url(self):
        return self.get_provider_account().get_avatar_url()

    def get_provider(self, request=None):
        provider = getattr(self, "_provider", None)
        if provider:
            return provider
        adapter = get_adapter(request)
        provider = self._provider = adapter.get_provider(
            request, provider=self.provider
        )
        return provider

    def get_provider_account(self):
        return self.get_provider().wrap_account(self)


class SocialToken(models.Model):
    app = models.ForeignKey(SocialApp, on_delete=models.CASCADE)
    account = models.ForeignKey(SocialAccount, on_delete=models.CASCADE)
    token = models.TextField(
        verbose_name=_("token"),
        help_text=_('"oauth_token" (OAuth1) or access token (OAuth2)'),
    )
    token_secret = models.TextField(
        blank=True,
        verbose_name=_("token secret"),
        help_text=_('"oauth_token_secret" (OAuth1) or refresh token (OAuth2)'),
    )
    expires_at = models.DateTimeField(
        blank=True, null=True, verbose_name=_("expires at")
    )

    class Meta:
        unique_together = ("app", "account")
        verbose_name = _("social application token")
        verbose_name_plural = _("social application tokens")

    def __str__(self):
        return self.token


class SocialLogin(object):
    """
    Represents a social user that is in the process of being logged
    in. This consists of the following information:

    `account` (`SocialAccount` instance): The social account being
    logged in. Providers are not responsible for checking whether or
    not an account already exists or not. Therefore, a provider
    typically creates a new (unsaved) `SocialAccount` instance. The
    `User` instance pointed to by the account (`account.user`) may be
    prefilled by the provider for use as a starting point later on
    during the signup process.

    `token` (`SocialToken` instance): An optional access token token
    that results from performing a successful authentication
    handshake.

    `state` (`dict`): The state to be preserved during the
    authentication handshake. Note that this state may end up in the
    url -- do not put any secrets in here. It currently only contains
    the url to redirect to after login.

    `email_addresses` (list of `EmailAddress`): Optional list of
    email addresses retrieved from the provider.
    """

    def __init__(self, user=None, account=None, token=None, email_addresses=[]):
        if token:
            assert token.account is None or token.account == account
        self.token = token
        self.user = user
        self.account = account
        self.email_addresses = email_addresses
        self.state = {}

    def connect(self, request, user):
        self.user = user
        self.save(request, connect=True)

    def serialize(self):
        serialize_instance = get_adapter().serialize_instance
        ret = dict(
            account=serialize_instance(self.account),
            user=serialize_instance(self.user),
            state=self.state,
            email_addresses=[serialize_instance(ea) for ea in self.email_addresses],
        )
        if self.token:
            ret["token"] = serialize_instance(self.token)
        return ret

    @classmethod
    def deserialize(cls, data):
        deserialize_instance = get_adapter().deserialize_instance
        account = deserialize_instance(SocialAccount, data["account"])
        user = deserialize_instance(get_user_model(), data["user"])
        if "token" in data:
            token = deserialize_instance(SocialToken, data["token"])
        else:
            token = None
        email_addresses = []
        for ea in data["email_addresses"]:
            email_address = deserialize_instance(EmailAddress, ea)
            email_addresses.append(email_address)
        ret = cls()
        ret.token = token
        ret.account = account
        ret.user = user
        ret.email_addresses = email_addresses
        ret.state = data["state"]
        return ret

    def save(self, request, connect=False):
        """
        Saves a new account. Note that while the account is new,
        the user may be an existing one (when connecting accounts)
        """
        user = self.user
        user.save()
        self.account.user = user
        self.account.save()
        if app_settings.STORE_TOKENS and self.token and self.token.app_id:
            self.token.account = self.account
            self.token.save()
        if connect:
            # TODO: Add any new email addresses automatically?
            pass
        else:
            setup_user_email(request, user, self.email_addresses)

    @property
    def is_existing(self):
        """When `False`, this social login represents a temporary account, not
        yet backed by a database record.
        """
        return self.user.pk is not None

    def lookup(self):
        """Look up the existing local user account to which this social login
        points, if any.
        """
        if not self._lookup_by_socialaccount():
            if app_settings.EMAIL_AUTHENTICATION or app_settings.PROVIDERS.get(
                self.account.provider, {}
            ).get("EMAIL_AUTHENTICATION", False):
                self._lookup_by_email()

    def _lookup_by_socialaccount(self):
        assert not self.is_existing
        try:
            a = SocialAccount.objects.get(
                provider=self.account.provider, uid=self.account.uid
            )
            # Update account
            a.extra_data = self.account.extra_data
            self.account = a
            self.user = self.account.user
            a.save()
            # Update token
            if app_settings.STORE_TOKENS and self.token and self.token.app.pk:
                assert not self.token.pk
                try:
                    t = SocialToken.objects.get(
                        account=self.account, app=self.token.app
                    )
                    t.token = self.token.token
                    if self.token.token_secret:
                        # only update the refresh token if we got one
                        # many oauth2 providers do not resend the refresh token
                        t.token_secret = self.token.token_secret
                    t.expires_at = self.token.expires_at
                    t.save()
                    self.token = t
                except SocialToken.DoesNotExist:
                    self.token.account = a
                    self.token.save()
            return True
        except SocialAccount.DoesNotExist:
            pass

    def _lookup_by_email(self):
        emails = [e.email for e in self.email_addresses if e.verified]
        if not emails:
            return
        address = (
            EmailAddress.objects.lookup(emails).order_by("-verified", "user_id").first()
        )
        if address:
            self.user = address.user

    def get_redirect_url(self, request):
        url = self.state.get("next")
        return url

    @classmethod
    def state_from_request(cls, request):
        state = {}
        next_url = get_next_redirect_url(request)
        if next_url:
            state["next"] = next_url
        state["process"] = get_request_param(request, "process", "login")
        state["scope"] = get_request_param(request, "scope", "")
        state["auth_params"] = get_request_param(request, "auth_params", "")
        return state

    @classmethod
    def stash_state(cls, request):
        state = cls.state_from_request(request)
        verifier = get_random_string(16)
        request.session["socialaccount_state"] = (state, verifier)
        return verifier

    @classmethod
    def unstash_state(cls, request):
        if "socialaccount_state" not in request.session:
            raise PermissionDenied()
        state, verifier = request.session.pop("socialaccount_state")
        return state

    @classmethod
    def verify_and_unstash_state(cls, request, verifier):
        if "socialaccount_state" not in request.session:
            raise PermissionDenied()
        state, verifier2 = request.session.pop("socialaccount_state")
        if verifier != verifier2:
            raise PermissionDenied()
        return state

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\urls.py ---

from django.urls import path

from . import views


urlpatterns = [
    path(
        "login/cancelled/",
        views.login_cancelled,
        name="socialaccount_login_cancelled",
    ),
    path("login/error/", views.login_error, name="socialaccount_login_error"),
    path("signup/", views.signup, name="socialaccount_signup"),
    path("connections/", views.connections, name="socialaccount_connections"),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\views.py ---

from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.contrib.sites.shortcuts import get_current_site
from django.http import HttpResponseRedirect
from django.urls import reverse, reverse_lazy
from django.views.generic.base import TemplateView
from django.views.generic.edit import FormView

from ..account import app_settings as account_settings
from ..account.adapter import get_adapter as get_account_adapter
from ..account.views import (
    AjaxCapableProcessFormViewMixin,
    CloseableSignupMixin,
    RedirectAuthenticatedUserMixin,
)
from ..utils import get_form_class
from . import app_settings, helpers
from .adapter import get_adapter
from .forms import DisconnectForm, SignupForm
from .models import SocialAccount, SocialLogin


class SignupView(
    RedirectAuthenticatedUserMixin,
    CloseableSignupMixin,
    AjaxCapableProcessFormViewMixin,
    FormView,
):
    form_class = SignupForm
    template_name = "socialaccount/signup." + account_settings.TEMPLATE_EXTENSION

    def get_form_class(self):
        return get_form_class(app_settings.FORMS, "signup", self.form_class)

    def dispatch(self, request, *args, **kwargs):
        self.sociallogin = None
        data = request.session.get("socialaccount_sociallogin")
        if data:
            self.sociallogin = SocialLogin.deserialize(data)
        if not self.sociallogin:
            return HttpResponseRedirect(reverse("account_login"))
        return super(SignupView, self).dispatch(request, *args, **kwargs)

    def is_open(self):
        return get_adapter(self.request).is_open_for_signup(
            self.request, self.sociallogin
        )

    def get_form_kwargs(self):
        ret = super(SignupView, self).get_form_kwargs()
        ret["sociallogin"] = self.sociallogin
        return ret

    def form_valid(self, form):
        self.request.session.pop("socialaccount_sociallogin", None)
        user, resp = form.try_save(self.request)
        if not resp:
            resp = helpers.complete_social_signup(self.request, self.sociallogin)
        return resp

    def get_context_data(self, **kwargs):
        ret = super(SignupView, self).get_context_data(**kwargs)
        ret.update(
            dict(
                site=get_current_site(self.request),
                account=self.sociallogin.account,
            )
        )
        return ret

    def get_authenticated_redirect_url(self):
        return reverse(connections)


signup = SignupView.as_view()


class LoginCancelledView(TemplateView):
    template_name = (
        "socialaccount/login_cancelled." + account_settings.TEMPLATE_EXTENSION
    )


login_cancelled = LoginCancelledView.as_view()


class LoginErrorView(TemplateView):
    template_name = (
        "socialaccount/authentication_error." + account_settings.TEMPLATE_EXTENSION
    )


login_error = LoginErrorView.as_view()


class ConnectionsView(AjaxCapableProcessFormViewMixin, FormView):
    template_name = "socialaccount/connections." + account_settings.TEMPLATE_EXTENSION
    form_class = DisconnectForm
    success_url = reverse_lazy("socialaccount_connections")

    def get_form_class(self):
        return get_form_class(app_settings.FORMS, "disconnect", self.form_class)

    def get_form_kwargs(self):
        kwargs = super(ConnectionsView, self).get_form_kwargs()
        kwargs["request"] = self.request
        return kwargs

    def form_valid(self, form):
        get_account_adapter().add_message(
            self.request,
            messages.INFO,
            "socialaccount/messages/account_disconnected.txt",
        )
        form.save()
        return super(ConnectionsView, self).form_valid(form)

    def get_ajax_data(self):
        account_data = []
        for account in SocialAccount.objects.filter(user=self.request.user):
            provider_account = account.get_provider_account()
            account_data.append(
                {
                    "id": account.pk,
                    "provider": account.provider,
                    "name": provider_account.to_str(),
                }
            )
        return {"socialaccounts": account_data}


connections = login_required(ConnectionsView.as_view())

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\socialaccount\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\models.py ---


# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\urls.py ---

from importlib import import_module

from django.urls import include, path

from allauth.socialaccount import providers

from . import app_settings


urlpatterns = [path("", include("allauth.account.urls"))]

if app_settings.SOCIALACCOUNT_ENABLED:
    urlpatterns += [path("social/", include("allauth.socialaccount.urls"))]

# Provider urlpatterns, as separate attribute (for reusability).
provider_urlpatterns = []
provider_classes = providers.registry.get_class_list()

# We need to move the OpenID Connect provider to the end. The reason is that
# matches URLs that the builtin providers also match.
provider_classes = [cls for cls in provider_classes if cls.id != "openid_connect"] + [
    cls for cls in provider_classes if cls.id == "openid_connect"
]
for provider_class in provider_classes:
    try:
        prov_mod = import_module(provider_class.get_package() + ".urls")
    except ImportError:
        continue
    prov_urlpatterns = getattr(prov_mod, "urlpatterns", None)
    if prov_urlpatterns:
        provider_urlpatterns += prov_urlpatterns

urlpatterns += provider_urlpatterns

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\allauth\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\asgiref\wsgi.py ---

from io import BytesIO
from tempfile import SpooledTemporaryFile

from asgiref.sync import AsyncToSync, sync_to_async


class WsgiToAsgi:
    """
    Wraps a WSGI application to make it into an ASGI application.
    """

    def __init__(self, wsgi_application):
        self.wsgi_application = wsgi_application

    async def __call__(self, scope, receive, send):
        """
        ASGI application instantiation point.
        We return a new WsgiToAsgiInstance here with the WSGI app
        and the scope, ready to respond when it is __call__ed.
        """
        await WsgiToAsgiInstance(self.wsgi_application)(scope, receive, send)


class WsgiToAsgiInstance:
    """
    Per-socket instance of a wrapped WSGI application
    """

    def __init__(self, wsgi_application):
        self.wsgi_application = wsgi_application
        self.response_started = False
        self.response_content_length = None

    async def __call__(self, scope, receive, send):
        if scope["type"] != "http":
            raise ValueError("WSGI wrapper received a non-HTTP scope")
        self.scope = scope
        with SpooledTemporaryFile(max_size=65536) as body:
            # Alright, wait for the http.request messages
            while True:
                message = await receive()
                if message["type"] != "http.request":
                    raise ValueError("WSGI wrapper received a non-HTTP-request message")
                body.write(message.get("body", b""))
                if not message.get("more_body"):
                    break
            body.seek(0)
            # Wrap send so it can be called from the subthread
            self.sync_send = AsyncToSync(send)
            # Call the WSGI app
            await self.run_wsgi_app(body)

    def build_environ(self, scope, body):
        """
        Builds a scope and request body into a WSGI environ object.
        """
        script_name = scope.get("root_path", "").encode("utf8").decode("latin1")
        path_info = scope["path"].encode("utf8").decode("latin1")
        if path_info.startswith(script_name):
            path_info = path_info[len(script_name) :]
        environ = {
            "REQUEST_METHOD": scope["method"],
            "SCRIPT_NAME": script_name,
            "PATH_INFO": path_info,
            "QUERY_STRING": scope["query_string"].decode("ascii"),
            "SERVER_PROTOCOL": "HTTP/%s" % scope["http_version"],
            "wsgi.version": (1, 0),
            "wsgi.url_scheme": scope.get("scheme", "http"),
            "wsgi.input": body,
            "wsgi.errors": BytesIO(),
            "wsgi.multithread": True,
            "wsgi.multiprocess": True,
            "wsgi.run_once": False,
        }
        # Get server name and port - required in WSGI, not in ASGI
        if "server" in scope:
            environ["SERVER_NAME"] = scope["server"][0]
            environ["SERVER_PORT"] = str(scope["server"][1])
        else:
            environ["SERVER_NAME"] = "localhost"
            environ["SERVER_PORT"] = "80"

        if scope.get("client") is not None:
            environ["REMOTE_ADDR"] = scope["client"][0]

        # Go through headers and make them into environ entries
        for name, value in self.scope.get("headers", []):
            name = name.decode("latin1")
            if name == "content-length":
                corrected_name = "CONTENT_LENGTH"
            elif name == "content-type":
                corrected_name = "CONTENT_TYPE"
            else:
                corrected_name = "HTTP_%s" % name.upper().replace("-", "_")
            # HTTPbis say only ASCII chars are allowed in headers, but we latin1 just in case
            value = value.decode("latin1")
            if corrected_name in environ:
                value = environ[corrected_name] + "," + value
            environ[corrected_name] = value
        return environ

    def start_response(self, status, response_headers, exc_info=None):
        """
        WSGI start_response callable.
        """
        # Don't allow re-calling once response has begun
        if self.response_started:
            raise exc_info[1].with_traceback(exc_info[2])
        # Don't allow re-calling without exc_info
        if hasattr(self, "response_start") and exc_info is None:
            raise ValueError(
                "You cannot call start_response a second time without exc_info"
            )
        # Extract status code
        status_code, _ = status.split(" ", 1)
        status_code = int(status_code)
        # Extract headers
        headers = [
            (name.lower().encode("ascii"), value.encode("ascii"))
            for name, value in response_headers
        ]
        # Extract content-length
        self.response_content_length = None
        for name, value in response_headers:
            if name.lower() == "content-length":
                self.response_content_length = int(value)
        # Build and send response start message.
        self.response_start = {
            "type": "http.response.start",
            "status": status_code,
            "headers": headers,
        }

    @sync_to_async
    def run_wsgi_app(self, body):
        """
        Called in a subthread to run the WSGI app. We encapsulate like
        this so that the start_response callable is called in the same thread.
        """
        # Translate the scope and incoming request body into a WSGI environ
        environ = self.build_environ(self.scope, body)
        # Run the WSGI app
        bytes_sent = 0
        for output in self.wsgi_application(environ, self.start_response):
            # If this is the first response, include the response headers
            if not self.response_started:
                self.response_started = True
                self.sync_send(self.response_start)
            # If the application supplies a Content-Length header
            if self.response_content_length is not None:
                # The server should not transmit more bytes to the client than the header allows
                bytes_allowed = self.response_content_length - bytes_sent
                if len(output) > bytes_allowed:
                    output = output[:bytes_allowed]
            self.sync_send(
                {"type": "http.response.body", "body": output, "more_body": True}
            )
            bytes_sent += len(output)
            # The server should stop iterating over the response when enough data has been sent
            if bytes_sent == self.response_content_length:
                break
        # Close connection
        if not self.response_started:
            self.response_started = True
            self.sync_send(self.response_start)
        self.sync_send({"type": "http.response.body"})

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\asgiref\wsgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\celery\backends\database\models.py ---

"""Database models used by the SQLAlchemy result store backend."""
from datetime import datetime

import sqlalchemy as sa
from sqlalchemy.types import PickleType

from celery import states

from .session import ResultModelBase

__all__ = ('Task', 'TaskExtended', 'TaskSet')


class Task(ResultModelBase):
    """Task result/status."""

    __tablename__ = 'celery_taskmeta'
    __table_args__ = {'sqlite_autoincrement': True}

    id = sa.Column(sa.Integer, sa.Sequence('task_id_sequence'),
                   primary_key=True, autoincrement=True)
    task_id = sa.Column(sa.String(155), unique=True)
    status = sa.Column(sa.String(50), default=states.PENDING)
    result = sa.Column(PickleType, nullable=True)
    date_done = sa.Column(sa.DateTime, default=datetime.utcnow,
                          onupdate=datetime.utcnow, nullable=True)
    traceback = sa.Column(sa.Text, nullable=True)

    def __init__(self, task_id):
        self.task_id = task_id

    def to_dict(self):
        return {
            'task_id': self.task_id,
            'status': self.status,
            'result': self.result,
            'traceback': self.traceback,
            'date_done': self.date_done,
        }

    def __repr__(self):
        return '<Task {0.task_id} state: {0.status}>'.format(self)

    @classmethod
    def configure(cls, schema=None, name=None):
        cls.__table__.schema = schema
        cls.id.default.schema = schema
        cls.__table__.name = name or cls.__tablename__


class TaskExtended(Task):
    """For the extend result."""

    __tablename__ = 'celery_taskmeta'
    __table_args__ = {'sqlite_autoincrement': True, 'extend_existing': True}

    name = sa.Column(sa.String(155), nullable=True)
    args = sa.Column(sa.LargeBinary, nullable=True)
    kwargs = sa.Column(sa.LargeBinary, nullable=True)
    worker = sa.Column(sa.String(155), nullable=True)
    retries = sa.Column(sa.Integer, nullable=True)
    queue = sa.Column(sa.String(155), nullable=True)

    def to_dict(self):
        task_dict = super().to_dict()
        task_dict.update({
            'name': self.name,
            'args': self.args,
            'kwargs': self.kwargs,
            'worker': self.worker,
            'retries': self.retries,
            'queue': self.queue,
        })
        return task_dict


class TaskSet(ResultModelBase):
    """TaskSet result."""

    __tablename__ = 'celery_tasksetmeta'
    __table_args__ = {'sqlite_autoincrement': True}

    id = sa.Column(sa.Integer, sa.Sequence('taskset_id_sequence'),
                   autoincrement=True, primary_key=True)
    taskset_id = sa.Column(sa.String(155), unique=True)
    result = sa.Column(PickleType, nullable=True)
    date_done = sa.Column(sa.DateTime, default=datetime.utcnow,
                          nullable=True)

    def __init__(self, taskset_id, result):
        self.taskset_id = taskset_id
        self.result = result

    def to_dict(self):
        return {
            'taskset_id': self.taskset_id,
            'result': self.result,
            'date_done': self.date_done,
        }

    def __repr__(self):
        return f'<TaskSet: {self.taskset_id}>'

    @classmethod
    def configure(cls, schema=None, name=None):
        cls.__table__.schema = schema
        cls.id.default.schema = schema
        cls.__table__.name = name or cls.__tablename__

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\celery\backends\database\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\channels\apps.py ---

from django.apps import AppConfig


class ChannelsConfig(AppConfig):
    name = "channels"
    verbose_name = "Channels"

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\channels\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\channels_redis\serializers.py ---

import abc
import base64
import hashlib
import json
import random

try:
    from cryptography.fernet import Fernet, MultiFernet
except ImportError:
    MultiFernet = Fernet = None


class SerializerDoesNotExist(KeyError):
    """The requested serializer was not found."""


class BaseMessageSerializer(abc.ABC):
    def __init__(
        self,
        symmetric_encryption_keys=None,
        random_prefix_length=0,
        expiry=None,
    ):
        self.random_prefix_length = random_prefix_length
        self.expiry = expiry
        # Set up any encryption objects
        self._setup_encryption(symmetric_encryption_keys)

    def _setup_encryption(self, symmetric_encryption_keys):
        # See if we can do encryption if they asked
        if symmetric_encryption_keys:
            if isinstance(symmetric_encryption_keys, (str, bytes)):
                raise ValueError(
                    "symmetric_encryption_keys must be a list of possible keys"
                )
            if MultiFernet is None:
                raise ValueError(
                    "Cannot run with encryption without 'cryptography' installed."
                )
            sub_fernets = [self.make_fernet(key) for key in symmetric_encryption_keys]
            self.crypter = MultiFernet(sub_fernets)
        else:
            self.crypter = None

    def make_fernet(self, key):
        """
        Given a single encryption key, returns a Fernet instance using it.
        """
        if Fernet is None:
            raise ValueError(
                "Cannot run with encryption without 'cryptography' installed."
            )

        if isinstance(key, str):
            key = key.encode("utf-8")
        formatted_key = base64.urlsafe_b64encode(hashlib.sha256(key).digest())
        return Fernet(formatted_key)

    @abc.abstractmethod
    def as_bytes(self, message, *args, **kwargs):
        raise NotImplementedError

    @abc.abstractmethod
    def from_bytes(self, message, *args, **kwargs):
        raise NotImplementedError

    def serialize(self, message):
        """
        Serializes message to a byte string.
        """
        message = self.as_bytes(message)
        if self.crypter:
            message = self.crypter.encrypt(message)

        if self.random_prefix_length > 0:
            # provide random prefix
            message = (
                random.getrandbits(8 * self.random_prefix_length).to_bytes(
                    self.random_prefix_length, "big"
                )
                + message
            )
        return message

    def deserialize(self, message):
        """
        Deserializes from a byte string.
        """
        if self.random_prefix_length > 0:
            # Removes the random prefix
            message = message[self.random_prefix_length :]  # noqa: E203

        if self.crypter:
            ttl = self.expiry if self.expiry is None else self.expiry + 10
            message = self.crypter.decrypt(message, ttl)
        return self.from_bytes(message)


class MissingSerializer(BaseMessageSerializer):
    exception = None

    def __init__(self, *args, **kwargs):
        raise self.exception


class JSONSerializer(BaseMessageSerializer):
    # json module by default always produces str while loads accepts bytes
    # thus we must force bytes conversion
    # we use UTF-8 since it is the recommended encoding for interoperability
    # see https://docs.python.org/3/library/json.html#character-encodings
    def as_bytes(self, message, *args, **kwargs):
        message = json.dumps(message, *args, **kwargs)
        return message.encode("utf-8")

    from_bytes = staticmethod(json.loads)


# code ready for a future in which msgpack may become an optional dependency
try:
    import msgpack
except ImportError as exc:

    class MsgPackSerializer(MissingSerializer):
        exception = exc

else:

    class MsgPackSerializer(BaseMessageSerializer):
        as_bytes = staticmethod(msgpack.packb)
        from_bytes = staticmethod(msgpack.unpackb)


class SerializersRegistry:
    """
    Serializers registry inspired by that of ``django.core.serializers``.
    """

    def __init__(self):
        self._registry = {}

    def register_serializer(self, format, serializer_class):
        """
        Register a new serializer for given format
        """
        assert isinstance(serializer_class, type) and (
            issubclass(serializer_class, BaseMessageSerializer)
            or (
                hasattr(serializer_class, "serialize")
                and hasattr(serializer_class, "deserialize")
            )
        ), """
            `serializer_class` should be a class which implements `serialize` and `deserialize` method
            or a subclass of `channels_redis.serializers.BaseMessageSerializer`
        """

        self._registry[format] = serializer_class

    def get_serializer(self, format, *args, **kwargs):
        try:
            serializer_class = self._registry[format]
        except KeyError:
            raise SerializerDoesNotExist(format)

        return serializer_class(*args, **kwargs)


registry = SerializersRegistry()
registry.register_serializer("json", JSONSerializer)
registry.register_serializer("msgpack", MsgPackSerializer)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\channels_redis\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\charset_normalizer\models.py ---

from encodings.aliases import aliases
from hashlib import sha256
from json import dumps
from re import sub
from typing import Any, Dict, Iterator, List, Optional, Tuple, Union

from .constant import RE_POSSIBLE_ENCODING_INDICATION, TOO_BIG_SEQUENCE
from .utils import iana_name, is_multi_byte_encoding, unicode_range


class CharsetMatch:
    def __init__(
        self,
        payload: bytes,
        guessed_encoding: str,
        mean_mess_ratio: float,
        has_sig_or_bom: bool,
        languages: "CoherenceMatches",
        decoded_payload: Optional[str] = None,
        preemptive_declaration: Optional[str] = None,
    ):
        self._payload: bytes = payload

        self._encoding: str = guessed_encoding
        self._mean_mess_ratio: float = mean_mess_ratio
        self._languages: CoherenceMatches = languages
        self._has_sig_or_bom: bool = has_sig_or_bom
        self._unicode_ranges: Optional[List[str]] = None

        self._leaves: List[CharsetMatch] = []
        self._mean_coherence_ratio: float = 0.0

        self._output_payload: Optional[bytes] = None
        self._output_encoding: Optional[str] = None

        self._string: Optional[str] = decoded_payload

        self._preemptive_declaration: Optional[str] = preemptive_declaration

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, CharsetMatch):
            if isinstance(other, str):
                return iana_name(other) == self.encoding
            return False
        return self.encoding == other.encoding and self.fingerprint == other.fingerprint

    def __lt__(self, other: object) -> bool:
        """
        Implemented to make sorted available upon CharsetMatches items.
        """
        if not isinstance(other, CharsetMatch):
            raise ValueError

        chaos_difference: float = abs(self.chaos - other.chaos)
        coherence_difference: float = abs(self.coherence - other.coherence)

        # Below 1% difference --> Use Coherence
        if chaos_difference < 0.01 and coherence_difference > 0.02:
            return self.coherence > other.coherence
        elif chaos_difference < 0.01 and coherence_difference <= 0.02:
            # When having a difficult decision, use the result that decoded as many multi-byte as possible.
            # preserve RAM usage!
            if len(self._payload) >= TOO_BIG_SEQUENCE:
                return self.chaos < other.chaos
            return self.multi_byte_usage > other.multi_byte_usage

        return self.chaos < other.chaos

    @property
    def multi_byte_usage(self) -> float:
        return 1.0 - (len(str(self)) / len(self.raw))

    def __str__(self) -> str:
        # Lazy Str Loading
        if self._string is None:
            self._string = str(self._payload, self._encoding, "strict")
        return self._string

    def __repr__(self) -> str:
        return "<CharsetMatch '{}' bytes({})>".format(self.encoding, self.fingerprint)

    def add_submatch(self, other: "CharsetMatch") -> None:
        if not isinstance(other, CharsetMatch) or other == self:
            raise ValueError(
                "Unable to add instance <{}> as a submatch of a CharsetMatch".format(
                    other.__class__
                )
            )

        other._string = None  # Unload RAM usage; dirty trick.
        self._leaves.append(other)

    @property
    def encoding(self) -> str:
        return self._encoding

    @property
    def encoding_aliases(self) -> List[str]:
        """
        Encoding name are known by many name, using this could help when searching for IBM855 when it's listed as CP855.
        """
        also_known_as: List[str] = []
        for u, p in aliases.items():
            if self.encoding == u:
                also_known_as.append(p)
            elif self.encoding == p:
                also_known_as.append(u)
        return also_known_as

    @property
    def bom(self) -> bool:
        return self._has_sig_or_bom

    @property
    def byte_order_mark(self) -> bool:
        return self._has_sig_or_bom

    @property
    def languages(self) -> List[str]:
        """
        Return the complete list of possible languages found in decoded sequence.
        Usually not really useful. Returned list may be empty even if 'language' property return something != 'Unknown'.
        """
        return [e[0] for e in self._languages]

    @property
    def language(self) -> str:
        """
        Most probable language found in decoded sequence. If none were detected or inferred, the property will return
        "Unknown".
        """
        if not self._languages:
            # Trying to infer the language based on the given encoding
            # Its either English or we should not pronounce ourselves in certain cases.
            if "ascii" in self.could_be_from_charset:
                return "English"

            # doing it there to avoid circular import
            from charset_normalizer.cd import encoding_languages, mb_encoding_languages

            languages = (
                mb_encoding_languages(self.encoding)
                if is_multi_byte_encoding(self.encoding)
                else encoding_languages(self.encoding)
            )

            if len(languages) == 0 or "Latin Based" in languages:
                return "Unknown"

            return languages[0]

        return self._languages[0][0]

    @property
    def chaos(self) -> float:
        return self._mean_mess_ratio

    @property
    def coherence(self) -> float:
        if not self._languages:
            return 0.0
        return self._languages[0][1]

    @property
    def percent_chaos(self) -> float:
        return round(self.chaos * 100, ndigits=3)

    @property
    def percent_coherence(self) -> float:
        return round(self.coherence * 100, ndigits=3)

    @property
    def raw(self) -> bytes:
        """
        Original untouched bytes.
        """
        return self._payload

    @property
    def submatch(self) -> List["CharsetMatch"]:
        return self._leaves

    @property
    def has_submatch(self) -> bool:
        return len(self._leaves) > 0

    @property
    def alphabets(self) -> List[str]:
        if self._unicode_ranges is not None:
            return self._unicode_ranges
        # list detected ranges
        detected_ranges: List[Optional[str]] = [
            unicode_range(char) for char in str(self)
        ]
        # filter and sort
        self._unicode_ranges = sorted(list({r for r in detected_ranges if r}))
        return self._unicode_ranges

    @property
    def could_be_from_charset(self) -> List[str]:
        """
        The complete list of encoding that output the exact SAME str result and therefore could be the originating
        encoding.
        This list does include the encoding available in property 'encoding'.
        """
        return [self._encoding] + [m.encoding for m in self._leaves]

    def output(self, encoding: str = "utf_8") -> bytes:
        """
        Method to get re-encoded bytes payload using given target encoding. Default to UTF-8.
        Any errors will be simply ignored by the encoder NOT replaced.
        """
        if self._output_encoding is None or self._output_encoding != encoding:
            self._output_encoding = encoding
            decoded_string = str(self)
            if (
                self._preemptive_declaration is not None
                and self._preemptive_declaration.lower()
                not in ["utf-8", "utf8", "utf_8"]
            ):
                patched_header = sub(
                    RE_POSSIBLE_ENCODING_INDICATION,
                    lambda m: m.string[m.span()[0] : m.span()[1]].replace(
                        m.groups()[0], iana_name(self._output_encoding)  # type: ignore[arg-type]
                    ),
                    decoded_string[:8192],
                    1,
                )

                decoded_string = patched_header + decoded_string[8192:]

            self._output_payload = decoded_string.encode(encoding, "replace")

        return self._output_payload  # type: ignore

    @property
    def fingerprint(self) -> str:
        """
        Retrieve the unique SHA256 computed using the transformed (re-encoded) payload. Not the original one.
        """
        return sha256(self.output()).hexdigest()


class CharsetMatches:
    """
    Container with every CharsetMatch items ordered by default from most probable to the less one.
    Act like a list(iterable) but does not implements all related methods.
    """

    def __init__(self, results: Optional[List[CharsetMatch]] = None):
        self._results: List[CharsetMatch] = sorted(results) if results else []

    def __iter__(self) -> Iterator[CharsetMatch]:
        yield from self._results

    def __getitem__(self, item: Union[int, str]) -> CharsetMatch:
        """
        Retrieve a single item either by its position or encoding name (alias may be used here).
        Raise KeyError upon invalid index or encoding not present in results.
        """
        if isinstance(item, int):
            return self._results[item]
        if isinstance(item, str):
            item = iana_name(item, False)
            for result in self._results:
                if item in result.could_be_from_charset:
                    return result
        raise KeyError

    def __len__(self) -> int:
        return len(self._results)

    def __bool__(self) -> bool:
        return len(self._results) > 0

    def append(self, item: CharsetMatch) -> None:
        """
        Insert a single match. Will be inserted accordingly to preserve sort.
        Can be inserted as a submatch.
        """
        if not isinstance(item, CharsetMatch):
            raise ValueError(
                "Cannot append instance '{}' to CharsetMatches".format(
                    str(item.__class__)
                )
            )
        # We should disable the submatch factoring when the input file is too heavy (conserve RAM usage)
        if len(item.raw) < TOO_BIG_SEQUENCE:
            for match in self._results:
                if match.fingerprint == item.fingerprint and match.chaos == item.chaos:
                    match.add_submatch(item)
                    return
        self._results.append(item)
        self._results = sorted(self._results)

    def best(self) -> Optional["CharsetMatch"]:
        """
        Simply return the first match. Strict equivalent to matches[0].
        """
        if not self._results:
            return None
        return self._results[0]

    def first(self) -> Optional["CharsetMatch"]:
        """
        Redundant method, call the method best(). Kept for BC reasons.
        """
        return self.best()


CoherenceMatch = Tuple[str, float]
CoherenceMatches = List[CoherenceMatch]


class CliDetectionResult:
    def __init__(
        self,
        path: str,
        encoding: Optional[str],
        encoding_aliases: List[str],
        alternative_encodings: List[str],
        language: str,
        alphabets: List[str],
        has_sig_or_bom: bool,
        chaos: float,
        coherence: float,
        unicode_path: Optional[str],
        is_preferred: bool,
    ):
        self.path: str = path
        self.unicode_path: Optional[str] = unicode_path
        self.encoding: Optional[str] = encoding
        self.encoding_aliases: List[str] = encoding_aliases
        self.alternative_encodings: List[str] = alternative_encodings
        self.language: str = language
        self.alphabets: List[str] = alphabets
        self.has_sig_or_bom: bool = has_sig_or_bom
        self.chaos: float = chaos
        self.coherence: float = coherence
        self.is_preferred: bool = is_preferred

    @property
    def __dict__(self) -> Dict[str, Any]:  # type: ignore
        return {
            "path": self.path,
            "encoding": self.encoding,
            "encoding_aliases": self.encoding_aliases,
            "alternative_encodings": self.alternative_encodings,
            "language": self.language,
            "alphabets": self.alphabets,
            "has_sig_or_bom": self.has_sig_or_bom,
            "chaos": self.chaos,
            "coherence": self.coherence,
            "unicode_path": self.unicode_path,
            "is_preferred": self.is_preferred,
        }

    def to_json(self) -> str:
        return dumps(self.__dict__, ensure_ascii=True, indent=4)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\charset_normalizer\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\corsheaders\apps.py ---

from __future__ import annotations

from django.apps import AppConfig
from django.core.checks import Tags
from django.core.checks import register

from corsheaders.checks import check_settings


class CorsHeadersAppConfig(AppConfig):
    name = "corsheaders"
    verbose_name = "django-cors-headers"

    def ready(self) -> None:
        register(Tags.security)(check_settings)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\corsheaders\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\panels\history\views.py ---

from django.http import HttpResponseBadRequest, JsonResponse
from django.template.loader import render_to_string

from debug_toolbar.decorators import render_with_toolbar_language, require_show_toolbar
from debug_toolbar.panels.history.forms import HistoryStoreForm
from debug_toolbar.toolbar import DebugToolbar


@require_show_toolbar
@render_with_toolbar_language
def history_sidebar(request):
    """Returns the selected debug toolbar history snapshot."""
    form = HistoryStoreForm(request.GET)

    if form.is_valid():
        store_id = form.cleaned_data["store_id"]
        toolbar = DebugToolbar.fetch(store_id)
        exclude_history = form.cleaned_data["exclude_history"]
        context = {}
        if toolbar is None:
            # When the store_id has been popped already due to
            # RESULTS_CACHE_SIZE
            return JsonResponse(context)
        for panel in toolbar.panels:
            if exclude_history and not panel.is_historical:
                continue
            panel_context = {"panel": panel}
            context[panel.panel_id] = {
                "button": render_to_string(
                    "debug_toolbar/includes/panel_button.html", panel_context
                ),
                "content": render_to_string(
                    "debug_toolbar/includes/panel_content.html", panel_context
                ),
            }
        return JsonResponse(context)
    return HttpResponseBadRequest("Form errors")


@require_show_toolbar
@render_with_toolbar_language
def history_refresh(request):
    """Returns the refreshed list of table rows for the History Panel."""
    form = HistoryStoreForm(request.GET)

    if form.is_valid():
        requests = []
        # Convert to list to handle mutations happening in parallel
        for id, toolbar in list(DebugToolbar._store.items()):
            requests.append(
                {
                    "id": id,
                    "content": render_to_string(
                        "debug_toolbar/panels/history_tr.html",
                        {
                            "id": id,
                            "store_context": {
                                "toolbar": toolbar,
                                "form": HistoryStoreForm(
                                    initial={
                                        "store_id": id,
                                        "exclude_history": True,
                                    }
                                ),
                            },
                        },
                    ),
                }
            )

        return JsonResponse({"requests": requests})
    return HttpResponseBadRequest("Form errors")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\panels\history\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\panels\sql\views.py ---

from django.http import HttpResponseBadRequest, JsonResponse
from django.template.loader import render_to_string
from django.views.decorators.csrf import csrf_exempt

from debug_toolbar.decorators import render_with_toolbar_language, require_show_toolbar
from debug_toolbar.forms import SignedDataForm
from debug_toolbar.panels.sql.forms import SQLSelectForm


def get_signed_data(request):
    """Unpack a signed data form, if invalid returns None"""
    data = request.GET if request.method == "GET" else request.POST
    signed_form = SignedDataForm(data)
    if signed_form.is_valid():
        return signed_form.verified_data()
    return None


@csrf_exempt
@require_show_toolbar
@render_with_toolbar_language
def sql_select(request):
    """Returns the output of the SQL SELECT statement"""
    verified_data = get_signed_data(request)
    if not verified_data:
        return HttpResponseBadRequest("Invalid signature")
    form = SQLSelectForm(verified_data)

    if form.is_valid():
        sql = form.cleaned_data["raw_sql"]
        params = form.cleaned_data["params"]
        with form.cursor as cursor:
            cursor.execute(sql, params)
            headers = [d[0] for d in cursor.description]
            result = cursor.fetchall()

        context = {
            "result": result,
            "sql": form.reformat_sql(),
            "duration": form.cleaned_data["duration"],
            "headers": headers,
            "alias": form.cleaned_data["alias"],
        }
        content = render_to_string("debug_toolbar/panels/sql_select.html", context)
        return JsonResponse({"content": content})
    return HttpResponseBadRequest("Form errors")


@csrf_exempt
@require_show_toolbar
@render_with_toolbar_language
def sql_explain(request):
    """Returns the output of the SQL EXPLAIN on the given query"""
    verified_data = get_signed_data(request)
    if not verified_data:
        return HttpResponseBadRequest("Invalid signature")
    form = SQLSelectForm(verified_data)

    if form.is_valid():
        sql = form.cleaned_data["raw_sql"]
        params = form.cleaned_data["params"]
        vendor = form.connection.vendor
        with form.cursor as cursor:
            if vendor == "sqlite":
                # SQLite's EXPLAIN dumps the low-level opcodes generated for a query;
                # EXPLAIN QUERY PLAN dumps a more human-readable summary
                # See https://www.sqlite.org/lang_explain.html for details
                cursor.execute(f"EXPLAIN QUERY PLAN {sql}", params)
            elif vendor == "postgresql":
                cursor.execute(f"EXPLAIN ANALYZE {sql}", params)
            else:
                cursor.execute(f"EXPLAIN {sql}", params)
            headers = [d[0] for d in cursor.description]
            result = cursor.fetchall()

        context = {
            "result": result,
            "sql": form.reformat_sql(),
            "duration": form.cleaned_data["duration"],
            "headers": headers,
            "alias": form.cleaned_data["alias"],
        }
        content = render_to_string("debug_toolbar/panels/sql_explain.html", context)
        return JsonResponse({"content": content})
    return HttpResponseBadRequest("Form errors")


@csrf_exempt
@require_show_toolbar
@render_with_toolbar_language
def sql_profile(request):
    """Returns the output of running the SQL and getting the profiling statistics"""
    verified_data = get_signed_data(request)
    if not verified_data:
        return HttpResponseBadRequest("Invalid signature")
    form = SQLSelectForm(verified_data)

    if form.is_valid():
        sql = form.cleaned_data["raw_sql"]
        params = form.cleaned_data["params"]
        result = None
        headers = None
        result_error = None
        with form.cursor as cursor:
            try:
                cursor.execute("SET PROFILING=1")  # Enable profiling
                cursor.execute(sql, params)  # Execute SELECT
                cursor.execute("SET PROFILING=0")  # Disable profiling
                # The Query ID should always be 1 here but I'll subselect to get
                # the last one just in case...
                cursor.execute(
                    """
                    SELECT *
                    FROM information_schema.profiling
                    WHERE query_id = (
                        SELECT query_id
                        FROM information_schema.profiling
                        ORDER BY query_id DESC
                        LIMIT 1
                    )
                    """
                )
                headers = [d[0] for d in cursor.description]
                result = cursor.fetchall()
            except Exception:
                result_error = (
                    "Profiling is either not available or not supported by your "
                    "database."
                )

        context = {
            "result": result,
            "result_error": result_error,
            "sql": form.reformat_sql(),
            "duration": form.cleaned_data["duration"],
            "headers": headers,
            "alias": form.cleaned_data["alias"],
        }
        content = render_to_string("debug_toolbar/panels/sql_profile.html", context)
        return JsonResponse({"content": content})
    return HttpResponseBadRequest("Form errors")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\panels\sql\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\panels\templates\views.py ---

from django.core import signing
from django.http import HttpResponseBadRequest, JsonResponse
from django.template import Origin, TemplateDoesNotExist
from django.template.engine import Engine
from django.template.loader import render_to_string
from django.utils.html import format_html, mark_safe

from debug_toolbar.decorators import render_with_toolbar_language, require_show_toolbar


@require_show_toolbar
@render_with_toolbar_language
def template_source(request):
    """
    Return the source of a template, syntax-highlighted by Pygments if
    it's available.
    """
    template_origin_name = request.GET.get("template_origin")
    if template_origin_name is None:
        return HttpResponseBadRequest('"template_origin" key is required')
    try:
        template_origin_name = signing.loads(template_origin_name)
    except Exception:
        return HttpResponseBadRequest('"template_origin" is invalid')
    template_name = request.GET.get("template", template_origin_name)

    final_loaders = []
    loaders = Engine.get_default().template_loaders

    for loader in loaders:
        if loader is not None:
            # When the loader has loaders associated with it,
            # append those loaders to the list. This occurs with
            # django.template.loaders.cached.Loader
            if hasattr(loader, "loaders"):
                final_loaders += loader.loaders
            else:
                final_loaders.append(loader)

    for loader in final_loaders:
        origin = Origin(template_origin_name)
        try:
            source = loader.get_contents(origin)
            break
        except TemplateDoesNotExist:
            pass
    else:
        source = f"Template Does Not Exist: {template_origin_name}"

    try:
        from pygments import highlight
        from pygments.formatters import HtmlFormatter
        from pygments.lexers import HtmlDjangoLexer
    except ModuleNotFoundError:
        source = format_html("<code>{}</code>", source)
    else:
        source = highlight(source, HtmlDjangoLexer(), HtmlFormatter())
        source = mark_safe(source)

    content = render_to_string(
        "debug_toolbar/panels/template_source.html",
        {"source": source, "template_name": template_name},
    )
    return JsonResponse({"content": content})

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\panels\templates\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\panels\settings.py ---

from django.conf import settings
from django.utils.translation import gettext_lazy as _
from django.views.debug import get_default_exception_reporter_filter

from debug_toolbar.panels import Panel

get_safe_settings = get_default_exception_reporter_filter().get_safe_settings


class SettingsPanel(Panel):
    """
    A panel to display all variables in django.conf.settings
    """

    template = "debug_toolbar/panels/settings.html"

    nav_title = _("Settings")

    def title(self):
        return _("Settings from %s") % settings.SETTINGS_MODULE

    def generate_stats(self, request, response):
        self.record_stats({"settings": dict(sorted(get_safe_settings().items()))})

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\panels\settings.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\apps.py ---

import inspect
import mimetypes

from django.apps import AppConfig
from django.conf import settings
from django.core.checks import Warning, register
from django.middleware.gzip import GZipMiddleware
from django.utils.module_loading import import_string
from django.utils.translation import gettext_lazy as _

from debug_toolbar import settings as dt_settings


class DebugToolbarConfig(AppConfig):
    name = "debug_toolbar"
    verbose_name = _("Debug Toolbar")

    def ready(self):
        from debug_toolbar.toolbar import DebugToolbar

        # Import the panels when the app is ready and call their ready() methods.  This
        # allows panels like CachePanel to enable their instrumentation immediately.
        for cls in DebugToolbar.get_panel_classes():
            cls.ready()


def check_template_config(config):
    """
    Checks if a template configuration is valid.

    The toolbar requires either the toolbars to be unspecified or
    ``django.template.loaders.app_directories.Loader`` to be
    included in the loaders.
    If custom loaders are specified, then APP_DIRS must be True.
    """

    def flat_loaders(loaders):
        """
        Recursively flatten the settings list of template loaders.

        Check for (loader, [child_loaders]) tuples.
        Django's default cached loader uses this pattern.
        """
        for loader in loaders:
            if isinstance(loader, tuple):
                yield loader[0]
                yield from flat_loaders(loader[1])
            else:
                yield loader

    app_dirs = config.get("APP_DIRS", False)
    loaders = config.get("OPTIONS", {}).get("loaders", None)
    if loaders:
        loaders = list(flat_loaders(loaders))

    # By default the app loader is included.
    has_app_loaders = (
        loaders is None or "django.template.loaders.app_directories.Loader" in loaders
    )
    return has_app_loaders or app_dirs


@register
def check_middleware(app_configs, **kwargs):
    from debug_toolbar.middleware import DebugToolbarMiddleware

    errors = []
    gzip_index = None
    debug_toolbar_indexes = []

    if all(not check_template_config(config) for config in settings.TEMPLATES):
        errors.append(
            Warning(
                "At least one DjangoTemplates TEMPLATES configuration needs "
                "to use django.template.loaders.app_directories.Loader or "
                "have APP_DIRS set to True.",
                hint=(
                    "Include django.template.loaders.app_directories.Loader "
                    'in ["OPTIONS"]["loaders"]. Alternatively use '
                    "APP_DIRS=True for at least one "
                    "django.template.backends.django.DjangoTemplates "
                    "backend configuration."
                ),
                id="debug_toolbar.W006",
            )
        )

    # If old style MIDDLEWARE_CLASSES is being used, report an error.
    if settings.is_overridden("MIDDLEWARE_CLASSES"):
        errors.append(
            Warning(
                "debug_toolbar is incompatible with MIDDLEWARE_CLASSES setting.",
                hint="Use MIDDLEWARE instead of MIDDLEWARE_CLASSES",
                id="debug_toolbar.W004",
            )
        )
        return errors

    # Determine the indexes which gzip and/or the toolbar are installed at
    for i, middleware in enumerate(settings.MIDDLEWARE):
        if is_middleware_class(GZipMiddleware, middleware):
            gzip_index = i
        elif is_middleware_class(DebugToolbarMiddleware, middleware):
            debug_toolbar_indexes.append(i)

    if not debug_toolbar_indexes:
        # If the toolbar does not appear, report an error.
        errors.append(
            Warning(
                "debug_toolbar.middleware.DebugToolbarMiddleware is missing "
                "from MIDDLEWARE.",
                hint="Add debug_toolbar.middleware.DebugToolbarMiddleware to "
                "MIDDLEWARE.",
                id="debug_toolbar.W001",
            )
        )
    elif len(debug_toolbar_indexes) != 1:
        # If the toolbar appears multiple times, report an error.
        errors.append(
            Warning(
                "debug_toolbar.middleware.DebugToolbarMiddleware occurs "
                "multiple times in MIDDLEWARE.",
                hint="Load debug_toolbar.middleware.DebugToolbarMiddleware only "
                "once in MIDDLEWARE.",
                id="debug_toolbar.W002",
            )
        )
    elif gzip_index is not None and debug_toolbar_indexes[0] < gzip_index:
        # If the toolbar appears before the gzip index, report an error.
        errors.append(
            Warning(
                "debug_toolbar.middleware.DebugToolbarMiddleware occurs before "
                "django.middleware.gzip.GZipMiddleware in MIDDLEWARE.",
                hint="Move debug_toolbar.middleware.DebugToolbarMiddleware to "
                "after django.middleware.gzip.GZipMiddleware in MIDDLEWARE.",
                id="debug_toolbar.W003",
            )
        )
    return errors


@register
def check_panel_configs(app_configs, **kwargs):
    """Allow each panel to check the toolbar's integration for their its own purposes."""
    from debug_toolbar.toolbar import DebugToolbar

    errors = []
    for panel_class in DebugToolbar.get_panel_classes():
        for check_message in panel_class.run_checks():
            errors.append(check_message)
    return errors


def is_middleware_class(middleware_class, middleware_path):
    try:
        middleware_cls = import_string(middleware_path)
    except ImportError:
        return
    return inspect.isclass(middleware_cls) and issubclass(
        middleware_cls, middleware_class
    )


@register
def check_panels(app_configs, **kwargs):
    errors = []
    panels = dt_settings.get_panels()
    if not panels:
        errors.append(
            Warning(
                "Setting DEBUG_TOOLBAR_PANELS is empty.",
                hint="Set DEBUG_TOOLBAR_PANELS to a non-empty list in your "
                "settings.py.",
                id="debug_toolbar.W005",
            )
        )
    return errors


@register()
def js_mimetype_check(app_configs, **kwargs):
    """
    Check that JavaScript files are resolving to the correct content type.
    """
    # Ideally application/javascript is returned, but text/javascript is
    # acceptable.
    javascript_types = {"application/javascript", "text/javascript"}
    check_failed = not set(mimetypes.guess_type("toolbar.js")).intersection(
        javascript_types
    )
    if check_failed:
        return [
            Warning(
                "JavaScript files are resolving to the wrong content type.",
                hint="The Django Debug Toolbar may not load properly while mimetypes are misconfigured. "
                "See the Django documentation for an explanation of why this occurs.\n"
                "https://docs.djangoproject.com/en/stable/ref/contrib/staticfiles/#static-file-development-view\n"
                "\n"
                "This typically occurs on Windows machines. The suggested solution is to modify "
                "HKEY_CLASSES_ROOT in the registry to specify the content type for JavaScript "
                "files.\n"
                "\n"
                "[HKEY_CLASSES_ROOT\\.js]\n"
                '"Content Type"="application/javascript"',
                id="debug_toolbar.W007",
            )
        ]
    return []

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\settings.py ---

import warnings
from functools import lru_cache

from django.conf import settings
from django.dispatch import receiver
from django.test.signals import setting_changed

CONFIG_DEFAULTS = {
    # Toolbar options
    "DISABLE_PANELS": {
        "debug_toolbar.panels.profiling.ProfilingPanel",
        "debug_toolbar.panels.redirects.RedirectsPanel",
    },
    "INSERT_BEFORE": "</body>",
    "RENDER_PANELS": None,
    "RESULTS_CACHE_SIZE": 25,
    "ROOT_TAG_EXTRA_ATTRS": "",
    "SHOW_COLLAPSED": False,
    "SHOW_TOOLBAR_CALLBACK": "debug_toolbar.middleware.show_toolbar",
    # Panel options
    "EXTRA_SIGNALS": [],
    "ENABLE_STACKTRACES": True,
    "ENABLE_STACKTRACES_LOCALS": False,
    "HIDE_IN_STACKTRACES": (
        "socketserver",
        "threading",
        "wsgiref",
        "debug_toolbar",
        "django.db",
        "django.core.handlers",
        "django.core.servers",
        "django.utils.decorators",
        "django.utils.deprecation",
        "django.utils.functional",
    ),
    "PRETTIFY_SQL": True,
    "PROFILER_CAPTURE_PROJECT_CODE": True,
    "PROFILER_MAX_DEPTH": 10,
    "PROFILER_THRESHOLD_RATIO": 8,
    "SHOW_TEMPLATE_CONTEXT": True,
    "SKIP_TEMPLATE_PREFIXES": ("django/forms/widgets/", "admin/widgets/"),
    "SQL_WARNING_THRESHOLD": 500,  # milliseconds
    "OBSERVE_REQUEST_CALLBACK": "debug_toolbar.toolbar.observe_request",
    "TOOLBAR_LANGUAGE": None,
}


@lru_cache(maxsize=None)
def get_config():
    USER_CONFIG = getattr(settings, "DEBUG_TOOLBAR_CONFIG", {})
    CONFIG = CONFIG_DEFAULTS.copy()
    CONFIG.update(USER_CONFIG)
    return CONFIG


PANELS_DEFAULTS = [
    "debug_toolbar.panels.history.HistoryPanel",
    "debug_toolbar.panels.versions.VersionsPanel",
    "debug_toolbar.panels.timer.TimerPanel",
    "debug_toolbar.panels.settings.SettingsPanel",
    "debug_toolbar.panels.headers.HeadersPanel",
    "debug_toolbar.panels.request.RequestPanel",
    "debug_toolbar.panels.sql.SQLPanel",
    "debug_toolbar.panels.staticfiles.StaticFilesPanel",
    "debug_toolbar.panels.templates.TemplatesPanel",
    "debug_toolbar.panels.cache.CachePanel",
    "debug_toolbar.panels.signals.SignalsPanel",
    "debug_toolbar.panels.redirects.RedirectsPanel",
    "debug_toolbar.panels.profiling.ProfilingPanel",
]


@lru_cache(maxsize=None)
def get_panels():
    try:
        PANELS = list(settings.DEBUG_TOOLBAR_PANELS)
    except AttributeError:
        PANELS = PANELS_DEFAULTS

    logging_panel = "debug_toolbar.panels.logging.LoggingPanel"
    if logging_panel in PANELS:
        PANELS = [panel for panel in PANELS if panel != logging_panel]
        warnings.warn(
            f"Please remove {logging_panel} from your DEBUG_TOOLBAR_PANELS setting.",
            DeprecationWarning,
            stacklevel=1,
        )
    return PANELS


@receiver(setting_changed)
def update_toolbar_config(*, setting, **kwargs):
    """
    Refresh configuration when overriding settings.
    """
    if setting == "DEBUG_TOOLBAR_CONFIG":
        get_config.cache_clear()
    elif setting == "DEBUG_TOOLBAR_PANELS":
        from debug_toolbar.toolbar import DebugToolbar

        get_panels.cache_clear()
        DebugToolbar._panel_classes = None
        # Not implemented: invalidate debug_toolbar.urls.

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\settings.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\urls.py ---

from debug_toolbar import APP_NAME
from debug_toolbar.toolbar import DebugToolbar

app_name = APP_NAME
urlpatterns = DebugToolbar.get_urls()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\views.py ---

from django.http import JsonResponse
from django.utils.html import escape
from django.utils.translation import gettext as _

from debug_toolbar.decorators import render_with_toolbar_language, require_show_toolbar
from debug_toolbar.toolbar import DebugToolbar


@require_show_toolbar
@render_with_toolbar_language
def render_panel(request):
    """Render the contents of a panel"""
    toolbar = DebugToolbar.fetch(request.GET["store_id"])
    if toolbar is None:
        content = _(
            "Data for this panel isn't available anymore. "
            "Please reload the page and retry."
        )
        content = "<p>%s</p>" % escape(content)
        scripts = []
    else:
        panel = toolbar.get_panel_by_id(request.GET["panel_id"])
        content = panel.content
        scripts = panel.scripts
    return JsonResponse({"content": content, "scripts": scripts})

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\debug_toolbar\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\admin\apps.py ---

from django.apps import AppConfig
from django.contrib.admin.checks import check_admin_app, check_dependencies
from django.core import checks
from django.utils.translation import gettext_lazy as _


class SimpleAdminConfig(AppConfig):
    """Simple AppConfig which does not do automatic discovery."""

    default_auto_field = "django.db.models.AutoField"
    default_site = "django.contrib.admin.sites.AdminSite"
    name = "django.contrib.admin"
    verbose_name = _("Administration")

    def ready(self):
        checks.register(check_dependencies, checks.Tags.admin)
        checks.register(check_admin_app, checks.Tags.admin)


class AdminConfig(SimpleAdminConfig):
    """The default AppConfig for admin which does autodiscovery."""

    default = True

    def ready(self):
        super().ready()
        self.module.autodiscover()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\admin\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\admin\models.py ---

import json
import warnings

from django.conf import settings
from django.contrib.admin.utils import quote
from django.contrib.contenttypes.models import ContentType
from django.db import models
from django.urls import NoReverseMatch, reverse
from django.utils import timezone
from django.utils.deprecation import RemovedInDjango60Warning
from django.utils.text import get_text_list
from django.utils.translation import gettext
from django.utils.translation import gettext_lazy as _

ADDITION = 1
CHANGE = 2
DELETION = 3

ACTION_FLAG_CHOICES = [
    (ADDITION, _("Addition")),
    (CHANGE, _("Change")),
    (DELETION, _("Deletion")),
]


class LogEntryManager(models.Manager):
    use_in_migrations = True

    def log_action(
        self,
        user_id,
        content_type_id,
        object_id,
        object_repr,
        action_flag,
        change_message="",
    ):
        warnings.warn(
            "LogEntryManager.log_action() is deprecated. Use log_actions() instead.",
            RemovedInDjango60Warning,
            stacklevel=2,
        )
        if isinstance(change_message, list):
            change_message = json.dumps(change_message)
        return self.model.objects.create(
            user_id=user_id,
            content_type_id=content_type_id,
            object_id=str(object_id),
            object_repr=object_repr[:200],
            action_flag=action_flag,
            change_message=change_message,
        )

    def log_actions(
        self, user_id, queryset, action_flag, change_message="", *, single_object=False
    ):
        # RemovedInDjango60Warning.
        if type(self).log_action != LogEntryManager.log_action:
            warnings.warn(
                "The usage of log_action() is deprecated. Implement log_actions() "
                "instead.",
                RemovedInDjango60Warning,
                stacklevel=2,
            )
            return [
                self.log_action(
                    user_id=user_id,
                    content_type_id=ContentType.objects.get_for_model(
                        obj, for_concrete_model=False
                    ).id,
                    object_id=obj.pk,
                    object_repr=str(obj),
                    action_flag=action_flag,
                    change_message=change_message,
                )
                for obj in queryset
            ]

        if isinstance(change_message, list):
            change_message = json.dumps(change_message)

        log_entry_list = [
            self.model(
                user_id=user_id,
                content_type_id=ContentType.objects.get_for_model(
                    obj, for_concrete_model=False
                ).id,
                object_id=obj.pk,
                object_repr=str(obj)[:200],
                action_flag=action_flag,
                change_message=change_message,
            )
            for obj in queryset
        ]

        if single_object and log_entry_list:
            instance = log_entry_list[0]
            instance.save()
            return instance

        return self.model.objects.bulk_create(log_entry_list)


class LogEntry(models.Model):
    action_time = models.DateTimeField(
        _("action time"),
        default=timezone.now,
        editable=False,
    )
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        models.CASCADE,
        verbose_name=_("user"),
    )
    content_type = models.ForeignKey(
        ContentType,
        models.SET_NULL,
        verbose_name=_("content type"),
        blank=True,
        null=True,
    )
    object_id = models.TextField(_("object id"), blank=True, null=True)
    # Translators: 'repr' means representation
    # (https://docs.python.org/library/functions.html#repr)
    object_repr = models.CharField(_("object repr"), max_length=200)
    action_flag = models.PositiveSmallIntegerField(
        _("action flag"), choices=ACTION_FLAG_CHOICES
    )
    # change_message is either a string or a JSON structure
    change_message = models.TextField(_("change message"), blank=True)

    objects = LogEntryManager()

    class Meta:
        verbose_name = _("log entry")
        verbose_name_plural = _("log entries")
        db_table = "django_admin_log"
        ordering = ["-action_time"]

    def __repr__(self):
        return str(self.action_time)

    def __str__(self):
        if self.is_addition():
            return gettext("Added â€œ%(object)sâ€.") % {"object": self.object_repr}
        elif self.is_change():
            return gettext("Changed â€œ%(object)sâ€ â€” %(changes)s") % {
                "object": self.object_repr,
                "changes": self.get_change_message(),
            }
        elif self.is_deletion():
            return gettext("Deleted â€œ%(object)s.â€") % {"object": self.object_repr}

        return gettext("LogEntry Object")

    def is_addition(self):
        return self.action_flag == ADDITION

    def is_change(self):
        return self.action_flag == CHANGE

    def is_deletion(self):
        return self.action_flag == DELETION

    def get_change_message(self):
        """
        If self.change_message is a JSON structure, interpret it as a change
        string, properly translated.
        """
        if self.change_message and self.change_message[0] == "[":
            try:
                change_message = json.loads(self.change_message)
            except json.JSONDecodeError:
                return self.change_message
            messages = []
            for sub_message in change_message:
                if "added" in sub_message:
                    if sub_message["added"]:
                        sub_message["added"]["name"] = gettext(
                            sub_message["added"]["name"]
                        )
                        messages.append(
                            gettext("Added {name} â€œ{object}â€.").format(
                                **sub_message["added"]
                            )
                        )
                    else:
                        messages.append(gettext("Added."))

                elif "changed" in sub_message:
                    sub_message["changed"]["fields"] = get_text_list(
                        [
                            gettext(field_name)
                            for field_name in sub_message["changed"]["fields"]
                        ],
                        gettext("and"),
                    )
                    if "name" in sub_message["changed"]:
                        sub_message["changed"]["name"] = gettext(
                            sub_message["changed"]["name"]
                        )
                        messages.append(
                            gettext("Changed {fields} for {name} â€œ{object}â€.").format(
                                **sub_message["changed"]
                            )
                        )
                    else:
                        messages.append(
                            gettext("Changed {fields}.").format(
                                **sub_message["changed"]
                            )
                        )

                elif "deleted" in sub_message:
                    sub_message["deleted"]["name"] = gettext(
                        sub_message["deleted"]["name"]
                    )
                    messages.append(
                        gettext("Deleted {name} â€œ{object}â€.").format(
                            **sub_message["deleted"]
                        )
                    )

            change_message = " ".join(msg[0].upper() + msg[1:] for msg in messages)
            return change_message or gettext("No fields changed.")
        else:
            return self.change_message

    def get_edited_object(self):
        """Return the edited object represented by this log entry."""
        return self.content_type.get_object_for_this_type(pk=self.object_id)

    def get_admin_url(self):
        """
        Return the admin URL to edit the object represented by this log entry.
        """
        if self.content_type and self.object_id:
            url_name = "admin:%s_%s_change" % (
                self.content_type.app_label,
                self.content_type.model,
            )
            try:
                return reverse(url_name, args=(quote(self.object_id),))
            except NoReverseMatch:
                pass
        return None

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\admin\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\admindocs\apps.py ---

from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _


class AdminDocsConfig(AppConfig):
    name = "django.contrib.admindocs"
    verbose_name = _("Administrative Documentation")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\admindocs\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\admindocs\urls.py ---

from django.contrib.admindocs import views
from django.urls import path, re_path

urlpatterns = [
    path(
        "",
        views.BaseAdminDocsView.as_view(template_name="admin_doc/index.html"),
        name="django-admindocs-docroot",
    ),
    path(
        "bookmarklets/",
        views.BookmarkletsView.as_view(),
        name="django-admindocs-bookmarklets",
    ),
    path(
        "tags/",
        views.TemplateTagIndexView.as_view(),
        name="django-admindocs-tags",
    ),
    path(
        "filters/",
        views.TemplateFilterIndexView.as_view(),
        name="django-admindocs-filters",
    ),
    path(
        "views/",
        views.ViewIndexView.as_view(),
        name="django-admindocs-views-index",
    ),
    path(
        "views/<view>/",
        views.ViewDetailView.as_view(),
        name="django-admindocs-views-detail",
    ),
    path(
        "models/",
        views.ModelIndexView.as_view(),
        name="django-admindocs-models-index",
    ),
    re_path(
        r"^models/(?P<app_label>[^.]+)\.(?P<model_name>[^/]+)/$",
        views.ModelDetailView.as_view(),
        name="django-admindocs-models-detail",
    ),
    path(
        "templates/<path:template>/",
        views.TemplateDetailView.as_view(),
        name="django-admindocs-templates",
    ),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\admindocs\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\admindocs\views.py ---

import inspect
from importlib import import_module
from inspect import cleandoc
from pathlib import Path

from django.apps import apps
from django.contrib import admin
from django.contrib.admin.views.decorators import staff_member_required
from django.contrib.admindocs import utils
from django.contrib.admindocs.utils import (
    remove_non_capturing_groups,
    replace_metacharacters,
    replace_named_groups,
    replace_unnamed_groups,
)
from django.core.exceptions import ImproperlyConfigured, ViewDoesNotExist
from django.db import models
from django.http import Http404
from django.template.engine import Engine
from django.urls import get_mod_func, get_resolver, get_urlconf
from django.utils._os import safe_join
from django.utils.decorators import method_decorator
from django.utils.functional import cached_property
from django.utils.inspect import (
    func_accepts_kwargs,
    func_accepts_var_args,
    get_func_full_args,
    method_has_no_args,
)
from django.utils.translation import gettext as _
from django.views.generic import TemplateView

from .utils import get_view_name

# Exclude methods starting with these strings from documentation
MODEL_METHODS_EXCLUDE = ("_", "add_", "delete", "save", "set_")


class BaseAdminDocsView(TemplateView):
    """
    Base view for admindocs views.
    """

    @method_decorator(staff_member_required)
    def dispatch(self, request, *args, **kwargs):
        if not utils.docutils_is_available:
            # Display an error message for people without docutils
            self.template_name = "admin_doc/missing_docutils.html"
            return self.render_to_response(admin.site.each_context(request))
        return super().dispatch(request, *args, **kwargs)

    def get_context_data(self, **kwargs):
        return super().get_context_data(
            **{
                **kwargs,
                **admin.site.each_context(self.request),
            }
        )


class BookmarkletsView(BaseAdminDocsView):
    template_name = "admin_doc/bookmarklets.html"


class TemplateTagIndexView(BaseAdminDocsView):
    template_name = "admin_doc/template_tag_index.html"

    def get_context_data(self, **kwargs):
        tags = []
        try:
            engine = Engine.get_default()
        except ImproperlyConfigured:
            # Non-trivial TEMPLATES settings aren't supported (#24125).
            pass
        else:
            app_libs = sorted(engine.template_libraries.items())
            builtin_libs = [("", lib) for lib in engine.template_builtins]
            for module_name, library in builtin_libs + app_libs:
                for tag_name, tag_func in library.tags.items():
                    title, body, metadata = utils.parse_docstring(tag_func.__doc__)
                    title = title and utils.parse_rst(
                        title, "tag", _("tag:") + tag_name
                    )
                    body = body and utils.parse_rst(body, "tag", _("tag:") + tag_name)
                    for key in metadata:
                        metadata[key] = utils.parse_rst(
                            metadata[key], "tag", _("tag:") + tag_name
                        )
                    tag_library = module_name.split(".")[-1]
                    tags.append(
                        {
                            "name": tag_name,
                            "title": title,
                            "body": body,
                            "meta": metadata,
                            "library": tag_library,
                        }
                    )
        return super().get_context_data(**{**kwargs, "tags": tags})


class TemplateFilterIndexView(BaseAdminDocsView):
    template_name = "admin_doc/template_filter_index.html"

    def get_context_data(self, **kwargs):
        filters = []
        try:
            engine = Engine.get_default()
        except ImproperlyConfigured:
            # Non-trivial TEMPLATES settings aren't supported (#24125).
            pass
        else:
            app_libs = sorted(engine.template_libraries.items())
            builtin_libs = [("", lib) for lib in engine.template_builtins]
            for module_name, library in builtin_libs + app_libs:
                for filter_name, filter_func in library.filters.items():
                    title, body, metadata = utils.parse_docstring(filter_func.__doc__)
                    title = title and utils.parse_rst(
                        title, "filter", _("filter:") + filter_name
                    )
                    body = body and utils.parse_rst(
                        body, "filter", _("filter:") + filter_name
                    )
                    for key in metadata:
                        metadata[key] = utils.parse_rst(
                            metadata[key], "filter", _("filter:") + filter_name
                        )
                    tag_library = module_name.split(".")[-1]
                    filters.append(
                        {
                            "name": filter_name,
                            "title": title,
                            "body": body,
                            "meta": metadata,
                            "library": tag_library,
                        }
                    )
        return super().get_context_data(**{**kwargs, "filters": filters})


class ViewIndexView(BaseAdminDocsView):
    template_name = "admin_doc/view_index.html"

    def get_context_data(self, **kwargs):
        views = []
        url_resolver = get_resolver(get_urlconf())
        try:
            view_functions = extract_views_from_urlpatterns(url_resolver.url_patterns)
        except ImproperlyConfigured:
            view_functions = []
        for func, regex, namespace, name in view_functions:
            views.append(
                {
                    "full_name": get_view_name(func),
                    "url": simplify_regex(regex),
                    "url_name": ":".join((namespace or []) + (name and [name] or [])),
                    "namespace": ":".join(namespace or []),
                    "name": name,
                }
            )
        return super().get_context_data(**{**kwargs, "views": views})


class ViewDetailView(BaseAdminDocsView):
    template_name = "admin_doc/view_detail.html"

    @staticmethod
    def _get_view_func(view):
        urlconf = get_urlconf()
        if get_resolver(urlconf)._is_callback(view):
            mod, func = get_mod_func(view)
            try:
                # Separate the module and function, e.g.
                # 'mymodule.views.myview' -> 'mymodule.views', 'myview').
                return getattr(import_module(mod), func)
            except ImportError:
                # Import may fail because view contains a class name, e.g.
                # 'mymodule.views.ViewContainer.my_view', so mod takes the form
                # 'mymodule.views.ViewContainer'. Parse it again to separate
                # the module and class.
                mod, klass = get_mod_func(mod)
                return getattr(getattr(import_module(mod), klass), func)

    def get_context_data(self, **kwargs):
        view = self.kwargs["view"]
        view_func = self._get_view_func(view)
        if view_func is None:
            raise Http404
        title, body, metadata = utils.parse_docstring(view_func.__doc__)
        title = title and utils.parse_rst(title, "view", _("view:") + view)
        body = body and utils.parse_rst(body, "view", _("view:") + view)
        for key in metadata:
            metadata[key] = utils.parse_rst(metadata[key], "model", _("view:") + view)
        return super().get_context_data(
            **{
                **kwargs,
                "name": view,
                "summary": title,
                "body": body,
                "meta": metadata,
            }
        )


class ModelIndexView(BaseAdminDocsView):
    template_name = "admin_doc/model_index.html"

    def get_context_data(self, **kwargs):
        m_list = [m._meta for m in apps.get_models()]
        return super().get_context_data(**{**kwargs, "models": m_list})


class ModelDetailView(BaseAdminDocsView):
    template_name = "admin_doc/model_detail.html"

    def get_context_data(self, **kwargs):
        model_name = self.kwargs["model_name"]
        # Get the model class.
        try:
            app_config = apps.get_app_config(self.kwargs["app_label"])
        except LookupError:
            raise Http404(_("App %(app_label)r not found") % self.kwargs)
        try:
            model = app_config.get_model(model_name)
        except LookupError:
            raise Http404(
                _("Model %(model_name)r not found in app %(app_label)r") % self.kwargs
            )

        opts = model._meta

        title, body, metadata = utils.parse_docstring(model.__doc__)
        title = title and utils.parse_rst(title, "model", _("model:") + model_name)
        body = body and utils.parse_rst(body, "model", _("model:") + model_name)

        # Gather fields/field descriptions.
        fields = []
        for field in opts.fields:
            # ForeignKey is a special case since the field will actually be a
            # descriptor that returns the other object
            if isinstance(field, models.ForeignKey):
                data_type = field.remote_field.model.__name__
                app_label = field.remote_field.model._meta.app_label
                verbose = utils.parse_rst(
                    (
                        _("the related `%(app_label)s.%(data_type)s` object")
                        % {
                            "app_label": app_label,
                            "data_type": data_type,
                        }
                    ),
                    "model",
                    _("model:") + data_type,
                )
            else:
                data_type = get_readable_field_data_type(field)
                verbose = field.verbose_name
            fields.append(
                {
                    "name": field.name,
                    "data_type": data_type,
                    "verbose": verbose or "",
                    "help_text": field.help_text,
                }
            )

        # Gather many-to-many fields.
        for field in opts.many_to_many:
            data_type = field.remote_field.model.__name__
            app_label = field.remote_field.model._meta.app_label
            verbose = _("related `%(app_label)s.%(object_name)s` objects") % {
                "app_label": app_label,
                "object_name": data_type,
            }
            fields.append(
                {
                    "name": "%s.all" % field.name,
                    "data_type": "List",
                    "verbose": utils.parse_rst(
                        _("all %s") % verbose, "model", _("model:") + opts.model_name
                    ),
                }
            )
            fields.append(
                {
                    "name": "%s.count" % field.name,
                    "data_type": "Integer",
                    "verbose": utils.parse_rst(
                        _("number of %s") % verbose,
                        "model",
                        _("model:") + opts.model_name,
                    ),
                }
            )

        methods = []
        # Gather model methods.
        for func_name, func in model.__dict__.items():
            if inspect.isfunction(func) or isinstance(
                func, (cached_property, property)
            ):
                try:
                    for exclude in MODEL_METHODS_EXCLUDE:
                        if func_name.startswith(exclude):
                            raise StopIteration
                except StopIteration:
                    continue
                verbose = func.__doc__
                verbose = verbose and (
                    utils.parse_rst(
                        cleandoc(verbose), "model", _("model:") + opts.model_name
                    )
                )
                # Show properties, cached_properties, and methods without
                # arguments as fields. Otherwise, show as a 'method with
                # arguments'.
                if isinstance(func, (cached_property, property)):
                    fields.append(
                        {
                            "name": func_name,
                            "data_type": get_return_data_type(func_name),
                            "verbose": verbose or "",
                        }
                    )
                elif (
                    method_has_no_args(func)
                    and not func_accepts_kwargs(func)
                    and not func_accepts_var_args(func)
                ):
                    fields.append(
                        {
                            "name": func_name,
                            "data_type": get_return_data_type(func_name),
                            "verbose": verbose or "",
                        }
                    )
                else:
                    arguments = get_func_full_args(func)
                    # Join arguments with ', ' and in case of default value,
                    # join it with '='. Use repr() so that strings will be
                    # correctly displayed.
                    print_arguments = ", ".join(
                        [
                            "=".join([arg_el[0], *map(repr, arg_el[1:])])
                            for arg_el in arguments
                        ]
                    )
                    methods.append(
                        {
                            "name": func_name,
                            "arguments": print_arguments,
                            "verbose": verbose or "",
                        }
                    )

        # Gather related objects
        for rel in opts.related_objects:
            verbose = _("related `%(app_label)s.%(object_name)s` objects") % {
                "app_label": rel.related_model._meta.app_label,
                "object_name": rel.related_model._meta.object_name,
            }
            accessor = rel.accessor_name
            fields.append(
                {
                    "name": "%s.all" % accessor,
                    "data_type": "List",
                    "verbose": utils.parse_rst(
                        _("all %s") % verbose, "model", _("model:") + opts.model_name
                    ),
                }
            )
            fields.append(
                {
                    "name": "%s.count" % accessor,
                    "data_type": "Integer",
                    "verbose": utils.parse_rst(
                        _("number of %s") % verbose,
                        "model",
                        _("model:") + opts.model_name,
                    ),
                }
            )
        return super().get_context_data(
            **{
                **kwargs,
                "name": opts.label,
                "summary": title,
                "description": body,
                "fields": fields,
                "methods": methods,
            }
        )


class TemplateDetailView(BaseAdminDocsView):
    template_name = "admin_doc/template_detail.html"

    def get_context_data(self, **kwargs):
        template = self.kwargs["template"]
        templates = []
        try:
            default_engine = Engine.get_default()
        except ImproperlyConfigured:
            # Non-trivial TEMPLATES settings aren't supported (#24125).
            pass
        else:
            directories = list(default_engine.dirs)
            for loader in default_engine.template_loaders:
                if hasattr(loader, "get_dirs"):
                    for dir_ in loader.get_dirs():
                        if dir_ not in directories:
                            directories.append(dir_)
            for index, directory in enumerate(directories):
                template_file = Path(safe_join(directory, template))
                if template_file.exists():
                    template_contents = template_file.read_text()
                else:
                    template_contents = ""
                templates.append(
                    {
                        "file": template_file,
                        "exists": template_file.exists(),
                        "contents": template_contents,
                        "order": index,
                    }
                )
        return super().get_context_data(
            **{
                **kwargs,
                "name": template,
                "templates": templates,
            }
        )


####################
# Helper functions #
####################


def get_return_data_type(func_name):
    """Return a somewhat-helpful data type given a function name"""
    if func_name.startswith("get_"):
        if func_name.endswith("_list"):
            return "List"
        elif func_name.endswith("_count"):
            return "Integer"
    return ""


def get_readable_field_data_type(field):
    """
    Return the description for a given field type, if it exists. Fields'
    descriptions can contain format strings, which will be interpolated with
    the values of field.__dict__ before being output.
    """
    return field.description % field.__dict__


def extract_views_from_urlpatterns(urlpatterns, base="", namespace=None):
    """
    Return a list of views from a list of urlpatterns.

    Each object in the returned list is a 4-tuple:
    (view_func, regex, namespace, name)
    """
    views = []
    for p in urlpatterns:
        if hasattr(p, "url_patterns"):
            try:
                patterns = p.url_patterns
            except ImportError:
                continue
            views.extend(
                extract_views_from_urlpatterns(
                    patterns,
                    base + str(p.pattern),
                    (namespace or []) + (p.namespace and [p.namespace] or []),
                )
            )
        elif hasattr(p, "callback"):
            try:
                views.append((p.callback, base + str(p.pattern), namespace, p.name))
            except ViewDoesNotExist:
                continue
        else:
            raise TypeError(_("%s does not appear to be a urlpattern object") % p)
    return views


def simplify_regex(pattern):
    r"""
    Clean up urlpattern regexes into something more readable by humans. For
    example, turn "^(?P<sport_slug>\w+)/athletes/(?P<athlete_slug>\w+)/$"
    into "/<sport_slug>/athletes/<athlete_slug>/".
    """
    pattern = remove_non_capturing_groups(pattern)
    pattern = replace_named_groups(pattern)
    pattern = replace_unnamed_groups(pattern)
    pattern = replace_metacharacters(pattern)
    if not pattern.startswith("/"):
        pattern = "/" + pattern
    return pattern

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\admindocs\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\auth\admin.py ---

from django.conf import settings
from django.contrib import admin, messages
from django.contrib.admin.options import IS_POPUP_VAR
from django.contrib.admin.utils import unquote
from django.contrib.auth import update_session_auth_hash
from django.contrib.auth.forms import (
    AdminPasswordChangeForm,
    AdminUserCreationForm,
    UserChangeForm,
)
from django.contrib.auth.models import Group, User
from django.core.exceptions import PermissionDenied
from django.db import router, transaction
from django.http import Http404, HttpResponseRedirect
from django.template.response import TemplateResponse
from django.urls import path, reverse
from django.utils.decorators import method_decorator
from django.utils.html import escape
from django.utils.translation import gettext
from django.utils.translation import gettext_lazy as _
from django.views.decorators.csrf import csrf_protect
from django.views.decorators.debug import sensitive_post_parameters

csrf_protect_m = method_decorator(csrf_protect)
sensitive_post_parameters_m = method_decorator(sensitive_post_parameters())


@admin.register(Group)
class GroupAdmin(admin.ModelAdmin):
    search_fields = ("name",)
    ordering = ("name",)
    filter_horizontal = ("permissions",)

    def formfield_for_manytomany(self, db_field, request=None, **kwargs):
        if db_field.name == "permissions":
            qs = kwargs.get("queryset", db_field.remote_field.model.objects)
            # Avoid a major performance hit resolving permission names which
            # triggers a content_type load:
            kwargs["queryset"] = qs.select_related("content_type")
        return super().formfield_for_manytomany(db_field, request=request, **kwargs)


@admin.register(User)
class UserAdmin(admin.ModelAdmin):
    add_form_template = "admin/auth/user/add_form.html"
    change_user_password_template = None
    fieldsets = (
        (None, {"fields": ("username", "password")}),
        (_("Personal info"), {"fields": ("first_name", "last_name", "email")}),
        (
            _("Permissions"),
            {
                "fields": (
                    "is_active",
                    "is_staff",
                    "is_superuser",
                    "groups",
                    "user_permissions",
                ),
            },
        ),
        (_("Important dates"), {"fields": ("last_login", "date_joined")}),
    )
    add_fieldsets = (
        (
            None,
            {
                "classes": ("wide",),
                "fields": ("username", "usable_password", "password1", "password2"),
            },
        ),
    )
    form = UserChangeForm
    add_form = AdminUserCreationForm
    change_password_form = AdminPasswordChangeForm
    list_display = ("username", "email", "first_name", "last_name", "is_staff")
    list_filter = ("is_staff", "is_superuser", "is_active", "groups")
    search_fields = ("username", "first_name", "last_name", "email")
    ordering = ("username",)
    filter_horizontal = (
        "groups",
        "user_permissions",
    )

    def get_fieldsets(self, request, obj=None):
        if not obj:
            return self.add_fieldsets
        return super().get_fieldsets(request, obj)

    def get_form(self, request, obj=None, **kwargs):
        """
        Use special form during user creation
        """
        defaults = {}
        if obj is None:
            defaults["form"] = self.add_form
        defaults.update(kwargs)
        return super().get_form(request, obj, **defaults)

    def get_urls(self):
        return [
            path(
                "<id>/password/",
                self.admin_site.admin_view(self.user_change_password),
                name="auth_user_password_change",
            ),
        ] + super().get_urls()

    # RemovedInDjango60Warning: when the deprecation ends, replace with:
    # def lookup_allowed(self, lookup, value, request):
    def lookup_allowed(self, lookup, value, request=None):
        # Don't allow lookups involving passwords.
        return not lookup.startswith("password") and super().lookup_allowed(
            lookup, value, request
        )

    @sensitive_post_parameters_m
    @csrf_protect_m
    def add_view(self, request, form_url="", extra_context=None):
        with transaction.atomic(using=router.db_for_write(self.model)):
            return self._add_view(request, form_url, extra_context)

    def _add_view(self, request, form_url="", extra_context=None):
        # It's an error for a user to have add permission but NOT change
        # permission for users. If we allowed such users to add users, they
        # could create superusers, which would mean they would essentially have
        # the permission to change users. To avoid the problem entirely, we
        # disallow users from adding users if they don't have change
        # permission.
        if not self.has_change_permission(request):
            if self.has_add_permission(request) and settings.DEBUG:
                # Raise Http404 in debug mode so that the user gets a helpful
                # error message.
                raise Http404(
                    'Your user does not have the "Change user" permission. In '
                    "order to add users, Django requires that your user "
                    'account have both the "Add user" and "Change user" '
                    "permissions set."
                )
            raise PermissionDenied
        if extra_context is None:
            extra_context = {}
        username_field = self.opts.get_field(self.model.USERNAME_FIELD)
        defaults = {
            "auto_populated_fields": (),
            "username_help_text": username_field.help_text,
        }
        extra_context.update(defaults)
        return super().add_view(request, form_url, extra_context)

    @sensitive_post_parameters_m
    def user_change_password(self, request, id, form_url=""):
        user = self.get_object(request, unquote(id))
        if not self.has_change_permission(request, user):
            raise PermissionDenied
        if user is None:
            raise Http404(
                _("%(name)s object with primary key %(key)r does not exist.")
                % {
                    "name": self.opts.verbose_name,
                    "key": escape(id),
                }
            )
        if request.method == "POST":
            form = self.change_password_form(user, request.POST)
            if form.is_valid():
                # If disabling password-based authentication was requested
                # (via the form field `usable_password`), the submit action
                # must be "unset-password". This check is most relevant when
                # the admin user has two submit buttons available (for example
                # when Javascript is disabled).
                valid_submission = (
                    form.cleaned_data["set_usable_password"]
                    or "unset-password" in request.POST
                )
                if not valid_submission:
                    msg = gettext("Conflicting form data submitted. Please try again.")
                    messages.error(request, msg)
                    return HttpResponseRedirect(request.get_full_path())

                user = form.save()
                change_message = self.construct_change_message(request, form, None)
                self.log_change(request, user, change_message)
                if user.has_usable_password():
                    msg = gettext("Password changed successfully.")
                else:
                    msg = gettext("Password-based authentication was disabled.")
                messages.success(request, msg)
                update_session_auth_hash(request, form.user)
                return HttpResponseRedirect(
                    reverse(
                        "%s:%s_%s_change"
                        % (
                            self.admin_site.name,
                            user._meta.app_label,
                            user._meta.model_name,
                        ),
                        args=(user.pk,),
                    )
                )
        else:
            form = self.change_password_form(user)

        fieldsets = [(None, {"fields": list(form.base_fields)})]
        admin_form = admin.helpers.AdminForm(form, fieldsets, {})

        if user.has_usable_password():
            title = _("Change password: %s")
        else:
            title = _("Set password: %s")
        context = {
            "title": title % escape(user.get_username()),
            "adminForm": admin_form,
            "form_url": form_url,
            "form": form,
            "is_popup": (IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET),
            "is_popup_var": IS_POPUP_VAR,
            "add": True,
            "change": False,
            "has_delete_permission": False,
            "has_change_permission": True,
            "has_absolute_url": False,
            "opts": self.opts,
            "original": user,
            "save_as": False,
            "show_save": True,
            **self.admin_site.each_context(request),
        }

        request.current_app = self.admin_site.name

        return TemplateResponse(
            request,
            self.change_user_password_template
            or "admin/auth/user/change_password.html",
            context,
        )

    def response_add(self, request, obj, post_url_continue=None):
        """
        Determine the HttpResponse for the add_view stage. It mostly defers to
        its superclass implementation but is customized because the User model
        has a slightly different workflow.
        """
        # We should allow further modification of the user just added i.e. the
        # 'Save' button should behave like the 'Save and continue editing'
        # button except in two scenarios:
        # * The user has pressed the 'Save and add another' button
        # * We are adding a user in a popup
        if "_addanother" not in request.POST and IS_POPUP_VAR not in request.POST:
            request.POST = request.POST.copy()
            request.POST["_continue"] = 1
        return super().response_add(request, obj, post_url_continue)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\auth\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\auth\apps.py ---

from django.apps import AppConfig
from django.core import checks
from django.db.models.query_utils import DeferredAttribute
from django.db.models.signals import post_migrate
from django.utils.translation import gettext_lazy as _

from . import get_user_model
from .checks import check_middleware, check_models_permissions, check_user_model
from .management import create_permissions
from .signals import user_logged_in


class AuthConfig(AppConfig):
    default_auto_field = "django.db.models.AutoField"
    name = "django.contrib.auth"
    verbose_name = _("Authentication and Authorization")

    def ready(self):
        post_migrate.connect(
            create_permissions,
            dispatch_uid="django.contrib.auth.management.create_permissions",
        )
        last_login_field = getattr(get_user_model(), "last_login", None)
        # Register the handler only if UserModel.last_login is a field.
        if isinstance(last_login_field, DeferredAttribute):
            from .models import update_last_login

            user_logged_in.connect(update_last_login, dispatch_uid="update_last_login")
        checks.register(check_user_model, checks.Tags.models)
        checks.register(check_models_permissions, checks.Tags.models)
        checks.register(check_middleware)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\auth\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\auth\models.py ---

from collections.abc import Iterable

from django.apps import apps
from django.contrib import auth
from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager
from django.contrib.auth.hashers import make_password
from django.contrib.contenttypes.models import ContentType
from django.core.exceptions import PermissionDenied
from django.core.mail import send_mail
from django.db import models
from django.db.models.manager import EmptyManager
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from .validators import UnicodeUsernameValidator


def update_last_login(sender, user, **kwargs):
    """
    A signal receiver which updates the last_login date for
    the user logging in.
    """
    user.last_login = timezone.now()
    user.save(update_fields=["last_login"])


class PermissionManager(models.Manager):
    use_in_migrations = True

    def get_by_natural_key(self, codename, app_label, model):
        return self.get(
            codename=codename,
            content_type=ContentType.objects.db_manager(self.db).get_by_natural_key(
                app_label, model
            ),
        )


class Permission(models.Model):
    """
    The permissions system provides a way to assign permissions to specific
    users and groups of users.

    The permission system is used by the Django admin site, but may also be
    useful in your own code. The Django admin site uses permissions as follows:

        - The "add" permission limits the user's ability to view the "add" form
          and add an object.
        - The "change" permission limits a user's ability to view the change
          list, view the "change" form and change an object.
        - The "delete" permission limits the ability to delete an object.
        - The "view" permission limits the ability to view an object.

    Permissions are set globally per type of object, not per specific object
    instance. It is possible to say "Mary may change news stories," but it's
    not currently possible to say "Mary may change news stories, but only the
    ones she created herself" or "Mary may only change news stories that have a
    certain status or publication date."

    The permissions listed above are automatically created for each model.
    """

    name = models.CharField(_("name"), max_length=255)
    content_type = models.ForeignKey(
        ContentType,
        models.CASCADE,
        verbose_name=_("content type"),
    )
    codename = models.CharField(_("codename"), max_length=100)

    objects = PermissionManager()

    class Meta:
        verbose_name = _("permission")
        verbose_name_plural = _("permissions")
        unique_together = [["content_type", "codename"]]
        ordering = ["content_type__app_label", "content_type__model", "codename"]

    def __str__(self):
        return "%s | %s" % (self.content_type, self.name)

    def natural_key(self):
        return (self.codename,) + self.content_type.natural_key()

    natural_key.dependencies = ["contenttypes.contenttype"]


class GroupManager(models.Manager):
    """
    The manager for the auth's Group model.
    """

    use_in_migrations = True

    def get_by_natural_key(self, name):
        return self.get(name=name)


class Group(models.Model):
    """
    Groups are a generic way of categorizing users to apply permissions, or
    some other label, to those users. A user can belong to any number of
    groups.

    A user in a group automatically has all the permissions granted to that
    group. For example, if the group 'Site editors' has the permission
    can_edit_home_page, any user in that group will have that permission.

    Beyond permissions, groups are a convenient way to categorize users to
    apply some label, or extended functionality, to them. For example, you
    could create a group 'Special users', and you could write code that would
    do special things to those users -- such as giving them access to a
    members-only portion of your site, or sending them members-only email
    messages.
    """

    name = models.CharField(_("name"), max_length=150, unique=True)
    permissions = models.ManyToManyField(
        Permission,
        verbose_name=_("permissions"),
        blank=True,
    )

    objects = GroupManager()

    class Meta:
        verbose_name = _("group")
        verbose_name_plural = _("groups")

    def __str__(self):
        return self.name

    def natural_key(self):
        return (self.name,)


class UserManager(BaseUserManager):
    use_in_migrations = True

    def _create_user(self, username, email, password, **extra_fields):
        """
        Create and save a user with the given username, email, and password.
        """
        if not username:
            raise ValueError("The given username must be set")
        email = self.normalize_email(email)
        # Lookup the real model class from the global app registry so this
        # manager method can be used in migrations. This is fine because
        # managers are by definition working on the real model.
        GlobalUserModel = apps.get_model(
            self.model._meta.app_label, self.model._meta.object_name
        )
        username = GlobalUserModel.normalize_username(username)
        user = self.model(username=username, email=email, **extra_fields)
        user.password = make_password(password)
        user.save(using=self._db)
        return user

    def create_user(self, username, email=None, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", False)
        extra_fields.setdefault("is_superuser", False)
        return self._create_user(username, email, password, **extra_fields)

    def create_superuser(self, username, email=None, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)

        if extra_fields.get("is_staff") is not True:
            raise ValueError("Superuser must have is_staff=True.")
        if extra_fields.get("is_superuser") is not True:
            raise ValueError("Superuser must have is_superuser=True.")

        return self._create_user(username, email, password, **extra_fields)

    def with_perm(
        self, perm, is_active=True, include_superusers=True, backend=None, obj=None
    ):
        if backend is None:
            backends = auth._get_backends(return_tuples=True)
            if len(backends) == 1:
                backend, _ = backends[0]
            else:
                raise ValueError(
                    "You have multiple authentication backends configured and "
                    "therefore must provide the `backend` argument."
                )
        elif not isinstance(backend, str):
            raise TypeError(
                "backend must be a dotted import path string (got %r)." % backend
            )
        else:
            backend = auth.load_backend(backend)
        if hasattr(backend, "with_perm"):
            return backend.with_perm(
                perm,
                is_active=is_active,
                include_superusers=include_superusers,
                obj=obj,
            )
        return self.none()


# A few helper functions for common logic between User and AnonymousUser.
def _user_get_permissions(user, obj, from_name):
    permissions = set()
    name = "get_%s_permissions" % from_name
    for backend in auth.get_backends():
        if hasattr(backend, name):
            permissions.update(getattr(backend, name)(user, obj))
    return permissions


def _user_has_perm(user, perm, obj):
    """
    A backend can raise `PermissionDenied` to short-circuit permission checking.
    """
    for backend in auth.get_backends():
        if not hasattr(backend, "has_perm"):
            continue
        try:
            if backend.has_perm(user, perm, obj):
                return True
        except PermissionDenied:
            return False
    return False


def _user_has_module_perms(user, app_label):
    """
    A backend can raise `PermissionDenied` to short-circuit permission checking.
    """
    for backend in auth.get_backends():
        if not hasattr(backend, "has_module_perms"):
            continue
        try:
            if backend.has_module_perms(user, app_label):
                return True
        except PermissionDenied:
            return False
    return False


class PermissionsMixin(models.Model):
    """
    Add the fields and methods necessary to support the Group and Permission
    models using the ModelBackend.
    """

    is_superuser = models.BooleanField(
        _("superuser status"),
        default=False,
        help_text=_(
            "Designates that this user has all permissions without "
            "explicitly assigning them."
        ),
    )
    groups = models.ManyToManyField(
        Group,
        verbose_name=_("groups"),
        blank=True,
        help_text=_(
            "The groups this user belongs to. A user will get all permissions "
            "granted to each of their groups."
        ),
        related_name="user_set",
        related_query_name="user",
    )
    user_permissions = models.ManyToManyField(
        Permission,
        verbose_name=_("user permissions"),
        blank=True,
        help_text=_("Specific permissions for this user."),
        related_name="user_set",
        related_query_name="user",
    )

    class Meta:
        abstract = True

    def get_user_permissions(self, obj=None):
        """
        Return a list of permission strings that this user has directly.
        Query all available auth backends. If an object is passed in,
        return only permissions matching this object.
        """
        return _user_get_permissions(self, obj, "user")

    def get_group_permissions(self, obj=None):
        """
        Return a list of permission strings that this user has through their
        groups. Query all available auth backends. If an object is passed in,
        return only permissions matching this object.
        """
        return _user_get_permissions(self, obj, "group")

    def get_all_permissions(self, obj=None):
        return _user_get_permissions(self, obj, "all")

    def has_perm(self, perm, obj=None):
        """
        Return True if the user has the specified permission. Query all
        available auth backends, but return immediately if any backend returns
        True. Thus, a user who has permission from a single auth backend is
        assumed to have permission in general. If an object is provided, check
        permissions for that object.
        """
        # Active superusers have all permissions.
        if self.is_active and self.is_superuser:
            return True

        # Otherwise we need to check the backends.
        return _user_has_perm(self, perm, obj)

    def has_perms(self, perm_list, obj=None):
        """
        Return True if the user has each of the specified permissions. If
        object is passed, check if the user has all required perms for it.
        """
        if not isinstance(perm_list, Iterable) or isinstance(perm_list, str):
            raise ValueError("perm_list must be an iterable of permissions.")
        return all(self.has_perm(perm, obj) for perm in perm_list)

    def has_module_perms(self, app_label):
        """
        Return True if the user has any permissions in the given app label.
        Use similar logic as has_perm(), above.
        """
        # Active superusers have all permissions.
        if self.is_active and self.is_superuser:
            return True

        return _user_has_module_perms(self, app_label)


class AbstractUser(AbstractBaseUser, PermissionsMixin):
    """
    An abstract base class implementing a fully featured User model with
    admin-compliant permissions.

    Username and password are required. Other fields are optional.
    """

    username_validator = UnicodeUsernameValidator()

    username = models.CharField(
        _("username"),
        max_length=150,
        unique=True,
        help_text=_(
            "Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."
        ),
        validators=[username_validator],
        error_messages={
            "unique": _("A user with that username already exists."),
        },
    )
    first_name = models.CharField(_("first name"), max_length=150, blank=True)
    last_name = models.CharField(_("last name"), max_length=150, blank=True)
    email = models.EmailField(_("email address"), blank=True)
    is_staff = models.BooleanField(
        _("staff status"),
        default=False,
        help_text=_("Designates whether the user can log into this admin site."),
    )
    is_active = models.BooleanField(
        _("active"),
        default=True,
        help_text=_(
            "Designates whether this user should be treated as active. "
            "Unselect this instead of deleting accounts."
        ),
    )
    date_joined = models.DateTimeField(_("date joined"), default=timezone.now)

    objects = UserManager()

    EMAIL_FIELD = "email"
    USERNAME_FIELD = "username"
    REQUIRED_FIELDS = ["email"]

    class Meta:
        verbose_name = _("user")
        verbose_name_plural = _("users")
        abstract = True

    def clean(self):
        super().clean()
        self.email = self.__class__.objects.normalize_email(self.email)

    def get_full_name(self):
        """
        Return the first_name plus the last_name, with a space in between.
        """
        full_name = "%s %s" % (self.first_name, self.last_name)
        return full_name.strip()

    def get_short_name(self):
        """Return the short name for the user."""
        return self.first_name

    def email_user(self, subject, message, from_email=None, **kwargs):
        """Send an email to this user."""
        send_mail(subject, message, from_email, [self.email], **kwargs)


class User(AbstractUser):
    """
    Users within the Django authentication system are represented by this
    model.

    Username and password are required. Other fields are optional.
    """

    class Meta(AbstractUser.Meta):
        swappable = "AUTH_USER_MODEL"


class AnonymousUser:
    id = None
    pk = None
    username = ""
    is_staff = False
    is_active = False
    is_superuser = False
    _groups = EmptyManager(Group)
    _user_permissions = EmptyManager(Permission)

    def __str__(self):
        return "AnonymousUser"

    def __eq__(self, other):
        return isinstance(other, self.__class__)

    def __hash__(self):
        return 1  # instances always return the same hash value

    def __int__(self):
        raise TypeError(
            "Cannot cast AnonymousUser to int. Are you trying to use it in place of "
            "User?"
        )

    def save(self):
        raise NotImplementedError(
            "Django doesn't provide a DB representation for AnonymousUser."
        )

    def delete(self):
        raise NotImplementedError(
            "Django doesn't provide a DB representation for AnonymousUser."
        )

    def set_password(self, raw_password):
        raise NotImplementedError(
            "Django doesn't provide a DB representation for AnonymousUser."
        )

    def check_password(self, raw_password):
        raise NotImplementedError(
            "Django doesn't provide a DB representation for AnonymousUser."
        )

    @property
    def groups(self):
        return self._groups

    @property
    def user_permissions(self):
        return self._user_permissions

    def get_user_permissions(self, obj=None):
        return _user_get_permissions(self, obj, "user")

    def get_group_permissions(self, obj=None):
        return set()

    def get_all_permissions(self, obj=None):
        return _user_get_permissions(self, obj, "all")

    def has_perm(self, perm, obj=None):
        return _user_has_perm(self, perm, obj=obj)

    def has_perms(self, perm_list, obj=None):
        if not isinstance(perm_list, Iterable) or isinstance(perm_list, str):
            raise ValueError("perm_list must be an iterable of permissions.")
        return all(self.has_perm(perm, obj) for perm in perm_list)

    def has_module_perms(self, module):
        return _user_has_module_perms(self, module)

    @property
    def is_anonymous(self):
        return True

    @property
    def is_authenticated(self):
        return False

    def get_username(self):
        return self.username

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\auth\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\auth\urls.py ---

# The views used below are normally mapped in the AdminSite instance.
# This URLs file is used to provide a reliable view deployment for test purposes.
# It is also provided as a convenience to those who want to deploy these URLs
# elsewhere.

from django.contrib.auth import views
from django.urls import path

urlpatterns = [
    path("login/", views.LoginView.as_view(), name="login"),
    path("logout/", views.LogoutView.as_view(), name="logout"),
    path(
        "password_change/", views.PasswordChangeView.as_view(), name="password_change"
    ),
    path(
        "password_change/done/",
        views.PasswordChangeDoneView.as_view(),
        name="password_change_done",
    ),
    path("password_reset/", views.PasswordResetView.as_view(), name="password_reset"),
    path(
        "password_reset/done/",
        views.PasswordResetDoneView.as_view(),
        name="password_reset_done",
    ),
    path(
        "reset/<uidb64>/<token>/",
        views.PasswordResetConfirmView.as_view(),
        name="password_reset_confirm",
    ),
    path(
        "reset/done/",
        views.PasswordResetCompleteView.as_view(),
        name="password_reset_complete",
    ),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\auth\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\auth\views.py ---

from urllib.parse import urlparse, urlunparse

from django.conf import settings

# Avoid shadowing the login() and logout() views below.
from django.contrib.auth import REDIRECT_FIELD_NAME, get_user_model
from django.contrib.auth import login as auth_login
from django.contrib.auth import logout as auth_logout
from django.contrib.auth import update_session_auth_hash
from django.contrib.auth.decorators import login_not_required, login_required
from django.contrib.auth.forms import (
    AuthenticationForm,
    PasswordChangeForm,
    PasswordResetForm,
    SetPasswordForm,
)
from django.contrib.auth.tokens import default_token_generator
from django.contrib.sites.shortcuts import get_current_site
from django.core.exceptions import ImproperlyConfigured, ValidationError
from django.http import HttpResponseRedirect, QueryDict
from django.shortcuts import resolve_url
from django.urls import reverse_lazy
from django.utils.decorators import method_decorator
from django.utils.http import url_has_allowed_host_and_scheme, urlsafe_base64_decode
from django.utils.translation import gettext_lazy as _
from django.views.decorators.cache import never_cache
from django.views.decorators.csrf import csrf_protect
from django.views.decorators.debug import sensitive_post_parameters
from django.views.generic.base import TemplateView
from django.views.generic.edit import FormView

UserModel = get_user_model()


class RedirectURLMixin:
    next_page = None
    redirect_field_name = REDIRECT_FIELD_NAME
    success_url_allowed_hosts = set()

    def get_success_url(self):
        return self.get_redirect_url() or self.get_default_redirect_url()

    def get_redirect_url(self):
        """Return the user-originating redirect URL if it's safe."""
        redirect_to = self.request.POST.get(
            self.redirect_field_name, self.request.GET.get(self.redirect_field_name)
        )
        url_is_safe = url_has_allowed_host_and_scheme(
            url=redirect_to,
            allowed_hosts=self.get_success_url_allowed_hosts(),
            require_https=self.request.is_secure(),
        )
        return redirect_to if url_is_safe else ""

    def get_success_url_allowed_hosts(self):
        return {self.request.get_host(), *self.success_url_allowed_hosts}

    def get_default_redirect_url(self):
        """Return the default redirect URL."""
        if self.next_page:
            return resolve_url(self.next_page)
        raise ImproperlyConfigured("No URL to redirect to. Provide a next_page.")


@method_decorator(login_not_required, name="dispatch")
class LoginView(RedirectURLMixin, FormView):
    """
    Display the login form and handle the login action.
    """

    form_class = AuthenticationForm
    authentication_form = None
    template_name = "registration/login.html"
    redirect_authenticated_user = False
    extra_context = None

    @method_decorator(sensitive_post_parameters())
    @method_decorator(csrf_protect)
    @method_decorator(never_cache)
    def dispatch(self, request, *args, **kwargs):
        if self.redirect_authenticated_user and self.request.user.is_authenticated:
            redirect_to = self.get_success_url()
            if redirect_to == self.request.path:
                raise ValueError(
                    "Redirection loop for authenticated user detected. Check that "
                    "your LOGIN_REDIRECT_URL doesn't point to a login page."
                )
            return HttpResponseRedirect(redirect_to)
        return super().dispatch(request, *args, **kwargs)

    def get_default_redirect_url(self):
        """Return the default redirect URL."""
        if self.next_page:
            return resolve_url(self.next_page)
        else:
            return resolve_url(settings.LOGIN_REDIRECT_URL)

    def get_form_class(self):
        return self.authentication_form or self.form_class

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs["request"] = self.request
        return kwargs

    def form_valid(self, form):
        """Security check complete. Log the user in."""
        auth_login(self.request, form.get_user())
        return HttpResponseRedirect(self.get_success_url())

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        current_site = get_current_site(self.request)
        context.update(
            {
                self.redirect_field_name: self.get_redirect_url(),
                "site": current_site,
                "site_name": current_site.name,
                **(self.extra_context or {}),
            }
        )
        return context


class LogoutView(RedirectURLMixin, TemplateView):
    """
    Log out the user and display the 'You are logged out' message.
    """

    http_method_names = ["post", "options"]
    template_name = "registration/logged_out.html"
    extra_context = None

    @method_decorator(csrf_protect)
    @method_decorator(never_cache)
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        """Logout may be done via POST."""
        auth_logout(request)
        redirect_to = self.get_success_url()
        if redirect_to != request.get_full_path():
            # Redirect to target page once the session has been cleared.
            return HttpResponseRedirect(redirect_to)
        return super().get(request, *args, **kwargs)

    def get_default_redirect_url(self):
        """Return the default redirect URL."""
        if self.next_page:
            return resolve_url(self.next_page)
        elif settings.LOGOUT_REDIRECT_URL:
            return resolve_url(settings.LOGOUT_REDIRECT_URL)
        else:
            return self.request.path

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        current_site = get_current_site(self.request)
        context.update(
            {
                "site": current_site,
                "site_name": current_site.name,
                "title": _("Logged out"),
                "subtitle": None,
                **(self.extra_context or {}),
            }
        )
        return context


def logout_then_login(request, login_url=None):
    """
    Log out the user if they are logged in. Then redirect to the login page.
    """
    login_url = resolve_url(login_url or settings.LOGIN_URL)
    return LogoutView.as_view(next_page=login_url)(request)


def redirect_to_login(next, login_url=None, redirect_field_name=REDIRECT_FIELD_NAME):
    """
    Redirect the user to the login page, passing the given 'next' page.
    """
    resolved_url = resolve_url(login_url or settings.LOGIN_URL)

    login_url_parts = list(urlparse(resolved_url))
    if redirect_field_name:
        querystring = QueryDict(login_url_parts[4], mutable=True)
        querystring[redirect_field_name] = next
        login_url_parts[4] = querystring.urlencode(safe="/")

    return HttpResponseRedirect(urlunparse(login_url_parts))


# Class-based password reset views
# - PasswordResetView sends the mail
# - PasswordResetDoneView shows a success message for the above
# - PasswordResetConfirmView checks the link the user clicked and
#   prompts for a new password
# - PasswordResetCompleteView shows a success message for the above


class PasswordContextMixin:
    extra_context = None

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context.update(
            {"title": self.title, "subtitle": None, **(self.extra_context or {})}
        )
        return context


@method_decorator(login_not_required, name="dispatch")
class PasswordResetView(PasswordContextMixin, FormView):
    email_template_name = "registration/password_reset_email.html"
    extra_email_context = None
    form_class = PasswordResetForm
    from_email = None
    html_email_template_name = None
    subject_template_name = "registration/password_reset_subject.txt"
    success_url = reverse_lazy("password_reset_done")
    template_name = "registration/password_reset_form.html"
    title = _("Password reset")
    token_generator = default_token_generator

    @method_decorator(csrf_protect)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)

    def form_valid(self, form):
        opts = {
            "use_https": self.request.is_secure(),
            "token_generator": self.token_generator,
            "from_email": self.from_email,
            "email_template_name": self.email_template_name,
            "subject_template_name": self.subject_template_name,
            "request": self.request,
            "html_email_template_name": self.html_email_template_name,
            "extra_email_context": self.extra_email_context,
        }
        form.save(**opts)
        return super().form_valid(form)


INTERNAL_RESET_SESSION_TOKEN = "_password_reset_token"


@method_decorator(login_not_required, name="dispatch")
class PasswordResetDoneView(PasswordContextMixin, TemplateView):
    template_name = "registration/password_reset_done.html"
    title = _("Password reset sent")


@method_decorator(login_not_required, name="dispatch")
class PasswordResetConfirmView(PasswordContextMixin, FormView):
    form_class = SetPasswordForm
    post_reset_login = False
    post_reset_login_backend = None
    reset_url_token = "set-password"
    success_url = reverse_lazy("password_reset_complete")
    template_name = "registration/password_reset_confirm.html"
    title = _("Enter new password")
    token_generator = default_token_generator

    @method_decorator(sensitive_post_parameters())
    @method_decorator(never_cache)
    def dispatch(self, *args, **kwargs):
        if "uidb64" not in kwargs or "token" not in kwargs:
            raise ImproperlyConfigured(
                "The URL path must contain 'uidb64' and 'token' parameters."
            )

        self.validlink = False
        self.user = self.get_user(kwargs["uidb64"])

        if self.user is not None:
            token = kwargs["token"]
            if token == self.reset_url_token:
                session_token = self.request.session.get(INTERNAL_RESET_SESSION_TOKEN)
                if self.token_generator.check_token(self.user, session_token):
                    # If the token is valid, display the password reset form.
                    self.validlink = True
                    return super().dispatch(*args, **kwargs)
            else:
                if self.token_generator.check_token(self.user, token):
                    # Store the token in the session and redirect to the
                    # password reset form at a URL without the token. That
                    # avoids the possibility of leaking the token in the
                    # HTTP Referer header.
                    self.request.session[INTERNAL_RESET_SESSION_TOKEN] = token
                    redirect_url = self.request.path.replace(
                        token, self.reset_url_token
                    )
                    return HttpResponseRedirect(redirect_url)

        # Display the "Password reset unsuccessful" page.
        return self.render_to_response(self.get_context_data())

    def get_user(self, uidb64):
        try:
            # urlsafe_base64_decode() decodes to bytestring
            uid = urlsafe_base64_decode(uidb64).decode()
            user = UserModel._default_manager.get(pk=uid)
        except (
            TypeError,
            ValueError,
            OverflowError,
            UserModel.DoesNotExist,
            ValidationError,
        ):
            user = None
        return user

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs["user"] = self.user
        return kwargs

    def form_valid(self, form):
        user = form.save()
        del self.request.session[INTERNAL_RESET_SESSION_TOKEN]
        if self.post_reset_login:
            auth_login(self.request, user, self.post_reset_login_backend)
        return super().form_valid(form)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        if self.validlink:
            context["validlink"] = True
        else:
            context.update(
                {
                    "form": None,
                    "title": _("Password reset unsuccessful"),
                    "validlink": False,
                }
            )
        return context


@method_decorator(login_not_required, name="dispatch")
class PasswordResetCompleteView(PasswordContextMixin, TemplateView):
    template_name = "registration/password_reset_complete.html"
    title = _("Password reset complete")

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context["login_url"] = resolve_url(settings.LOGIN_URL)
        return context


class PasswordChangeView(PasswordContextMixin, FormView):
    form_class = PasswordChangeForm
    success_url = reverse_lazy("password_change_done")
    template_name = "registration/password_change_form.html"
    title = _("Password change")

    @method_decorator(sensitive_post_parameters())
    @method_decorator(csrf_protect)
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs["user"] = self.request.user
        return kwargs

    def form_valid(self, form):
        form.save()
        # Updating the password logs out all other sessions for the user
        # except the current one.
        update_session_auth_hash(self.request, form.user)
        return super().form_valid(form)


class PasswordChangeDoneView(PasswordContextMixin, TemplateView):
    template_name = "registration/password_change_done.html"
    title = _("Password change successful")

    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\auth\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\contenttypes\admin.py ---

from functools import partial

from django.contrib.admin.checks import InlineModelAdminChecks
from django.contrib.admin.options import InlineModelAdmin, flatten_fieldsets
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.forms import (
    BaseGenericInlineFormSet,
    generic_inlineformset_factory,
)
from django.core import checks
from django.core.exceptions import FieldDoesNotExist
from django.forms import ALL_FIELDS
from django.forms.models import modelform_defines_fields


class GenericInlineModelAdminChecks(InlineModelAdminChecks):
    def _check_exclude_of_parent_model(self, obj, parent_model):
        # There's no FK to exclude, so no exclusion checks are required.
        return []

    def _check_relation(self, obj, parent_model):
        # There's no FK, but we do need to confirm that the ct_field and
        # ct_fk_field are valid, and that they are part of a GenericForeignKey.

        gfks = [
            f
            for f in obj.model._meta.private_fields
            if isinstance(f, GenericForeignKey)
        ]
        if not gfks:
            return [
                checks.Error(
                    "'%s' has no GenericForeignKey." % obj.model._meta.label,
                    obj=obj.__class__,
                    id="admin.E301",
                )
            ]
        else:
            # Check that the ct_field and ct_fk_fields exist
            try:
                obj.model._meta.get_field(obj.ct_field)
            except FieldDoesNotExist:
                return [
                    checks.Error(
                        "'ct_field' references '%s', which is not a field on '%s'."
                        % (
                            obj.ct_field,
                            obj.model._meta.label,
                        ),
                        obj=obj.__class__,
                        id="admin.E302",
                    )
                ]

            try:
                obj.model._meta.get_field(obj.ct_fk_field)
            except FieldDoesNotExist:
                return [
                    checks.Error(
                        "'ct_fk_field' references '%s', which is not a field on '%s'."
                        % (
                            obj.ct_fk_field,
                            obj.model._meta.label,
                        ),
                        obj=obj.__class__,
                        id="admin.E303",
                    )
                ]

            # There's one or more GenericForeignKeys; make sure that one of them
            # uses the right ct_field and ct_fk_field.
            for gfk in gfks:
                if gfk.ct_field == obj.ct_field and gfk.fk_field == obj.ct_fk_field:
                    return []

            return [
                checks.Error(
                    "'%s' has no GenericForeignKey using content type field '%s' and "
                    "object ID field '%s'."
                    % (
                        obj.model._meta.label,
                        obj.ct_field,
                        obj.ct_fk_field,
                    ),
                    obj=obj.__class__,
                    id="admin.E304",
                )
            ]


class GenericInlineModelAdmin(InlineModelAdmin):
    ct_field = "content_type"
    ct_fk_field = "object_id"
    formset = BaseGenericInlineFormSet

    checks_class = GenericInlineModelAdminChecks

    def get_formset(self, request, obj=None, **kwargs):
        if "fields" in kwargs:
            fields = kwargs.pop("fields")
        else:
            fields = flatten_fieldsets(self.get_fieldsets(request, obj))
        exclude = [*(self.exclude or []), *self.get_readonly_fields(request, obj)]
        if (
            self.exclude is None
            and hasattr(self.form, "_meta")
            and self.form._meta.exclude
        ):
            # Take the custom ModelForm's Meta.exclude into account only if the
            # GenericInlineModelAdmin doesn't define its own.
            exclude.extend(self.form._meta.exclude)
        exclude = exclude or None
        can_delete = self.can_delete and self.has_delete_permission(request, obj)
        defaults = {
            "ct_field": self.ct_field,
            "fk_field": self.ct_fk_field,
            "form": self.form,
            "formfield_callback": partial(self.formfield_for_dbfield, request=request),
            "formset": self.formset,
            "extra": self.get_extra(request, obj),
            "can_delete": can_delete,
            "can_order": False,
            "fields": fields,
            "min_num": self.get_min_num(request, obj),
            "max_num": self.get_max_num(request, obj),
            "exclude": exclude,
            **kwargs,
        }

        if defaults["fields"] is None and not modelform_defines_fields(
            defaults["form"]
        ):
            defaults["fields"] = ALL_FIELDS

        return generic_inlineformset_factory(self.model, **defaults)


class GenericStackedInline(GenericInlineModelAdmin):
    template = "admin/edit_inline/stacked.html"


class GenericTabularInline(GenericInlineModelAdmin):
    template = "admin/edit_inline/tabular.html"

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\contenttypes\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\contenttypes\apps.py ---

from django.apps import AppConfig
from django.contrib.contenttypes.checks import (
    check_generic_foreign_keys,
    check_model_name_lengths,
)
from django.core import checks
from django.db.models.signals import post_migrate, pre_migrate
from django.utils.translation import gettext_lazy as _

from .management import create_contenttypes, inject_rename_contenttypes_operations


class ContentTypesConfig(AppConfig):
    default_auto_field = "django.db.models.AutoField"
    name = "django.contrib.contenttypes"
    verbose_name = _("Content Types")

    def ready(self):
        pre_migrate.connect(inject_rename_contenttypes_operations, sender=self)
        post_migrate.connect(create_contenttypes)
        checks.register(check_generic_foreign_keys, checks.Tags.models)
        checks.register(check_model_name_lengths, checks.Tags.models)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\contenttypes\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\contenttypes\models.py ---

from collections import defaultdict

from django.apps import apps
from django.db import models
from django.db.models import Q
from django.utils.translation import gettext_lazy as _


class ContentTypeManager(models.Manager):
    use_in_migrations = True

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Cache shared by all the get_for_* methods to speed up
        # ContentType retrieval.
        self._cache = {}

    def get_by_natural_key(self, app_label, model):
        try:
            ct = self._cache[self.db][(app_label, model)]
        except KeyError:
            ct = self.get(app_label=app_label, model=model)
            self._add_to_cache(self.db, ct)
        return ct

    def _get_opts(self, model, for_concrete_model):
        if for_concrete_model:
            model = model._meta.concrete_model
        return model._meta

    def _get_from_cache(self, opts):
        key = (opts.app_label, opts.model_name)
        return self._cache[self.db][key]

    def get_for_model(self, model, for_concrete_model=True):
        """
        Return the ContentType object for a given model, creating the
        ContentType if necessary. Lookups are cached so that subsequent lookups
        for the same model don't hit the database.
        """
        opts = self._get_opts(model, for_concrete_model)
        try:
            return self._get_from_cache(opts)
        except KeyError:
            pass

        # The ContentType entry was not found in the cache, therefore we
        # proceed to load or create it.
        try:
            # Start with get() and not get_or_create() in order to use
            # the db_for_read (see #20401).
            ct = self.get(app_label=opts.app_label, model=opts.model_name)
        except self.model.DoesNotExist:
            # Not found in the database; we proceed to create it. This time
            # use get_or_create to take care of any race conditions.
            ct, created = self.get_or_create(
                app_label=opts.app_label,
                model=opts.model_name,
            )
        self._add_to_cache(self.db, ct)
        return ct

    def get_for_models(self, *models, for_concrete_models=True):
        """
        Given *models, return a dictionary mapping {model: content_type}.
        """
        results = {}
        # Models that aren't already in the cache grouped by app labels.
        needed_models = defaultdict(set)
        # Mapping of opts to the list of models requiring it.
        needed_opts = defaultdict(list)
        for model in models:
            opts = self._get_opts(model, for_concrete_models)
            try:
                ct = self._get_from_cache(opts)
            except KeyError:
                needed_models[opts.app_label].add(opts.model_name)
                needed_opts[(opts.app_label, opts.model_name)].append(model)
            else:
                results[model] = ct
        if needed_opts:
            # Lookup required content types from the DB.
            condition = Q(
                *(
                    Q(("app_label", app_label), ("model__in", models))
                    for app_label, models in needed_models.items()
                ),
                _connector=Q.OR,
            )
            cts = self.filter(condition)
            for ct in cts:
                opts_models = needed_opts.pop((ct.app_label, ct.model), [])
                for model in opts_models:
                    results[model] = ct
                self._add_to_cache(self.db, ct)
        # Create content types that weren't in the cache or DB.
        for (app_label, model_name), opts_models in needed_opts.items():
            ct = self.create(app_label=app_label, model=model_name)
            self._add_to_cache(self.db, ct)
            for model in opts_models:
                results[model] = ct
        return results

    def get_for_id(self, id):
        """
        Lookup a ContentType by ID. Use the same shared cache as get_for_model
        (though ContentTypes are not created on-the-fly by get_by_id).
        """
        try:
            ct = self._cache[self.db][id]
        except KeyError:
            # This could raise a DoesNotExist; that's correct behavior and will
            # make sure that only correct ctypes get stored in the cache dict.
            ct = self.get(pk=id)
            self._add_to_cache(self.db, ct)
        return ct

    def clear_cache(self):
        """
        Clear out the content-type cache.
        """
        self._cache.clear()

    def _add_to_cache(self, using, ct):
        """Insert a ContentType into the cache."""
        # Note it's possible for ContentType objects to be stale; model_class()
        # will return None. Hence, there is no reliance on
        # model._meta.app_label here, just using the model fields instead.
        key = (ct.app_label, ct.model)
        self._cache.setdefault(using, {})[key] = ct
        self._cache.setdefault(using, {})[ct.id] = ct


class ContentType(models.Model):
    app_label = models.CharField(max_length=100)
    model = models.CharField(_("python model class name"), max_length=100)
    objects = ContentTypeManager()

    class Meta:
        verbose_name = _("content type")
        verbose_name_plural = _("content types")
        db_table = "django_content_type"
        unique_together = [["app_label", "model"]]

    def __str__(self):
        return self.app_labeled_name

    @property
    def name(self):
        model = self.model_class()
        if not model:
            return self.model
        return str(model._meta.verbose_name)

    @property
    def app_labeled_name(self):
        model = self.model_class()
        if not model:
            return self.model
        return "%s | %s" % (
            model._meta.app_config.verbose_name,
            model._meta.verbose_name,
        )

    def model_class(self):
        """Return the model class for this type of content."""
        try:
            return apps.get_model(self.app_label, self.model)
        except LookupError:
            return None

    def get_object_for_this_type(self, using=None, **kwargs):
        """
        Return an object of this type for the keyword arguments given.
        Basically, this is a proxy around this object_type's get_object() model
        method. The ObjectNotExist exception, if thrown, will not be caught,
        so code that calls this method should catch it.
        """
        return self.model_class()._base_manager.using(using).get(**kwargs)

    def get_all_objects_for_this_type(self, **kwargs):
        """
        Return all objects of this type for the keyword arguments given.
        """
        return self.model_class()._base_manager.filter(**kwargs)

    def natural_key(self):
        return (self.app_label, self.model)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\contenttypes\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\contenttypes\views.py ---

from django.apps import apps
from django.contrib.contenttypes.models import ContentType
from django.contrib.sites.shortcuts import get_current_site
from django.core.exceptions import ObjectDoesNotExist
from django.http import Http404, HttpResponseRedirect
from django.utils.translation import gettext as _


def shortcut(request, content_type_id, object_id):
    """
    Redirect to an object's page based on a content-type ID and an object ID.
    """
    # Look up the object, making sure it's got a get_absolute_url() function.
    try:
        content_type = ContentType.objects.get(pk=content_type_id)
        if not content_type.model_class():
            raise Http404(
                _("Content type %(ct_id)s object has no associated model")
                % {"ct_id": content_type_id}
            )
        obj = content_type.get_object_for_this_type(pk=object_id)
    except (ObjectDoesNotExist, ValueError):
        raise Http404(
            _("Content type %(ct_id)s object %(obj_id)s doesnâ€™t exist")
            % {"ct_id": content_type_id, "obj_id": object_id}
        )

    try:
        get_absolute_url = obj.get_absolute_url
    except AttributeError:
        raise Http404(
            _("%(ct_name)s objects donâ€™t have a get_absolute_url() method")
            % {"ct_name": content_type.name}
        )
    absurl = get_absolute_url()

    # Try to figure out the object's domain, so we can do a cross-site redirect
    # if necessary.

    # If the object actually defines a domain, we're done.
    if absurl.startswith(("http://", "https://", "//")):
        return HttpResponseRedirect(absurl)

    # Otherwise, we need to introspect the object's relationships for a
    # relation to the Site object
    try:
        object_domain = get_current_site(request).domain
    except ObjectDoesNotExist:
        object_domain = None

    if apps.is_installed("django.contrib.sites"):
        Site = apps.get_model("sites.Site")
        opts = obj._meta

        for field in opts.many_to_many:
            # Look for a many-to-many relationship to Site.
            if field.remote_field.model is Site:
                site_qs = getattr(obj, field.name).all()
                if object_domain and site_qs.filter(domain=object_domain).exists():
                    # The current site's domain matches a site attached to the
                    # object.
                    break
                # Caveat: In the case of multiple related Sites, this just
                # selects the *first* one, which is arbitrary.
                site = site_qs.first()
                if site:
                    object_domain = site.domain
                    break
        else:
            # No many-to-many relationship to Site found. Look for a
            # many-to-one relationship to Site.
            for field in obj._meta.fields:
                if field.remote_field and field.remote_field.model is Site:
                    try:
                        site = getattr(obj, field.name)
                    except Site.DoesNotExist:
                        continue
                    if site is not None:
                        object_domain = site.domain
                        break

    # If all that malarkey found an object domain, use it. Otherwise, fall back
    # to whatever get_absolute_url() returned.
    if object_domain is not None:
        protocol = request.scheme
        return HttpResponseRedirect("%s://%s%s" % (protocol, object_domain, absurl))
    else:
        return HttpResponseRedirect(absurl)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\contenttypes\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\flatpages\admin.py ---

from django.contrib import admin
from django.contrib.flatpages.forms import FlatpageForm
from django.contrib.flatpages.models import FlatPage
from django.utils.translation import gettext_lazy as _


@admin.register(FlatPage)
class FlatPageAdmin(admin.ModelAdmin):
    form = FlatpageForm
    fieldsets = (
        (None, {"fields": ("url", "title", "content", "sites")}),
        (
            _("Advanced options"),
            {
                "classes": ("collapse",),
                "fields": ("registration_required", "template_name"),
            },
        ),
    )
    list_display = ("url", "title")
    list_filter = ("sites", "registration_required")
    search_fields = ("url", "title")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\flatpages\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\flatpages\apps.py ---

from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _


class FlatPagesConfig(AppConfig):
    default_auto_field = "django.db.models.AutoField"
    name = "django.contrib.flatpages"
    verbose_name = _("Flat Pages")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\flatpages\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\flatpages\models.py ---

from django.contrib.sites.models import Site
from django.db import models
from django.urls import NoReverseMatch, get_script_prefix, reverse
from django.utils.encoding import iri_to_uri
from django.utils.translation import gettext_lazy as _


class FlatPage(models.Model):
    url = models.CharField(_("URL"), max_length=100, db_index=True)
    title = models.CharField(_("title"), max_length=200)
    content = models.TextField(_("content"), blank=True)
    enable_comments = models.BooleanField(_("enable comments"), default=False)
    template_name = models.CharField(
        _("template name"),
        max_length=70,
        blank=True,
        help_text=_(
            "Example: â€œflatpages/contact_page.htmlâ€. If this isnâ€™t provided, "
            "the system will use â€œflatpages/default.htmlâ€."
        ),
    )
    registration_required = models.BooleanField(
        _("registration required"),
        help_text=_(
            "If this is checked, only logged-in users will be able to view the page."
        ),
        default=False,
    )
    sites = models.ManyToManyField(Site, verbose_name=_("sites"))

    class Meta:
        db_table = "django_flatpage"
        verbose_name = _("flat page")
        verbose_name_plural = _("flat pages")
        ordering = ["url"]

    def __str__(self):
        return "%s -- %s" % (self.url, self.title)

    def get_absolute_url(self):
        from .views import flatpage

        for url in (self.url.lstrip("/"), self.url):
            try:
                return reverse(flatpage, kwargs={"url": url})
            except NoReverseMatch:
                pass
        # Handle script prefix manually because we bypass reverse()
        return iri_to_uri(get_script_prefix().rstrip("/") + self.url)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\flatpages\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\flatpages\urls.py ---

from django.contrib.flatpages import views
from django.urls import path

urlpatterns = [
    path("<path:url>", views.flatpage, name="django.contrib.flatpages.views.flatpage"),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\flatpages\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\flatpages\views.py ---

from django.conf import settings
from django.contrib.flatpages.models import FlatPage
from django.contrib.sites.shortcuts import get_current_site
from django.http import Http404, HttpResponse, HttpResponsePermanentRedirect
from django.shortcuts import get_object_or_404
from django.template import loader
from django.utils.safestring import mark_safe
from django.views.decorators.csrf import csrf_protect

DEFAULT_TEMPLATE = "flatpages/default.html"

# This view is called from FlatpageFallbackMiddleware.process_response
# when a 404 is raised, which often means CsrfViewMiddleware.process_view
# has not been called even if CsrfViewMiddleware is installed. So we need
# to use @csrf_protect, in case the template needs {% csrf_token %}.
# However, we can't just wrap this view; if no matching flatpage exists,
# or a redirect is required for authentication, the 404 needs to be returned
# without any CSRF checks. Therefore, we only
# CSRF protect the internal implementation.


def flatpage(request, url):
    """
    Public interface to the flat page view.

    Models: `flatpages.flatpages`
    Templates: Uses the template defined by the ``template_name`` field,
        or :template:`flatpages/default.html` if template_name is not defined.
    Context:
        flatpage
            `flatpages.flatpages` object
    """
    if not url.startswith("/"):
        url = "/" + url
    site_id = get_current_site(request).id
    try:
        f = get_object_or_404(FlatPage, url=url, sites=site_id)
    except Http404:
        if not url.endswith("/") and settings.APPEND_SLASH:
            url += "/"
            f = get_object_or_404(FlatPage, url=url, sites=site_id)
            return HttpResponsePermanentRedirect("%s/" % request.path)
        else:
            raise
    return render_flatpage(request, f)


@csrf_protect
def render_flatpage(request, f):
    """
    Internal interface to the flat page view.
    """
    # If registration is required for accessing this page, and the user isn't
    # logged in, redirect to the login page.
    if f.registration_required and not request.user.is_authenticated:
        from django.contrib.auth.views import redirect_to_login

        return redirect_to_login(request.path)
    if f.template_name:
        template = loader.select_template((f.template_name, DEFAULT_TEMPLATE))
    else:
        template = loader.get_template(DEFAULT_TEMPLATE)

    # To avoid having to always use the "|safe" filter in flatpage templates,
    # mark the title and content as already safe (since they are raw HTML
    # content in the first place).
    f.title = mark_safe(f.title)
    f.content = mark_safe(f.content)

    return HttpResponse(template.render({"flatpage": f}, request))

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\flatpages\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\db\backends\base\models.py ---

from django.contrib.gis import gdal


class SpatialRefSysMixin:
    """
    The SpatialRefSysMixin is a class used by the database-dependent
    SpatialRefSys objects to reduce redundant code.
    """

    @property
    def srs(self):
        """
        Return a GDAL SpatialReference object.
        """
        # TODO: Is caching really necessary here?  Is complexity worth it?
        if hasattr(self, "_srs"):
            # Returning a clone of the cached SpatialReference object.
            return self._srs.clone()
        else:
            # Attempting to cache a SpatialReference object.

            # Trying to get from WKT first.
            try:
                self._srs = gdal.SpatialReference(self.wkt)
                return self.srs
            except Exception as e:
                msg = e

            try:
                self._srs = gdal.SpatialReference(self.proj4text)
                return self.srs
            except Exception as e:
                msg = e

            raise Exception(
                "Could not get OSR SpatialReference from WKT: %s\nError:\n%s"
                % (self.wkt, msg)
            )

    @property
    def ellipsoid(self):
        """
        Return a tuple of the ellipsoid parameters:
        (semimajor axis, semiminor axis, and inverse flattening).
        """
        return self.srs.ellipsoid

    @property
    def name(self):
        "Return the projection name."
        return self.srs.name

    @property
    def spheroid(self):
        "Return the spheroid name for this spatial reference."
        return self.srs["spheroid"]

    @property
    def datum(self):
        "Return the datum for this spatial reference."
        return self.srs["datum"]

    @property
    def projected(self):
        "Is this Spatial Reference projected?"
        return self.srs.projected

    @property
    def local(self):
        "Is this Spatial Reference local?"
        return self.srs.local

    @property
    def geographic(self):
        "Is this Spatial Reference geographic?"
        return self.srs.geographic

    @property
    def linear_name(self):
        "Return the linear units name."
        return self.srs.linear_name

    @property
    def linear_units(self):
        "Return the linear units."
        return self.srs.linear_units

    @property
    def angular_name(self):
        "Return the name of the angular units."
        return self.srs.angular_name

    @property
    def angular_units(self):
        "Return the angular units."
        return self.srs.angular_units

    @property
    def units(self):
        "Return a tuple of the units and the name."
        if self.projected or self.local:
            return (self.linear_units, self.linear_name)
        elif self.geographic:
            return (self.angular_units, self.angular_name)
        else:
            return (None, None)

    @classmethod
    def get_units(cls, wkt):
        """
        Return a tuple of (unit_value, unit_name) for the given WKT without
        using any of the database fields.
        """
        return gdal.SpatialReference(wkt).units

    @classmethod
    def get_spheroid(cls, wkt, string=True):
        """
        Class method used by GeometryField on initialization to
        retrieve the `SPHEROID[..]` parameters from the given WKT.
        """
        srs = gdal.SpatialReference(wkt)
        sphere_params = srs.ellipsoid
        sphere_name = srs["spheroid"]

        if not string:
            return sphere_name, sphere_params
        else:
            # `string` parameter used to place in format acceptable by PostGIS
            if len(sphere_params) == 3:
                radius, flattening = sphere_params[0], sphere_params[2]
            else:
                radius, flattening = sphere_params
            return 'SPHEROID["%s",%s,%s]' % (sphere_name, radius, flattening)

    def __str__(self):
        """
        Return the string representation, a 'pretty' OGC WKT.
        """
        return str(self.srs)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\db\backends\base\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\db\backends\oracle\models.py ---

"""
 The GeometryColumns and SpatialRefSys models for the Oracle spatial
 backend.

 It should be noted that Oracle Spatial does not have database tables
 named according to the OGC standard, so the closest analogs are used.
 For example, the `USER_SDO_GEOM_METADATA` is used for the GeometryColumns
 model and the `SDO_COORD_REF_SYS` is used for the SpatialRefSys model.
"""

from django.contrib.gis.db import models
from django.contrib.gis.db.backends.base.models import SpatialRefSysMixin


class OracleGeometryColumns(models.Model):
    "Maps to the Oracle USER_SDO_GEOM_METADATA table."
    table_name = models.CharField(max_length=32)
    column_name = models.CharField(max_length=1024)
    srid = models.IntegerField(primary_key=True)
    # TODO: Add support for `diminfo` column (type MDSYS.SDO_DIM_ARRAY).

    class Meta:
        app_label = "gis"
        db_table = "USER_SDO_GEOM_METADATA"
        managed = False

    def __str__(self):
        return "%s - %s (SRID: %s)" % (self.table_name, self.column_name, self.srid)

    @classmethod
    def table_name_col(cls):
        """
        Return the name of the metadata column used to store the feature table
        name.
        """
        return "table_name"

    @classmethod
    def geom_col_name(cls):
        """
        Return the name of the metadata column used to store the feature
        geometry column.
        """
        return "column_name"


class OracleSpatialRefSys(models.Model, SpatialRefSysMixin):
    "Maps to the Oracle MDSYS.CS_SRS table."
    cs_name = models.CharField(max_length=68)
    srid = models.IntegerField(primary_key=True)
    auth_srid = models.IntegerField()
    auth_name = models.CharField(max_length=256)
    wktext = models.CharField(max_length=2046)
    # Optional geometry representing the bounds of this coordinate
    # system.  By default, all are NULL in the table.
    cs_bounds = models.PolygonField(null=True)

    class Meta:
        app_label = "gis"
        db_table = "CS_SRS"
        managed = False

    @property
    def wkt(self):
        return self.wktext

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\db\backends\oracle\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\db\backends\postgis\models.py ---

"""
 The GeometryColumns and SpatialRefSys models for the PostGIS backend.
"""

from django.contrib.gis.db.backends.base.models import SpatialRefSysMixin
from django.db import models


class PostGISGeometryColumns(models.Model):
    """
    The 'geometry_columns' view from PostGIS. See the PostGIS
    documentation at Ch. 4.3.2.
    """

    f_table_catalog = models.CharField(max_length=256)
    f_table_schema = models.CharField(max_length=256)
    f_table_name = models.CharField(max_length=256)
    f_geometry_column = models.CharField(max_length=256)
    coord_dimension = models.IntegerField()
    srid = models.IntegerField(primary_key=True)
    type = models.CharField(max_length=30)

    class Meta:
        app_label = "gis"
        db_table = "geometry_columns"
        managed = False

    def __str__(self):
        return "%s.%s - %dD %s field (SRID: %d)" % (
            self.f_table_name,
            self.f_geometry_column,
            self.coord_dimension,
            self.type,
            self.srid,
        )

    @classmethod
    def table_name_col(cls):
        """
        Return the name of the metadata column used to store the feature table
        name.
        """
        return "f_table_name"

    @classmethod
    def geom_col_name(cls):
        """
        Return the name of the metadata column used to store the feature
        geometry column.
        """
        return "f_geometry_column"


class PostGISSpatialRefSys(models.Model, SpatialRefSysMixin):
    """
    The 'spatial_ref_sys' table from PostGIS. See the PostGIS
    documentation at Ch. 4.2.1.
    """

    srid = models.IntegerField(primary_key=True)
    auth_name = models.CharField(max_length=256)
    auth_srid = models.IntegerField()
    srtext = models.CharField(max_length=2048)
    proj4text = models.CharField(max_length=2048)

    class Meta:
        app_label = "gis"
        db_table = "spatial_ref_sys"
        managed = False

    @property
    def wkt(self):
        return self.srtext

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\db\backends\postgis\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\db\backends\spatialite\models.py ---

"""
 The GeometryColumns and SpatialRefSys models for the SpatiaLite backend.
"""

from django.contrib.gis.db.backends.base.models import SpatialRefSysMixin
from django.db import models


class SpatialiteGeometryColumns(models.Model):
    """
    The 'geometry_columns' table from SpatiaLite.
    """

    f_table_name = models.CharField(max_length=256)
    f_geometry_column = models.CharField(max_length=256)
    coord_dimension = models.IntegerField()
    srid = models.IntegerField(primary_key=True)
    spatial_index_enabled = models.IntegerField()
    type = models.IntegerField(db_column="geometry_type")

    class Meta:
        app_label = "gis"
        db_table = "geometry_columns"
        managed = False

    def __str__(self):
        return "%s.%s - %dD %s field (SRID: %d)" % (
            self.f_table_name,
            self.f_geometry_column,
            self.coord_dimension,
            self.type,
            self.srid,
        )

    @classmethod
    def table_name_col(cls):
        """
        Return the name of the metadata column used to store the feature table
        name.
        """
        return "f_table_name"

    @classmethod
    def geom_col_name(cls):
        """
        Return the name of the metadata column used to store the feature
        geometry column.
        """
        return "f_geometry_column"


class SpatialiteSpatialRefSys(models.Model, SpatialRefSysMixin):
    """
    The 'spatial_ref_sys' table from SpatiaLite.
    """

    srid = models.IntegerField(primary_key=True)
    auth_name = models.CharField(max_length=256)
    auth_srid = models.IntegerField()
    ref_sys_name = models.CharField(max_length=256)
    proj4text = models.CharField(max_length=2048)
    srtext = models.CharField(max_length=2048)

    class Meta:
        app_label = "gis"
        db_table = "spatial_ref_sys"
        managed = False

    @property
    def wkt(self):
        return self.srtext

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\db\backends\spatialite\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\sitemaps\views.py ---

from django.apps import apps
from django.contrib.gis.db.models import GeometryField
from django.contrib.gis.db.models.functions import AsKML, Transform
from django.contrib.gis.shortcuts import render_to_kml, render_to_kmz
from django.core.exceptions import FieldDoesNotExist
from django.db import DEFAULT_DB_ALIAS, connections
from django.http import Http404


def kml(request, label, model, field_name=None, compress=False, using=DEFAULT_DB_ALIAS):
    """
    This view generates KML for the given app label, model, and field name.

    The field name must be that of a geographic field.
    """
    placemarks = []
    try:
        klass = apps.get_model(label, model)
    except LookupError:
        raise Http404(
            'You must supply a valid app label and module name.  Got "%s.%s"'
            % (label, model)
        )

    if field_name:
        try:
            field = klass._meta.get_field(field_name)
            if not isinstance(field, GeometryField):
                raise FieldDoesNotExist
        except FieldDoesNotExist:
            raise Http404("Invalid geometry field.")

    connection = connections[using]

    if connection.features.has_AsKML_function:
        # Database will take care of transformation.
        placemarks = klass._default_manager.using(using).annotate(kml=AsKML(field_name))
    else:
        # If the database offers no KML method, we use the `kml`
        # attribute of the lazy geometry instead.
        placemarks = []
        if connection.features.has_Transform_function:
            qs = klass._default_manager.using(using).annotate(
                **{"%s_4326" % field_name: Transform(field_name, 4326)}
            )
            field_name += "_4326"
        else:
            qs = klass._default_manager.using(using).all()
        for mod in qs:
            mod.kml = getattr(mod, field_name).kml
            placemarks.append(mod)

    # Getting the render function and rendering to the correct.
    if compress:
        render = render_to_kmz
    else:
        render = render_to_kml
    return render("gis/kml/placemarks.kml", {"places": placemarks})


def kmz(request, label, model, field_name=None, using=DEFAULT_DB_ALIAS):
    """
    Return KMZ for the given app label, model, and field name.
    """
    return kml(request, label, model, field_name, compress=True, using=using)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\sitemaps\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\apps.py ---

from django.apps import AppConfig
from django.core import serializers
from django.utils.translation import gettext_lazy as _


class GISConfig(AppConfig):
    default_auto_field = "django.db.models.AutoField"
    name = "django.contrib.gis"
    verbose_name = _("GIS")

    def ready(self):
        serializers.BUILTIN_SERIALIZERS.setdefault(
            "geojson", "django.contrib.gis.serializers.geojson"
        )

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\views.py ---

from django.http import Http404
from django.utils.translation import gettext as _


def feed(request, url, feed_dict=None):
    """Provided for backwards compatibility."""
    if not feed_dict:
        raise Http404(_("No feeds are registered."))

    slug = url.partition("/")[0]
    try:
        f = feed_dict[slug]
    except KeyError:
        raise Http404(_("Slug %r isnâ€™t registered.") % slug)

    instance = f()
    instance.feed_url = getattr(f, "feed_url", None) or request.path
    instance.title_template = f.title_template or ("feeds/%s_title.html" % slug)
    instance.description_template = f.description_template or (
        "feeds/%s_description.html" % slug
    )
    return instance(request)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\gis\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\humanize\apps.py ---

from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _


class HumanizeConfig(AppConfig):
    name = "django.contrib.humanize"
    verbose_name = _("Humanize")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\humanize\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\messages\apps.py ---

from django.apps import AppConfig
from django.contrib.messages.storage import base
from django.contrib.messages.utils import get_level_tags
from django.core.signals import setting_changed
from django.utils.functional import SimpleLazyObject
from django.utils.translation import gettext_lazy as _


def update_level_tags(setting, **kwargs):
    if setting == "MESSAGE_TAGS":
        base.LEVEL_TAGS = SimpleLazyObject(get_level_tags)


class MessagesConfig(AppConfig):
    name = "django.contrib.messages"
    verbose_name = _("Messages")

    def ready(self):
        setting_changed.connect(update_level_tags)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\messages\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\messages\views.py ---

from django.contrib import messages


class SuccessMessageMixin:
    """
    Add a success message on successful form submission.
    """

    success_message = ""

    def form_valid(self, form):
        response = super().form_valid(form)
        success_message = self.get_success_message(form.cleaned_data)
        if success_message:
            messages.success(self.request, success_message)
        return response

    def get_success_message(self, cleaned_data):
        return self.success_message % cleaned_data

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\messages\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\postgres\apps.py ---

from django.apps import AppConfig
from django.core.signals import setting_changed
from django.db import connections
from django.db.backends.postgresql.psycopg_any import RANGE_TYPES
from django.db.backends.signals import connection_created
from django.db.migrations.writer import MigrationWriter
from django.db.models import CharField, OrderBy, TextField
from django.db.models.functions import Collate
from django.db.models.indexes import IndexExpression
from django.utils.translation import gettext_lazy as _

from .indexes import OpClass
from .lookups import (
    SearchLookup,
    TrigramSimilar,
    TrigramStrictWordSimilar,
    TrigramWordSimilar,
    Unaccent,
)
from .serializers import RangeSerializer
from .signals import register_type_handlers


def uninstall_if_needed(setting, value, enter, **kwargs):
    """
    Undo the effects of PostgresConfig.ready() when django.contrib.postgres
    is "uninstalled" by override_settings().
    """
    if (
        not enter
        and setting == "INSTALLED_APPS"
        and "django.contrib.postgres" not in set(value)
    ):
        connection_created.disconnect(register_type_handlers)
        CharField._unregister_lookup(Unaccent)
        TextField._unregister_lookup(Unaccent)
        CharField._unregister_lookup(SearchLookup)
        TextField._unregister_lookup(SearchLookup)
        CharField._unregister_lookup(TrigramSimilar)
        TextField._unregister_lookup(TrigramSimilar)
        CharField._unregister_lookup(TrigramWordSimilar)
        TextField._unregister_lookup(TrigramWordSimilar)
        CharField._unregister_lookup(TrigramStrictWordSimilar)
        TextField._unregister_lookup(TrigramStrictWordSimilar)
        # Disconnect this receiver until the next time this app is installed
        # and ready() connects it again to prevent unnecessary processing on
        # each setting change.
        setting_changed.disconnect(uninstall_if_needed)
        MigrationWriter.unregister_serializer(RANGE_TYPES)


class PostgresConfig(AppConfig):
    name = "django.contrib.postgres"
    verbose_name = _("PostgreSQL extensions")

    def ready(self):
        setting_changed.connect(uninstall_if_needed)
        # Connections may already exist before we are called.
        for conn in connections.all(initialized_only=True):
            if conn.vendor == "postgresql":
                conn.introspection.data_types_reverse.update(
                    {
                        3904: "django.contrib.postgres.fields.IntegerRangeField",
                        3906: "django.contrib.postgres.fields.DecimalRangeField",
                        3910: "django.contrib.postgres.fields.DateTimeRangeField",
                        3912: "django.contrib.postgres.fields.DateRangeField",
                        3926: "django.contrib.postgres.fields.BigIntegerRangeField",
                    }
                )
                if conn.connection is not None:
                    register_type_handlers(conn)
        connection_created.connect(register_type_handlers)
        CharField.register_lookup(Unaccent)
        TextField.register_lookup(Unaccent)
        CharField.register_lookup(SearchLookup)
        TextField.register_lookup(SearchLookup)
        CharField.register_lookup(TrigramSimilar)
        TextField.register_lookup(TrigramSimilar)
        CharField.register_lookup(TrigramWordSimilar)
        TextField.register_lookup(TrigramWordSimilar)
        CharField.register_lookup(TrigramStrictWordSimilar)
        TextField.register_lookup(TrigramStrictWordSimilar)
        MigrationWriter.register_serializer(RANGE_TYPES, RangeSerializer)
        IndexExpression.register_wrappers(OrderBy, OpClass, Collate)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\postgres\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\postgres\serializers.py ---

from django.db.migrations.serializer import BaseSerializer


class RangeSerializer(BaseSerializer):
    def serialize(self):
        module = self.value.__class__.__module__
        # Ranges are implemented in psycopg2._range but the public import
        # location is psycopg2.extras.
        module = "psycopg2.extras" if module == "psycopg2._range" else module
        return "%s.%r" % (module, self.value), {"import %s" % module}

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\postgres\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\redirects\admin.py ---

from django.contrib import admin
from django.contrib.redirects.models import Redirect


@admin.register(Redirect)
class RedirectAdmin(admin.ModelAdmin):
    list_display = ("old_path", "new_path")
    list_filter = ("site",)
    search_fields = ("old_path", "new_path")
    radio_fields = {"site": admin.VERTICAL}

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\redirects\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\redirects\apps.py ---

from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _


class RedirectsConfig(AppConfig):
    default_auto_field = "django.db.models.AutoField"
    name = "django.contrib.redirects"
    verbose_name = _("Redirects")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\redirects\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\redirects\models.py ---

from django.contrib.sites.models import Site
from django.db import models
from django.utils.translation import gettext_lazy as _


class Redirect(models.Model):
    site = models.ForeignKey(Site, models.CASCADE, verbose_name=_("site"))
    old_path = models.CharField(
        _("redirect from"),
        max_length=200,
        db_index=True,
        help_text=_(
            "This should be an absolute path, excluding the domain name. Example: "
            "â€œ/events/search/â€."
        ),
    )
    new_path = models.CharField(
        _("redirect to"),
        max_length=200,
        blank=True,
        help_text=_(
            "This can be either an absolute path (as above) or a full URL "
            "starting with a scheme such as â€œhttps://â€."
        ),
    )

    class Meta:
        verbose_name = _("redirect")
        verbose_name_plural = _("redirects")
        db_table = "django_redirect"
        unique_together = [["site", "old_path"]]
        ordering = ["old_path"]

    def __str__(self):
        return "%s ---> %s" % (self.old_path, self.new_path)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\redirects\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sessions\apps.py ---

from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _


class SessionsConfig(AppConfig):
    name = "django.contrib.sessions"
    verbose_name = _("Sessions")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sessions\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sessions\models.py ---

from django.contrib.sessions.base_session import AbstractBaseSession, BaseSessionManager


class SessionManager(BaseSessionManager):
    use_in_migrations = True


class Session(AbstractBaseSession):
    """
    Django provides full support for anonymous sessions. The session
    framework lets you store and retrieve arbitrary data on a
    per-site-visitor basis. It stores data on the server side and
    abstracts the sending and receiving of cookies. Cookies contain a
    session ID -- not the data itself.

    The Django sessions framework is entirely cookie-based. It does
    not fall back to putting session IDs in URLs. This is an intentional
    design decision. Not only does that behavior make URLs ugly, it makes
    your site vulnerable to session-ID theft via the "Referer" header.

    For complete documentation on using Sessions in your code, consult
    the sessions documentation that is shipped with Django (also available
    on the Django web site).
    """

    objects = SessionManager()

    @classmethod
    def get_session_store_class(cls):
        from django.contrib.sessions.backends.db import SessionStore

        return SessionStore

    class Meta(AbstractBaseSession.Meta):
        db_table = "django_session"

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sessions\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sessions\serializers.py ---

from django.core.signing import JSONSerializer as BaseJSONSerializer

JSONSerializer = BaseJSONSerializer

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sessions\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sitemaps\apps.py ---

from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _


class SiteMapsConfig(AppConfig):
    default_auto_field = "django.db.models.AutoField"
    name = "django.contrib.sitemaps"
    verbose_name = _("Site Maps")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sitemaps\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sitemaps\views.py ---

import datetime
from dataclasses import dataclass
from functools import wraps

from django.contrib.sites.shortcuts import get_current_site
from django.core.paginator import EmptyPage, PageNotAnInteger
from django.http import Http404
from django.template.response import TemplateResponse
from django.urls import reverse
from django.utils import timezone
from django.utils.http import http_date


@dataclass
class SitemapIndexItem:
    location: str
    last_mod: bool = None


def x_robots_tag(func):
    @wraps(func)
    def inner(request, *args, **kwargs):
        response = func(request, *args, **kwargs)
        response.headers["X-Robots-Tag"] = "noindex, noodp, noarchive"
        return response

    return inner


def _get_latest_lastmod(current_lastmod, new_lastmod):
    """
    Returns the latest `lastmod` where `lastmod` can be either a date or a
    datetime.
    """
    if not isinstance(new_lastmod, datetime.datetime):
        new_lastmod = datetime.datetime.combine(new_lastmod, datetime.time.min)
    if timezone.is_naive(new_lastmod):
        new_lastmod = timezone.make_aware(new_lastmod, datetime.timezone.utc)
    return new_lastmod if current_lastmod is None else max(current_lastmod, new_lastmod)


@x_robots_tag
def index(
    request,
    sitemaps,
    template_name="sitemap_index.xml",
    content_type="application/xml",
    sitemap_url_name="django.contrib.sitemaps.views.sitemap",
):
    req_protocol = request.scheme
    req_site = get_current_site(request)

    sites = []  # all sections' sitemap URLs
    all_indexes_lastmod = True
    latest_lastmod = None
    for section, site in sitemaps.items():
        # For each section label, add links of all pages of its sitemap
        # (usually generated by the `sitemap` view).
        if callable(site):
            site = site()
        protocol = req_protocol if site.protocol is None else site.protocol
        sitemap_url = reverse(sitemap_url_name, kwargs={"section": section})
        absolute_url = "%s://%s%s" % (protocol, req_site.domain, sitemap_url)
        site_lastmod = site.get_latest_lastmod()
        if all_indexes_lastmod:
            if site_lastmod is not None:
                latest_lastmod = _get_latest_lastmod(latest_lastmod, site_lastmod)
            else:
                all_indexes_lastmod = False
        sites.append(SitemapIndexItem(absolute_url, site_lastmod))
        # Add links to all pages of the sitemap.
        for page in range(2, site.paginator.num_pages + 1):
            sites.append(
                SitemapIndexItem("%s?p=%s" % (absolute_url, page), site_lastmod)
            )
    # If lastmod is defined for all sites, set header so as
    # ConditionalGetMiddleware is able to send 304 NOT MODIFIED
    if all_indexes_lastmod and latest_lastmod:
        headers = {"Last-Modified": http_date(latest_lastmod.timestamp())}
    else:
        headers = None
    return TemplateResponse(
        request,
        template_name,
        {"sitemaps": sites},
        content_type=content_type,
        headers=headers,
    )


@x_robots_tag
def sitemap(
    request,
    sitemaps,
    section=None,
    template_name="sitemap.xml",
    content_type="application/xml",
):
    req_protocol = request.scheme
    req_site = get_current_site(request)

    if section is not None:
        if section not in sitemaps:
            raise Http404("No sitemap available for section: %r" % section)
        maps = [sitemaps[section]]
    else:
        maps = sitemaps.values()
    page = request.GET.get("p", 1)

    lastmod = None
    all_sites_lastmod = True
    urls = []
    for site in maps:
        try:
            if callable(site):
                site = site()
            urls.extend(site.get_urls(page=page, site=req_site, protocol=req_protocol))
            if all_sites_lastmod:
                site_lastmod = getattr(site, "latest_lastmod", None)
                if site_lastmod is not None:
                    lastmod = _get_latest_lastmod(lastmod, site_lastmod)
                else:
                    all_sites_lastmod = False
        except EmptyPage:
            raise Http404("Page %s empty" % page)
        except PageNotAnInteger:
            raise Http404("No page '%s'" % page)
    # If lastmod is defined for all sites, set header so as
    # ConditionalGetMiddleware is able to send 304 NOT MODIFIED
    if all_sites_lastmod:
        headers = {"Last-Modified": http_date(lastmod.timestamp())} if lastmod else None
    else:
        headers = None
    return TemplateResponse(
        request,
        template_name,
        {"urlset": urls},
        content_type=content_type,
        headers=headers,
    )

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sitemaps\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sites\admin.py ---

from django.contrib import admin
from django.contrib.sites.models import Site


@admin.register(Site)
class SiteAdmin(admin.ModelAdmin):
    list_display = ("domain", "name")
    search_fields = ("domain", "name")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sites\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sites\apps.py ---

from django.apps import AppConfig
from django.contrib.sites.checks import check_site_id
from django.core import checks
from django.db.models.signals import post_migrate
from django.utils.translation import gettext_lazy as _

from .management import create_default_site


class SitesConfig(AppConfig):
    default_auto_field = "django.db.models.AutoField"
    name = "django.contrib.sites"
    verbose_name = _("Sites")

    def ready(self):
        post_migrate.connect(create_default_site, sender=self)
        checks.register(check_site_id, checks.Tags.sites)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sites\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sites\models.py ---

import string

from django.core.exceptions import ImproperlyConfigured, ValidationError
from django.db import models
from django.db.models.signals import pre_delete, pre_save
from django.http.request import split_domain_port
from django.utils.translation import gettext_lazy as _

SITE_CACHE = {}


def _simple_domain_name_validator(value):
    """
    Validate that the given value contains no whitespaces to prevent common
    typos.
    """
    checks = ((s in value) for s in string.whitespace)
    if any(checks):
        raise ValidationError(
            _("The domain name cannot contain any spaces or tabs."),
            code="invalid",
        )


class SiteManager(models.Manager):
    use_in_migrations = True

    def _get_site_by_id(self, site_id):
        if site_id not in SITE_CACHE:
            site = self.get(pk=site_id)
            SITE_CACHE[site_id] = site
        return SITE_CACHE[site_id]

    def _get_site_by_request(self, request):
        host = request.get_host()
        try:
            # First attempt to look up the site by host with or without port.
            if host not in SITE_CACHE:
                SITE_CACHE[host] = self.get(domain__iexact=host)
            return SITE_CACHE[host]
        except Site.DoesNotExist:
            # Fallback to looking up site after stripping port from the host.
            domain, port = split_domain_port(host)
            if domain not in SITE_CACHE:
                SITE_CACHE[domain] = self.get(domain__iexact=domain)
            return SITE_CACHE[domain]

    def get_current(self, request=None):
        """
        Return the current Site based on the SITE_ID in the project's settings.
        If SITE_ID isn't defined, return the site with domain matching
        request.get_host(). The ``Site`` object is cached the first time it's
        retrieved from the database.
        """
        from django.conf import settings

        if getattr(settings, "SITE_ID", ""):
            site_id = settings.SITE_ID
            return self._get_site_by_id(site_id)
        elif request:
            return self._get_site_by_request(request)

        raise ImproperlyConfigured(
            'You\'re using the Django "sites framework" without having '
            "set the SITE_ID setting. Create a site in your database and "
            "set the SITE_ID setting or pass a request to "
            "Site.objects.get_current() to fix this error."
        )

    def clear_cache(self):
        """Clear the ``Site`` object cache."""
        global SITE_CACHE
        SITE_CACHE = {}

    def get_by_natural_key(self, domain):
        return self.get(domain=domain)


class Site(models.Model):
    domain = models.CharField(
        _("domain name"),
        max_length=100,
        validators=[_simple_domain_name_validator],
        unique=True,
    )
    name = models.CharField(_("display name"), max_length=50)

    objects = SiteManager()

    class Meta:
        db_table = "django_site"
        verbose_name = _("site")
        verbose_name_plural = _("sites")
        ordering = ["domain"]

    def __str__(self):
        return self.domain

    def natural_key(self):
        return (self.domain,)


def clear_site_cache(sender, **kwargs):
    """
    Clear the cache (if primed) each time a site is saved or deleted.
    """
    instance = kwargs["instance"]
    using = kwargs["using"]
    try:
        del SITE_CACHE[instance.pk]
    except KeyError:
        pass
    try:
        del SITE_CACHE[Site.objects.using(using).get(pk=instance.pk).domain]
    except (KeyError, Site.DoesNotExist):
        pass


pre_save.connect(clear_site_cache, sender=Site)
pre_delete.connect(clear_site_cache, sender=Site)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\sites\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\staticfiles\apps.py ---

from django.apps import AppConfig
from django.contrib.staticfiles.checks import check_finders, check_storages
from django.core import checks
from django.utils.translation import gettext_lazy as _


class StaticFilesConfig(AppConfig):
    name = "django.contrib.staticfiles"
    verbose_name = _("Static Files")
    ignore_patterns = ["CVS", ".*", "*~"]

    def ready(self):
        checks.register(check_finders, checks.Tags.staticfiles)
        checks.register(check_storages, checks.Tags.staticfiles)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\staticfiles\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\staticfiles\urls.py ---

from django.conf import settings
from django.conf.urls.static import static
from django.contrib.staticfiles.views import serve

urlpatterns = []


def staticfiles_urlpatterns(prefix=None):
    """
    Helper function to return a URL pattern for serving static files.
    """
    if prefix is None:
        prefix = settings.STATIC_URL
    return static(prefix, view=serve)


# Only append if urlpatterns are empty
if settings.DEBUG and not urlpatterns:
    urlpatterns += staticfiles_urlpatterns()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\staticfiles\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\staticfiles\views.py ---

"""
Views and functions for serving static files. These are only to be used during
development, and SHOULD NOT be used in a production setting.

"""

import os
import posixpath

from django.conf import settings
from django.contrib.staticfiles import finders
from django.http import Http404
from django.views import static


def serve(request, path, insecure=False, **kwargs):
    """
    Serve static files below a given point in the directory structure or
    from locations inferred from the staticfiles finders.

    To use, put a URL pattern such as::

        from django.contrib.staticfiles import views

        path('<path:path>', views.serve)

    in your URLconf.

    It uses the django.views.static.serve() view to serve the found files.
    """
    if not settings.DEBUG and not insecure:
        raise Http404
    normalized_path = posixpath.normpath(path).lstrip("/")
    absolute_path = finders.find(normalized_path)
    if not absolute_path:
        if path.endswith("/") or path == "":
            raise Http404("Directory indexes are not allowed here.")
        raise Http404("'%s' could not be found" % path)
    document_root, path = os.path.split(absolute_path)
    return static.serve(request, path, document_root=document_root, **kwargs)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\staticfiles\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\syndication\apps.py ---

from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _


class SyndicationConfig(AppConfig):
    name = "django.contrib.syndication"
    verbose_name = _("Syndication")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\syndication\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\syndication\views.py ---

from inspect import getattr_static, unwrap

from django.contrib.sites.shortcuts import get_current_site
from django.core.exceptions import ImproperlyConfigured, ObjectDoesNotExist
from django.http import Http404, HttpResponse
from django.template import TemplateDoesNotExist, loader
from django.utils import feedgenerator
from django.utils.encoding import iri_to_uri
from django.utils.html import escape
from django.utils.http import http_date
from django.utils.timezone import get_default_timezone, is_naive, make_aware
from django.utils.translation import get_language


def add_domain(domain, url, secure=False):
    protocol = "https" if secure else "http"
    if url.startswith("//"):
        # Support network-path reference (see #16753) - RSS requires a protocol
        url = "%s:%s" % (protocol, url)
    elif not url.startswith(("http://", "https://", "mailto:")):
        url = iri_to_uri("%s://%s%s" % (protocol, domain, url))
    return url


class FeedDoesNotExist(ObjectDoesNotExist):
    pass


class Feed:
    feed_type = feedgenerator.DefaultFeed
    title_template = None
    description_template = None
    language = None

    def __call__(self, request, *args, **kwargs):
        try:
            obj = self.get_object(request, *args, **kwargs)
        except ObjectDoesNotExist:
            raise Http404("Feed object does not exist.")
        feedgen = self.get_feed(obj, request)
        response = HttpResponse(content_type=feedgen.content_type)
        if hasattr(self, "item_pubdate") or hasattr(self, "item_updateddate"):
            # if item_pubdate or item_updateddate is defined for the feed, set
            # header so as ConditionalGetMiddleware is able to send 304 NOT MODIFIED
            response.headers["Last-Modified"] = http_date(
                feedgen.latest_post_date().timestamp()
            )
        feedgen.write(response, "utf-8")
        return response

    def item_title(self, item):
        # Titles should be double escaped by default (see #6533)
        return escape(str(item))

    def item_description(self, item):
        return str(item)

    def item_link(self, item):
        try:
            return item.get_absolute_url()
        except AttributeError:
            raise ImproperlyConfigured(
                "Give your %s class a get_absolute_url() method, or define an "
                "item_link() method in your Feed class." % item.__class__.__name__
            )

    def item_enclosures(self, item):
        enc_url = self._get_dynamic_attr("item_enclosure_url", item)
        if enc_url:
            enc = feedgenerator.Enclosure(
                url=str(enc_url),
                length=str(self._get_dynamic_attr("item_enclosure_length", item)),
                mime_type=str(self._get_dynamic_attr("item_enclosure_mime_type", item)),
            )
            return [enc]
        return []

    def _get_dynamic_attr(self, attname, obj, default=None):
        try:
            attr = getattr(self, attname)
        except AttributeError:
            return default
        if callable(attr):
            # Check co_argcount rather than try/excepting the function and
            # catching the TypeError, because something inside the function
            # may raise the TypeError. This technique is more accurate.
            func = unwrap(attr)
            try:
                code = func.__code__
            except AttributeError:
                func = unwrap(attr.__call__)
                code = func.__code__
            # If function doesn't have arguments and it is not a static method,
            # it was decorated without using @functools.wraps.
            if not code.co_argcount and not isinstance(
                getattr_static(self, func.__name__, None), staticmethod
            ):
                raise ImproperlyConfigured(
                    f"Feed method {attname!r} decorated by {func.__name__!r} needs to "
                    f"use @functools.wraps."
                )
            if code.co_argcount == 2:  # one argument is 'self'
                return attr(obj)
            else:
                return attr()
        return attr

    def feed_extra_kwargs(self, obj):
        """
        Return an extra keyword arguments dictionary that is used when
        initializing the feed generator.
        """
        return {}

    def item_extra_kwargs(self, item):
        """
        Return an extra keyword arguments dictionary that is used with
        the `add_item` call of the feed generator.
        """
        return {}

    def get_object(self, request, *args, **kwargs):
        return None

    def get_context_data(self, **kwargs):
        """
        Return a dictionary to use as extra context if either
        ``self.description_template`` or ``self.item_template`` are used.

        Default implementation preserves the old behavior
        of using {'obj': item, 'site': current_site} as the context.
        """
        return {"obj": kwargs.get("item"), "site": kwargs.get("site")}

    def get_feed(self, obj, request):
        """
        Return a feedgenerator.DefaultFeed object, fully populated, for
        this feed. Raise FeedDoesNotExist for invalid parameters.
        """
        current_site = get_current_site(request)

        link = self._get_dynamic_attr("link", obj)
        link = add_domain(current_site.domain, link, request.is_secure())

        feed = self.feed_type(
            title=self._get_dynamic_attr("title", obj),
            subtitle=self._get_dynamic_attr("subtitle", obj),
            link=link,
            description=self._get_dynamic_attr("description", obj),
            language=self.language or get_language(),
            feed_url=add_domain(
                current_site.domain,
                self._get_dynamic_attr("feed_url", obj) or request.path,
                request.is_secure(),
            ),
            author_name=self._get_dynamic_attr("author_name", obj),
            author_link=self._get_dynamic_attr("author_link", obj),
            author_email=self._get_dynamic_attr("author_email", obj),
            categories=self._get_dynamic_attr("categories", obj),
            feed_copyright=self._get_dynamic_attr("feed_copyright", obj),
            feed_guid=self._get_dynamic_attr("feed_guid", obj),
            ttl=self._get_dynamic_attr("ttl", obj),
            **self.feed_extra_kwargs(obj),
        )

        title_tmp = None
        if self.title_template is not None:
            try:
                title_tmp = loader.get_template(self.title_template)
            except TemplateDoesNotExist:
                pass

        description_tmp = None
        if self.description_template is not None:
            try:
                description_tmp = loader.get_template(self.description_template)
            except TemplateDoesNotExist:
                pass

        for item in self._get_dynamic_attr("items", obj):
            context = self.get_context_data(
                item=item, site=current_site, obj=obj, request=request
            )
            if title_tmp is not None:
                title = title_tmp.render(context, request)
            else:
                title = self._get_dynamic_attr("item_title", item)
            if description_tmp is not None:
                description = description_tmp.render(context, request)
            else:
                description = self._get_dynamic_attr("item_description", item)
            link = add_domain(
                current_site.domain,
                self._get_dynamic_attr("item_link", item),
                request.is_secure(),
            )
            enclosures = self._get_dynamic_attr("item_enclosures", item)
            author_name = self._get_dynamic_attr("item_author_name", item)
            if author_name is not None:
                author_email = self._get_dynamic_attr("item_author_email", item)
                author_link = self._get_dynamic_attr("item_author_link", item)
            else:
                author_email = author_link = None

            tz = get_default_timezone()

            pubdate = self._get_dynamic_attr("item_pubdate", item)
            if pubdate and is_naive(pubdate):
                pubdate = make_aware(pubdate, tz)

            updateddate = self._get_dynamic_attr("item_updateddate", item)
            if updateddate and is_naive(updateddate):
                updateddate = make_aware(updateddate, tz)

            feed.add_item(
                title=title,
                link=link,
                description=description,
                unique_id=self._get_dynamic_attr("item_guid", item, link),
                unique_id_is_permalink=self._get_dynamic_attr(
                    "item_guid_is_permalink", item
                ),
                enclosures=enclosures,
                pubdate=pubdate,
                updateddate=updateddate,
                author_name=author_name,
                author_email=author_email,
                author_link=author_link,
                comments=self._get_dynamic_attr("item_comments", item),
                categories=self._get_dynamic_attr("item_categories", item),
                item_copyright=self._get_dynamic_attr("item_copyright", item),
                **self.item_extra_kwargs(item),
            )
        return feed

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\contrib\syndication\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\core\checks\urls.py ---

import inspect
from collections import Counter

from django.conf import settings
from django.core.exceptions import ViewDoesNotExist

from . import Error, Tags, Warning, register


@register(Tags.urls)
def check_url_config(app_configs, **kwargs):
    if getattr(settings, "ROOT_URLCONF", None):
        from django.urls import get_resolver

        resolver = get_resolver()
        return check_resolver(resolver)
    return []


def check_resolver(resolver):
    """
    Recursively check the resolver.
    """
    check_method = getattr(resolver, "check", None)
    if check_method is not None:
        return check_method()
    elif not hasattr(resolver, "resolve"):
        return get_warning_for_invalid_pattern(resolver)
    else:
        return []


@register(Tags.urls)
def check_url_namespaces_unique(app_configs, **kwargs):
    """
    Warn if URL namespaces used in applications aren't unique.
    """
    if not getattr(settings, "ROOT_URLCONF", None):
        return []

    from django.urls import get_resolver

    resolver = get_resolver()
    all_namespaces = _load_all_namespaces(resolver)
    counter = Counter(all_namespaces)
    non_unique_namespaces = [n for n, count in counter.items() if count > 1]
    errors = []
    for namespace in non_unique_namespaces:
        errors.append(
            Warning(
                "URL namespace '{}' isn't unique. You may not be able to reverse "
                "all URLs in this namespace".format(namespace),
                id="urls.W005",
            )
        )
    return errors


def _load_all_namespaces(resolver, parents=()):
    """
    Recursively load all namespaces from URL patterns.
    """
    url_patterns = getattr(resolver, "url_patterns", [])
    namespaces = [
        ":".join(parents + (url.namespace,))
        for url in url_patterns
        if getattr(url, "namespace", None) is not None
    ]
    for pattern in url_patterns:
        namespace = getattr(pattern, "namespace", None)
        current = parents
        if namespace is not None:
            current += (namespace,)
        namespaces.extend(_load_all_namespaces(pattern, current))
    return namespaces


def get_warning_for_invalid_pattern(pattern):
    """
    Return a list containing a warning that the pattern is invalid.

    describe_pattern() cannot be used here, because we cannot rely on the
    urlpattern having regex or name attributes.
    """
    if isinstance(pattern, str):
        hint = (
            "Try removing the string '{}'. The list of urlpatterns should not "
            "have a prefix string as the first element.".format(pattern)
        )
    elif isinstance(pattern, tuple):
        hint = "Try using path() instead of a tuple."
    else:
        hint = None

    return [
        Error(
            "Your URL pattern {!r} is invalid. Ensure that urlpatterns is a list "
            "of path() and/or re_path() instances.".format(pattern),
            hint=hint,
            id="urls.E004",
        )
    ]


@register(Tags.urls)
def check_url_settings(app_configs, **kwargs):
    errors = []
    for name in ("STATIC_URL", "MEDIA_URL"):
        value = getattr(settings, name)
        if value and not value.endswith("/"):
            errors.append(E006(name))
    return errors


def E006(name):
    return Error(
        "The {} setting must end with a slash.".format(name),
        id="urls.E006",
    )


@register(Tags.urls)
def check_custom_error_handlers(app_configs, **kwargs):
    if not getattr(settings, "ROOT_URLCONF", None):
        return []

    from django.urls import get_resolver

    resolver = get_resolver()

    errors = []
    # All handlers take (request, exception) arguments except handler500
    # which takes (request).
    for status_code, num_parameters in [(400, 2), (403, 2), (404, 2), (500, 1)]:
        try:
            handler = resolver.resolve_error_handler(status_code)
        except (ImportError, ViewDoesNotExist) as e:
            path = getattr(resolver.urlconf_module, "handler%s" % status_code)
            msg = (
                "The custom handler{status_code} view '{path}' could not be "
                "imported."
            ).format(status_code=status_code, path=path)
            errors.append(Error(msg, hint=str(e), id="urls.E008"))
            continue
        signature = inspect.signature(handler)
        args = [None] * num_parameters
        try:
            signature.bind(*args)
        except TypeError:
            msg = (
                "The custom handler{status_code} view '{path}' does not "
                "take the correct number of arguments ({args})."
            ).format(
                status_code=status_code,
                path=handler.__module__ + "." + handler.__qualname__,
                args="request, exception" if num_parameters == 2 else "request",
            )
            errors.append(Error(msg, id="urls.E007"))
    return errors

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\core\checks\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\core\handlers\asgi.py ---

import asyncio
import logging
import sys
import tempfile
import traceback
from contextlib import aclosing

from asgiref.sync import ThreadSensitiveContext, sync_to_async

from django.conf import settings
from django.core import signals
from django.core.exceptions import RequestAborted, RequestDataTooBig
from django.core.handlers import base
from django.http import (
    FileResponse,
    HttpRequest,
    HttpResponse,
    HttpResponseBadRequest,
    HttpResponseServerError,
    QueryDict,
    parse_cookie,
)
from django.urls import set_script_prefix
from django.utils.functional import cached_property

logger = logging.getLogger("django.request")


def get_script_prefix(scope):
    """
    Return the script prefix to use from either the scope or a setting.
    """
    if settings.FORCE_SCRIPT_NAME:
        return settings.FORCE_SCRIPT_NAME
    return scope.get("root_path", "") or ""


class ASGIRequest(HttpRequest):
    """
    Custom request subclass that decodes from an ASGI-standard request dict
    and wraps request body handling.
    """

    # Number of seconds until a Request gives up on trying to read a request
    # body and aborts.
    body_receive_timeout = 60

    def __init__(self, scope, body_file):
        self.scope = scope
        self._post_parse_error = False
        self._read_started = False
        self.resolver_match = None
        self.path = scope["path"]
        self.script_name = get_script_prefix(scope)
        if self.script_name:
            # TODO: Better is-prefix checking, slash handling?
            self.path_info = scope["path"].removeprefix(self.script_name)
        else:
            self.path_info = scope["path"]
        # HTTP basics.
        self.method = self.scope["method"].upper()
        # Ensure query string is encoded correctly.
        query_string = self.scope.get("query_string", "")
        if isinstance(query_string, bytes):
            query_string = query_string.decode()
        self.META = {
            "REQUEST_METHOD": self.method,
            "QUERY_STRING": query_string,
            "SCRIPT_NAME": self.script_name,
            "PATH_INFO": self.path_info,
            # WSGI-expecting code will need these for a while
            "wsgi.multithread": True,
            "wsgi.multiprocess": True,
        }
        if self.scope.get("client"):
            self.META["REMOTE_ADDR"] = self.scope["client"][0]
            self.META["REMOTE_HOST"] = self.META["REMOTE_ADDR"]
            self.META["REMOTE_PORT"] = self.scope["client"][1]
        if self.scope.get("server"):
            self.META["SERVER_NAME"] = self.scope["server"][0]
            self.META["SERVER_PORT"] = str(self.scope["server"][1])
        else:
            self.META["SERVER_NAME"] = "unknown"
            self.META["SERVER_PORT"] = "0"
        # Headers go into META.
        for name, value in self.scope.get("headers", []):
            name = name.decode("latin1")
            if name == "content-length":
                corrected_name = "CONTENT_LENGTH"
            elif name == "content-type":
                corrected_name = "CONTENT_TYPE"
            else:
                corrected_name = "HTTP_%s" % name.upper().replace("-", "_")
            # HTTP/2 say only ASCII chars are allowed in headers, but decode
            # latin1 just in case.
            value = value.decode("latin1")
            if corrected_name in self.META:
                value = self.META[corrected_name] + "," + value
            self.META[corrected_name] = value
        # Pull out request encoding, if provided.
        self._set_content_type_params(self.META)
        # Directly assign the body file to be our stream.
        self._stream = body_file
        # Other bits.
        self.resolver_match = None

    @cached_property
    def GET(self):
        return QueryDict(self.META["QUERY_STRING"])

    def _get_scheme(self):
        return self.scope.get("scheme") or super()._get_scheme()

    def _get_post(self):
        if not hasattr(self, "_post"):
            self._load_post_and_files()
        return self._post

    def _set_post(self, post):
        self._post = post

    def _get_files(self):
        if not hasattr(self, "_files"):
            self._load_post_and_files()
        return self._files

    POST = property(_get_post, _set_post)
    FILES = property(_get_files)

    @cached_property
    def COOKIES(self):
        return parse_cookie(self.META.get("HTTP_COOKIE", ""))

    def close(self):
        super().close()
        self._stream.close()


class ASGIHandler(base.BaseHandler):
    """Handler for ASGI requests."""

    request_class = ASGIRequest
    # Size to chunk response bodies into for multiple response messages.
    chunk_size = 2**16

    def __init__(self):
        super().__init__()
        self.load_middleware(is_async=True)

    async def __call__(self, scope, receive, send):
        """
        Async entrypoint - parses the request and hands off to get_response.
        """
        # Serve only HTTP connections.
        # FIXME: Allow to override this.
        if scope["type"] != "http":
            raise ValueError(
                "Django can only handle ASGI/HTTP connections, not %s." % scope["type"]
            )

        async with ThreadSensitiveContext():
            await self.handle(scope, receive, send)

    async def handle(self, scope, receive, send):
        """
        Handles the ASGI request. Called via the __call__ method.
        """
        # Receive the HTTP request body as a stream object.
        try:
            body_file = await self.read_body(receive)
        except RequestAborted:
            return
        # Request is complete and can be served.
        set_script_prefix(get_script_prefix(scope))
        await signals.request_started.asend(sender=self.__class__, scope=scope)
        # Get the request and check for basic issues.
        request, error_response = self.create_request(scope, body_file)
        if request is None:
            body_file.close()
            await self.send_response(error_response, send)
            await sync_to_async(error_response.close)()
            return

        async def process_request(request, send):
            response = await self.run_get_response(request)
            try:
                await self.send_response(response, send)
            except asyncio.CancelledError:
                # Client disconnected during send_response (ignore exception).
                pass

            return response

        # Try to catch a disconnect while getting response.
        tasks = [
            # Check the status of these tasks and (optionally) terminate them
            # in this order. The listen_for_disconnect() task goes first
            # because it should not raise unexpected errors that would prevent
            # us from cancelling process_request().
            asyncio.create_task(self.listen_for_disconnect(receive)),
            asyncio.create_task(process_request(request, send)),
        ]
        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
        # Now wait on both tasks (they may have both finished by now).
        for task in tasks:
            if task.done():
                try:
                    task.result()
                except RequestAborted:
                    # Ignore client disconnects.
                    pass
                except AssertionError:
                    body_file.close()
                    raise
            else:
                # Allow views to handle cancellation.
                task.cancel()
                try:
                    await task
                except asyncio.CancelledError:
                    # Task re-raised the CancelledError as expected.
                    pass

        try:
            response = tasks[1].result()
        except asyncio.CancelledError:
            await signals.request_finished.asend(sender=self.__class__)
        else:
            await sync_to_async(response.close)()

        body_file.close()

    async def listen_for_disconnect(self, receive):
        """Listen for disconnect from the client."""
        message = await receive()
        if message["type"] == "http.disconnect":
            raise RequestAborted()
        # This should never happen.
        assert False, "Invalid ASGI message after request body: %s" % message["type"]

    async def run_get_response(self, request):
        """Get async response."""
        # Use the async mode of BaseHandler.
        response = await self.get_response_async(request)
        response._handler_class = self.__class__
        # Increase chunk size on file responses (ASGI servers handles low-level
        # chunking).
        if isinstance(response, FileResponse):
            response.block_size = self.chunk_size
        return response

    async def read_body(self, receive):
        """Reads an HTTP body from an ASGI connection."""
        # Use the tempfile that auto rolls-over to a disk file as it fills up.
        body_file = tempfile.SpooledTemporaryFile(
            max_size=settings.FILE_UPLOAD_MAX_MEMORY_SIZE, mode="w+b"
        )
        while True:
            message = await receive()
            if message["type"] == "http.disconnect":
                body_file.close()
                # Early client disconnect.
                raise RequestAborted()
            # Add a body chunk from the message, if provided.
            if "body" in message:
                body_file.write(message["body"])
            # Quit out if that's the end.
            if not message.get("more_body", False):
                break
        body_file.seek(0)
        return body_file

    def create_request(self, scope, body_file):
        """
        Create the Request object and returns either (request, None) or
        (None, response) if there is an error response.
        """
        try:
            return self.request_class(scope, body_file), None
        except UnicodeDecodeError:
            logger.warning(
                "Bad Request (UnicodeDecodeError)",
                exc_info=sys.exc_info(),
                extra={"status_code": 400},
            )
            return None, HttpResponseBadRequest()
        except RequestDataTooBig:
            return None, HttpResponse("413 Payload too large", status=413)

    def handle_uncaught_exception(self, request, resolver, exc_info):
        """Last-chance handler for exceptions."""
        # There's no WSGI server to catch the exception further up
        # if this fails, so translate it into a plain text response.
        try:
            return super().handle_uncaught_exception(request, resolver, exc_info)
        except Exception:
            return HttpResponseServerError(
                traceback.format_exc() if settings.DEBUG else "Internal Server Error",
                content_type="text/plain",
            )

    async def send_response(self, response, send):
        """Encode and send a response out over ASGI."""
        # Collect cookies into headers. Have to preserve header case as there
        # are some non-RFC compliant clients that require e.g. Content-Type.
        response_headers = []
        for header, value in response.items():
            if isinstance(header, str):
                header = header.encode("ascii")
            if isinstance(value, str):
                value = value.encode("latin1")
            response_headers.append((bytes(header), bytes(value)))
        for c in response.cookies.values():
            response_headers.append(
                (b"Set-Cookie", c.output(header="").encode("ascii").strip())
            )
        # Initial response message.
        await send(
            {
                "type": "http.response.start",
                "status": response.status_code,
                "headers": response_headers,
            }
        )
        # Streaming responses need to be pinned to their iterator.
        if response.streaming:
            # - Consume via `__aiter__` and not `streaming_content` directly, to
            #   allow mapping of a sync iterator.
            # - Use aclosing() when consuming aiter.
            #   See https://github.com/python/cpython/commit/6e8dcda
            async with aclosing(aiter(response)) as content:
                async for part in content:
                    for chunk, _ in self.chunk_bytes(part):
                        await send(
                            {
                                "type": "http.response.body",
                                "body": chunk,
                                # Ignore "more" as there may be more parts; instead,
                                # use an empty final closing message with False.
                                "more_body": True,
                            }
                        )
            # Final closing message.
            await send({"type": "http.response.body"})
        # Other responses just need chunking.
        else:
            # Yield chunks of response.
            for chunk, last in self.chunk_bytes(response.content):
                await send(
                    {
                        "type": "http.response.body",
                        "body": chunk,
                        "more_body": not last,
                    }
                )

    @classmethod
    def chunk_bytes(cls, data):
        """
        Chunks some data up so it can be sent in reasonable size messages.
        Yields (chunk, last_chunk) tuples.
        """
        position = 0
        if not data:
            yield data, True
            return
        while position < len(data):
            yield (
                data[position : position + cls.chunk_size],
                (position + cls.chunk_size) >= len(data),
            )
            position += cls.chunk_size

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\core\handlers\asgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\core\handlers\wsgi.py ---

from io import IOBase

from django.conf import settings
from django.core import signals
from django.core.handlers import base
from django.http import HttpRequest, QueryDict, parse_cookie
from django.urls import set_script_prefix
from django.utils.encoding import repercent_broken_unicode
from django.utils.functional import cached_property
from django.utils.regex_helper import _lazy_re_compile

_slashes_re = _lazy_re_compile(rb"/+")


class LimitedStream(IOBase):
    """
    Wrap another stream to disallow reading it past a number of bytes.

    Based on the implementation from werkzeug.wsgi.LimitedStream
    See https://github.com/pallets/werkzeug/blob/dbf78f67/src/werkzeug/wsgi.py#L828
    """

    def __init__(self, stream, limit):
        self._read = stream.read
        self._readline = stream.readline
        self._pos = 0
        self.limit = limit

    def read(self, size=-1, /):
        _pos = self._pos
        limit = self.limit
        if _pos >= limit:
            return b""
        if size == -1 or size is None:
            size = limit - _pos
        else:
            size = min(size, limit - _pos)
        data = self._read(size)
        self._pos += len(data)
        return data

    def readline(self, size=-1, /):
        _pos = self._pos
        limit = self.limit
        if _pos >= limit:
            return b""
        if size == -1 or size is None:
            size = limit - _pos
        else:
            size = min(size, limit - _pos)
        line = self._readline(size)
        self._pos += len(line)
        return line


class WSGIRequest(HttpRequest):
    def __init__(self, environ):
        script_name = get_script_name(environ)
        # If PATH_INFO is empty (e.g. accessing the SCRIPT_NAME URL without a
        # trailing slash), operate as if '/' was requested.
        path_info = get_path_info(environ) or "/"
        self.environ = environ
        self.path_info = path_info
        # be careful to only replace the first slash in the path because of
        # http://test/something and http://test//something being different as
        # stated in RFC 3986.
        self.path = "%s/%s" % (script_name.rstrip("/"), path_info.replace("/", "", 1))
        self.META = environ
        self.META["PATH_INFO"] = path_info
        self.META["SCRIPT_NAME"] = script_name
        self.method = environ["REQUEST_METHOD"].upper()
        # Set content_type, content_params, and encoding.
        self._set_content_type_params(environ)
        try:
            content_length = int(environ.get("CONTENT_LENGTH"))
        except (ValueError, TypeError):
            content_length = 0
        self._stream = LimitedStream(self.environ["wsgi.input"], content_length)
        self._read_started = False
        self.resolver_match = None

    def _get_scheme(self):
        return self.environ.get("wsgi.url_scheme")

    @cached_property
    def GET(self):
        # The WSGI spec says 'QUERY_STRING' may be absent.
        raw_query_string = get_bytes_from_wsgi(self.environ, "QUERY_STRING", "")
        return QueryDict(raw_query_string, encoding=self._encoding)

    def _get_post(self):
        if not hasattr(self, "_post"):
            self._load_post_and_files()
        return self._post

    def _set_post(self, post):
        self._post = post

    @cached_property
    def COOKIES(self):
        raw_cookie = get_str_from_wsgi(self.environ, "HTTP_COOKIE", "")
        return parse_cookie(raw_cookie)

    @property
    def FILES(self):
        if not hasattr(self, "_files"):
            self._load_post_and_files()
        return self._files

    POST = property(_get_post, _set_post)


class WSGIHandler(base.BaseHandler):
    request_class = WSGIRequest

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.load_middleware()

    def __call__(self, environ, start_response):
        set_script_prefix(get_script_name(environ))
        signals.request_started.send(sender=self.__class__, environ=environ)
        request = self.request_class(environ)
        response = self.get_response(request)

        response._handler_class = self.__class__

        status = "%d %s" % (response.status_code, response.reason_phrase)
        response_headers = [
            *response.items(),
            *(("Set-Cookie", c.output(header="")) for c in response.cookies.values()),
        ]
        start_response(status, response_headers)
        if getattr(response, "file_to_stream", None) is not None and environ.get(
            "wsgi.file_wrapper"
        ):
            # If `wsgi.file_wrapper` is used the WSGI server does not call
            # .close on the response, but on the file wrapper. Patch it to use
            # response.close instead which takes care of closing all files.
            response.file_to_stream.close = response.close
            response = environ["wsgi.file_wrapper"](
                response.file_to_stream, response.block_size
            )
        return response


def get_path_info(environ):
    """Return the HTTP request's PATH_INFO as a string."""
    path_info = get_bytes_from_wsgi(environ, "PATH_INFO", "/")

    return repercent_broken_unicode(path_info).decode()


def get_script_name(environ):
    """
    Return the equivalent of the HTTP request's SCRIPT_NAME environment
    variable. If Apache mod_rewrite is used, return what would have been
    the script name prior to any rewriting (so it's the script name as seen
    from the client's perspective), unless the FORCE_SCRIPT_NAME setting is
    set (to anything).
    """
    if settings.FORCE_SCRIPT_NAME is not None:
        return settings.FORCE_SCRIPT_NAME

    # If Apache's mod_rewrite had a whack at the URL, Apache set either
    # SCRIPT_URL or REDIRECT_URL to the full resource URL before applying any
    # rewrites. Unfortunately not every web server (lighttpd!) passes this
    # information through all the time, so FORCE_SCRIPT_NAME, above, is still
    # needed.
    script_url = get_bytes_from_wsgi(environ, "SCRIPT_URL", "") or get_bytes_from_wsgi(
        environ, "REDIRECT_URL", ""
    )

    if script_url:
        if b"//" in script_url:
            # mod_wsgi squashes multiple successive slashes in PATH_INFO,
            # do the same with script_url before manipulating paths (#17133).
            script_url = _slashes_re.sub(b"/", script_url)
        path_info = get_bytes_from_wsgi(environ, "PATH_INFO", "")
        script_name = script_url.removesuffix(path_info)
    else:
        script_name = get_bytes_from_wsgi(environ, "SCRIPT_NAME", "")

    return script_name.decode()


def get_bytes_from_wsgi(environ, key, default):
    """
    Get a value from the WSGI environ dictionary as bytes.

    key and default should be strings.
    """
    value = environ.get(key, default)
    # Non-ASCII values in the WSGI environ are arbitrarily decoded with
    # ISO-8859-1. This is wrong for Django websites where UTF-8 is the default.
    # Re-encode to recover the original bytestring.
    return value.encode("iso-8859-1")


def get_str_from_wsgi(environ, key, default):
    """
    Get a value from the WSGI environ dictionary as str.

    key and default should be str objects.
    """
    value = get_bytes_from_wsgi(environ, key, default)
    return value.decode(errors="replace")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\core\handlers\wsgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\core\asgi.py ---

import django
from django.core.handlers.asgi import ASGIHandler


def get_asgi_application():
    """
    The public interface to Django's ASGI support. Return an ASGI 3 callable.

    Avoids making django.core.handlers.ASGIHandler a public API, in case the
    internal implementation changes or moves in the future.
    """
    django.setup(set_prefix=False)
    return ASGIHandler()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\core\asgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\core\wsgi.py ---

import django
from django.core.handlers.wsgi import WSGIHandler


def get_wsgi_application():
    """
    The public interface to Django's WSGI support. Return a WSGI callable.

    Avoids making django.core.handlers.WSGIHandler a public API, in case the
    internal WSGI implementation changes or moves in the future.
    """
    django.setup(set_prefix=False)
    return WSGIHandler()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\core\wsgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\db\migrations\operations\models.py ---

from django.db import models
from django.db.migrations.operations.base import Operation, OperationCategory
from django.db.migrations.state import ModelState
from django.db.migrations.utils import field_references, resolve_relation
from django.db.models.options import normalize_together
from django.utils.functional import cached_property

from .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField


def _check_for_duplicates(arg_name, objs):
    used_vals = set()
    for val in objs:
        if val in used_vals:
            raise ValueError(
                "Found duplicate value %s in CreateModel %s argument." % (val, arg_name)
            )
        used_vals.add(val)


class ModelOperation(Operation):
    def __init__(self, name):
        self.name = name

    @cached_property
    def name_lower(self):
        return self.name.lower()

    def references_model(self, name, app_label):
        return name.lower() == self.name_lower

    def reduce(self, operation, app_label):
        return super().reduce(operation, app_label) or self.can_reduce_through(
            operation, app_label
        )

    def can_reduce_through(self, operation, app_label):
        return not operation.references_model(self.name, app_label)


class CreateModel(ModelOperation):
    """Create a model's table."""

    category = OperationCategory.ADDITION
    serialization_expand_args = ["fields", "options", "managers"]

    def __init__(self, name, fields, options=None, bases=None, managers=None):
        self.fields = fields
        self.options = options or {}
        self.bases = bases or (models.Model,)
        self.managers = managers or []
        super().__init__(name)
        # Sanity-check that there are no duplicated field names, bases, or
        # manager names
        _check_for_duplicates("fields", (name for name, _ in self.fields))
        _check_for_duplicates(
            "bases",
            (
                (
                    base._meta.label_lower
                    if hasattr(base, "_meta")
                    else base.lower() if isinstance(base, str) else base
                )
                for base in self.bases
            ),
        )
        _check_for_duplicates("managers", (name for name, _ in self.managers))

    def deconstruct(self):
        kwargs = {
            "name": self.name,
            "fields": self.fields,
        }
        if self.options:
            kwargs["options"] = self.options
        if self.bases and self.bases != (models.Model,):
            kwargs["bases"] = self.bases
        if self.managers and self.managers != [("objects", models.Manager())]:
            kwargs["managers"] = self.managers
        return (self.__class__.__qualname__, [], kwargs)

    def state_forwards(self, app_label, state):
        state.add_model(
            ModelState(
                app_label,
                self.name,
                list(self.fields),
                dict(self.options),
                tuple(self.bases),
                list(self.managers),
            )
        )

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.name)
        if self.allow_migrate_model(schema_editor.connection.alias, model):
            schema_editor.create_model(model)

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        model = from_state.apps.get_model(app_label, self.name)
        if self.allow_migrate_model(schema_editor.connection.alias, model):
            schema_editor.delete_model(model)

    def describe(self):
        return "Create %smodel %s" % (
            "proxy " if self.options.get("proxy", False) else "",
            self.name,
        )

    @property
    def migration_name_fragment(self):
        return self.name_lower

    def references_model(self, name, app_label):
        name_lower = name.lower()
        if name_lower == self.name_lower:
            return True

        # Check we didn't inherit from the model
        reference_model_tuple = (app_label, name_lower)
        for base in self.bases:
            if (
                base is not models.Model
                and isinstance(base, (models.base.ModelBase, str))
                and resolve_relation(base, app_label) == reference_model_tuple
            ):
                return True

        # Check we have no FKs/M2Ms with it
        for _name, field in self.fields:
            if field_references(
                (app_label, self.name_lower), field, reference_model_tuple
            ):
                return True
        return False

    def reduce(self, operation, app_label):
        if (
            isinstance(operation, DeleteModel)
            and self.name_lower == operation.name_lower
            and not self.options.get("proxy", False)
        ):
            return []
        elif (
            isinstance(operation, RenameModel)
            and self.name_lower == operation.old_name_lower
        ):
            return [
                CreateModel(
                    operation.new_name,
                    fields=self.fields,
                    options=self.options,
                    bases=self.bases,
                    managers=self.managers,
                ),
            ]
        elif (
            isinstance(operation, AlterModelOptions)
            and self.name_lower == operation.name_lower
        ):
            options = {**self.options, **operation.options}
            for key in operation.ALTER_OPTION_KEYS:
                if key not in operation.options:
                    options.pop(key, None)
            return [
                CreateModel(
                    self.name,
                    fields=self.fields,
                    options=options,
                    bases=self.bases,
                    managers=self.managers,
                ),
            ]
        elif (
            isinstance(operation, AlterModelManagers)
            and self.name_lower == operation.name_lower
        ):
            return [
                CreateModel(
                    self.name,
                    fields=self.fields,
                    options=self.options,
                    bases=self.bases,
                    managers=operation.managers,
                ),
            ]
        elif (
            isinstance(operation, AlterTogetherOptionOperation)
            and self.name_lower == operation.name_lower
        ):
            return [
                CreateModel(
                    self.name,
                    fields=self.fields,
                    options={
                        **self.options,
                        **{operation.option_name: operation.option_value},
                    },
                    bases=self.bases,
                    managers=self.managers,
                ),
            ]
        elif (
            isinstance(operation, AlterOrderWithRespectTo)
            and self.name_lower == operation.name_lower
        ):
            return [
                CreateModel(
                    self.name,
                    fields=self.fields,
                    options={
                        **self.options,
                        "order_with_respect_to": operation.order_with_respect_to,
                    },
                    bases=self.bases,
                    managers=self.managers,
                ),
            ]
        elif (
            isinstance(operation, FieldOperation)
            and self.name_lower == operation.model_name_lower
        ):
            if isinstance(operation, AddField):
                return [
                    CreateModel(
                        self.name,
                        fields=self.fields + [(operation.name, operation.field)],
                        options=self.options,
                        bases=self.bases,
                        managers=self.managers,
                    ),
                ]
            elif isinstance(operation, AlterField):
                return [
                    CreateModel(
                        self.name,
                        fields=[
                            (n, operation.field if n == operation.name else v)
                            for n, v in self.fields
                        ],
                        options=self.options,
                        bases=self.bases,
                        managers=self.managers,
                    ),
                ]
            elif isinstance(operation, RemoveField):
                options = self.options.copy()
                for option_name in ("unique_together", "index_together"):
                    option = options.pop(option_name, None)
                    if option:
                        option = set(
                            filter(
                                bool,
                                (
                                    tuple(
                                        f for f in fields if f != operation.name_lower
                                    )
                                    for fields in option
                                ),
                            )
                        )
                        if option:
                            options[option_name] = option
                order_with_respect_to = options.get("order_with_respect_to")
                if order_with_respect_to == operation.name_lower:
                    del options["order_with_respect_to"]
                return [
                    CreateModel(
                        self.name,
                        fields=[
                            (n, v)
                            for n, v in self.fields
                            if n.lower() != operation.name_lower
                        ],
                        options=options,
                        bases=self.bases,
                        managers=self.managers,
                    ),
                ]
            elif isinstance(operation, RenameField):
                options = self.options.copy()
                for option_name in ("unique_together", "index_together"):
                    option = options.get(option_name)
                    if option:
                        options[option_name] = {
                            tuple(
                                operation.new_name if f == operation.old_name else f
                                for f in fields
                            )
                            for fields in option
                        }
                order_with_respect_to = options.get("order_with_respect_to")
                if order_with_respect_to == operation.old_name:
                    options["order_with_respect_to"] = operation.new_name
                return [
                    CreateModel(
                        self.name,
                        fields=[
                            (operation.new_name if n == operation.old_name else n, v)
                            for n, v in self.fields
                        ],
                        options=options,
                        bases=self.bases,
                        managers=self.managers,
                    ),
                ]
        elif (
            isinstance(operation, IndexOperation)
            and self.name_lower == operation.model_name_lower
        ):
            if isinstance(operation, AddIndex):
                return [
                    CreateModel(
                        self.name,
                        fields=self.fields,
                        options={
                            **self.options,
                            "indexes": [
                                *self.options.get("indexes", []),
                                operation.index,
                            ],
                        },
                        bases=self.bases,
                        managers=self.managers,
                    ),
                ]
            elif isinstance(operation, RemoveIndex):
                options_indexes = [
                    index
                    for index in self.options.get("indexes", [])
                    if index.name != operation.name
                ]
                return [
                    CreateModel(
                        self.name,
                        fields=self.fields,
                        options={
                            **self.options,
                            "indexes": options_indexes,
                        },
                        bases=self.bases,
                        managers=self.managers,
                    ),
                ]
            elif isinstance(operation, AddConstraint):
                return [
                    CreateModel(
                        self.name,
                        fields=self.fields,
                        options={
                            **self.options,
                            "constraints": [
                                *self.options.get("constraints", []),
                                operation.constraint,
                            ],
                        },
                        bases=self.bases,
                        managers=self.managers,
                    ),
                ]
            elif isinstance(operation, RemoveConstraint):
                options_constraints = [
                    constraint
                    for constraint in self.options.get("constraints", [])
                    if constraint.name != operation.name
                ]
                return [
                    CreateModel(
                        self.name,
                        fields=self.fields,
                        options={
                            **self.options,
                            "constraints": options_constraints,
                        },
                        bases=self.bases,
                        managers=self.managers,
                    ),
                ]
        return super().reduce(operation, app_label)


class DeleteModel(ModelOperation):
    """Drop a model's table."""

    category = OperationCategory.REMOVAL

    def deconstruct(self):
        kwargs = {
            "name": self.name,
        }
        return (self.__class__.__qualname__, [], kwargs)

    def state_forwards(self, app_label, state):
        state.remove_model(app_label, self.name_lower)

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        model = from_state.apps.get_model(app_label, self.name)
        if self.allow_migrate_model(schema_editor.connection.alias, model):
            schema_editor.delete_model(model)

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.name)
        if self.allow_migrate_model(schema_editor.connection.alias, model):
            schema_editor.create_model(model)

    def references_model(self, name, app_label):
        # The deleted model could be referencing the specified model through
        # related fields.
        return True

    def describe(self):
        return "Delete model %s" % self.name

    @property
    def migration_name_fragment(self):
        return "delete_%s" % self.name_lower


class RenameModel(ModelOperation):
    """Rename a model."""

    category = OperationCategory.ALTERATION

    def __init__(self, old_name, new_name):
        self.old_name = old_name
        self.new_name = new_name
        super().__init__(old_name)

    @cached_property
    def old_name_lower(self):
        return self.old_name.lower()

    @cached_property
    def new_name_lower(self):
        return self.new_name.lower()

    def deconstruct(self):
        kwargs = {
            "old_name": self.old_name,
            "new_name": self.new_name,
        }
        return (self.__class__.__qualname__, [], kwargs)

    def state_forwards(self, app_label, state):
        state.rename_model(app_label, self.old_name, self.new_name)

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        new_model = to_state.apps.get_model(app_label, self.new_name)
        if self.allow_migrate_model(schema_editor.connection.alias, new_model):
            old_model = from_state.apps.get_model(app_label, self.old_name)
            # Move the main table
            schema_editor.alter_db_table(
                new_model,
                old_model._meta.db_table,
                new_model._meta.db_table,
            )
            # Alter the fields pointing to us
            for related_object in old_model._meta.related_objects:
                if related_object.related_model == old_model:
                    model = new_model
                    related_key = (app_label, self.new_name_lower)
                else:
                    related_key = (
                        related_object.related_model._meta.app_label,
                        related_object.related_model._meta.model_name,
                    )
                    model = to_state.apps.get_model(*related_key)
                to_field = to_state.apps.get_model(*related_key)._meta.get_field(
                    related_object.field.name
                )
                schema_editor.alter_field(
                    model,
                    related_object.field,
                    to_field,
                )
            # Rename M2M fields whose name is based on this model's name.
            fields = zip(
                old_model._meta.local_many_to_many, new_model._meta.local_many_to_many
            )
            for old_field, new_field in fields:
                # Skip self-referential fields as these are renamed above.
                if (
                    new_field.model == new_field.related_model
                    or not new_field.remote_field.through._meta.auto_created
                ):
                    continue
                # Rename columns and the M2M table.
                schema_editor._alter_many_to_many(
                    new_model,
                    old_field,
                    new_field,
                    strict=False,
                )

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        self.new_name_lower, self.old_name_lower = (
            self.old_name_lower,
            self.new_name_lower,
        )
        self.new_name, self.old_name = self.old_name, self.new_name

        self.database_forwards(app_label, schema_editor, from_state, to_state)

        self.new_name_lower, self.old_name_lower = (
            self.old_name_lower,
            self.new_name_lower,
        )
        self.new_name, self.old_name = self.old_name, self.new_name

    def references_model(self, name, app_label):
        return (
            name.lower() == self.old_name_lower or name.lower() == self.new_name_lower
        )

    def describe(self):
        return "Rename model %s to %s" % (self.old_name, self.new_name)

    @property
    def migration_name_fragment(self):
        return "rename_%s_%s" % (self.old_name_lower, self.new_name_lower)

    def reduce(self, operation, app_label):
        if (
            isinstance(operation, RenameModel)
            and self.new_name_lower == operation.old_name_lower
        ):
            return [
                RenameModel(
                    self.old_name,
                    operation.new_name,
                ),
            ]
        # Skip `ModelOperation.reduce` as we want to run `references_model`
        # against self.new_name.
        return super(ModelOperation, self).reduce(
            operation, app_label
        ) or not operation.references_model(self.new_name, app_label)


class ModelOptionOperation(ModelOperation):
    category = OperationCategory.ALTERATION

    def reduce(self, operation, app_label):
        if (
            isinstance(operation, (self.__class__, DeleteModel))
            and self.name_lower == operation.name_lower
        ):
            return [operation]
        return super().reduce(operation, app_label)


class AlterModelTable(ModelOptionOperation):
    """Rename a model's table."""

    def __init__(self, name, table):
        self.table = table
        super().__init__(name)

    def deconstruct(self):
        kwargs = {
            "name": self.name,
            "table": self.table,
        }
        return (self.__class__.__qualname__, [], kwargs)

    def state_forwards(self, app_label, state):
        state.alter_model_options(app_label, self.name_lower, {"db_table": self.table})

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        new_model = to_state.apps.get_model(app_label, self.name)
        if self.allow_migrate_model(schema_editor.connection.alias, new_model):
            old_model = from_state.apps.get_model(app_label, self.name)
            schema_editor.alter_db_table(
                new_model,
                old_model._meta.db_table,
                new_model._meta.db_table,
            )
            # Rename M2M fields whose name is based on this model's db_table
            for old_field, new_field in zip(
                old_model._meta.local_many_to_many, new_model._meta.local_many_to_many
            ):
                if new_field.remote_field.through._meta.auto_created:
                    schema_editor.alter_db_table(
                        new_field.remote_field.through,
                        old_field.remote_field.through._meta.db_table,
                        new_field.remote_field.through._meta.db_table,
                    )

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        return self.database_forwards(app_label, schema_editor, from_state, to_state)

    def describe(self):
        return "Rename table for %s to %s" % (
            self.name,
            self.table if self.table is not None else "(default)",
        )

    @property
    def migration_name_fragment(self):
        return "alter_%s_table" % self.name_lower


class AlterModelTableComment(ModelOptionOperation):
    def __init__(self, name, table_comment):
        self.table_comment = table_comment
        super().__init__(name)

    def deconstruct(self):
        kwargs = {
            "name": self.name,
            "table_comment": self.table_comment,
        }
        return (self.__class__.__qualname__, [], kwargs)

    def state_forwards(self, app_label, state):
        state.alter_model_options(
            app_label, self.name_lower, {"db_table_comment": self.table_comment}
        )

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        new_model = to_state.apps.get_model(app_label, self.name)
        if self.allow_migrate_model(schema_editor.connection.alias, new_model):
            old_model = from_state.apps.get_model(app_label, self.name)
            schema_editor.alter_db_table_comment(
                new_model,
                old_model._meta.db_table_comment,
                new_model._meta.db_table_comment,
            )

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        return self.database_forwards(app_label, schema_editor, from_state, to_state)

    def describe(self):
        return f"Alter {self.name} table comment"

    @property
    def migration_name_fragment(self):
        return f"alter_{self.name_lower}_table_comment"


class AlterTogetherOptionOperation(ModelOptionOperation):
    option_name = None

    def __init__(self, name, option_value):
        if option_value:
            option_value = set(normalize_together(option_value))
        setattr(self, self.option_name, option_value)
        super().__init__(name)

    @cached_property
    def option_value(self):
        return getattr(self, self.option_name)

    def deconstruct(self):
        kwargs = {
            "name": self.name,
            self.option_name: self.option_value,
        }
        return (self.__class__.__qualname__, [], kwargs)

    def state_forwards(self, app_label, state):
        state.alter_model_options(
            app_label,
            self.name_lower,
            {self.option_name: self.option_value},
        )

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        new_model = to_state.apps.get_model(app_label, self.name)
        if self.allow_migrate_model(schema_editor.connection.alias, new_model):
            old_model = from_state.apps.get_model(app_label, self.name)
            alter_together = getattr(schema_editor, "alter_%s" % self.option_name)
            alter_together(
                new_model,
                getattr(old_model._meta, self.option_name, set()),
                getattr(new_model._meta, self.option_name, set()),
            )

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        return self.database_forwards(app_label, schema_editor, from_state, to_state)

    def references_field(self, model_name, name, app_label):
        return self.references_model(model_name, app_label) and (
            not self.option_value
            or any((name in fields) for fields in self.option_value)
        )

    def describe(self):
        return "Alter %s for %s (%s constraint(s))" % (
            self.option_name,
            self.name,
            len(self.option_value or ""),
        )

    @property
    def migration_name_fragment(self):
        return "alter_%s_%s" % (self.name_lower, self.option_name)

    def can_reduce_through(self, operation, app_label):
        return super().can_reduce_through(operation, app_label) or (
            isinstance(operation, AlterTogetherOptionOperation)
            and type(operation) is not type(self)
        )


class AlterUniqueTogether(AlterTogetherOptionOperation):
    """
    Change the value of unique_together to the target one.
    Input value of unique_together must be a set of tuples.
    """

    option_name = "unique_together"

    def __init__(self, name, unique_together):
        super().__init__(name, unique_together)


class AlterIndexTogether(AlterTogetherOptionOperation):
    """
    Change the value of index_together to the target one.
    Input value of index_together must be a set of tuples.
    """

    option_name = "index_together"

    def __init__(self, name, index_together):
        super().__init__(name, index_together)


class AlterOrderWithRespectTo(ModelOptionOperation):
    """Represent a change with the order_with_respect_to option."""

    option_name = "order_with_respect_to"

    def __init__(self, name, order_with_respect_to):
        self.order_with_respect_to = order_with_respect_to
        super().__init__(name)

    def deconstruct(self):
        kwargs = {
            "name": self.name,
            "order_with_respect_to": self.order_with_respect_to,
        }
        return (self.__class__.__qualname__, [], kwargs)

    def state_forwards(self, app_label, state):
        state.alter_model_options(
            app_label,
            self.name_lower,
            {self.option_name: self.order_with_respect_to},
        )

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        to_model = to_state.apps.get_model(app_label, self.name)
        if self.allow_migrate_model(schema_editor.connection.alias, to_model):
            from_model = from_state.apps.get_model(app_label, self.name)
            # Remove a field if we need to
            if (
                from_model._meta.order_with_respect_to
                and not to_model._meta.order_with_respect_to
            ):
                schema_editor.remove_field(
                    from_model, from_model._meta.get_field("_order")
                )
            # Add a field if we need to (altering the column is untouched as
            # it's likely a rename)
            elif (
                to_model._meta.order_with_respect_to
                and not from_model._meta.order_with_respect_to
            ):
                field = to_model._meta.get_field("_order")
                if not field.has_default():
                    field.default = 0
                schema_editor.add_field(
                    from_model,
                    field,
                )

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        self.database_forwards(app_label, schema_editor, from_state, to_state)

    def references_field(self, model_name, name, app_label):
        return self.references_model(model_name, app_label) and (
            self.order_with_respect_to is None or name == self.order_with_respect_to
        )

    def describe(self):
        return "Set order_with_respect_to on %s to %s" % (
            self.name,
            self.order_with_respect_to,
        )

    @property
    def migration_name_fragment(self):
        return "alter_%s_order_with_respect_to" % self.name_lower


class AlterModelOptions(ModelOptionOperation):
    """
    Set new model options that don't directly affect the database schema
    (like verbose_name, permissions, ordering). Python code in migrations
    may still need them.
    """

    # Model options we want to compare and preserve in an AlterModelOptions op
    ALTER_OPTION_KEYS = [
        "base_manager_name",
        "default_manager_name",
        "default_related_name",
        "get_latest_by",
        "managed",
        "ordering",
        "permissions",
        "default_permissions",
        "select_on_save",
        "verbose_name",
        "verbose_name_plural",
    ]

    def __init__(self, name, options):
        self.options = options
        super().__init__(name)

    def deconstruct(self):
        kwargs = {
            "name": self.name,
            "options": self.options,
        }
        return (self.__class__.__qualname__, [], kwargs)

    def state_forwards(self, app_label, state):
        state.alter_model_options(
            app_label,
            self.name_lower,
            self.options,
            self.ALTER_OPTION_KEYS,
        )

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        pass

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        pass

    def describe(self):
        return "Change Meta options on %s" % self.name

    @property
    def migration_name_fragment(self):
        return "alter_%s_options" % self.name_lower


class AlterModelManagers(ModelOptionOperation):
    """Alter the model's managers."""

    serialization_expand_args = ["managers"]

    def __init__(self, name, managers):
        self.managers = managers
        super().__init__(name)

    def deconstruct(self):
        return (self.__class__.__qualname__, [self.name, self.managers], {})

    def state_forwards(self, app_label, state):
        state.alter_model_managers(app_label, self.name_lower, self.managers)

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        pass

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        pass

    def describe(self):
        return "Change managers on %s" % self.name

    @property
    def migration_name_fragment(self):
        return "alter_%s_managers" % self.name_lower


class IndexOperation(Operation):
    option_name = "indexes"

    @cached_property
    def model_name_lower(self):
        return self.model_name.lower()


class AddIndex(IndexOperation):
    """Add an index on a model."""

    category = OperationCategory.ADDITION

    def __init__(self, model_name, index):
        self.model_name = model_name
        if not index.name:
            raise ValueError(
                "Indexes passed to AddIndex operations require a name "
                "argument. %r doesn't have one." % index
            )
        self.index = index

    def state_forwards(self, app_label, state):
        state.add_index(app_label, self.model_name_lower, self.index)

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.model_name)
        if self.allow_migrate_model(schema_editor.connection.alias, model):
            schema_editor.add_index(model, self.index)

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        model = from_state.apps.get_model(app_label, self.model_name)
        if self.allow_migrate_model(schema_editor.connection.alias, model):
            schema_editor.remove_index(model, self.index)

    def deconstruct(self):
        kwargs = {
            "model_name": self.model_name,
            "index": self.index,
        }
        return (
            self.__class__.__qualname__,
            [],
            kwargs,
        )

    def describe(self):
        if self.index.expressions:
            return "Create index %s on %s on model %s" % (
                self.index.name,
                ", ".join([str(expression) for expression in self.index.expressions]),
                self.model_name,
            )
        return "Create index %s on field(s) %s of model %s" % (
            self.index.name,
            ", ".join(self.index.fields),
            self.model_name,
        )

    @property
    def migration_name_fragment(self):
        return "%s_%s" % (self.model_name_lower, self.index.name.lower())

    def reduce(self, operation, app_label):
        if isinstance(operation, RemoveIndex) and self.index.name == operation.name:
            return []
        if isinstance(operation, RenameIndex) and self.index.name == operation.old_name:
            self.index.name = operation.new_name
            return [AddIndex(model_name=self.model_name, index=self.index)]
        return super().reduce(operation, app_label)


class RemoveIndex(IndexOperation):
    """Remove an index from a model."""

    category = OperationCategory.REMOVAL

    def __init__(self, model_name, name):
        self.model_name = model_name
        self.name = name

    def state_forwards(self, app_label, state):
        state.remove_index(app_label, self.model_name_lower, self.name)

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        model = from_state.apps.get_model(app_label, self.model_name)
        if self.allow_migrate_model(schema_editor.connection.alias, model):
            from_model_state = from_state.models[app_label, self.model_name_lower]
            index = from_model_state.get_index_by_name(self.name)
            schema_editor.remove_index(model, index)

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.model_name)
        if self.allow_migrate_model(schema_editor.connection.alias, model):
            to_model_state = to_state.models[app_label, self.model_name_lower]
            index = to_model_state.get_index_by_name(self.name)
            schema_editor.add_index(model, index)

    def deconstruct(self):
        kwargs = {
            "model_name": self.model_name,
            "name": self.name,
        }
        return (
            self.__class__.__qualname__,
            [],
            kwargs,
        )

    def describe(self):
        return "Remove index %s from %s" % (self.name, self.model_name)

    @property
    def migration_name_fragment(self):
        return "remove_%s_%s" % (self.model_name_lower, self.name.lower())


class RenameIndex(IndexOperation):
    """Rename an index."""

    category = OperationCategory.ALTERATION

    def __init__(self, model_name, new_name, old_name=None, old_fields=None):
        if not old_name and not old_fields:
            raise ValueError(
                "RenameIndex requires one of old_name and old_fields arguments to be "
                "set."
            )
        if old_name and old_fields:
            raise ValueError(
                "RenameIndex.old_name and old_fields are mutually exclusive."
            )
        self.model_name = model_name
        self.new_name = new_name
        self.old_name = old_name
        self.old_fields = old_fields

    @cached_property
    def old_name_lower(self):
        return self.old_name.lower()

    @cached_property
    def new_name_lower(self):
        return self.new_name.lower()

    def deconstruct(self):
        kwargs = {
            "model_name": self.model_name,
            "new_name": self.new_name,
        }
        if self.old_name:
            kwargs["old_name"] = self.old_name
        if self.old_fields:
            kwargs["old_fields"] = self.old_fields
        return (self.__class__.__qualname__, [], kwargs)

    def state_forwards(self, app_label, state):
        if self.old_fields:
            state.add_index(
                app_label,
                self.model_name_lower,
                models.Index(fields=self.old_fields, name=self.new_name),
            )
            state.remove_model_options(
                app_label,
                self.model_name_lower,
                AlterIndexTogether.option_name,
                self.old_fields,
            )
        else:
            state.rename_index(
                app_label, self.model_name_lower, self.old_name, self.new_name
            )

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.model_name)
        if not self.allow_migrate_model(schema_editor.connection.alias, model):
            return

        if self.old_fields:
            from_model = from_state.apps.get_model(app_label, self.model_name)
            columns = [
                from_model._meta.get_field(field).column for field in self.old_fields
            ]
            matching_index_name = schema_editor._constraint_names(
                from_model,
                column_names=columns,
                index=True,
                unique=False,
            )
            if len(matching_index_name) != 1:
                raise ValueError(
                    "Found wrong number (%s) of indexes for %s(%s)."
                    % (
                        len(matching_index_name),
                        from_model._meta.db_table,
                        ", ".join(columns),
                    )
                )
            old_index = models.Index(
                fields=self.old_fields,
                name=matching_index_name[0],
            )
        else:
            from_model_state = from_state.models[app_label, self.model_name_lower]
            old_index = from_model_state.get_index_by_name(self.old_name)
        # Don't alter when the index name is not changed.
        if old_index.name == self.new_name:
            return

        to_model_state = to_state.models[app_label, self.model_name_lower]
        new_index = to_model_state.get_index_by_name(self.new_name)
        schema_editor.rename_index(model, old_index, new_index)

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        if self.old_fields:
            # Backward operation with unnamed index is a no-op.
            return

        self.new_name_lower, self.old_name_lower = (
            self.old_name_lower,
            self.new_name_lower,
        )
        self.new_name, self.old_name = self.old_name, self.new_name

        self.database_forwards(app_label, schema_editor, from_state, to_state)

        self.new_name_lower, self.old_name_lower = (
            self.old_name_lower,
            self.new_name_lower,
        )
        self.new_name, self.old_name = self.old_name, self.new_name

    def describe(self):
        if self.old_name:
            return (
                f"Rename index {self.old_name} on {self.model_name} to {self.new_name}"
            )
        return (
            f"Rename unnamed index for {self.old_fields} on {self.model_name} to "
            f"{self.new_name}"
        )

    @property
    def migration_name_fragment(self):
        if self.old_name:
            return "rename_%s_%s" % (self.old_name_lower, self.new_name_lower)
        return "rename_%s_%s_%s" % (
            self.model_name_lower,
            "_".join(self.old_fields),
            self.new_name_lower,
        )

    def reduce(self, operation, app_label):
        if (
            isinstance(operation, RenameIndex)
            and self.model_name_lower == operation.model_name_lower
            and operation.old_name
            and self.new_name_lower == operation.old_name_lower
        ):
            return [
                RenameIndex(
                    self.model_name,
                    new_name=operation.new_name,
                    old_name=self.old_name,
                    old_fields=self.old_fields,
                )
            ]
        return super().reduce(operation, app_label)


class AddConstraint(IndexOperation):
    category = OperationCategory.ADDITION
    option_name = "constraints"

    def __init__(self, model_name, constraint):
        self.model_name = model_name
        self.constraint = constraint

    def state_forwards(self, app_label, state):
        state.add_constraint(app_label, self.model_name_lower, self.constraint)

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.model_name)
        if self.allow_migrate_model(schema_editor.connection.alias, model):
            schema_editor.add_constraint(model, self.constraint)

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.model_name)
        if self.allow_migrate_model(schema_editor.connection.alias, model):
            schema_editor.remove_constraint(model, self.constraint)

    def deconstruct(self):
        return (
            self.__class__.__name__,
            [],
            {
                "model_name": self.model_name,
                "constraint": self.constraint,
            },
        )

    def describe(self):
        return "Create constraint %s on model %s" % (
            self.constraint.name,
            self.model_name,
        )

    @property
    def migration_name_fragment(self):
        return "%s_%s" % (self.model_name_lower, self.constraint.name.lower())

    def reduce(self, operation, app_label):
        if (
            isinstance(operation, RemoveConstraint)
            and self.model_name_lower == operation.model_name_lower
            and self.constraint.name == operation.name
        ):
            return []
        return super().reduce(operation, app_label)


class RemoveConstraint(IndexOperation):
    category = OperationCategory.REMOVAL
    option_name = "constraints"

    def __init__(self, model_name, name):
        self.model_name = model_name
        self.name = name

    def state_forwards(self, app_label, state):
        state.remove_constraint(app_label, self.model_name_lower, self.name)

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.model_name)
        if self.allow_migrate_model(schema_editor.connection.alias, model):
            from_model_state = from_state.models[app_label, self.model_name_lower]
            constraint = from_model_state.get_constraint_by_name(self.name)
            schema_editor.remove_constraint(model, constraint)

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.model_name)
        if self.allow_migrate_model(schema_editor.connection.alias, model):
            to_model_state = to_state.models[app_label, self.model_name_lower]
            constraint = to_model_state.get_constraint_by_name(self.name)
            schema_editor.add_constraint(model, constraint)

    def deconstruct(self):
        return (
            self.__class__.__name__,
            [],
            {
                "model_name": self.model_name,
                "name": self.name,
            },
        )

    def describe(self):
        return "Remove constraint %s from model %s" % (self.name, self.model_name)

    @property
    def migration_name_fragment(self):
        return "remove_%s_%s" % (self.model_name_lower, self.name.lower())

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\db\migrations\operations\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\forms\models.py ---

"""
Helper functions for creating Form classes from Django models
and database field objects.
"""

from itertools import chain

from django.core.exceptions import (
    NON_FIELD_ERRORS,
    FieldError,
    ImproperlyConfigured,
    ValidationError,
)
from django.core.validators import ProhibitNullCharactersValidator
from django.db.models.utils import AltersData
from django.forms.fields import ChoiceField, Field
from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass
from django.forms.formsets import BaseFormSet, formset_factory
from django.forms.utils import ErrorList
from django.forms.widgets import (
    HiddenInput,
    MultipleHiddenInput,
    RadioSelect,
    SelectMultiple,
)
from django.utils.choices import BaseChoiceIterator
from django.utils.hashable import make_hashable
from django.utils.text import capfirst, get_text_list
from django.utils.translation import gettext
from django.utils.translation import gettext_lazy as _

__all__ = (
    "ModelForm",
    "BaseModelForm",
    "model_to_dict",
    "fields_for_model",
    "ModelChoiceField",
    "ModelMultipleChoiceField",
    "ALL_FIELDS",
    "BaseModelFormSet",
    "modelformset_factory",
    "BaseInlineFormSet",
    "inlineformset_factory",
    "modelform_factory",
)

ALL_FIELDS = "__all__"


def construct_instance(form, instance, fields=None, exclude=None):
    """
    Construct and return a model instance from the bound ``form``'s
    ``cleaned_data``, but do not save the returned instance to the database.
    """
    from django.db import models

    opts = instance._meta

    cleaned_data = form.cleaned_data
    file_field_list = []
    for f in opts.fields:
        if (
            not f.editable
            or isinstance(f, models.AutoField)
            or f.name not in cleaned_data
        ):
            continue
        if fields is not None and f.name not in fields:
            continue
        if exclude and f.name in exclude:
            continue
        # Leave defaults for fields that aren't in POST data, except for
        # checkbox inputs because they don't appear in POST data if not checked.
        if (
            f.has_default()
            and form[f.name].field.widget.value_omitted_from_data(
                form.data, form.files, form.add_prefix(f.name)
            )
            and cleaned_data.get(f.name) in form[f.name].field.empty_values
        ):
            continue
        # Defer saving file-type fields until after the other fields, so a
        # callable upload_to can use the values from other fields.
        if isinstance(f, models.FileField):
            file_field_list.append(f)
        else:
            f.save_form_data(instance, cleaned_data[f.name])

    for f in file_field_list:
        f.save_form_data(instance, cleaned_data[f.name])

    return instance


# ModelForms #################################################################


def model_to_dict(instance, fields=None, exclude=None):
    """
    Return a dict containing the data in ``instance`` suitable for passing as
    a Form's ``initial`` keyword argument.

    ``fields`` is an optional list of field names. If provided, return only the
    named.

    ``exclude`` is an optional list of field names. If provided, exclude the
    named from the returned dict, even if they are listed in the ``fields``
    argument.
    """
    opts = instance._meta
    data = {}
    for f in chain(opts.concrete_fields, opts.private_fields, opts.many_to_many):
        if not getattr(f, "editable", False):
            continue
        if fields is not None and f.name not in fields:
            continue
        if exclude and f.name in exclude:
            continue
        data[f.name] = f.value_from_object(instance)
    return data


def apply_limit_choices_to_to_formfield(formfield):
    """Apply limit_choices_to to the formfield's queryset if needed."""
    from django.db.models import Exists, OuterRef, Q

    if hasattr(formfield, "queryset") and hasattr(formfield, "get_limit_choices_to"):
        limit_choices_to = formfield.get_limit_choices_to()
        if limit_choices_to:
            complex_filter = limit_choices_to
            if not isinstance(complex_filter, Q):
                complex_filter = Q(**limit_choices_to)
            complex_filter &= Q(pk=OuterRef("pk"))
            # Use Exists() to avoid potential duplicates.
            formfield.queryset = formfield.queryset.filter(
                Exists(formfield.queryset.model._base_manager.filter(complex_filter)),
            )


def fields_for_model(
    model,
    fields=None,
    exclude=None,
    widgets=None,
    formfield_callback=None,
    localized_fields=None,
    labels=None,
    help_texts=None,
    error_messages=None,
    field_classes=None,
    *,
    apply_limit_choices_to=True,
    form_declared_fields=None,
):
    """
    Return a dictionary containing form fields for the given model.

    ``fields`` is an optional list of field names. If provided, return only the
    named fields.

    ``exclude`` is an optional list of field names. If provided, exclude the
    named fields from the returned fields, even if they are listed in the
    ``fields`` argument.

    ``widgets`` is a dictionary of model field names mapped to a widget.

    ``formfield_callback`` is a callable that takes a model field and returns
    a form field.

    ``localized_fields`` is a list of names of fields which should be localized.

    ``labels`` is a dictionary of model field names mapped to a label.

    ``help_texts`` is a dictionary of model field names mapped to a help text.

    ``error_messages`` is a dictionary of model field names mapped to a
    dictionary of error messages.

    ``field_classes`` is a dictionary of model field names mapped to a form
    field class.

    ``apply_limit_choices_to`` is a boolean indicating if limit_choices_to
    should be applied to a field's queryset.

    ``form_declared_fields`` is a dictionary of form fields created directly on
    a form.
    """
    form_declared_fields = form_declared_fields or {}
    field_dict = {}
    ignored = []
    opts = model._meta
    # Avoid circular import
    from django.db.models import Field as ModelField

    sortable_private_fields = [
        f for f in opts.private_fields if isinstance(f, ModelField)
    ]
    for f in sorted(
        chain(opts.concrete_fields, sortable_private_fields, opts.many_to_many)
    ):
        if not getattr(f, "editable", False):
            if (
                fields is not None
                and f.name in fields
                and (exclude is None or f.name not in exclude)
            ):
                raise FieldError(
                    "'%s' cannot be specified for %s model form as it is a "
                    "non-editable field" % (f.name, model.__name__)
                )
            continue
        if fields is not None and f.name not in fields:
            continue
        if exclude and f.name in exclude:
            continue
        if f.name in form_declared_fields:
            field_dict[f.name] = form_declared_fields[f.name]
            continue

        kwargs = {}
        if widgets and f.name in widgets:
            kwargs["widget"] = widgets[f.name]
        if localized_fields == ALL_FIELDS or (
            localized_fields and f.name in localized_fields
        ):
            kwargs["localize"] = True
        if labels and f.name in labels:
            kwargs["label"] = labels[f.name]
        if help_texts and f.name in help_texts:
            kwargs["help_text"] = help_texts[f.name]
        if error_messages and f.name in error_messages:
            kwargs["error_messages"] = error_messages[f.name]
        if field_classes and f.name in field_classes:
            kwargs["form_class"] = field_classes[f.name]

        if formfield_callback is None:
            formfield = f.formfield(**kwargs)
        elif not callable(formfield_callback):
            raise TypeError("formfield_callback must be a function or callable")
        else:
            formfield = formfield_callback(f, **kwargs)

        if formfield:
            if apply_limit_choices_to:
                apply_limit_choices_to_to_formfield(formfield)
            field_dict[f.name] = formfield
        else:
            ignored.append(f.name)
    if fields:
        field_dict = {
            f: field_dict.get(f)
            for f in fields
            if (not exclude or f not in exclude) and f not in ignored
        }
    return field_dict


class ModelFormOptions:
    def __init__(self, options=None):
        self.model = getattr(options, "model", None)
        self.fields = getattr(options, "fields", None)
        self.exclude = getattr(options, "exclude", None)
        self.widgets = getattr(options, "widgets", None)
        self.localized_fields = getattr(options, "localized_fields", None)
        self.labels = getattr(options, "labels", None)
        self.help_texts = getattr(options, "help_texts", None)
        self.error_messages = getattr(options, "error_messages", None)
        self.field_classes = getattr(options, "field_classes", None)
        self.formfield_callback = getattr(options, "formfield_callback", None)


class ModelFormMetaclass(DeclarativeFieldsMetaclass):
    def __new__(mcs, name, bases, attrs):
        new_class = super().__new__(mcs, name, bases, attrs)

        if bases == (BaseModelForm,):
            return new_class

        opts = new_class._meta = ModelFormOptions(getattr(new_class, "Meta", None))

        # We check if a string was passed to `fields` or `exclude`,
        # which is likely to be a mistake where the user typed ('foo') instead
        # of ('foo',)
        for opt in ["fields", "exclude", "localized_fields"]:
            value = getattr(opts, opt)
            if isinstance(value, str) and value != ALL_FIELDS:
                msg = (
                    "%(model)s.Meta.%(opt)s cannot be a string. "
                    "Did you mean to type: ('%(value)s',)?"
                    % {
                        "model": new_class.__name__,
                        "opt": opt,
                        "value": value,
                    }
                )
                raise TypeError(msg)

        if opts.model:
            # If a model is defined, extract form fields from it.
            if opts.fields is None and opts.exclude is None:
                raise ImproperlyConfigured(
                    "Creating a ModelForm without either the 'fields' attribute "
                    "or the 'exclude' attribute is prohibited; form %s "
                    "needs updating." % name
                )

            if opts.fields == ALL_FIELDS:
                # Sentinel for fields_for_model to indicate "get the list of
                # fields from the model"
                opts.fields = None

            fields = fields_for_model(
                opts.model,
                opts.fields,
                opts.exclude,
                opts.widgets,
                opts.formfield_callback,
                opts.localized_fields,
                opts.labels,
                opts.help_texts,
                opts.error_messages,
                opts.field_classes,
                # limit_choices_to will be applied during ModelForm.__init__().
                apply_limit_choices_to=False,
                form_declared_fields=new_class.declared_fields,
            )

            # make sure opts.fields doesn't specify an invalid field
            none_model_fields = {k for k, v in fields.items() if not v}
            missing_fields = none_model_fields.difference(new_class.declared_fields)
            if missing_fields:
                message = "Unknown field(s) (%s) specified for %s"
                message %= (", ".join(missing_fields), opts.model.__name__)
                raise FieldError(message)
            # Include all the other declared fields.
            fields.update(new_class.declared_fields)
        else:
            fields = new_class.declared_fields

        new_class.base_fields = fields

        return new_class


class BaseModelForm(BaseForm, AltersData):
    def __init__(
        self,
        data=None,
        files=None,
        auto_id="id_%s",
        prefix=None,
        initial=None,
        error_class=ErrorList,
        label_suffix=None,
        empty_permitted=False,
        instance=None,
        use_required_attribute=None,
        renderer=None,
    ):
        opts = self._meta
        if opts.model is None:
            raise ValueError("ModelForm has no model class specified.")
        if instance is None:
            # if we didn't get an instance, instantiate a new one
            self.instance = opts.model()
            object_data = {}
        else:
            self.instance = instance
            object_data = model_to_dict(instance, opts.fields, opts.exclude)
        # if initial was provided, it should override the values from instance
        if initial is not None:
            object_data.update(initial)
        # self._validate_unique will be set to True by BaseModelForm.clean().
        # It is False by default so overriding self.clean() and failing to call
        # super will stop validate_unique from being called.
        self._validate_unique = False
        super().__init__(
            data,
            files,
            auto_id,
            prefix,
            object_data,
            error_class,
            label_suffix,
            empty_permitted,
            use_required_attribute=use_required_attribute,
            renderer=renderer,
        )
        for formfield in self.fields.values():
            apply_limit_choices_to_to_formfield(formfield)

    def _get_validation_exclusions(self):
        """
        For backwards-compatibility, exclude several types of fields from model
        validation. See tickets #12507, #12521, #12553.
        """
        exclude = set()
        # Build up a list of fields that should be excluded from model field
        # validation and unique checks.
        for f in self.instance._meta.fields:
            field = f.name
            # Exclude fields that aren't on the form. The developer may be
            # adding these values to the model after form validation.
            if field not in self.fields:
                exclude.add(f.name)

            # Don't perform model validation on fields that were defined
            # manually on the form and excluded via the ModelForm's Meta
            # class. See #12901.
            elif self._meta.fields and field not in self._meta.fields:
                exclude.add(f.name)
            elif self._meta.exclude and field in self._meta.exclude:
                exclude.add(f.name)

            # Exclude fields that failed form validation. There's no need for
            # the model fields to validate them as well.
            elif field in self._errors:
                exclude.add(f.name)

            # Exclude empty fields that are not required by the form, if the
            # underlying model field is required. This keeps the model field
            # from raising a required error. Note: don't exclude the field from
            # validation if the model field allows blanks. If it does, the blank
            # value may be included in a unique check, so cannot be excluded
            # from validation.
            else:
                form_field = self.fields[field]
                field_value = self.cleaned_data.get(field)
                if (
                    not f.blank
                    and not form_field.required
                    and field_value in form_field.empty_values
                ):
                    exclude.add(f.name)
        return exclude

    def clean(self):
        self._validate_unique = True
        return self.cleaned_data

    def _update_errors(self, errors):
        # Override any validation error messages defined at the model level
        # with those defined at the form level.
        opts = self._meta

        # Allow the model generated by construct_instance() to raise
        # ValidationError and have them handled in the same way as others.
        if hasattr(errors, "error_dict"):
            error_dict = errors.error_dict
        else:
            error_dict = {NON_FIELD_ERRORS: errors}

        for field, messages in error_dict.items():
            if (
                field == NON_FIELD_ERRORS
                and opts.error_messages
                and NON_FIELD_ERRORS in opts.error_messages
            ):
                error_messages = opts.error_messages[NON_FIELD_ERRORS]
            elif field in self.fields:
                error_messages = self.fields[field].error_messages
            else:
                continue

            for message in messages:
                if (
                    isinstance(message, ValidationError)
                    and message.code in error_messages
                ):
                    message.message = error_messages[message.code]

        self.add_error(None, errors)

    def _post_clean(self):
        opts = self._meta

        exclude = self._get_validation_exclusions()

        # Foreign Keys being used to represent inline relationships
        # are excluded from basic field value validation. This is for two
        # reasons: firstly, the value may not be supplied (#12507; the
        # case of providing new values to the admin); secondly the
        # object being referred to may not yet fully exist (#12749).
        # However, these fields *must* be included in uniqueness checks,
        # so this can't be part of _get_validation_exclusions().
        for name, field in self.fields.items():
            if isinstance(field, InlineForeignKeyField):
                exclude.add(name)

        try:
            self.instance = construct_instance(
                self, self.instance, opts.fields, opts.exclude
            )
        except ValidationError as e:
            self._update_errors(e)

        try:
            self.instance.full_clean(exclude=exclude, validate_unique=False)
        except ValidationError as e:
            self._update_errors(e)

        # Validate uniqueness if needed.
        if self._validate_unique:
            self.validate_unique()

    def validate_unique(self):
        """
        Call the instance's validate_unique() method and update the form's
        validation errors if any were raised.
        """
        exclude = self._get_validation_exclusions()
        try:
            self.instance.validate_unique(exclude=exclude)
        except ValidationError as e:
            self._update_errors(e)

    def _save_m2m(self):
        """
        Save the many-to-many fields and generic relations for this form.
        """
        cleaned_data = self.cleaned_data
        exclude = self._meta.exclude
        fields = self._meta.fields
        opts = self.instance._meta
        # Note that for historical reasons we want to include also
        # private_fields here. (GenericRelation was previously a fake
        # m2m field).
        for f in chain(opts.many_to_many, opts.private_fields):
            if not hasattr(f, "save_form_data"):
                continue
            if fields and f.name not in fields:
                continue
            if exclude and f.name in exclude:
                continue
            if f.name in cleaned_data:
                f.save_form_data(self.instance, cleaned_data[f.name])

    def save(self, commit=True):
        """
        Save this form's self.instance object if commit=True. Otherwise, add
        a save_m2m() method to the form which can be called after the instance
        is saved manually at a later time. Return the model instance.
        """
        if self.errors:
            raise ValueError(
                "The %s could not be %s because the data didn't validate."
                % (
                    self.instance._meta.object_name,
                    "created" if self.instance._state.adding else "changed",
                )
            )
        if commit:
            # If committing, save the instance and the m2m data immediately.
            self.instance.save()
            self._save_m2m()
        else:
            # If not committing, add a method to the form to allow deferred
            # saving of m2m data.
            self.save_m2m = self._save_m2m
        return self.instance

    save.alters_data = True


class ModelForm(BaseModelForm, metaclass=ModelFormMetaclass):
    pass


def modelform_factory(
    model,
    form=ModelForm,
    fields=None,
    exclude=None,
    formfield_callback=None,
    widgets=None,
    localized_fields=None,
    labels=None,
    help_texts=None,
    error_messages=None,
    field_classes=None,
):
    """
    Return a ModelForm containing form fields for the given model. You can
    optionally pass a `form` argument to use as a starting point for
    constructing the ModelForm.

    ``fields`` is an optional list of field names. If provided, include only
    the named fields in the returned fields. If omitted or '__all__', use all
    fields.

    ``exclude`` is an optional list of field names. If provided, exclude the
    named fields from the returned fields, even if they are listed in the
    ``fields`` argument.

    ``widgets`` is a dictionary of model field names mapped to a widget.

    ``localized_fields`` is a list of names of fields which should be localized.

    ``formfield_callback`` is a callable that takes a model field and returns
    a form field.

    ``labels`` is a dictionary of model field names mapped to a label.

    ``help_texts`` is a dictionary of model field names mapped to a help text.

    ``error_messages`` is a dictionary of model field names mapped to a
    dictionary of error messages.

    ``field_classes`` is a dictionary of model field names mapped to a form
    field class.
    """
    # Create the inner Meta class. FIXME: ideally, we should be able to
    # construct a ModelForm without creating and passing in a temporary
    # inner class.

    # Build up a list of attributes that the Meta object will have.
    attrs = {"model": model}
    if fields is not None:
        attrs["fields"] = fields
    if exclude is not None:
        attrs["exclude"] = exclude
    if widgets is not None:
        attrs["widgets"] = widgets
    if localized_fields is not None:
        attrs["localized_fields"] = localized_fields
    if labels is not None:
        attrs["labels"] = labels
    if help_texts is not None:
        attrs["help_texts"] = help_texts
    if error_messages is not None:
        attrs["error_messages"] = error_messages
    if field_classes is not None:
        attrs["field_classes"] = field_classes

    # If parent form class already has an inner Meta, the Meta we're
    # creating needs to inherit from the parent's inner meta.
    bases = (form.Meta,) if hasattr(form, "Meta") else ()
    Meta = type("Meta", bases, attrs)
    if formfield_callback:
        Meta.formfield_callback = staticmethod(formfield_callback)
    # Give this new form class a reasonable name.
    class_name = model.__name__ + "Form"

    # Class attributes for the new form class.
    form_class_attrs = {"Meta": Meta}

    if getattr(Meta, "fields", None) is None and getattr(Meta, "exclude", None) is None:
        raise ImproperlyConfigured(
            "Calling modelform_factory without defining 'fields' or "
            "'exclude' explicitly is prohibited."
        )

    # Instantiate type(form) in order to use the same metaclass as form.
    return type(form)(class_name, (form,), form_class_attrs)


# ModelFormSets ##############################################################


class BaseModelFormSet(BaseFormSet, AltersData):
    """
    A ``FormSet`` for editing a queryset and/or adding new objects to it.
    """

    model = None
    edit_only = False

    # Set of fields that must be unique among forms of this set.
    unique_fields = set()

    def __init__(
        self,
        data=None,
        files=None,
        auto_id="id_%s",
        prefix=None,
        queryset=None,
        *,
        initial=None,
        **kwargs,
    ):
        self.queryset = queryset
        self.initial_extra = initial
        super().__init__(
            **{
                "data": data,
                "files": files,
                "auto_id": auto_id,
                "prefix": prefix,
                **kwargs,
            }
        )

    def initial_form_count(self):
        """Return the number of forms that are required in this FormSet."""
        if not self.is_bound:
            return len(self.get_queryset())
        return super().initial_form_count()

    def _existing_object(self, pk):
        if not hasattr(self, "_object_dict"):
            self._object_dict = {o.pk: o for o in self.get_queryset()}
        return self._object_dict.get(pk)

    def _get_to_python(self, field):
        """
        If the field is a related field, fetch the concrete field's (that
        is, the ultimate pointed-to field's) to_python.
        """
        while field.remote_field is not None:
            field = field.remote_field.get_related_field()
        return field.to_python

    def _construct_form(self, i, **kwargs):
        pk_required = i < self.initial_form_count()
        if pk_required:
            if self.is_bound:
                pk_key = "%s-%s" % (self.add_prefix(i), self.model._meta.pk.name)
                try:
                    pk = self.data[pk_key]
                except KeyError:
                    # The primary key is missing. The user may have tampered
                    # with POST data.
                    pass
                else:
                    to_python = self._get_to_python(self.model._meta.pk)
                    try:
                        pk = to_python(pk)
                    except ValidationError:
                        # The primary key exists but is an invalid value. The
                        # user may have tampered with POST data.
                        pass
                    else:
                        kwargs["instance"] = self._existing_object(pk)
            else:
                kwargs["instance"] = self.get_queryset()[i]
        elif self.initial_extra:
            # Set initial values for extra forms
            try:
                kwargs["initial"] = self.initial_extra[i - self.initial_form_count()]
            except IndexError:
                pass
        form = super()._construct_form(i, **kwargs)
        if pk_required:
            form.fields[self.model._meta.pk.name].required = True
        return form

    def get_queryset(self):
        if not hasattr(self, "_queryset"):
            if self.queryset is not None:
                qs = self.queryset
            else:
                qs = self.model._default_manager.get_queryset()

            # If the queryset isn't already ordered we need to add an
            # artificial ordering here to make sure that all formsets
            # constructed from this queryset have the same form order.
            if not qs.ordered:
                qs = qs.order_by(self.model._meta.pk.name)

            # Removed queryset limiting here. As per discussion re: #13023
            # on django-dev, max_num should not prevent existing
            # related objects/inlines from being displayed.
            self._queryset = qs
        return self._queryset

    def save_new(self, form, commit=True):
        """Save and return a new model instance for the given form."""
        return form.save(commit=commit)

    def save_existing(self, form, obj, commit=True):
        """Save and return an existing model instance for the given form."""
        return form.save(commit=commit)

    def delete_existing(self, obj, commit=True):
        """Deletes an existing model instance."""
        if commit:
            obj.delete()

    def save(self, commit=True):
        """
        Save model instances for every form, adding and changing instances
        as necessary, and return the list of instances.
        """
        if not commit:
            self.saved_forms = []

            def save_m2m():
                for form in self.saved_forms:
                    form.save_m2m()

            self.save_m2m = save_m2m
        if self.edit_only:
            return self.save_existing_objects(commit)
        else:
            return self.save_existing_objects(commit) + self.save_new_objects(commit)

    save.alters_data = True

    def clean(self):
        self.validate_unique()

    def validate_unique(self):
        # Collect unique_checks and date_checks to run from all the forms.
        all_unique_checks = set()
        all_date_checks = set()
        forms_to_delete = self.deleted_forms
        valid_forms = [
            form
            for form in self.forms
            if form.is_valid() and form not in forms_to_delete
        ]
        for form in valid_forms:
            exclude = form._get_validation_exclusions()
            unique_checks, date_checks = form.instance._get_unique_checks(
                exclude=exclude,
                include_meta_constraints=True,
            )
            all_unique_checks.update(unique_checks)
            all_date_checks.update(date_checks)

        errors = []
        # Do each of the unique checks (unique and unique_together)
        for uclass, unique_check in all_unique_checks:
            seen_data = set()
            for form in valid_forms:
                # Get the data for the set of fields that must be unique among
                # the forms.
                row_data = (
                    field if field in self.unique_fields else form.cleaned_data[field]
                    for field in unique_check
                    if field in form.cleaned_data
                )
                # Reduce Model instances to their primary key values
                row_data = tuple(
                    (
                        d._get_pk_val()
                        if hasattr(d, "_get_pk_val")
                        # Prevent "unhashable type" errors later on.
                        else make_hashable(d)
                    )
                    for d in row_data
                )
                if row_data and None not in row_data:
                    # if we've already seen it then we have a uniqueness failure
                    if row_data in seen_data:
                        # poke error messages into the right places and mark
                        # the form as invalid
                        errors.append(self.get_unique_error_message(unique_check))
                        form._errors[NON_FIELD_ERRORS] = self.error_class(
                            [self.get_form_error()],
                            renderer=self.renderer,
                        )
                        # Remove the data from the cleaned_data dict since it
                        # was invalid.
                        for field in unique_check:
                            if field in form.cleaned_data:
                                del form.cleaned_data[field]
                    # mark the data as seen
                    seen_data.add(row_data)
        # iterate over each of the date checks now
        for date_check in all_date_checks:
            seen_data = set()
            uclass, lookup, field, unique_for = date_check
            for form in valid_forms:
                # see if we have data for both fields
                if (
                    form.cleaned_data
                    and form.cleaned_data[field] is not None
                    and form.cleaned_data[unique_for] is not None
                ):
                    # if it's a date lookup we need to get the data for all the fields
                    if lookup == "date":
                        date = form.cleaned_data[unique_for]
                        date_data = (date.year, date.month, date.day)
                    # otherwise it's just the attribute on the date/datetime
                    # object
                    else:
                        date_data = (getattr(form.cleaned_data[unique_for], lookup),)
                    data = (form.cleaned_data[field],) + date_data
                    # if we've already seen it then we have a uniqueness failure
                    if data in seen_data:
                        # poke error messages into the right places and mark
                        # the form as invalid
                        errors.append(self.get_date_error_message(date_check))
                        form._errors[NON_FIELD_ERRORS] = self.error_class(
                            [self.get_form_error()],
                            renderer=self.renderer,
                        )
                        # Remove the data from the cleaned_data dict since it
                        # was invalid.
                        del form.cleaned_data[field]
                    # mark the data as seen
                    seen_data.add(data)

        if errors:
            raise ValidationError(errors)

    def get_unique_error_message(self, unique_check):
        if len(unique_check) == 1:
            return gettext("Please correct the duplicate data for %(field)s.") % {
                "field": unique_check[0],
            }
        else:
            return gettext(
                "Please correct the duplicate data for %(field)s, which must be unique."
            ) % {
                "field": get_text_list(unique_check, _("and")),
            }

    def get_date_error_message(self, date_check):
        return gettext(
            "Please correct the duplicate data for %(field_name)s "
            "which must be unique for the %(lookup)s in %(date_field)s."
        ) % {
            "field_name": date_check[2],
            "date_field": date_check[3],
            "lookup": str(date_check[1]),
        }

    def get_form_error(self):
        return gettext("Please correct the duplicate values below.")

    def save_existing_objects(self, commit=True):
        self.changed_objects = []
        self.deleted_objects = []
        if not self.initial_forms:
            return []

        saved_instances = []
        forms_to_delete = self.deleted_forms
        for form in self.initial_forms:
            obj = form.instance
            # If the pk is None, it means either:
            # 1. The object is an unexpected empty model, created by invalid
            #    POST data such as an object outside the formset's queryset.
            # 2. The object was already deleted from the database.
            if obj.pk is None:
                continue
            if form in forms_to_delete:
                self.deleted_objects.append(obj)
                self.delete_existing(obj, commit=commit)
            elif form.has_changed():
                self.changed_objects.append((obj, form.changed_data))
                saved_instances.append(self.save_existing(form, obj, commit=commit))
                if not commit:
                    self.saved_forms.append(form)
        return saved_instances

    def save_new_objects(self, commit=True):
        self.new_objects = []
        for form in self.extra_forms:
            if not form.has_changed():
                continue
            # If someone has marked an add form for deletion, don't save the
            # object.
            if self.can_delete and self._should_delete_form(form):
                continue
            self.new_objects.append(self.save_new(form, commit=commit))
            if not commit:
                self.saved_forms.append(form)
        return self.new_objects

    def add_fields(self, form, index):
        """Add a hidden field for the object's primary key."""
        from django.db.models import AutoField, ForeignKey, OneToOneField

        self._pk_field = pk = self.model._meta.pk
        # If a pk isn't editable, then it won't be on the form, so we need to
        # add it here so we can tell which object is which when we get the
        # data back. Generally, pk.editable should be false, but for some
        # reason, auto_created pk fields and AutoField's editable attribute is
        # True, so check for that as well.

        def pk_is_not_editable(pk):
            return (
                (not pk.editable)
                or (pk.auto_created or isinstance(pk, AutoField))
                or (
                    pk.remote_field
                    and pk.remote_field.parent_link
                    and pk_is_not_editable(pk.remote_field.model._meta.pk)
                )
            )

        if pk_is_not_editable(pk) or pk.name not in form.fields:
            if form.is_bound:
                # If we're adding the related instance, ignore its primary key
                # as it could be an auto-generated default which isn't actually
                # in the database.
                pk_value = None if form.instance._state.adding else form.instance.pk
            else:
                try:
                    if index is not None:
                        pk_value = self.get_queryset()[index].pk
                    else:
                        pk_value = None
                except IndexError:
                    pk_value = None
            if isinstance(pk, (ForeignKey, OneToOneField)):
                qs = pk.remote_field.model._default_manager.get_queryset()
            else:
                qs = self.model._default_manager.get_queryset()
            qs = qs.using(form.instance._state.db)
            if form._meta.widgets:
                widget = form._meta.widgets.get(self._pk_field.name, HiddenInput)
            else:
                widget = HiddenInput
            form.fields[self._pk_field.name] = ModelChoiceField(
                qs, initial=pk_value, required=False, widget=widget
            )
        super().add_fields(form, index)


def modelformset_factory(
    model,
    form=ModelForm,
    formfield_callback=None,
    formset=BaseModelFormSet,
    extra=1,
    can_delete=False,
    can_order=False,
    max_num=None,
    fields=None,
    exclude=None,
    widgets=None,
    validate_max=False,
    localized_fields=None,
    labels=None,
    help_texts=None,
    error_messages=None,
    min_num=None,
    validate_min=False,
    field_classes=None,
    absolute_max=None,
    can_delete_extra=True,
    renderer=None,
    edit_only=False,
):
    """Return a FormSet class for the given Django model class."""
    meta = getattr(form, "Meta", None)
    if (
        getattr(meta, "fields", fields) is None
        and getattr(meta, "exclude", exclude) is None
    ):
        raise ImproperlyConfigured(
            "Calling modelformset_factory without defining 'fields' or "
            "'exclude' explicitly is prohibited."
        )

    form = modelform_factory(
        model,
        form=form,
        fields=fields,
        exclude=exclude,
        formfield_callback=formfield_callback,
        widgets=widgets,
        localized_fields=localized_fields,
        labels=labels,
        help_texts=help_texts,
        error_messages=error_messages,
        field_classes=field_classes,
    )
    FormSet = formset_factory(
        form,
        formset,
        extra=extra,
        min_num=min_num,
        max_num=max_num,
        can_order=can_order,
        can_delete=can_delete,
        validate_min=validate_min,
        validate_max=validate_max,
        absolute_max=absolute_max,
        can_delete_extra=can_delete_extra,
        renderer=renderer,
    )
    FormSet.model = model
    FormSet.edit_only = edit_only
    return FormSet


# InlineFormSets #############################################################


class BaseInlineFormSet(BaseModelFormSet):
    """A formset for child objects related to a parent."""

    def __init__(
        self,
        data=None,
        files=None,
        instance=None,
        save_as_new=False,
        prefix=None,
        queryset=None,
        **kwargs,
    ):
        if instance is None:
            self.instance = self.fk.remote_field.model()
        else:
            self.instance = instance
        self.save_as_new = save_as_new
        if queryset is None:
            queryset = self.model._default_manager
        if self.instance.pk is not None:
            qs = queryset.filter(**{self.fk.name: self.instance})
        else:
            qs = queryset.none()
        self.unique_fields = {self.fk.name}
        super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)

        # Add the generated field to form._meta.fields if it's defined to make
        # sure validation isn't skipped on that field.
        if self.form._meta.fields and self.fk.name not in self.form._meta.fields:
            if isinstance(self.form._meta.fields, tuple):
                self.form._meta.fields = list(self.form._meta.fields)
            self.form._meta.fields.append(self.fk.name)

    def initial_form_count(self):
        if self.save_as_new:
            return 0
        return super().initial_form_count()

    def _construct_form(self, i, **kwargs):
        form = super()._construct_form(i, **kwargs)
        if self.save_as_new:
            mutable = getattr(form.data, "_mutable", None)
            # Allow modifying an immutable QueryDict.
            if mutable is not None:
                form.data._mutable = True
            # Remove the primary key from the form's data, we are only
            # creating new instances
            form.data[form.add_prefix(self._pk_field.name)] = None
            # Remove the foreign key from the form's data
            form.data[form.add_prefix(self.fk.name)] = None
            if mutable is not None:
                form.data._mutable = mutable

        # Set the fk value here so that the form can do its validation.
        fk_value = self.instance.pk
        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:
            fk_value = getattr(self.instance, self.fk.remote_field.field_name)
            fk_value = getattr(fk_value, "pk", fk_value)
        setattr(form.instance, self.fk.attname, fk_value)
        return form

    @classmethod
    def get_default_prefix(cls):
        return cls.fk.remote_field.get_accessor_name(model=cls.model).replace("+", "")

    def save_new(self, form, commit=True):
        # Ensure the latest copy of the related instance is present on each
        # form (it may have been saved after the formset was originally
        # instantiated).
        setattr(form.instance, self.fk.name, self.instance)
        return super().save_new(form, commit=commit)

    def add_fields(self, form, index):
        super().add_fields(form, index)
        if self._pk_field == self.fk:
            name = self._pk_field.name
            kwargs = {"pk_field": True}
        else:
            # The foreign key field might not be on the form, so we poke at the
            # Model field to get the label, since we need that for error messages.
            name = self.fk.name
            kwargs = {
                "label": getattr(
                    form.fields.get(name), "label", capfirst(self.fk.verbose_name)
                )
            }

        # The InlineForeignKeyField assumes that the foreign key relation is
        # based on the parent model's pk. If this isn't the case, set to_field
        # to correctly resolve the initial form value.
        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:
            kwargs["to_field"] = self.fk.remote_field.field_name

        # If we're adding a new object, ignore a parent's auto-generated key
        # as it will be regenerated on the save request.
        if self.instance._state.adding:
            if kwargs.get("to_field") is not None:
                to_field = self.instance._meta.get_field(kwargs["to_field"])
            else:
                to_field = self.instance._meta.pk

            if to_field.has_default() and (
                # Don't ignore a parent's auto-generated key if it's not the
                # parent model's pk and form data is provided.
                to_field.attname == self.fk.remote_field.model._meta.pk.name
                or not form.data
            ):
                setattr(self.instance, to_field.attname, None)

        form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)

    def get_unique_error_message(self, unique_check):
        unique_check = [field for field in unique_check if field != self.fk.name]
        return super().get_unique_error_message(unique_check)


def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):
    """
    Find and return the ForeignKey from model to parent if there is one
    (return None if can_fail is True and no such field exists). If fk_name is
    provided, assume it is the name of the ForeignKey field. Unless can_fail is
    True, raise an exception if there isn't a ForeignKey from model to
    parent_model.
    """
    # avoid circular import
    from django.db.models import ForeignKey

    opts = model._meta
    if fk_name:
        fks_to_parent = [f for f in opts.fields if f.name == fk_name]
        if len(fks_to_parent) == 1:
            fk = fks_to_parent[0]
            all_parents = (*parent_model._meta.all_parents, parent_model)
            if (
                not isinstance(fk, ForeignKey)
                or (
                    # ForeignKey to proxy models.
                    fk.remote_field.model._meta.proxy
                    and fk.remote_field.model._meta.proxy_for_model not in all_parents
                )
                or (
                    # ForeignKey to concrete models.
                    not fk.remote_field.model._meta.proxy
                    and fk.remote_field.model != parent_model
                    and fk.remote_field.model not in all_parents
                )
            ):
                raise ValueError(
                    "fk_name '%s' is not a ForeignKey to '%s'."
                    % (fk_name, parent_model._meta.label)
                )
        elif not fks_to_parent:
            raise ValueError(
                "'%s' has no field named '%s'." % (model._meta.label, fk_name)
            )
    else:
        # Try to discover what the ForeignKey from model to parent_model is
        all_parents = (*parent_model._meta.all_parents, parent_model)
        fks_to_parent = [
            f
            for f in opts.fields
            if isinstance(f, ForeignKey)
            and (
                f.remote_field.model == parent_model
                or f.remote_field.model in all_parents
                or (
                    f.remote_field.model._meta.proxy
                    and f.remote_field.model._meta.proxy_for_model in all_parents
                )
            )
        ]
        if len(fks_to_parent) == 1:
            fk = fks_to_parent[0]
        elif not fks_to_parent:
            if can_fail:
                return
            raise ValueError(
                "'%s' has no ForeignKey to '%s'."
                % (
                    model._meta.label,
                    parent_model._meta.label,
                )
            )
        else:
            raise ValueError(
                "'%s' has more than one ForeignKey to '%s'. You must specify "
                "a 'fk_name' attribute."
                % (
                    model._meta.label,
                    parent_model._meta.label,
                )
            )
    return fk


def inlineformset_factory(
    parent_model,
    model,
    form=ModelForm,
    formset=BaseInlineFormSet,
    fk_name=None,
    fields=None,
    exclude=None,
    extra=3,
    can_order=False,
    can_delete=True,
    max_num=None,
    formfield_callback=None,
    widgets=None,
    validate_max=False,
    localized_fields=None,
    labels=None,
    help_texts=None,
    error_messages=None,
    min_num=None,
    validate_min=False,
    field_classes=None,
    absolute_max=None,
    can_delete_extra=True,
    renderer=None,
    edit_only=False,
):
    """
    Return an ``InlineFormSet`` for the given kwargs.

    ``fk_name`` must be provided if ``model`` has more than one ``ForeignKey``
    to ``parent_model``.
    """
    fk = _get_foreign_key(parent_model, model, fk_name=fk_name)
    # enforce a max_num=1 when the foreign key to the parent model is unique.
    if fk.unique:
        max_num = 1
    kwargs = {
        "form": form,
        "formfield_callback": formfield_callback,
        "formset": formset,
        "extra": extra,
        "can_delete": can_delete,
        "can_order": can_order,
        "fields": fields,
        "exclude": exclude,
        "min_num": min_num,
        "max_num": max_num,
        "widgets": widgets,
        "validate_min": validate_min,
        "validate_max": validate_max,
        "localized_fields": localized_fields,
        "labels": labels,
        "help_texts": help_texts,
        "error_messages": error_messages,
        "field_classes": field_classes,
        "absolute_max": absolute_max,
        "can_delete_extra": can_delete_extra,
        "renderer": renderer,
        "edit_only": edit_only,
    }
    FormSet = modelformset_factory(model, **kwargs)
    FormSet.fk = fk
    return FormSet


# Fields #####################################################################


class InlineForeignKeyField(Field):
    """
    A basic integer field that deals with validating the given value to a
    given parent instance in an inline.
    """

    widget = HiddenInput
    default_error_messages = {
        "invalid_choice": _("The inline value did not match the parent instance."),
    }

    def __init__(self, parent_instance, *args, pk_field=False, to_field=None, **kwargs):
        self.parent_instance = parent_instance
        self.pk_field = pk_field
        self.to_field = to_field
        if self.parent_instance is not None:
            if self.to_field:
                kwargs["initial"] = getattr(self.parent_instance, self.to_field)
            else:
                kwargs["initial"] = self.parent_instance.pk
        kwargs["required"] = False
        super().__init__(*args, **kwargs)

    def clean(self, value):
        if value in self.empty_values:
            if self.pk_field:
                return None
            # if there is no value act as we did before.
            return self.parent_instance
        # ensure the we compare the values as equal types.
        if self.to_field:
            orig = getattr(self.parent_instance, self.to_field)
        else:
            orig = self.parent_instance.pk
        if str(value) != str(orig):
            raise ValidationError(
                self.error_messages["invalid_choice"], code="invalid_choice"
            )
        return self.parent_instance

    def has_changed(self, initial, data):
        return False


class ModelChoiceIteratorValue:
    def __init__(self, value, instance):
        self.value = value
        self.instance = instance

    def __str__(self):
        return str(self.value)

    def __hash__(self):
        return hash(self.value)

    def __eq__(self, other):
        if isinstance(other, ModelChoiceIteratorValue):
            other = other.value
        return self.value == other


class ModelChoiceIterator(BaseChoiceIterator):
    def __init__(self, field):
        self.field = field
        self.queryset = field.queryset

    def __iter__(self):
        if self.field.empty_label is not None:
            yield ("", self.field.empty_label)
        queryset = self.queryset
        # Can't use iterator() when queryset uses prefetch_related()
        if not queryset._prefetch_related_lookups:
            queryset = queryset.iterator()
        for obj in queryset:
            yield self.choice(obj)

    def __len__(self):
        # count() adds a query but uses less memory since the QuerySet results
        # won't be cached. In most cases, the choices will only be iterated on,
        # and __len__() won't be called.
        return self.queryset.count() + (1 if self.field.empty_label is not None else 0)

    def __bool__(self):
        return self.field.empty_label is not None or self.queryset.exists()

    def choice(self, obj):
        return (
            ModelChoiceIteratorValue(self.field.prepare_value(obj), obj),
            self.field.label_from_instance(obj),
        )


class ModelChoiceField(ChoiceField):
    """A ChoiceField whose choices are a model QuerySet."""

    # This class is a subclass of ChoiceField for purity, but it doesn't
    # actually use any of ChoiceField's implementation.
    default_error_messages = {
        "invalid_choice": _(
            "Select a valid choice. That choice is not one of the available choices."
        ),
    }
    iterator = ModelChoiceIterator

    def __init__(
        self,
        queryset,
        *,
        empty_label="---------",
        required=True,
        widget=None,
        label=None,
        initial=None,
        help_text="",
        to_field_name=None,
        limit_choices_to=None,
        blank=False,
        **kwargs,
    ):
        # Call Field instead of ChoiceField __init__() because we don't need
        # ChoiceField.__init__().
        Field.__init__(
            self,
            required=required,
            widget=widget,
            label=label,
            initial=initial,
            help_text=help_text,
            **kwargs,
        )
        if (required and initial is not None) or (
            isinstance(self.widget, RadioSelect) and not blank
        ):
            self.empty_label = None
        else:
            self.empty_label = empty_label
        self.queryset = queryset
        self.limit_choices_to = limit_choices_to  # limit the queryset later.
        self.to_field_name = to_field_name

    def validate_no_null_characters(self, value):
        non_null_character_validator = ProhibitNullCharactersValidator()
        return non_null_character_validator(value)

    def get_limit_choices_to(self):
        """
        Return ``limit_choices_to`` for this form field.

        If it is a callable, invoke it and return the result.
        """
        if callable(self.limit_choices_to):
            return self.limit_choices_to()
        return self.limit_choices_to

    def __deepcopy__(self, memo):
        result = super(ChoiceField, self).__deepcopy__(memo)
        # Need to force a new ModelChoiceIterator to be created, bug #11183
        if self.queryset is not None:
            result.queryset = self.queryset.all()
        return result

    def _get_queryset(self):
        return self._queryset

    def _set_queryset(self, queryset):
        self._queryset = None if queryset is None else queryset.all()
        self.widget.choices = self.choices

    queryset = property(_get_queryset, _set_queryset)

    # this method will be used to create object labels by the QuerySetIterator.
    # Override it to customize the label.
    def label_from_instance(self, obj):
        """
        Convert objects into strings and generate the labels for the choices
        presented by this object. Subclasses can override this method to
        customize the display of the choices.
        """
        return str(obj)

    def _get_choices(self):
        # If self._choices is set, then somebody must have manually set
        # the property self.choices. In this case, just return self._choices.
        if hasattr(self, "_choices"):
            return self._choices

        # Otherwise, execute the QuerySet in self.queryset to determine the
        # choices dynamically. Return a fresh ModelChoiceIterator that has not been
        # consumed. Note that we're instantiating a new ModelChoiceIterator *each*
        # time _get_choices() is called (and, thus, each time self.choices is
        # accessed) so that we can ensure the QuerySet has not been consumed. This
        # construct might look complicated but it allows for lazy evaluation of
        # the queryset.
        return self.iterator(self)

    choices = property(_get_choices, ChoiceField.choices.fset)

    def prepare_value(self, value):
        if hasattr(value, "_meta"):
            if self.to_field_name:
                return value.serializable_value(self.to_field_name)
            else:
                return value.pk
        return super().prepare_value(value)

    def to_python(self, value):
        if value in self.empty_values:
            return None
        self.validate_no_null_characters(value)
        try:
            key = self.to_field_name or "pk"
            if isinstance(value, self.queryset.model):
                value = getattr(value, key)
            value = self.queryset.get(**{key: value})
        except (ValueError, TypeError, self.queryset.model.DoesNotExist):
            raise ValidationError(
                self.error_messages["invalid_choice"],
                code="invalid_choice",
                params={"value": value},
            )
        return value

    def validate(self, value):
        return Field.validate(self, value)

    def has_changed(self, initial, data):
        if self.disabled:
            return False
        initial_value = initial if initial is not None else ""
        data_value = data if data is not None else ""
        return str(self.prepare_value(initial_value)) != str(data_value)


class ModelMultipleChoiceField(ModelChoiceField):
    """A MultipleChoiceField whose choices are a model QuerySet."""

    widget = SelectMultiple
    hidden_widget = MultipleHiddenInput
    default_error_messages = {
        "invalid_list": _("Enter a list of values."),
        "invalid_choice": _(
            "Select a valid choice. %(value)s is not one of the available choices."
        ),
        "invalid_pk_value": _("â€œ%(pk)sâ€ is not a valid value."),
    }

    def __init__(self, queryset, **kwargs):
        super().__init__(queryset, empty_label=None, **kwargs)

    def to_python(self, value):
        if not value:
            return []
        return list(self._check_values(value))

    def clean(self, value):
        value = self.prepare_value(value)
        if self.required and not value:
            raise ValidationError(self.error_messages["required"], code="required")
        elif not self.required and not value:
            return self.queryset.none()
        if not isinstance(value, (list, tuple)):
            raise ValidationError(
                self.error_messages["invalid_list"],
                code="invalid_list",
            )
        qs = self._check_values(value)
        # Since this overrides the inherited ModelChoiceField.clean
        # we run custom validators here
        self.run_validators(value)
        return qs

    def _check_values(self, value):
        """
        Given a list of possible PK values, return a QuerySet of the
        corresponding objects. Raise a ValidationError if a given value is
        invalid (not a valid PK, not in the queryset, etc.)
        """
        key = self.to_field_name or "pk"
        # deduplicate given values to avoid creating many querysets or
        # requiring the database backend deduplicate efficiently.
        try:
            value = frozenset(value)
        except TypeError:
            # list of lists isn't hashable, for example
            raise ValidationError(
                self.error_messages["invalid_list"],
                code="invalid_list",
            )
        for pk in value:
            self.validate_no_null_characters(pk)
            try:
                self.queryset.filter(**{key: pk})
            except (ValueError, TypeError):
                raise ValidationError(
                    self.error_messages["invalid_pk_value"],
                    code="invalid_pk_value",
                    params={"pk": pk},
                )
        qs = self.queryset.filter(**{"%s__in" % key: value})
        pks = {str(getattr(o, key)) for o in qs}
        for val in value:
            if str(val) not in pks:
                raise ValidationError(
                    self.error_messages["invalid_choice"],
                    code="invalid_choice",
                    params={"value": val},
                )
        return qs

    def prepare_value(self, value):
        if (
            hasattr(value, "__iter__")
            and not isinstance(value, str)
            and not hasattr(value, "_meta")
        ):
            prepare_value = super().prepare_value
            return [prepare_value(v) for v in value]
        return super().prepare_value(value)

    def has_changed(self, initial, data):
        if self.disabled:
            return False
        if initial is None:
            initial = []
        if data is None:
            data = []
        if len(initial) != len(data):
            return True
        initial_set = {str(value) for value in self.prepare_value(initial)}
        data_set = {str(value) for value in data}
        return data_set != initial_set


def modelform_defines_fields(form_class):
    return hasattr(form_class, "_meta") and (
        form_class._meta.fields is not None or form_class._meta.exclude is not None
    )

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django\forms\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django_celery_beat\admin.py ---

"""Periodic Task Admin interface."""
from celery import current_app
from celery.utils import cached_property
from django import forms
from django.conf import settings
from django.contrib import admin, messages
from django.db.models import Case, Value, When
from django.forms.widgets import Select
from django.template.defaultfilters import pluralize
from django.utils.translation import gettext_lazy as _
from django.utils.translation import ngettext_lazy
from kombu.utils.json import loads

from .models import (ClockedSchedule, CrontabSchedule, IntervalSchedule,
                     PeriodicTask, PeriodicTasks, SolarSchedule)
from .utils import is_database_scheduler


class TaskSelectWidget(Select):
    """Widget that lets you choose between task names."""

    celery_app = current_app
    _choices = None

    def tasks_as_choices(self):
        _ = self._modules
        tasks = sorted(name for name in self.celery_app.tasks
                       if not name.startswith('celery.'))
        return (('', ''), ) + tuple(zip(tasks, tasks))

    @property
    def choices(self):
        if self._choices is None:
            self._choices = self.tasks_as_choices()
        return self._choices

    @choices.setter
    def choices(self, _):
        # ChoiceField.__init__ sets ``self.choices = choices``
        # which would override ours.
        pass

    @cached_property
    def _modules(self):
        self.celery_app.loader.import_default_modules()


class TaskChoiceField(forms.ChoiceField):
    """Field that lets you choose between task names."""

    widget = TaskSelectWidget

    def valid_value(self, value):
        return True


class PeriodicTaskForm(forms.ModelForm):
    """Form that lets you create and modify periodic tasks."""

    regtask = TaskChoiceField(
        label=_('Task (registered)'),
        required=False,
    )
    task = forms.CharField(
        label=_('Task (custom)'),
        required=False,
        max_length=200,
    )

    class Meta:
        """Form metadata."""

        model = PeriodicTask
        exclude = ()

    def clean(self):
        data = super().clean()
        regtask = data.get('regtask')
        if regtask:
            data['task'] = regtask
        if not data['task']:
            exc = forms.ValidationError(_('Need name of task'))
            self._errors['task'] = self.error_class(exc.messages)
            raise exc

        if data.get('expire_seconds') is not None and data.get('expires'):
            raise forms.ValidationError(
                _('Only one can be set, in expires and expire_seconds')
            )
        return data

    def _clean_json(self, field):
        value = self.cleaned_data[field]
        try:
            loads(value)
        except ValueError as exc:
            raise forms.ValidationError(
                _('Unable to parse JSON: %s') % exc,
            )
        return value

    def clean_args(self):
        return self._clean_json('args')

    def clean_kwargs(self):
        return self._clean_json('kwargs')


@admin.register(PeriodicTask)
class PeriodicTaskAdmin(admin.ModelAdmin):
    """Admin-interface for periodic tasks."""

    form = PeriodicTaskForm
    model = PeriodicTask
    celery_app = current_app
    date_hierarchy = 'start_time'
    list_display = ('name', 'enabled', 'scheduler', 'interval', 'start_time',
                    'last_run_at', 'one_off')
    list_filter = ['enabled', 'one_off', 'task', 'start_time', 'last_run_at']
    actions = ('enable_tasks', 'disable_tasks', 'toggle_tasks', 'run_tasks')
    search_fields = ('name',)
    fieldsets = (
        (None, {
            'fields': ('name', 'regtask', 'task', 'enabled', 'description',),
            'classes': ('extrapretty', 'wide'),
        }),
        (_('Schedule'), {
            'fields': ('interval', 'crontab', 'crontab_translation', 'solar',
                       'clocked', 'start_time', 'last_run_at', 'one_off'),
            'classes': ('extrapretty', 'wide'),
        }),
        (_('Arguments'), {
            'fields': ('args', 'kwargs'),
            'classes': ('extrapretty', 'wide', 'collapse', 'in'),
        }),
        (_('Execution Options'), {
            'fields': ('expires', 'expire_seconds', 'queue', 'exchange',
                       'routing_key', 'priority', 'headers'),
            'classes': ('extrapretty', 'wide', 'collapse', 'in'),
        }),
    )
    readonly_fields = (
        'last_run_at', 'crontab_translation',
    )

    def crontab_translation(self, obj):
        return obj.crontab.human_readable

    change_form_template = 'admin/djcelery/change_periodictask_form.html'

    def changeform_view(self, request, object_id=None, form_url='',
                        extra_context=None):
        extra_context = extra_context or {}
        crontabs = CrontabSchedule.objects.all()
        crontab_dict = {}
        for crontab in crontabs:
            crontab_dict[crontab.id] = crontab.human_readable
        extra_context['readable_crontabs'] = crontab_dict
        return super().changeform_view(request, object_id,
                                       extra_context=extra_context)

    def changelist_view(self, request, extra_context=None):
        extra_context = extra_context or {}
        scheduler = getattr(settings, 'CELERY_BEAT_SCHEDULER', None)
        extra_context['wrong_scheduler'] = not is_database_scheduler(scheduler)
        return super().changelist_view(
            request, extra_context)

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        return qs.select_related('interval', 'crontab', 'solar', 'clocked')

    @admin.action(
        description=_('Enable selected tasks')
    )
    def enable_tasks(self, request, queryset):
        rows_updated = queryset.update(enabled=True)
        PeriodicTasks.update_changed()
        self.message_user(
            request,
            ngettext_lazy(
                '{0} task was successfully enabled',
                '{0} tasks were successfully enabled',
                rows_updated
            ).format(rows_updated)
        )

    @admin.action(
        description=_('Disable selected tasks')
    )
    def disable_tasks(self, request, queryset):
        rows_updated = queryset.update(enabled=False, last_run_at=None)
        PeriodicTasks.update_changed()
        self.message_user(
            request,
            ngettext_lazy(
                '{0} task was successfully disabled',
                '{0} tasks were successfully disabled',
                rows_updated
            ).format(rows_updated)
        )

    def _toggle_tasks_activity(self, queryset):
        return queryset.update(enabled=Case(
            When(enabled=True, then=Value(False)),
            default=Value(True),
        ))

    @admin.action(
        description=_('Toggle activity of selected tasks')
    )
    def toggle_tasks(self, request, queryset):
        rows_updated = self._toggle_tasks_activity(queryset)
        PeriodicTasks.update_changed()
        self.message_user(
            request,
            ngettext_lazy(
                '{0} task was successfully toggled',
                '{0} tasks were successfully toggled',
                rows_updated
            ).format(rows_updated)
        )

    @admin.action(
        description=_('Run selected tasks')
    )
    def run_tasks(self, request, queryset):
        self.celery_app.loader.import_default_modules()
        tasks = [(self.celery_app.tasks.get(task.task),
                  loads(task.args),
                  loads(task.kwargs),
                  task.queue,
                  task.name)
                 for task in queryset]

        if any(t[0] is None for t in tasks):
            for i, t in enumerate(tasks):
                if t[0] is None:
                    break

            # variable "i" will be set because list "tasks" is not empty
            not_found_task_name = queryset[i].task

            self.message_user(
                request,
                _(f'task "{not_found_task_name}" not found'),
                level=messages.ERROR,
            )
            return

        task_ids = [
            task.apply_async(args=args, kwargs=kwargs, queue=queue,
                             periodic_task_name=periodic_task_name)
            if queue and len(queue)
            else task.apply_async(args=args, kwargs=kwargs,
                                  periodic_task_name=periodic_task_name)
            for task, args, kwargs, queue, periodic_task_name in tasks
        ]
        tasks_run = len(task_ids)
        self.message_user(
            request,
            _('{0} task{1} {2} successfully run').format(
                tasks_run,
                pluralize(tasks_run),
                pluralize(tasks_run, _('was,were')),
            ),
        )


class PeriodicTaskInline(admin.TabularInline):
    model = PeriodicTask
    fields = ('name', 'task', 'args', 'kwargs')
    readonly_fields = fields
    can_delete = False
    extra = 0
    show_change_link = True
    verbose_name = "Periodic Tasks Using This Schedule"
    verbose_name_plural = verbose_name

    def has_add_permission(self, request, obj):
        return False


class ScheduleAdmin(admin.ModelAdmin):
    inlines = [PeriodicTaskInline]


@admin.register(ClockedSchedule)
class ClockedScheduleAdmin(ScheduleAdmin):
    """Admin-interface for clocked schedules."""

    fields = (
        'clocked_time',
    )
    list_display = (
        'clocked_time',
    )


@admin.register(CrontabSchedule)
class CrontabScheduleAdmin(ScheduleAdmin):
    """Admin class for CrontabSchedule."""

    list_display = ('__str__', 'human_readable')
    fields = ('human_readable', 'minute', 'hour', 'day_of_month',
              'month_of_year', 'day_of_week', 'timezone')
    readonly_fields = ('human_readable', )


@admin.register(SolarSchedule)
class SolarScheduleAdmin(ScheduleAdmin):
    """Admin class for SolarSchedule."""
    pass


@admin.register(IntervalSchedule)
class IntervalScheduleAdmin(ScheduleAdmin):
    """Admin class for IntervalSchedule."""
    pass

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django_celery_beat\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django_celery_beat\apps.py ---

"""Django Application configuration."""
from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _

__all__ = ['BeatConfig']


class BeatConfig(AppConfig):
    """Default configuration for django_celery_beat app."""

    name = 'django_celery_beat'
    label = 'django_celery_beat'
    verbose_name = _('Periodic Tasks')
    default_auto_field = 'django.db.models.AutoField'

    def ready(self):
        from .signals import signals_connect
        signals_connect()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django_celery_beat\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django_celery_beat\models.py ---

"""Database models."""
try:
    from zoneinfo import available_timezones
except ImportError:
    from backports.zoneinfo import available_timezones

from datetime import timedelta

import timezone_field
from celery import current_app, schedules
from cron_descriptor import (FormatException, MissingFieldException,
                             WrongArgumentException, get_description)
from django.conf import settings
from django.core.exceptions import MultipleObjectsReturned, ValidationError
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models
from django.utils.translation import gettext_lazy as _

from . import querysets, validators
from .clockedschedule import clocked
from .tzcrontab import TzAwareCrontab
from .utils import make_aware, now

DAYS = 'days'
HOURS = 'hours'
MINUTES = 'minutes'
SECONDS = 'seconds'
MICROSECONDS = 'microseconds'

PERIOD_CHOICES = (
    (DAYS, _('Days')),
    (HOURS, _('Hours')),
    (MINUTES, _('Minutes')),
    (SECONDS, _('Seconds')),
    (MICROSECONDS, _('Microseconds')),
)

SINGULAR_PERIODS = (
    (DAYS, _('Day')),
    (HOURS, _('Hour')),
    (MINUTES, _('Minute')),
    (SECONDS, _('Second')),
    (MICROSECONDS, _('Microsecond')),
)

SOLAR_SCHEDULES = [
    ("dawn_astronomical", _("Astronomical dawn")),
    ("dawn_civil", _("Civil dawn")),
    ("dawn_nautical", _("Nautical dawn")),
    ("dusk_astronomical", _("Astronomical dusk")),
    ("dusk_civil", _("Civil dusk")),
    ("dusk_nautical", _("Nautical dusk")),
    ("solar_noon", _("Solar noon")),
    ("sunrise", _("Sunrise")),
    ("sunset", _("Sunset")),
]


def cronexp(field):
    """Representation of cron expression."""
    return field and str(field).replace(' ', '') or '*'


def crontab_schedule_celery_timezone():
    """Return timezone string from Django settings ``CELERY_TIMEZONE`` variable.

    If is not defined or is not a valid timezone, return ``"UTC"`` instead.
    """  # noqa: E501
    try:
        CELERY_TIMEZONE = getattr(
            settings, '%s_TIMEZONE' % current_app.namespace)
    except AttributeError:
        return 'UTC'
    if CELERY_TIMEZONE in available_timezones():
        return CELERY_TIMEZONE
    return 'UTC'


class SolarSchedule(models.Model):
    """Schedule following astronomical patterns.

    Example: to run every sunrise in New York City:

    >>> event='sunrise', latitude=40.7128, longitude=74.0060
    """

    event = models.CharField(
        max_length=24, choices=SOLAR_SCHEDULES,
        verbose_name=_('Solar Event'),
        help_text=_('The type of solar event when the job should run'),
    )
    latitude = models.DecimalField(
        max_digits=9, decimal_places=6,
        verbose_name=_('Latitude'),
        help_text=_('Run the task when the event happens at this latitude'),
        validators=[MinValueValidator(-90), MaxValueValidator(90)],
    )
    longitude = models.DecimalField(
        max_digits=9, decimal_places=6,
        verbose_name=_('Longitude'),
        help_text=_('Run the task when the event happens at this longitude'),
        validators=[MinValueValidator(-180), MaxValueValidator(180)],
    )

    class Meta:
        """Table information."""

        verbose_name = _('solar event')
        verbose_name_plural = _('solar events')
        ordering = ('event', 'latitude', 'longitude')
        unique_together = ('event', 'latitude', 'longitude')

    @property
    def schedule(self):
        return schedules.solar(self.event,
                               self.latitude,
                               self.longitude,
                               nowfun=lambda: make_aware(now()))

    @classmethod
    def from_schedule(cls, schedule):
        spec = {'event': schedule.event,
                'latitude': schedule.lat,
                'longitude': schedule.lon}

        # we do not check for MultipleObjectsReturned exception here because
        # the unique_together constraint safely prevents from duplicates
        try:
            return cls.objects.get(**spec)
        except cls.DoesNotExist:
            return cls(**spec)

    def __str__(self):
        return '{} ({}, {})'.format(
            self.get_event_display(),
            self.latitude,
            self.longitude
        )


class IntervalSchedule(models.Model):
    """Schedule executing on a regular interval.

    Example: execute every 2 days:

    >>> every=2, period=DAYS
    """

    DAYS = DAYS
    HOURS = HOURS
    MINUTES = MINUTES
    SECONDS = SECONDS
    MICROSECONDS = MICROSECONDS

    PERIOD_CHOICES = PERIOD_CHOICES

    every = models.IntegerField(
        null=False,
        verbose_name=_('Number of Periods'),
        help_text=_('Number of interval periods to wait before '
                    'running the task again'),
        validators=[MinValueValidator(1)],
    )
    period = models.CharField(
        max_length=24, choices=PERIOD_CHOICES,
        verbose_name=_('Interval Period'),
        help_text=_('The type of period between task runs (Example: days)'),
    )

    class Meta:
        """Table information."""

        verbose_name = _('interval')
        verbose_name_plural = _('intervals')
        ordering = ['period', 'every']

    @property
    def schedule(self):
        return schedules.schedule(
            timedelta(**{self.period: self.every}),
            nowfun=lambda: make_aware(now())
        )

    @classmethod
    def from_schedule(cls, schedule, period=SECONDS):
        every = max(schedule.run_every.total_seconds(), 0)
        try:
            return cls.objects.get(every=every, period=period)
        except cls.DoesNotExist:
            return cls(every=every, period=period)
        except MultipleObjectsReturned:
            return cls.objects.filter(every=every, period=period).first()

    def __str__(self):
        readable_period = None
        if self.every == 1:
            for period, _readable_period in SINGULAR_PERIODS:
                if period == self.period:
                    readable_period = _readable_period.lower()
                    break
            return _('every {}').format(readable_period)
        for period, _readable_period in PERIOD_CHOICES:
            if period == self.period:
                readable_period = _readable_period.lower()
                break
        return _('every {} {}').format(self.every, readable_period)

    @property
    def period_singular(self):
        return self.period[:-1]


class ClockedSchedule(models.Model):
    """clocked schedule."""

    clocked_time = models.DateTimeField(
        verbose_name=_('Clock Time'),
        help_text=_('Run the task at clocked time'),
    )

    class Meta:
        """Table information."""

        verbose_name = _('clocked')
        verbose_name_plural = _('clocked')
        ordering = ['clocked_time']

    def __str__(self):
        return f'{make_aware(self.clocked_time)}'

    @property
    def schedule(self):
        c = clocked(clocked_time=self.clocked_time)
        return c

    @classmethod
    def from_schedule(cls, schedule):
        spec = {'clocked_time': schedule.clocked_time}
        try:
            return cls.objects.get(**spec)
        except cls.DoesNotExist:
            return cls(**spec)
        except MultipleObjectsReturned:
            return cls.objects.filter(**spec).first()


class CrontabSchedule(models.Model):
    """Timezone Aware Crontab-like schedule.

    Example:  Run every hour at 0 minutes for days of month 10-15:

    >>> minute="0", hour="*", day_of_week="*",
    ... day_of_month="10-15", month_of_year="*"
    """

    #
    # The worst case scenario for day of month is a list of all 31 day numbers
    # '[1, 2, ..., 31]' which has a length of 115. Likewise, minute can be
    # 0..59 and hour can be 0..23. Ensure we can accomodate these by allowing
    # 4 chars for each value (what we save on 0-9 accomodates the []).
    # We leave the other fields at their historical length.
    #
    minute = models.CharField(
        max_length=60 * 4, default='*',
        verbose_name=_('Minute(s)'),
        help_text=_(
            'Cron Minutes to Run. Use "*" for "all". (Example: "0,30")'),
        validators=[validators.minute_validator],
    )
    hour = models.CharField(
        max_length=24 * 4, default='*',
        verbose_name=_('Hour(s)'),
        help_text=_(
            'Cron Hours to Run. Use "*" for "all". (Example: "8,20")'),
        validators=[validators.hour_validator],
    )
    day_of_month = models.CharField(
        max_length=31 * 4, default='*',
        verbose_name=_('Day(s) Of The Month'),
        help_text=_(
            'Cron Days Of The Month to Run. Use "*" for "all". '
            '(Example: "1,15")'),
        validators=[validators.day_of_month_validator],
    )
    month_of_year = models.CharField(
        max_length=64, default='*',
        verbose_name=_('Month(s) Of The Year'),
        help_text=_(
            'Cron Months (1-12) Of The Year to Run. Use "*" for "all". '
            '(Example: "1,12")'),
        validators=[validators.month_of_year_validator],
    )
    day_of_week = models.CharField(
        max_length=64, default='*',
        verbose_name=_('Day(s) Of The Week'),
        help_text=_(
            'Cron Days Of The Week to Run. Use "*" for "all", Sunday '
            'is 0 or 7, Monday is 1. (Example: "0,5")'),
        validators=[validators.day_of_week_validator],
    )

    timezone = timezone_field.TimeZoneField(
        default=crontab_schedule_celery_timezone,
        use_pytz=False,
        verbose_name=_('Cron Timezone'),
        help_text=_(
            'Timezone to Run the Cron Schedule on. Default is UTC.'),
    )

    class Meta:
        """Table information."""

        verbose_name = _('crontab')
        verbose_name_plural = _('crontabs')
        ordering = ['month_of_year', 'day_of_month',
                    'day_of_week', 'hour', 'minute', 'timezone']

    @property
    def human_readable(self):
        try:
            c = schedules.crontab(
                minute=self.minute,
                hour=self.hour,
                day_of_week=self.day_of_week,
                day_of_month=self.day_of_month,
                month_of_year=self.month_of_year,
            )
            day_of_week = cronexp(",".join(str(day) for day in c.day_of_week))
        except ValueError:
            day_of_week = cronexp(self.day_of_week)

        cron_expression = '{} {} {} {} {}'.format(
            cronexp(self.minute), cronexp(self.hour),
            cronexp(self.day_of_month), cronexp(self.month_of_year),
            day_of_week
        )
        try:
            human_readable = get_description(cron_expression)
        except (
            MissingFieldException,
            FormatException,
            WrongArgumentException
        ):
            return f'{cron_expression} {str(self.timezone)}'
        return f'{human_readable} {str(self.timezone)}'

    def __str__(self):
        return '{} {} {} {} {} (m/h/dM/MY/d) {}'.format(
            cronexp(self.minute), cronexp(self.hour),
            cronexp(self.day_of_month), cronexp(self.month_of_year),
            cronexp(self.day_of_week), str(self.timezone)
        )

    @property
    def schedule(self):
        crontab = schedules.crontab(
            minute=self.minute,
            hour=self.hour,
            day_of_week=self.day_of_week,
            day_of_month=self.day_of_month,
            month_of_year=self.month_of_year,
        )
        if getattr(settings, 'DJANGO_CELERY_BEAT_TZ_AWARE', True):
            crontab = TzAwareCrontab(
                minute=self.minute,
                hour=self.hour,
                day_of_week=self.day_of_week,
                day_of_month=self.day_of_month,
                month_of_year=self.month_of_year,
                tz=self.timezone
            )
        return crontab

    @classmethod
    def from_schedule(cls, schedule):
        spec = {'minute': schedule._orig_minute,
                'hour': schedule._orig_hour,
                'day_of_week': schedule._orig_day_of_week,
                'day_of_month': schedule._orig_day_of_month,
                'month_of_year': schedule._orig_month_of_year,
                'timezone': schedule.tz
                }
        try:
            return cls.objects.get(**spec)
        except cls.DoesNotExist:
            return cls(**spec)
        except MultipleObjectsReturned:
            return cls.objects.filter(**spec).first()


class PeriodicTasks(models.Model):
    """Helper table for tracking updates to periodic tasks.

    This stores a single row with ``ident=1``. ``last_update`` is updated via
    signals whenever anything changes in the :class:`~.PeriodicTask` model.
    Basically this acts like a DB data audit trigger.
    Doing this so we also track deletions, and not just insert/update.
    """

    ident = models.SmallIntegerField(default=1, primary_key=True, unique=True)
    last_update = models.DateTimeField(null=False)

    class Meta:
        verbose_name = _('periodic task track')
        verbose_name_plural = _('periodic task tracks')

    @classmethod
    def changed(cls, instance, **kwargs):
        if not instance.no_changes:
            cls.update_changed()

    @classmethod
    def update_changed(cls, **kwargs):
        cls.objects.update_or_create(ident=1, defaults={'last_update': now()})

    @classmethod
    def last_change(cls):
        try:
            return cls.objects.get(ident=1).last_update
        except cls.DoesNotExist:
            pass


class PeriodicTask(models.Model):
    """Model representing a periodic task."""

    name = models.CharField(
        max_length=200, unique=True,
        verbose_name=_('Name'),
        help_text=_('Short Description For This Task'),
    )
    task = models.CharField(
        max_length=200,
        verbose_name='Task Name',
        help_text=_('The Name of the Celery Task that Should be Run.  '
                    '(Example: "proj.tasks.import_contacts")'),
    )

    # You can only set ONE of the following schedule FK's
    # TODO: Redo this as a GenericForeignKey
    interval = models.ForeignKey(
        IntervalSchedule, on_delete=models.CASCADE,
        null=True, blank=True, verbose_name=_('Interval Schedule'),
        help_text=_('Interval Schedule to run the task on.  '
                    'Set only one schedule type, leave the others null.'),
    )
    crontab = models.ForeignKey(
        CrontabSchedule, on_delete=models.CASCADE, null=True, blank=True,
        verbose_name=_('Crontab Schedule'),
        help_text=_('Crontab Schedule to run the task on.  '
                    'Set only one schedule type, leave the others null.'),
    )
    solar = models.ForeignKey(
        SolarSchedule, on_delete=models.CASCADE, null=True, blank=True,
        verbose_name=_('Solar Schedule'),
        help_text=_('Solar Schedule to run the task on.  '
                    'Set only one schedule type, leave the others null.'),
    )
    clocked = models.ForeignKey(
        ClockedSchedule, on_delete=models.CASCADE, null=True, blank=True,
        verbose_name=_('Clocked Schedule'),
        help_text=_('Clocked Schedule to run the task on.  '
                    'Set only one schedule type, leave the others null.'),
    )
    # TODO: use django's JsonField
    args = models.TextField(
        blank=True, default='[]',
        verbose_name=_('Positional Arguments'),
        help_text=_(
            'JSON encoded positional arguments '
            '(Example: ["arg1", "arg2"])'),
    )
    kwargs = models.TextField(
        blank=True, default='{}',
        verbose_name=_('Keyword Arguments'),
        help_text=_(
            'JSON encoded keyword arguments '
            '(Example: {"argument": "value"})'),
    )

    queue = models.CharField(
        max_length=200, blank=True, null=True, default=None,
        verbose_name=_('Queue Override'),
        help_text=_(
            'Queue defined in CELERY_TASK_QUEUES. '
            'Leave None for default queuing.'),
    )

    # you can use low-level AMQP routing options here,
    # but you almost certaily want to leave these as None
    # http://docs.celeryproject.org/en/latest/userguide/routing.html#exchanges-queues-and-routing-keys
    exchange = models.CharField(
        max_length=200, blank=True, null=True, default=None,
        verbose_name=_('Exchange'),
        help_text=_('Override Exchange for low-level AMQP routing'),
    )
    routing_key = models.CharField(
        max_length=200, blank=True, null=True, default=None,
        verbose_name=_('Routing Key'),
        help_text=_('Override Routing Key for low-level AMQP routing'),
    )
    headers = models.TextField(
        blank=True, default='{}',
        verbose_name=_('AMQP Message Headers'),
        help_text=_('JSON encoded message headers for the AMQP message.'),
    )

    priority = models.PositiveIntegerField(
        default=None, validators=[MaxValueValidator(255)],
        blank=True, null=True,
        verbose_name=_('Priority'),
        help_text=_(
            'Priority Number between 0 and 255. '
            'Supported by: RabbitMQ, Redis (priority reversed, 0 is highest).')
    )
    expires = models.DateTimeField(
        blank=True, null=True,
        verbose_name=_('Expires Datetime'),
        help_text=_(
            'Datetime after which the schedule will no longer '
            'trigger the task to run'),
    )
    expire_seconds = models.PositiveIntegerField(
        blank=True, null=True,
        verbose_name=_('Expires timedelta with seconds'),
        help_text=_(
            'Timedelta with seconds which the schedule will no longer '
            'trigger the task to run'),

    )
    one_off = models.BooleanField(
        default=False,
        verbose_name=_('One-off Task'),
        help_text=_(
            'If True, the schedule will only run the task a single time'),
    )
    start_time = models.DateTimeField(
        blank=True, null=True,
        verbose_name=_('Start Datetime'),
        help_text=_(
            'Datetime when the schedule should begin '
            'triggering the task to run'),
    )
    enabled = models.BooleanField(
        default=True,
        verbose_name=_('Enabled'),
        help_text=_('Set to False to disable the schedule'),
    )
    last_run_at = models.DateTimeField(
        auto_now=False, auto_now_add=False,
        editable=False, blank=True, null=True,
        verbose_name=_('Last Run Datetime'),
        help_text=_(
            'Datetime that the schedule last triggered the task to run. '
            'Reset to None if enabled is set to False.'),
    )
    total_run_count = models.PositiveIntegerField(
        default=0, editable=False,
        verbose_name=_('Total Run Count'),
        help_text=_(
            'Running count of how many times the schedule '
            'has triggered the task'),
    )
    date_changed = models.DateTimeField(
        auto_now=True,
        verbose_name=_('Last Modified'),
        help_text=_('Datetime that this PeriodicTask was last modified'),
    )
    description = models.TextField(
        blank=True,
        verbose_name=_('Description'),
        help_text=_(
            'Detailed description about the details of this Periodic Task'),
    )

    objects = querysets.PeriodicTaskQuerySet.as_manager()
    no_changes = False

    class Meta:
        """Table information."""

        verbose_name = _('periodic task')
        verbose_name_plural = _('periodic tasks')

    def validate_unique(self, *args, **kwargs):
        super().validate_unique(*args, **kwargs)

        schedule_types = ['interval', 'crontab', 'solar', 'clocked']
        selected_schedule_types = [s for s in schedule_types
                                   if getattr(self, s)]

        if len(selected_schedule_types) == 0:
            raise ValidationError(
                'One of clocked, interval, crontab, or solar '
                'must be set.'
            )

        err_msg = 'Only one of clocked, interval, crontab, '\
            'or solar must be set'
        if len(selected_schedule_types) > 1:
            error_info = {}
            for selected_schedule_type in selected_schedule_types:
                error_info[selected_schedule_type] = [err_msg]
            raise ValidationError(error_info)

        # clocked must be one off task
        if self.clocked and not self.one_off:
            err_msg = 'clocked must be one off, one_off must set True'
            raise ValidationError(err_msg)

    def save(self, *args, **kwargs):
        self.exchange = self.exchange or None
        self.routing_key = self.routing_key or None
        self.queue = self.queue or None
        self.headers = self.headers or None
        if not self.enabled:
            self.last_run_at = None
        self._clean_expires()
        self.validate_unique()
        super().save(*args, **kwargs)
        PeriodicTasks.changed(self)

    def delete(self, *args, **kwargs):
        super().delete(*args, **kwargs)
        PeriodicTasks.changed(self)

    def _clean_expires(self):
        if self.expire_seconds is not None and self.expires:
            raise ValidationError(
                _('Only one can be set, in expires and expire_seconds')
            )

    @property
    def expires_(self):
        return self.expires or self.expire_seconds

    def __str__(self):
        fmt = '{0.name}: {{no schedule}}'
        if self.interval:
            fmt = '{0.name}: {0.interval}'
        if self.crontab:
            fmt = '{0.name}: {0.crontab}'
        if self.solar:
            fmt = '{0.name}: {0.solar}'
        if self.clocked:
            fmt = '{0.name}: {0.clocked}'
        return fmt.format(self)

    @property
    def scheduler(self):
        if self.interval:
            return self.interval
        if self.crontab:
            return self.crontab
        if self.solar:
            return self.solar
        if self.clocked:
            return self.clocked

    @property
    def schedule(self):
        return self.scheduler.schedule

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django_celery_beat\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django_filters\views.py ---

from django.core.exceptions import ImproperlyConfigured
from django.views.generic import View
from django.views.generic.list import (
    MultipleObjectMixin,
    MultipleObjectTemplateResponseMixin,
)

from .constants import ALL_FIELDS
from .filterset import filterset_factory


class FilterMixin:
    """
    A mixin that provides a way to show and handle a FilterSet in a request.
    """

    filterset_class = None
    filterset_fields = ALL_FIELDS
    strict = True

    def get_filterset_class(self):
        """
        Returns the filterset class to use in this view
        """
        if self.filterset_class:
            return self.filterset_class
        elif self.model:
            return filterset_factory(model=self.model, fields=self.filterset_fields)
        else:
            msg = "'%s' must define 'filterset_class' or 'model'"
            raise ImproperlyConfigured(msg % self.__class__.__name__)

    def get_filterset(self, filterset_class):
        """
        Returns an instance of the filterset to be used in this view.
        """
        kwargs = self.get_filterset_kwargs(filterset_class)
        return filterset_class(**kwargs)

    def get_filterset_kwargs(self, filterset_class):
        """
        Returns the keyword arguments for instantiating the filterset.
        """
        kwargs = {
            "data": self.request.GET or None,
            "request": self.request,
        }
        try:
            kwargs.update(
                {
                    "queryset": self.get_queryset(),
                }
            )
        except ImproperlyConfigured:
            # ignore the error here if the filterset has a model defined
            # to acquire a queryset from
            if filterset_class._meta.model is None:
                msg = (
                    "'%s' does not define a 'model' and the view '%s' does "
                    "not return a valid queryset from 'get_queryset'.  You "
                    "must fix one of them."
                )
                args = (filterset_class.__name__, self.__class__.__name__)
                raise ImproperlyConfigured(msg % args)
        return kwargs

    def get_strict(self):
        return self.strict


class BaseFilterView(FilterMixin, MultipleObjectMixin, View):
    def get(self, request, *args, **kwargs):
        filterset_class = self.get_filterset_class()
        self.filterset = self.get_filterset(filterset_class)

        if (
            not self.filterset.is_bound
            or self.filterset.is_valid()
            or not self.get_strict()
        ):
            self.object_list = self.filterset.qs
        else:
            self.object_list = self.filterset.queryset.none()

        context = self.get_context_data(
            filter=self.filterset, object_list=self.object_list
        )
        return self.render_to_response(context)


class FilterView(MultipleObjectTemplateResponseMixin, BaseFilterView):
    """
    Render some list of objects with filter, set by `self.model` or
    `self.queryset`.
    `self.queryset` can actually be any iterable of items, not just a queryset.
    """

    template_name_suffix = "_filter"


def object_filter(
    request,
    model=None,
    queryset=None,
    template_name=None,
    extra_context=None,
    context_processors=None,
    filter_class=None,
):
    class ECFilterView(FilterView):
        """Handle the extra_context from the functional object_filter view"""

        def get_context_data(self, **kwargs):
            context = super().get_context_data(**kwargs)
            extra_context = self.kwargs.get("extra_context") or {}
            for k, v in extra_context.items():
                if callable(v):
                    v = v()
                context[k] = v
            return context

    kwargs = dict(
        model=model,
        queryset=queryset,
        template_name=template_name,
        filterset_class=filter_class,
    )
    view = ECFilterView.as_view(**kwargs)
    return view(request, extra_context=extra_context)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\django_filters\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\docx\oxml\settings.py ---

# encoding: utf-8

"""Custom element classes related to document settings"""

from __future__ import absolute_import, division, print_function, unicode_literals

from docx.oxml.xmlchemy import BaseOxmlElement, ZeroOrOne


class CT_Settings(BaseOxmlElement):
    """`w:settings` element, root element for the settings part"""

    _tag_seq = (
        "w:writeProtection", "w:view", "w:zoom", "w:removePersonalInformation",
        "w:removeDateAndTime", "w:doNotDisplayPageBoundaries",
        "w:displayBackgroundShape", "w:printPostScriptOverText",
        "w:printFractionalCharacterWidth", "w:printFormsData", "w:embedTrueTypeFonts",
        "w:embedSystemFonts", "w:saveSubsetFonts", "w:saveFormsData", "w:mirrorMargins",
        "w:alignBordersAndEdges", "w:bordersDoNotSurroundHeader",
        "w:bordersDoNotSurroundFooter", "w:gutterAtTop", "w:hideSpellingErrors",
        "w:hideGrammaticalErrors", "w:activeWritingStyle", "w:proofState",
        "w:formsDesign", "w:attachedTemplate", "w:linkStyles",
        "w:stylePaneFormatFilter", "w:stylePaneSortMethod", "w:documentType",
        "w:mailMerge", "w:revisionView", "w:trackRevisions", "w:doNotTrackMoves",
        "w:doNotTrackFormatting", "w:documentProtection", "w:autoFormatOverride",
        "w:styleLockTheme", "w:styleLockQFSet", "w:defaultTabStop", "w:autoHyphenation",
        "w:consecutiveHyphenLimit", "w:hyphenationZone", "w:doNotHyphenateCaps",
        "w:showEnvelope", "w:summaryLength", "w:clickAndTypeStyle",
        "w:defaultTableStyle", "w:evenAndOddHeaders", "w:bookFoldRevPrinting",
        "w:bookFoldPrinting", "w:bookFoldPrintingSheets",
        "w:drawingGridHorizontalSpacing", "w:drawingGridVerticalSpacing",
        "w:displayHorizontalDrawingGridEvery", "w:displayVerticalDrawingGridEvery",
        "w:doNotUseMarginsForDrawingGridOrigin", "w:drawingGridHorizontalOrigin",
        "w:drawingGridVerticalOrigin", "w:doNotShadeFormData", "w:noPunctuationKerning",
        "w:characterSpacingControl", "w:printTwoOnOne", "w:strictFirstAndLastChars",
        "w:noLineBreaksAfter", "w:noLineBreaksBefore", "w:savePreviewPicture",
        "w:doNotValidateAgainstSchema", "w:saveInvalidXml", "w:ignoreMixedContent",
        "w:alwaysShowPlaceholderText", "w:doNotDemarcateInvalidXml",
        "w:saveXmlDataOnly", "w:useXSLTWhenSaving", "w:saveThroughXslt",
        "w:showXMLTags", "w:alwaysMergeEmptyNamespace", "w:updateFields",
        "w:hdrShapeDefaults", "w:footnotePr", "w:endnotePr", "w:compat", "w:docVars",
        "w:rsids", "m:mathPr", "w:attachedSchema", "w:themeFontLang",
        "w:clrSchemeMapping", "w:doNotIncludeSubdocsInStats",
        "w:doNotAutoCompressPictures", "w:forceUpgrade", "w:captions",
        "w:readModeInkLockDown", "w:smartTagType", "sl:schemaLibrary",
        "w:shapeDefaults", "w:doNotEmbedSmartTags", "w:decimalSymbol", "w:listSeparator"
    )
    evenAndOddHeaders = ZeroOrOne("w:evenAndOddHeaders", successors=_tag_seq[48:])
    del _tag_seq

    @property
    def evenAndOddHeaders_val(self):
        """value of `w:evenAndOddHeaders/@w:val` or |None| if not present."""
        evenAndOddHeaders = self.evenAndOddHeaders
        if evenAndOddHeaders is None:
            return False
        return evenAndOddHeaders.val

    @evenAndOddHeaders_val.setter
    def evenAndOddHeaders_val(self, value):
        if value in [None, False]:
            self._remove_evenAndOddHeaders()
        else:
            self.get_or_add_evenAndOddHeaders().val = value

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\docx\oxml\settings.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\docx\parts\settings.py ---

# encoding: utf-8

"""
|SettingsPart| and closely related objects
"""

from __future__ import (
    absolute_import, division, print_function, unicode_literals
)

import os

from ..opc.constants import CONTENT_TYPE as CT
from ..opc.packuri import PackURI
from ..opc.part import XmlPart
from ..oxml import parse_xml
from ..settings import Settings


class SettingsPart(XmlPart):
    """
    Document-level settings part of a WordprocessingML (WML) package.
    """
    @classmethod
    def default(cls, package):
        """
        Return a newly created settings part, containing a default
        `w:settings` element tree.
        """
        partname = PackURI('/word/settings.xml')
        content_type = CT.WML_SETTINGS
        element = parse_xml(cls._default_settings_xml())
        return cls(partname, content_type, element, package)

    @property
    def settings(self):
        """
        A |Settings| proxy object for the `w:settings` element in this part,
        containing the document-level settings for this document.
        """
        return Settings(self.element)

    @classmethod
    def _default_settings_xml(cls):
        """
        Return a bytestream containing XML for a default settings part.
        """
        path = os.path.join(
            os.path.split(__file__)[0], '..', 'templates',
            'default-settings.xml'
        )
        with open(path, 'rb') as f:
            xml_bytes = f.read()
        return xml_bytes

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\docx\parts\settings.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\docx\settings.py ---

# encoding: utf-8

"""Settings object, providing access to document-level settings"""

from __future__ import absolute_import, division, print_function, unicode_literals

from docx.shared import ElementProxy


class Settings(ElementProxy):
    """Provides access to document-level settings for a document.

    Accessed using the :attr:`.Document.settings` property.
    """

    __slots__ = ()

    @property
    def odd_and_even_pages_header_footer(self):
        """True if this document has distinct odd and even page headers and footers.

        Read/write.
        """
        return self._element.evenAndOddHeaders_val

    @odd_and_even_pages_header_footer.setter
    def odd_and_even_pages_header_footer(self, value):
        self._element.evenAndOddHeaders_val = value

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\docx\settings.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\drf_spectacular\apps.py ---

from django.apps import AppConfig


class SpectacularConfig(AppConfig):
    name = 'drf_spectacular'
    verbose_name = "drf-spectacular"

    def ready(self):
        import drf_spectacular.checks  # noqa: F401

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\drf_spectacular\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\drf_spectacular\serializers.py ---

from drf_spectacular.drainage import error, warn
from drf_spectacular.extensions import OpenApiSerializerExtension
from drf_spectacular.plumbing import force_instance, is_list_serializer, is_serializer


class PolymorphicProxySerializerExtension(OpenApiSerializerExtension):
    target_class = 'drf_spectacular.utils.PolymorphicProxySerializer'
    priority = -1

    def get_name(self):
        return self.target.component_name

    def map_serializer(self, auto_schema, direction):
        """ custom handling for @extend_schema's injection of PolymorphicProxySerializer """
        if isinstance(self.target.serializers, dict):
            sub_components = self._get_explicit_sub_components(auto_schema, direction)
        else:
            sub_components = self._get_implicit_sub_components(auto_schema, direction)

        if not self._has_discriminator():
            return {'oneOf': [schema for _, schema in sub_components]}
        else:
            return {
                'oneOf': [schema for _, schema in sub_components],
                'discriminator': {
                    'propertyName': self.target.resource_type_field_name,
                    'mapping': {resource_type: schema['$ref'] for resource_type, schema in sub_components}
                }
            }

    def _get_implicit_sub_components(self, auto_schema, direction):
        sub_components = []
        for sub_serializer in self.target.serializers:
            sub_serializer = self._prep_serializer(sub_serializer)
            (resolved_name, resolved_schema) = self._process_serializer(auto_schema, sub_serializer, direction)
            if not resolved_schema:
                continue

            if not self._has_discriminator():
                sub_components.append((None, resolved_schema))
            else:
                try:
                    discriminator_field = sub_serializer.fields[self.target.resource_type_field_name]
                    resource_type = discriminator_field.to_representation(None)
                except:  # noqa: E722
                    warn(
                        f'sub-serializer {resolved_name} of {self.target.component_name} '
                        f'must contain the discriminator field "{self.target.resource_type_field_name}". '
                        f'defaulting to sub-serializer name, but schema will likely not match the API.'
                    )
                    resource_type = resolved_name
                sub_components.append((resource_type, resolved_schema))

        return sub_components

    def _get_explicit_sub_components(self, auto_schema, direction):
        sub_components = []
        for resource_type, sub_serializer in self.target.serializers.items():
            sub_serializer = self._prep_serializer(sub_serializer)
            (_, resolved_schema) = self._process_serializer(auto_schema, sub_serializer, direction)
            if resolved_schema:
                sub_components.append((resource_type, resolved_schema))

        return sub_components

    def _has_discriminator(self):
        return self.target.resource_type_field_name is not None

    def _prep_serializer(self, serializer):
        serializer = force_instance(serializer)
        serializer.partial = self.target.partial
        return serializer

    def _process_serializer(self, auto_schema, serializer, direction):
        if is_list_serializer(serializer):
            if self._has_discriminator() or self.target._many is not False:
                warn(
                    "To control sub-serializer's \"many\" attribute, following usage pattern is necessary: "
                    "PolymorphicProxySerializer(serializers=[...], resource_type_field_name=None, "
                    "many=False). Ignoring serializer as it is not processable in this configuration."
                )
                return None, None
            schema = auto_schema._unwrap_list_serializer(serializer, direction)
            return None, schema
        elif is_serializer(serializer):
            resolved = auto_schema.resolve_serializer(serializer, direction)
            return (resolved.name, resolved.ref) if resolved else (None, None)
        else:
            error("PolymorphicProxySerializer's serializer argument contained unknown objects.")
            return None, None

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\drf_spectacular\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\drf_spectacular\settings.py ---

from contextlib import contextmanager
from typing import Any, Dict

from django.conf import settings
from rest_framework.settings import APISettings, perform_import

SPECTACULAR_DEFAULTS: Dict[str, Any] = {
    # A regex specifying the common denominator for all operation paths. If
    # SCHEMA_PATH_PREFIX is set to None, drf-spectacular will attempt to estimate
    # a common prefix. Use '' to disable.
    # Mainly used for tag extraction, where paths like '/api/v1/albums' with
    # a SCHEMA_PATH_PREFIX regex '/api/v[0-9]' would yield the tag 'albums'.
    'SCHEMA_PATH_PREFIX': None,
    # Remove matching SCHEMA_PATH_PREFIX from operation path. Usually used in
    # conjunction with appended prefixes in SERVERS.
    'SCHEMA_PATH_PREFIX_TRIM': False,
    # Insert a manual path prefix to the operation path, e.g. '/service/backend'.
    # Use this for example to align paths when the API is mounted as a sub-resource
    # behind a proxy and Django is not aware of that. Alternatively, prefixes can
    # also specified via SERVERS, but this makes the operation path more explicit.
    'SCHEMA_PATH_PREFIX_INSERT': '',
    # Coercion of {pk} to {id} is controlled by SCHEMA_COERCE_PATH_PK. Additionally,
    # some libraries (e.g. drf-nested-routers) use "_pk" suffixed path variables.
    # This setting globally coerces path variables like "{user_pk}" to "{user_id}".
    'SCHEMA_COERCE_PATH_PK_SUFFIX': False,

    # Schema generation parameters to influence how components are constructed.
    # Some schema features might not translate well to your target.
    # Demultiplexing/modifying components might help alleviate those issues.
    'DEFAULT_GENERATOR_CLASS': 'drf_spectacular.generators.SchemaGenerator',
    # Create separate components for PATCH endpoints (without required list)
    'COMPONENT_SPLIT_PATCH': True,
    # Split components into request and response parts where appropriate
    # This setting is highly recommended to achieve the most accurate API
    # description, however it comes at the cost of having more components.
    'COMPONENT_SPLIT_REQUEST': False,
    # Aid client generator targets that have trouble with read-only properties.
    'COMPONENT_NO_READ_ONLY_REQUIRED': False,

    # Adds "minLength: 1" to fields that do not allow blank strings. Deactivated
    # by default because serializers do not strictly enforce this on responses and
    # so "minLength: 1" may not always accurately describe API behavior.
    # Gets implicitly enabled by COMPONENT_SPLIT_REQUEST, because this can be
    # accurately modeled when request and response components are separated.
    'ENFORCE_NON_BLANK_FIELDS': False,

    # This version string will end up the in schema header. The default OpenAPI
    # version is 3.0.3, which is heavily tested. We now also support 3.1.0,
    # which contains the same features and a few mandatory, but minor changes.
    'OAS_VERSION': '3.0.3',

    # Configuration for serving a schema subset with SpectacularAPIView
    'SERVE_URLCONF': None,
    # complete public schema or a subset based on the requesting user
    'SERVE_PUBLIC': True,
    # include schema endpoint into schema
    'SERVE_INCLUDE_SCHEMA': True,
    # list of authentication/permission classes for spectacular's views.
    'SERVE_PERMISSIONS': ['rest_framework.permissions.AllowAny'],
    # None will default to DRF's AUTHENTICATION_CLASSES
    'SERVE_AUTHENTICATION': None,

    # Dictionary of general configuration to pass to the SwaggerUI({ ... })
    # https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/
    # The settings are serialized with json.dumps(). If you need customized JS, use a
    # string instead. The string must then contain valid JS and is passed unchanged.
    'SWAGGER_UI_SETTINGS': {
        'deepLinking': True,
    },
    # Initialize SwaggerUI with additional OAuth2 configuration.
    # https://swagger.io/docs/open-source-tools/swagger-ui/usage/oauth2/
    'SWAGGER_UI_OAUTH2_CONFIG': {},

    # Dictionary of general configuration to pass to the Redoc.init({ ... })
    # https://github.com/Redocly/redoc#redoc-options-object
    # The settings are serialized with json.dumps(). If you need customized JS, use a
    # string instead. The string must then contain valid JS and is passed unchanged.
    'REDOC_UI_SETTINGS': {},

    # CDNs for swagger and redoc. You can change the version or even host your
    # own depending on your requirements. For self-hosting, have a look at
    # the sidecar option in the README.
    'SWAGGER_UI_DIST': 'https://cdn.jsdelivr.net/npm/swagger-ui-dist@latest',
    'SWAGGER_UI_FAVICON_HREF': 'https://cdn.jsdelivr.net/npm/swagger-ui-dist@latest/favicon-32x32.png',
    'REDOC_DIST': 'https://cdn.jsdelivr.net/npm/redoc@latest',

    # Append OpenAPI objects to path and components in addition to the generated objects
    'APPEND_PATHS': {},
    'APPEND_COMPONENTS': {},

    # STRONGLY DISCOURAGED (with the exception for the djangorestframework-api-key library)
    # please don't use this anymore as it has tricky implications that
    # are hard to get right. For authentication, OpenApiAuthenticationExtension are
    # strongly preferred because they are more robust and easy to write.
    # However if used, the list of methods is appended to every endpoint in the schema!
    'SECURITY': [],

    # Postprocessing functions that run at the end of schema generation.
    # must satisfy interface result = hook(generator, request, public, result)
    'POSTPROCESSING_HOOKS': [
        'drf_spectacular.hooks.postprocess_schema_enums'
    ],

    # Preprocessing functions that run before schema generation.
    # must satisfy interface result = hook(endpoints=result) where result
    # is a list of Tuples (path, path_regex, method, callback).
    # Example: 'drf_spectacular.hooks.preprocess_exclude_path_format'
    'PREPROCESSING_HOOKS': [],

    # Determines how operations should be sorted. If you intend to do sorting with a
    # PREPROCESSING_HOOKS, be sure to disable this setting. If configured, the sorting
    # is applied after the PREPROCESSING_HOOKS. Accepts either
    # True (drf-spectacular's alpha-sorter), False, or a callable for sort's key arg.
    'SORT_OPERATIONS': True,

    # enum name overrides. dict with keys "YourEnum" and their choice values "field.choices"
    # e.g. {'SomeEnum': ['A', 'B'], 'OtherEnum': 'import.path.to.choices'}
    'ENUM_NAME_OVERRIDES': {},
    # Adds "blank" and "null" enum choices where appropriate. disable on client generation issues
    'ENUM_ADD_EXPLICIT_BLANK_NULL_CHOICE': True,
    # Add/Append a list of (``choice value`` - choice name) to the enum description string.
    'ENUM_GENERATE_CHOICE_DESCRIPTION': True,

    # function that returns a list of all classes that should be excluded from doc string extraction
    'GET_LIB_DOC_EXCLUDES': 'drf_spectacular.plumbing.get_lib_doc_excludes',

    # Function that returns a mocked request for view processing. For CLI usage
    # original_request will be None.
    # interface: request = build_mock_request(method, path, view, original_request, **kwargs)
    'GET_MOCK_REQUEST': 'drf_spectacular.plumbing.build_mock_request',

    # Camelize names like "operationId" and path parameter names
    # Camelization of the operation schema itself requires the addition of
    # 'drf_spectacular.contrib.djangorestframework_camel_case.camelize_serializer_fields'
    # to POSTPROCESSING_HOOKS. Please note that the hook depends on
    # ``djangorestframework_camel_case``, while CAMELIZE_NAMES itself does not.
    'CAMELIZE_NAMES': False,

    # Determines if and how free-form 'additionalProperties' should be emitted in the schema. Some
    # code generator targets are sensitive to this. None disables generic 'additionalProperties'.
    # allowed values are 'dict', 'bool', None
    'GENERIC_ADDITIONAL_PROPERTIES': 'dict',

    # Path converter schema overrides (e.g. <int:foo>). Can be used to either modify default
    # behavior or provide a schema for custom converters registered with register_converter(...).
    # Takes converter labels as keys and either basic python types, OpenApiType, or raw schemas
    # as values. Example: {'aint': OpenApiTypes.INT, 'bint': str, 'cint': {'type': ...}}
    'PATH_CONVERTER_OVERRIDES': {},

    # Determines whether operation parameters should be sorted alphanumerically or just in
    # the order they arrived. Accepts either True, False, or a callable for sort's key arg.
    'SORT_OPERATION_PARAMETERS': True,

    # @extend_schema allows to specify status codes besides 200. This functionality is usually used
    # to describe error responses, which rarely make use of list mechanics. Therefore, we suppress
    # listing (pagination and filtering) on non-2XX status codes by default. Toggle this to enable
    # list responses with ListSerializers/many=True irrespective of the status code.
    'ENABLE_LIST_MECHANICS_ON_NON_2XX': False,

    # This setting allows you to deviate from the default manager by accessing a different model
    # property. We use "objects" by default for compatibility reasons. Using "_default_manager"
    # will likely fix most issues, though you are free to choose any name.
    "DEFAULT_QUERY_MANAGER": 'objects',

    # Controls which authentication methods are exposed in the schema. If not None, will hide
    # authentication classes that are not contained in the whitelist. Use full import paths
    # like ['rest_framework.authentication.TokenAuthentication', ...].
    # Empty list ([]) will hide all authentication methods. The default None will show all.
    'AUTHENTICATION_WHITELIST': None,
    # Controls which parsers are exposed in the schema. Works analog to AUTHENTICATION_WHITELIST.
    # List of allowed parsers or None to allow all.
    'PARSER_WHITELIST': None,
    # Controls which renderers are exposed in the schema. Works analog to AUTHENTICATION_WHITELIST.
    # rest_framework.renderers.BrowsableAPIRenderer is ignored by default if whitelist is None
    'RENDERER_WHITELIST': None,

    # Option for turning off error and warn messages
    'DISABLE_ERRORS_AND_WARNINGS': False,

    # Runs exemplary schema generation and emits warnings as part of "./manage.py check --deploy"
    'ENABLE_DJANGO_DEPLOY_CHECK': True,

    # General schema metadata. Refer to spec for valid inputs
    # https://spec.openapis.org/oas/v3.0.3#openapi-object
    'TITLE': '',
    'DESCRIPTION': '',
    'TOS': None,
    # Optional: MAY contain "name", "url", "email"
    'CONTACT': {},
    # Optional: MUST contain "name", MAY contain URL
    'LICENSE': {},
    # Statically set schema version. May also be an empty string. When used together with
    # view versioning, will become '0.0.0 (v2)' for 'v2' versioned requests.
    # Set VERSION to None if only the request version should be rendered.
    'VERSION': '0.0.0',
    # Optional list of servers.
    # Each entry MUST contain "url", MAY contain "description", "variables"
    # e.g. [{'url': 'https://example.com/v1', 'description': 'Text'}, ...]
    'SERVERS': [],
    # Tags defined in the global scope
    'TAGS': [],
    # Optional: MUST contain 'url', may contain "description"
    'EXTERNAL_DOCS': {},

    # Arbitrary specification extensions attached to the schema's info object.
    # https://swagger.io/specification/#specification-extensions
    'EXTENSIONS_INFO': {},

    # Arbitrary specification extensions attached to the schema's root object.
    # https://swagger.io/specification/#specification-extensions
    'EXTENSIONS_ROOT': {},

    # Oauth2 related settings. used for example by django-oauth2-toolkit.
    # https://spec.openapis.org/oas/v3.0.3#oauthFlowsObject
    'OAUTH2_FLOWS': [],
    'OAUTH2_AUTHORIZATION_URL': None,
    'OAUTH2_TOKEN_URL': None,
    'OAUTH2_REFRESH_URL': None,
    'OAUTH2_SCOPES': None,
}

IMPORT_STRINGS = [
    'DEFAULT_GENERATOR_CLASS',
    'SERVE_AUTHENTICATION',
    'SERVE_PERMISSIONS',
    'POSTPROCESSING_HOOKS',
    'PREPROCESSING_HOOKS',
    'GET_LIB_DOC_EXCLUDES',
    'GET_MOCK_REQUEST',
    'SORT_OPERATIONS',
    'SORT_OPERATION_PARAMETERS',
    'AUTHENTICATION_WHITELIST',
    'RENDERER_WHITELIST',
    'PARSER_WHITELIST',
]


class SpectacularSettings(APISettings):
    _original_settings: Dict[str, Any] = {}

    def apply_patches(self, patches):
        for attr, val in patches.items():
            if attr.startswith('SERVE_') or attr == 'DEFAULT_GENERATOR_CLASS':
                raise AttributeError(
                    f'{attr} not allowed in custom_settings. use dedicated parameter instead.'
                )
            if attr in self.import_strings:
                val = perform_import(val, attr)
            # load and store original value, then override __dict__ entry
            self._original_settings[attr] = getattr(self, attr)
            setattr(self, attr, val)

    def clear_patches(self):
        for attr, orig_val in self._original_settings.items():
            setattr(self, attr, orig_val)
        self._original_settings = {}


spectacular_settings = SpectacularSettings(
    user_settings=getattr(settings, 'SPECTACULAR_SETTINGS', {}),  # type: ignore
    defaults=SPECTACULAR_DEFAULTS,  # type: ignore
    import_strings=IMPORT_STRINGS,
)


@contextmanager
def patched_settings(patches):
    """ temporarily patch the global spectacular settings (or do nothing) """
    if not patches:
        yield
    else:
        try:
            spectacular_settings.apply_patches(patches)
            yield
        finally:
            spectacular_settings.clear_patches()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\drf_spectacular\settings.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\drf_spectacular\views.py ---

import json
from collections import namedtuple
from importlib import import_module
from typing import Any, Dict, List, Optional, Type

from django.conf import settings
from django.templatetags.static import static
from django.utils import translation
from django.utils.translation import gettext_lazy as _
from django.views.generic import RedirectView
from rest_framework.renderers import TemplateHTMLRenderer
from rest_framework.response import Response
from rest_framework.reverse import reverse
from rest_framework.settings import api_settings
from rest_framework.views import APIView

from drf_spectacular.generators import SchemaGenerator
from drf_spectacular.plumbing import get_relative_url, set_query_parameters
from drf_spectacular.renderers import (
    OpenApiJsonRenderer, OpenApiJsonRenderer2, OpenApiYamlRenderer, OpenApiYamlRenderer2,
)
from drf_spectacular.settings import patched_settings, spectacular_settings
from drf_spectacular.types import OpenApiTypes
from drf_spectacular.utils import OpenApiParameter, extend_schema

if spectacular_settings.SERVE_INCLUDE_SCHEMA:
    SCHEMA_KWARGS: Dict[str, Any] = {'responses': {200: OpenApiTypes.OBJECT}}

    if settings.USE_I18N:
        SCHEMA_KWARGS['parameters'] = [
            OpenApiParameter(
                'lang', str, OpenApiParameter.QUERY, enum=list(dict(settings.LANGUAGES).keys())
            )
        ]
else:
    SCHEMA_KWARGS = {'exclude': True}

if spectacular_settings.SERVE_AUTHENTICATION is not None:
    AUTHENTICATION_CLASSES = spectacular_settings.SERVE_AUTHENTICATION
else:
    AUTHENTICATION_CLASSES = api_settings.DEFAULT_AUTHENTICATION_CLASSES


class SpectacularAPIView(APIView):
    __doc__ = _("""
    OpenApi3 schema for this API. Format can be selected via content negotiation.

    - YAML: application/vnd.oai.openapi
    - JSON: application/vnd.oai.openapi+json
    """)  # type: ignore
    renderer_classes = [
        OpenApiYamlRenderer, OpenApiYamlRenderer2, OpenApiJsonRenderer, OpenApiJsonRenderer2
    ]
    permission_classes = spectacular_settings.SERVE_PERMISSIONS
    authentication_classes = AUTHENTICATION_CLASSES
    generator_class: Type[SchemaGenerator] = spectacular_settings.DEFAULT_GENERATOR_CLASS
    serve_public: bool = spectacular_settings.SERVE_PUBLIC
    urlconf: Optional[str] = spectacular_settings.SERVE_URLCONF
    api_version: Optional[str] = None
    custom_settings: Optional[Dict[str, Any]] = None
    patterns: Optional[List[Any]] = None

    @extend_schema(**SCHEMA_KWARGS)
    def get(self, request, *args, **kwargs):
        # special handling of custom urlconf parameter
        if isinstance(self.urlconf, list) or isinstance(self.urlconf, tuple):
            ModuleWrapper = namedtuple('ModuleWrapper', ['urlpatterns'])
            if all(isinstance(i, str) for i in self.urlconf):
                # list of import string for urlconf
                patterns = []
                for item in self.urlconf:
                    url = import_module(item)
                    patterns += url.urlpatterns
                self.urlconf = ModuleWrapper(tuple(patterns))
            else:
                # explicitly resolved urlconf
                self.urlconf = ModuleWrapper(tuple(self.urlconf))

        with patched_settings(self.custom_settings):
            if settings.USE_I18N and request.GET.get('lang'):
                with translation.override(request.GET.get('lang')):
                    return self._get_schema_response(request)
            else:
                return self._get_schema_response(request)

    def _get_schema_response(self, request):
        # version specified as parameter to the view always takes precedence. after
        # that we try to source version through the schema view's own versioning_class.
        version = self.api_version or request.version or self._get_version_parameter(request)
        generator = self.generator_class(urlconf=self.urlconf, api_version=version, patterns=self.patterns)
        return Response(
            data=generator.get_schema(request=request, public=self.serve_public),
            headers={"Content-Disposition": f'inline; filename="{self._get_filename(request, version)}"'}
        )

    def _get_filename(self, request, version):
        return "{title}{version}.{suffix}".format(
            title=spectacular_settings.TITLE or 'schema',
            version=f' ({version})' if version else '',
            suffix=self.perform_content_negotiation(request, force=True)[0].format
        )

    def _get_version_parameter(self, request):
        version = request.GET.get('version')
        if not api_settings.ALLOWED_VERSIONS or version in api_settings.ALLOWED_VERSIONS:
            return version
        return None


class SpectacularYAMLAPIView(SpectacularAPIView):
    renderer_classes = [OpenApiYamlRenderer, OpenApiYamlRenderer2]


class SpectacularJSONAPIView(SpectacularAPIView):
    renderer_classes = [OpenApiJsonRenderer, OpenApiJsonRenderer2]


def _get_sidecar_url(filepath):
    return static(f'drf_spectacular_sidecar/{filepath}')


class SpectacularSwaggerView(APIView):
    renderer_classes = [TemplateHTMLRenderer]
    permission_classes = spectacular_settings.SERVE_PERMISSIONS
    authentication_classes = AUTHENTICATION_CLASSES
    url_name: str = 'schema'
    url: Optional[str] = None
    template_name: str = 'drf_spectacular/swagger_ui.html'
    template_name_js: str = 'drf_spectacular/swagger_ui.js'
    title: str = spectacular_settings.TITLE

    @extend_schema(exclude=True)
    def get(self, request, *args, **kwargs):
        return Response(
            data={
                'title': self.title,
                'swagger_ui_css': self._swagger_ui_resource('swagger-ui.css'),
                'swagger_ui_bundle': self._swagger_ui_resource('swagger-ui-bundle.js'),
                'swagger_ui_standalone': self._swagger_ui_resource('swagger-ui-standalone-preset.js'),
                'favicon_href': self._swagger_ui_favicon(),
                'schema_url': self._get_schema_url(request),
                'settings': self._dump(spectacular_settings.SWAGGER_UI_SETTINGS),
                'oauth2_config': self._dump(spectacular_settings.SWAGGER_UI_OAUTH2_CONFIG),
                'template_name_js': self.template_name_js,
                'csrf_header_name': self._get_csrf_header_name(),
                'schema_auth_names': self._dump(self._get_schema_auth_names()),
            },
            template_name=self.template_name,
        )

    def _dump(self, data):
        return data if isinstance(data, str) else json.dumps(data, indent=2)

    def _get_schema_url(self, request):
        schema_url = self.url or get_relative_url(reverse(self.url_name, request=request))
        return set_query_parameters(
            url=schema_url,
            lang=request.GET.get('lang'),
            version=request.GET.get('version')
        )

    def _get_csrf_header_name(self):
        csrf_header_name = settings.CSRF_HEADER_NAME
        if csrf_header_name.startswith('HTTP_'):
            csrf_header_name = csrf_header_name[5:]
        return csrf_header_name.replace('_', '-')

    def _get_schema_auth_names(self):
        from drf_spectacular.extensions import OpenApiAuthenticationExtension
        if spectacular_settings.SERVE_PUBLIC:
            return []
        auth_extensions = [
            OpenApiAuthenticationExtension.get_match(klass)
            for klass in self.authentication_classes
        ]
        return [auth.name for auth in auth_extensions if auth]

    @staticmethod
    def _swagger_ui_resource(filename):
        if spectacular_settings.SWAGGER_UI_DIST == 'SIDECAR':
            return _get_sidecar_url(f'swagger-ui-dist/{filename}')
        return f'{spectacular_settings.SWAGGER_UI_DIST}/{filename}'

    @staticmethod
    def _swagger_ui_favicon():
        if spectacular_settings.SWAGGER_UI_FAVICON_HREF == 'SIDECAR':
            return _get_sidecar_url('swagger-ui-dist/favicon-32x32.png')
        return spectacular_settings.SWAGGER_UI_FAVICON_HREF


class SpectacularSwaggerSplitView(SpectacularSwaggerView):
    """
    Alternate Swagger UI implementation that separates the html request from the
    javascript request to cater to web servers with stricter CSP policies.
    """
    url_self: Optional[str] = None

    @extend_schema(exclude=True)
    def get(self, request, *args, **kwargs):
        if request.GET.get('script') is not None:
            return Response(
                data={
                    'schema_url': self._get_schema_url(request),
                    'settings': self._dump(spectacular_settings.SWAGGER_UI_SETTINGS),
                    'oauth2_config': self._dump(spectacular_settings.SWAGGER_UI_OAUTH2_CONFIG),
                    'csrf_header_name': self._get_csrf_header_name(),
                    'schema_auth_names': self._dump(self._get_schema_auth_names()),
                },
                template_name=self.template_name_js,
                content_type='application/javascript',
            )
        else:
            script_url = self.url_self or request.get_full_path()
            return Response(
                data={
                    'title': self.title,
                    'swagger_ui_css': self._swagger_ui_resource('swagger-ui.css'),
                    'swagger_ui_bundle': self._swagger_ui_resource('swagger-ui-bundle.js'),
                    'swagger_ui_standalone': self._swagger_ui_resource('swagger-ui-standalone-preset.js'),
                    'favicon_href': self._swagger_ui_favicon(),
                    'script_url': set_query_parameters(
                        url=script_url,
                        lang=request.GET.get('lang'),
                        script=''  # signal to deliver init script
                    )
                },
                template_name=self.template_name,
            )


class SpectacularRedocView(APIView):
    renderer_classes = [TemplateHTMLRenderer]
    permission_classes = spectacular_settings.SERVE_PERMISSIONS
    authentication_classes = AUTHENTICATION_CLASSES
    url_name: str = 'schema'
    url: Optional[str] = None
    template_name: str = 'drf_spectacular/redoc.html'
    title: Optional[str] = spectacular_settings.TITLE

    @extend_schema(exclude=True)
    def get(self, request, *args, **kwargs):
        return Response(
            data={
                'title': self.title,
                'redoc_standalone': self._redoc_standalone(),
                'schema_url': self._get_schema_url(request),
                'settings': self._dump(spectacular_settings.REDOC_UI_SETTINGS),
            },
            template_name=self.template_name
        )

    def _dump(self, data):
        if not data:
            return None
        elif isinstance(data, str):
            return data
        else:
            return json.dumps(data, indent=2)

    @staticmethod
    def _redoc_standalone():
        if spectacular_settings.REDOC_DIST == 'SIDECAR':
            return _get_sidecar_url('redoc/bundles/redoc.standalone.js')
        return f'{spectacular_settings.REDOC_DIST}/bundles/redoc.standalone.js'

    def _get_schema_url(self, request):
        schema_url = self.url or get_relative_url(reverse(self.url_name, request=request))
        return set_query_parameters(
            url=schema_url,
            lang=request.GET.get('lang'),
            version=request.GET.get('version')
        )


class SpectacularSwaggerOauthRedirectView(RedirectView):
    """
    A view that serves the SwaggerUI oauth2-redirect.html file so that SwaggerUI can authenticate itself using Oauth2

    This view should be served as ``./oauth2-redirect.html`` relative to the SwaggerUI itself.
    If that is not possible, this views absolute url can also be set via the
    ``SPECTACULAR_SETTINGS.SWAGGER_UI_SETTINGS.oauth2RedirectUrl`` django settings.
    """
    def get_redirect_url(self, *args, **kwargs):
        return _get_sidecar_url("swagger-ui-dist/oauth2-redirect.html") + "?" + self.request.GET.urlencode()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\drf_spectacular\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\drf_yasg\views.py ---

import warnings
from functools import WRAPPER_ASSIGNMENTS, wraps

from django.utils.cache import add_never_cache_headers
from django.views.decorators.cache import cache_page
from django.views.decorators.vary import vary_on_headers
from rest_framework import exceptions
from rest_framework.response import Response
from rest_framework.settings import api_settings
from rest_framework.views import APIView

from .app_settings import swagger_settings
from .renderers import (
    OpenAPIRenderer, ReDocOldRenderer, ReDocRenderer, SwaggerJSONRenderer, SwaggerUIRenderer, SwaggerYAMLRenderer,
    _SpecRenderer
)

SPEC_RENDERERS = (SwaggerYAMLRenderer, SwaggerJSONRenderer, OpenAPIRenderer)
UI_RENDERERS = {
    'swagger': (SwaggerUIRenderer, ReDocRenderer),
    'redoc': (ReDocRenderer, SwaggerUIRenderer),
    'redoc-old': (ReDocOldRenderer, ReDocRenderer, SwaggerUIRenderer),
}


def deferred_never_cache(view_func):
    """
    Decorator that adds headers to a response so that it will
    never be cached.
    """

    @wraps(view_func, assigned=WRAPPER_ASSIGNMENTS)
    def _wrapped_view_func(request, *args, **kwargs):
        response = view_func(request, *args, **kwargs)

        # It is necessary to defer the add_never_cache_headers call because
        # cache_page also defers its cache update operation; if we do not defer
        # this, cache_page will give up because it will see and obey the "never
        # cache" headers
        def callback(response):
            add_never_cache_headers(response)
            return response

        response.add_post_render_callback(callback)
        return response

    return _wrapped_view_func


def get_schema_view(info=None, url=None, patterns=None, urlconf=None, public=False, validators=None,
                    generator_class=None, authentication_classes=None, permission_classes=None):
    """Create a SchemaView class with default renderers and generators.

    :param .Info info: information about the API; if omitted, defaults to :ref:`DEFAULT_INFO <default-swagger-settings>`
    :param str url: same as :class:`.OpenAPISchemaGenerator`
    :param patterns: same as :class:`.OpenAPISchemaGenerator`
    :param urlconf: same as :class:`.OpenAPISchemaGenerator`
    :param bool public: if False, includes only the endpoints that are accessible by the user viewing the schema
    :param list validators: a list of validator names to apply; the only allowed value is ``ssv``, for now
    :param type generator_class: schema generator class to use; should be a subclass of :class:`.OpenAPISchemaGenerator`
    :param list authentication_classes: authentication classes for the schema view itself
    :param list permission_classes: permission classes for the schema view itself
    :return: SchemaView class
    :rtype: type[drf_yasg.views.SchemaView]
    """
    _public = public
    _generator_class = generator_class or swagger_settings.DEFAULT_GENERATOR_CLASS
    _auth_classes = authentication_classes
    if _auth_classes is None:
        _auth_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES
    _perm_classes = permission_classes
    if _perm_classes is None:
        _perm_classes = api_settings.DEFAULT_PERMISSION_CLASSES
    info = info or swagger_settings.DEFAULT_INFO
    validators = validators or []
    _spec_renderers = tuple(renderer.with_validators(validators) for renderer in SPEC_RENDERERS)

    class SchemaView(APIView):
        _ignore_model_permissions = True
        schema = None  # exclude from schema
        public = _public
        generator_class = _generator_class
        authentication_classes = _auth_classes
        permission_classes = _perm_classes
        renderer_classes = _spec_renderers

        def get(self, request, version='', format=None):
            version = request.version or version or ''
            if isinstance(request.accepted_renderer, _SpecRenderer):
                generator = self.generator_class(info, version, url, patterns, urlconf)
            else:
                generator = self.generator_class(info, version, url, patterns=[])

            schema = generator.get_schema(request, self.public)
            if schema is None:
                raise exceptions.PermissionDenied()  # pragma: no cover
            return Response(schema)

        @classmethod
        def apply_cache(cls, view, cache_timeout, cache_kwargs):
            """Override this method to customize how caching is applied to the view.

            Arguments described in :meth:`.as_cached_view`.
            """
            view = vary_on_headers('Cookie', 'Authorization')(view)
            view = cache_page(cache_timeout, **cache_kwargs)(view)
            view = deferred_never_cache(view)  # disable in-browser caching
            return view

        @classmethod
        def as_cached_view(cls, cache_timeout=0, cache_kwargs=None, **initkwargs):
            """
            Calls .as_view() and wraps the result in a cache_page decorator.
            See https://docs.djangoproject.com/en/dev/topics/cache/

            :param int cache_timeout: same as cache_page; set to 0 for no cache
            :param dict cache_kwargs: dictionary of kwargs to be passed to cache_page
            :param initkwargs: kwargs for .as_view()
            :return: a view instance
            """
            cache_kwargs = cache_kwargs or {}
            view = cls.as_view(**initkwargs)
            if cache_timeout != 0:
                view = cls.apply_cache(view, cache_timeout, cache_kwargs)
            elif cache_kwargs:
                warnings.warn("cache_kwargs ignored because cache_timeout is 0 (disabled)")
            return view

        @classmethod
        def without_ui(cls, cache_timeout=0, cache_kwargs=None):
            """
            Instantiate this view with just JSON and YAML renderers, optionally wrapped with cache_page.
            See https://docs.djangoproject.com/en/dev/topics/cache/.

            :param int cache_timeout: same as cache_page; set to 0 for no cache
            :param dict cache_kwargs: dictionary of kwargs to be passed to cache_page
            :return: a view instance
            """
            return cls.as_cached_view(cache_timeout, cache_kwargs, renderer_classes=_spec_renderers)

        @classmethod
        def with_ui(cls, renderer='swagger', cache_timeout=0, cache_kwargs=None):
            """
            Instantiate this view with a Web UI renderer, optionally wrapped with cache_page.
            See https://docs.djangoproject.com/en/dev/topics/cache/.

            :param str renderer: UI renderer; allowed values are ``swagger``, ``redoc``
            :param int cache_timeout: same as cache_page; set to 0 for no cache
            :param dict cache_kwargs: dictionary of kwargs to be passed to cache_page
            :return: a view instance
            """
            assert renderer in UI_RENDERERS, "supported default renderers are " + ", ".join(UI_RENDERERS)
            renderer_classes = UI_RENDERERS[renderer] + _spec_renderers

            return cls.as_cached_view(cache_timeout, cache_kwargs, renderer_classes=renderer_classes)

    return SchemaView

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\drf_yasg\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\flask\views.py ---

import typing as t

from . import typing as ft
from .globals import current_app
from .globals import request


http_method_funcs = frozenset(
    ["get", "post", "head", "options", "delete", "put", "trace", "patch"]
)


class View:
    """Subclass this class and override :meth:`dispatch_request` to
    create a generic class-based view. Call :meth:`as_view` to create a
    view function that creates an instance of the class with the given
    arguments and calls its ``dispatch_request`` method with any URL
    variables.

    See :doc:`views` for a detailed guide.

    .. code-block:: python

        class Hello(View):
            init_every_request = False

            def dispatch_request(self, name):
                return f"Hello, {name}!"

        app.add_url_rule(
            "/hello/<name>", view_func=Hello.as_view("hello")
        )

    Set :attr:`methods` on the class to change what methods the view
    accepts.

    Set :attr:`decorators` on the class to apply a list of decorators to
    the generated view function. Decorators applied to the class itself
    will not be applied to the generated view function!

    Set :attr:`init_every_request` to ``False`` for efficiency, unless
    you need to store request-global data on ``self``.
    """

    #: The methods this view is registered for. Uses the same default
    #: (``["GET", "HEAD", "OPTIONS"]``) as ``route`` and
    #: ``add_url_rule`` by default.
    methods: t.ClassVar[t.Optional[t.Collection[str]]] = None

    #: Control whether the ``OPTIONS`` method is handled automatically.
    #: Uses the same default (``True``) as ``route`` and
    #: ``add_url_rule`` by default.
    provide_automatic_options: t.ClassVar[t.Optional[bool]] = None

    #: A list of decorators to apply, in order, to the generated view
    #: function. Remember that ``@decorator`` syntax is applied bottom
    #: to top, so the first decorator in the list would be the bottom
    #: decorator.
    #:
    #: .. versionadded:: 0.8
    decorators: t.ClassVar[t.List[t.Callable]] = []

    #: Create a new instance of this view class for every request by
    #: default. If a view subclass sets this to ``False``, the same
    #: instance is used for every request.
    #:
    #: A single instance is more efficient, especially if complex setup
    #: is done during init. However, storing data on ``self`` is no
    #: longer safe across requests, and :data:`~flask.g` should be used
    #: instead.
    #:
    #: .. versionadded:: 2.2
    init_every_request: t.ClassVar[bool] = True

    def dispatch_request(self) -> ft.ResponseReturnValue:
        """The actual view function behavior. Subclasses must override
        this and return a valid response. Any variables from the URL
        rule are passed as keyword arguments.
        """
        raise NotImplementedError()

    @classmethod
    def as_view(
        cls, name: str, *class_args: t.Any, **class_kwargs: t.Any
    ) -> ft.RouteCallable:
        """Convert the class into a view function that can be registered
        for a route.

        By default, the generated view will create a new instance of the
        view class for every request and call its
        :meth:`dispatch_request` method. If the view class sets
        :attr:`init_every_request` to ``False``, the same instance will
        be used for every request.

        Except for ``name``, all other arguments passed to this method
        are forwarded to the view class ``__init__`` method.

        .. versionchanged:: 2.2
            Added the ``init_every_request`` class attribute.
        """
        if cls.init_every_request:

            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:
                self = view.view_class(  # type: ignore[attr-defined]
                    *class_args, **class_kwargs
                )
                return current_app.ensure_sync(self.dispatch_request)(**kwargs)

        else:
            self = cls(*class_args, **class_kwargs)

            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:
                return current_app.ensure_sync(self.dispatch_request)(**kwargs)

        if cls.decorators:
            view.__name__ = name
            view.__module__ = cls.__module__
            for decorator in cls.decorators:
                view = decorator(view)

        # We attach the view class to the view function for two reasons:
        # first of all it allows us to easily figure out what class-based
        # view this thing came from, secondly it's also used for instantiating
        # the view class so you can actually replace it with something else
        # for testing purposes and debugging.
        view.view_class = cls  # type: ignore
        view.__name__ = name
        view.__doc__ = cls.__doc__
        view.__module__ = cls.__module__
        view.methods = cls.methods  # type: ignore
        view.provide_automatic_options = cls.provide_automatic_options  # type: ignore
        return view


class MethodView(View):
    """Dispatches request methods to the corresponding instance methods.
    For example, if you implement a ``get`` method, it will be used to
    handle ``GET`` requests.

    This can be useful for defining a REST API.

    :attr:`methods` is automatically set based on the methods defined on
    the class.

    See :doc:`views` for a detailed guide.

    .. code-block:: python

        class CounterAPI(MethodView):
            def get(self):
                return str(session.get("counter", 0))

            def post(self):
                session["counter"] = session.get("counter", 0) + 1
                return redirect(url_for("counter"))

        app.add_url_rule(
            "/counter", view_func=CounterAPI.as_view("counter")
        )
    """

    def __init_subclass__(cls, **kwargs: t.Any) -> None:
        super().__init_subclass__(**kwargs)

        if "methods" not in cls.__dict__:
            methods = set()

            for base in cls.__bases__:
                if getattr(base, "methods", None):
                    methods.update(base.methods)  # type: ignore[attr-defined]

            for key in http_method_funcs:
                if hasattr(cls, key):
                    methods.add(key.upper())

            if methods:
                cls.methods = methods

    def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:
        meth = getattr(self, request.method.lower(), None)

        # If the request method is HEAD and we don't have a handler for it
        # retry with GET.
        if meth is None and request.method == "HEAD":
            meth = getattr(self, "get", None)

        assert meth is not None, f"Unimplemented method {request.method!r}"
        return current_app.ensure_sync(meth)(**kwargs)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\flask\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\fontTools\varLib\models.py ---

"""Variation fonts interpolation models."""

__all__ = [
    "normalizeValue",
    "normalizeLocation",
    "supportScalar",
    "piecewiseLinearMap",
    "VariationModel",
]

from fontTools.misc.roundTools import noRound
from .errors import VariationModelError


def nonNone(lst):
    return [l for l in lst if l is not None]


def allNone(lst):
    return all(l is None for l in lst)


def allEqualTo(ref, lst, mapper=None):
    if mapper is None:
        return all(ref == item for item in lst)

    mapped = mapper(ref)
    return all(mapped == mapper(item) for item in lst)


def allEqual(lst, mapper=None):
    if not lst:
        return True
    it = iter(lst)
    try:
        first = next(it)
    except StopIteration:
        return True
    return allEqualTo(first, it, mapper=mapper)


def subList(truth, lst):
    assert len(truth) == len(lst)
    return [l for l, t in zip(lst, truth) if t]


def normalizeValue(v, triple, extrapolate=False):
    """Normalizes value based on a min/default/max triple.

    >>> normalizeValue(400, (100, 400, 900))
    0.0
    >>> normalizeValue(100, (100, 400, 900))
    -1.0
    >>> normalizeValue(650, (100, 400, 900))
    0.5
    """
    lower, default, upper = triple
    if not (lower <= default <= upper):
        raise ValueError(
            f"Invalid axis values, must be minimum, default, maximum: "
            f"{lower:3.3f}, {default:3.3f}, {upper:3.3f}"
        )
    if not extrapolate:
        v = max(min(v, upper), lower)

    if v == default or lower == upper:
        return 0.0

    if (v < default and lower != default) or (v > default and upper == default):
        return (v - default) / (default - lower)
    else:
        assert (v > default and upper != default) or (
            v < default and lower == default
        ), f"Ooops... v={v}, triple=({lower}, {default}, {upper})"
        return (v - default) / (upper - default)


def normalizeLocation(location, axes, extrapolate=False, *, validate=False):
    """Normalizes location based on axis min/default/max values from axes.

    >>> axes = {"wght": (100, 400, 900)}
    >>> normalizeLocation({"wght": 400}, axes)
    {'wght': 0.0}
    >>> normalizeLocation({"wght": 100}, axes)
    {'wght': -1.0}
    >>> normalizeLocation({"wght": 900}, axes)
    {'wght': 1.0}
    >>> normalizeLocation({"wght": 650}, axes)
    {'wght': 0.5}
    >>> normalizeLocation({"wght": 1000}, axes)
    {'wght': 1.0}
    >>> normalizeLocation({"wght": 0}, axes)
    {'wght': -1.0}
    >>> axes = {"wght": (0, 0, 1000)}
    >>> normalizeLocation({"wght": 0}, axes)
    {'wght': 0.0}
    >>> normalizeLocation({"wght": -1}, axes)
    {'wght': 0.0}
    >>> normalizeLocation({"wght": 1000}, axes)
    {'wght': 1.0}
    >>> normalizeLocation({"wght": 500}, axes)
    {'wght': 0.5}
    >>> normalizeLocation({"wght": 1001}, axes)
    {'wght': 1.0}
    >>> axes = {"wght": (0, 1000, 1000)}
    >>> normalizeLocation({"wght": 0}, axes)
    {'wght': -1.0}
    >>> normalizeLocation({"wght": -1}, axes)
    {'wght': -1.0}
    >>> normalizeLocation({"wght": 500}, axes)
    {'wght': -0.5}
    >>> normalizeLocation({"wght": 1000}, axes)
    {'wght': 0.0}
    >>> normalizeLocation({"wght": 1001}, axes)
    {'wght': 0.0}
    """
    if validate:
        assert set(location.keys()) <= set(axes.keys()), set(location.keys()) - set(
            axes.keys()
        )
    out = {}
    for tag, triple in axes.items():
        v = location.get(tag, triple[1])
        out[tag] = normalizeValue(v, triple, extrapolate=extrapolate)
    return out


def supportScalar(location, support, ot=True, extrapolate=False, axisRanges=None):
    """Returns the scalar multiplier at location, for a master
    with support.  If ot is True, then a peak value of zero
    for support of an axis means "axis does not participate".  That
    is how OpenType Variation Font technology works.

    If extrapolate is True, axisRanges must be a dict that maps axis
    names to (axisMin, axisMax) tuples.

      >>> supportScalar({}, {})
      1.0
      >>> supportScalar({'wght':.2}, {})
      1.0
      >>> supportScalar({'wght':.2}, {'wght':(0,2,3)})
      0.1
      >>> supportScalar({'wght':2.5}, {'wght':(0,2,4)})
      0.75
      >>> supportScalar({'wght':2.5, 'wdth':0}, {'wght':(0,2,4), 'wdth':(-1,0,+1)})
      0.75
      >>> supportScalar({'wght':2.5, 'wdth':.5}, {'wght':(0,2,4), 'wdth':(-1,0,+1)}, ot=False)
      0.375
      >>> supportScalar({'wght':2.5, 'wdth':0}, {'wght':(0,2,4), 'wdth':(-1,0,+1)})
      0.75
      >>> supportScalar({'wght':2.5, 'wdth':.5}, {'wght':(0,2,4), 'wdth':(-1,0,+1)})
      0.75
      >>> supportScalar({'wght':3}, {'wght':(0,1,2)}, extrapolate=True, axisRanges={'wght':(0, 2)})
      -1.0
      >>> supportScalar({'wght':-1}, {'wght':(0,1,2)}, extrapolate=True, axisRanges={'wght':(0, 2)})
      -1.0
      >>> supportScalar({'wght':3}, {'wght':(0,2,2)}, extrapolate=True, axisRanges={'wght':(0, 2)})
      1.5
      >>> supportScalar({'wght':-1}, {'wght':(0,2,2)}, extrapolate=True, axisRanges={'wght':(0, 2)})
      -0.5
    """
    if extrapolate and axisRanges is None:
        raise TypeError("axisRanges must be passed when extrapolate is True")
    scalar = 1.0
    for axis, (lower, peak, upper) in support.items():
        if ot:
            # OpenType-specific case handling
            if peak == 0.0:
                continue
            if lower > peak or peak > upper:
                continue
            if lower < 0.0 and upper > 0.0:
                continue
            v = location.get(axis, 0.0)
        else:
            assert axis in location
            v = location[axis]
        if v == peak:
            continue

        if extrapolate:
            axisMin, axisMax = axisRanges[axis]
            if v < axisMin and lower <= axisMin:
                if peak <= axisMin and peak < upper:
                    scalar *= (v - upper) / (peak - upper)
                    continue
                elif axisMin < peak:
                    scalar *= (v - lower) / (peak - lower)
                    continue
            elif axisMax < v and axisMax <= upper:
                if axisMax <= peak and lower < peak:
                    scalar *= (v - lower) / (peak - lower)
                    continue
                elif peak < axisMax:
                    scalar *= (v - upper) / (peak - upper)
                    continue

        if v <= lower or upper <= v:
            scalar = 0.0
            break

        if v < peak:
            scalar *= (v - lower) / (peak - lower)
        else:  # v > peak
            scalar *= (v - upper) / (peak - upper)
    return scalar


class VariationModel(object):
    """Locations must have the base master at the origin (ie. 0).

    If axis-ranges are not provided, values are assumed to be normalized to
    the range [-1, 1].

    If the extrapolate argument is set to True, then values are extrapolated
    outside the axis range.

      >>> from pprint import pprint
      >>> axisRanges = {'wght': (-180, +180), 'wdth': (-1, +1)}
      >>> locations = [ \
      {'wght':100}, \
      {'wght':-100}, \
      {'wght':-180}, \
      {'wdth':+.3}, \
      {'wght':+120,'wdth':.3}, \
      {'wght':+120,'wdth':.2}, \
      {}, \
      {'wght':+180,'wdth':.3}, \
      {'wght':+180}, \
      ]
      >>> model = VariationModel(locations, axisOrder=['wght'], axisRanges=axisRanges)
      >>> pprint(model.locations)
      [{},
       {'wght': -100},
       {'wght': -180},
       {'wght': 100},
       {'wght': 180},
       {'wdth': 0.3},
       {'wdth': 0.3, 'wght': 180},
       {'wdth': 0.3, 'wght': 120},
       {'wdth': 0.2, 'wght': 120}]
      >>> pprint(model.deltaWeights)
      [{},
       {0: 1.0},
       {0: 1.0},
       {0: 1.0},
       {0: 1.0},
       {0: 1.0},
       {0: 1.0, 4: 1.0, 5: 1.0},
       {0: 1.0, 3: 0.75, 4: 0.25, 5: 1.0, 6: 0.6666666666666666},
       {0: 1.0,
        3: 0.75,
        4: 0.25,
        5: 0.6666666666666667,
        6: 0.4444444444444445,
        7: 0.6666666666666667}]
    """

    def __init__(
        self, locations, axisOrder=None, extrapolate=False, *, axisRanges=None
    ):
        if len(set(tuple(sorted(l.items())) for l in locations)) != len(locations):
            raise VariationModelError("Locations must be unique.")

        self.origLocations = locations
        self.axisOrder = axisOrder if axisOrder is not None else []
        self.extrapolate = extrapolate
        if axisRanges is None:
            if extrapolate:
                axisRanges = self.computeAxisRanges(locations)
            else:
                allAxes = {axis for loc in locations for axis in loc.keys()}
                axisRanges = {axis: (-1, 1) for axis in allAxes}
        self.axisRanges = axisRanges

        locations = [{k: v for k, v in loc.items() if v != 0.0} for loc in locations]
        keyFunc = self.getMasterLocationsSortKeyFunc(
            locations, axisOrder=self.axisOrder
        )
        self.locations = sorted(locations, key=keyFunc)

        # Mapping from user's master order to our master order
        self.mapping = [self.locations.index(l) for l in locations]
        self.reverseMapping = [locations.index(l) for l in self.locations]

        self._computeMasterSupports()
        self._subModels = {}

    def getSubModel(self, items):
        """Return a sub-model and the items that are not None.

        The sub-model is necessary for working with the subset
        of items when some are None.

        The sub-model is cached."""
        if None not in items:
            return self, items
        key = tuple(v is not None for v in items)
        subModel = self._subModels.get(key)
        if subModel is None:
            subModel = VariationModel(subList(key, self.origLocations), self.axisOrder)
            self._subModels[key] = subModel
        return subModel, subList(key, items)

    @staticmethod
    def computeAxisRanges(locations):
        axisRanges = {}
        allAxes = {axis for loc in locations for axis in loc.keys()}
        for loc in locations:
            for axis in allAxes:
                value = loc.get(axis, 0)
                axisMin, axisMax = axisRanges.get(axis, (value, value))
                axisRanges[axis] = min(value, axisMin), max(value, axisMax)
        return axisRanges

    @staticmethod
    def getMasterLocationsSortKeyFunc(locations, axisOrder=[]):
        if {} not in locations:
            raise VariationModelError("Base master not found.")
        axisPoints = {}
        for loc in locations:
            if len(loc) != 1:
                continue
            axis = next(iter(loc))
            value = loc[axis]
            if axis not in axisPoints:
                axisPoints[axis] = {0.0}
            assert (
                value not in axisPoints[axis]
            ), 'Value "%s" in axisPoints["%s"] -->  %s' % (value, axis, axisPoints)
            axisPoints[axis].add(value)

        def getKey(axisPoints, axisOrder):
            def sign(v):
                return -1 if v < 0 else +1 if v > 0 else 0

            def key(loc):
                rank = len(loc)
                onPointAxes = [
                    axis
                    for axis, value in loc.items()
                    if axis in axisPoints and value in axisPoints[axis]
                ]
                orderedAxes = [axis for axis in axisOrder if axis in loc]
                orderedAxes.extend(
                    [axis for axis in sorted(loc.keys()) if axis not in axisOrder]
                )
                return (
                    rank,  # First, order by increasing rank
                    -len(onPointAxes),  # Next, by decreasing number of onPoint axes
                    tuple(
                        axisOrder.index(axis) if axis in axisOrder else 0x10000
                        for axis in orderedAxes
                    ),  # Next, by known axes
                    tuple(orderedAxes),  # Next, by all axes
                    tuple(
                        sign(loc[axis]) for axis in orderedAxes
                    ),  # Next, by signs of axis values
                    tuple(
                        abs(loc[axis]) for axis in orderedAxes
                    ),  # Next, by absolute value of axis values
                )

            return key

        ret = getKey(axisPoints, axisOrder)
        return ret

    def reorderMasters(self, master_list, mapping):
        # For changing the master data order without
        # recomputing supports and deltaWeights.
        new_list = [master_list[idx] for idx in mapping]
        self.origLocations = [self.origLocations[idx] for idx in mapping]
        locations = [
            {k: v for k, v in loc.items() if v != 0.0} for loc in self.origLocations
        ]
        self.mapping = [self.locations.index(l) for l in locations]
        self.reverseMapping = [locations.index(l) for l in self.locations]
        self._subModels = {}
        return new_list

    def _computeMasterSupports(self):
        self.supports = []
        regions = self._locationsToRegions()
        for i, region in enumerate(regions):
            locAxes = set(region.keys())
            # Walk over previous masters now
            for prev_region in regions[:i]:
                # Master with different axes do not participte
                if set(prev_region.keys()) != locAxes:
                    continue
                # If it's NOT in the current box, it does not participate
                relevant = True
                for axis, (lower, peak, upper) in region.items():
                    if not (
                        prev_region[axis][1] == peak
                        or lower < prev_region[axis][1] < upper
                    ):
                        relevant = False
                        break
                if not relevant:
                    continue

                # Split the box for new master; split in whatever direction
                # that has largest range ratio.
                #
                # For symmetry, we actually cut across multiple axes
                # if they have the largest, equal, ratio.
                # https://github.com/fonttools/fonttools/commit/7ee81c8821671157968b097f3e55309a1faa511e#commitcomment-31054804

                bestAxes = {}
                bestRatio = -1
                for axis in prev_region.keys():
                    val = prev_region[axis][1]
                    assert axis in region
                    lower, locV, upper = region[axis]
                    newLower, newUpper = lower, upper
                    if val < locV:
                        newLower = val
                        ratio = (val - locV) / (lower - locV)
                    elif locV < val:
                        newUpper = val
                        ratio = (val - locV) / (upper - locV)
                    else:  # val == locV
                        # Can't split box in this direction.
                        continue
                    if ratio > bestRatio:
                        bestAxes = {}
                        bestRatio = ratio
                    if ratio == bestRatio:
                        bestAxes[axis] = (newLower, locV, newUpper)

                for axis, triple in bestAxes.items():
                    region[axis] = triple
            self.supports.append(region)
        self._computeDeltaWeights()

    def _locationsToRegions(self):
        locations = self.locations
        axisRanges = self.axisRanges

        regions = []
        for loc in locations:
            region = {}
            for axis, locV in loc.items():
                if locV > 0:
                    region[axis] = (0, locV, axisRanges[axis][1])
                else:
                    region[axis] = (axisRanges[axis][0], locV, 0)
            regions.append(region)
        return regions

    def _computeDeltaWeights(self):
        self.deltaWeights = []
        for i, loc in enumerate(self.locations):
            deltaWeight = {}
            # Walk over previous masters now, populate deltaWeight
            for j, support in enumerate(self.supports[:i]):
                scalar = supportScalar(loc, support)
                if scalar:
                    deltaWeight[j] = scalar
            self.deltaWeights.append(deltaWeight)

    def getDeltas(self, masterValues, *, round=noRound):
        assert len(masterValues) == len(self.deltaWeights), (
            len(masterValues),
            len(self.deltaWeights),
        )
        mapping = self.reverseMapping
        out = []
        for i, weights in enumerate(self.deltaWeights):
            delta = masterValues[mapping[i]]
            for j, weight in weights.items():
                if weight == 1:
                    delta -= out[j]
                else:
                    delta -= out[j] * weight
            out.append(round(delta))
        return out

    def getDeltasAndSupports(self, items, *, round=noRound):
        model, items = self.getSubModel(items)
        return model.getDeltas(items, round=round), model.supports

    def getScalars(self, loc):
        """Return scalars for each delta, for the given location.
        If interpolating many master-values at the same location,
        this function allows speed up by fetching the scalars once
        and using them with interpolateFromMastersAndScalars()."""
        return [
            supportScalar(
                loc, support, extrapolate=self.extrapolate, axisRanges=self.axisRanges
            )
            for support in self.supports
        ]

    def getMasterScalars(self, targetLocation):
        """Return multipliers for each master, for the given location.
        If interpolating many master-values at the same location,
        this function allows speed up by fetching the scalars once
        and using them with interpolateFromValuesAndScalars().

        Note that the scalars used in interpolateFromMastersAndScalars(),
        are *not* the same as the ones returned here. They are the result
        of getScalars()."""
        out = self.getScalars(targetLocation)
        for i, weights in reversed(list(enumerate(self.deltaWeights))):
            for j, weight in weights.items():
                out[j] -= out[i] * weight

        out = [out[self.mapping[i]] for i in range(len(out))]
        return out

    @staticmethod
    def interpolateFromValuesAndScalars(values, scalars):
        """Interpolate from values and scalars coefficients.

        If the values are master-values, then the scalars should be
        fetched from getMasterScalars().

        If the values are deltas, then the scalars should be fetched
        from getScalars(); in which case this is the same as
        interpolateFromDeltasAndScalars().
        """
        v = None
        assert len(values) == len(scalars)
        for value, scalar in zip(values, scalars):
            if not scalar:
                continue
            contribution = value * scalar
            if v is None:
                v = contribution
            else:
                v += contribution
        return v

    @staticmethod
    def interpolateFromDeltasAndScalars(deltas, scalars):
        """Interpolate from deltas and scalars fetched from getScalars()."""
        return VariationModel.interpolateFromValuesAndScalars(deltas, scalars)

    def interpolateFromDeltas(self, loc, deltas):
        """Interpolate from deltas, at location loc."""
        scalars = self.getScalars(loc)
        return self.interpolateFromDeltasAndScalars(deltas, scalars)

    def interpolateFromMasters(self, loc, masterValues, *, round=noRound):
        """Interpolate from master-values, at location loc."""
        scalars = self.getMasterScalars(loc)
        return self.interpolateFromValuesAndScalars(masterValues, scalars)

    def interpolateFromMastersAndScalars(self, masterValues, scalars, *, round=noRound):
        """Interpolate from master-values, and scalars fetched from
        getScalars(), which is useful when you want to interpolate
        multiple master-values with the same location."""
        deltas = self.getDeltas(masterValues, round=round)
        return self.interpolateFromDeltasAndScalars(deltas, scalars)


def piecewiseLinearMap(v, mapping):
    keys = mapping.keys()
    if not keys:
        return v
    if v in keys:
        return mapping[v]
    k = min(keys)
    if v < k:
        return v + mapping[k] - k
    k = max(keys)
    if v > k:
        return v + mapping[k] - k
    # Interpolate
    a = max(k for k in keys if k < v)
    b = min(k for k in keys if k > v)
    va = mapping[a]
    vb = mapping[b]
    return va + (vb - va) * (v - a) / (b - a)


def main(args=None):
    """Normalize locations on a given designspace"""
    from fontTools import configLogger
    import argparse

    parser = argparse.ArgumentParser(
        "fonttools varLib.models",
        description=main.__doc__,
    )
    parser.add_argument(
        "--loglevel",
        metavar="LEVEL",
        default="INFO",
        help="Logging level (defaults to INFO)",
    )

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-d", "--designspace", metavar="DESIGNSPACE", type=str)
    group.add_argument(
        "-l",
        "--locations",
        metavar="LOCATION",
        nargs="+",
        help="Master locations as comma-separate coordinates. One must be all zeros.",
    )

    args = parser.parse_args(args)

    configLogger(level=args.loglevel)
    from pprint import pprint

    if args.designspace:
        from fontTools.designspaceLib import DesignSpaceDocument

        doc = DesignSpaceDocument()
        doc.read(args.designspace)
        locs = [s.location for s in doc.sources]
        print("Original locations:")
        pprint(locs)
        doc.normalize()
        print("Normalized locations:")
        locs = [s.location for s in doc.sources]
        pprint(locs)
    else:
        axes = [chr(c) for c in range(ord("A"), ord("Z") + 1)]
        locs = [
            dict(zip(axes, (float(v) for v in s.split(",")))) for s in args.locations
        ]

    model = VariationModel(locs)
    print("Sorted locations:")
    pprint(model.locations)
    print("Supports:")
    pprint(model.supports)


if __name__ == "__main__":
    import doctest, sys

    if len(sys.argv) > 1:
        sys.exit(main())

    sys.exit(doctest.testmod().failed)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\fontTools\varLib\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\gunicorn\http\wsgi.py ---

# -*- coding: utf-8 -
#
# This file is part of gunicorn released under the MIT license.
# See the NOTICE for more information.

import io
import logging
import os
import re
import sys

from gunicorn.http.message import HEADER_RE
from gunicorn.http.errors import InvalidHeader, InvalidHeaderName
from gunicorn import SERVER_SOFTWARE, SERVER
from gunicorn import util

# Send files in at most 1GB blocks as some operating systems can have problems
# with sending files in blocks over 2GB.
BLKSIZE = 0x3FFFFFFF

HEADER_VALUE_RE = re.compile(r'[\x00-\x1F\x7F]')

log = logging.getLogger(__name__)


class FileWrapper(object):

    def __init__(self, filelike, blksize=8192):
        self.filelike = filelike
        self.blksize = blksize
        if hasattr(filelike, 'close'):
            self.close = filelike.close

    def __getitem__(self, key):
        data = self.filelike.read(self.blksize)
        if data:
            return data
        raise IndexError


class WSGIErrorsWrapper(io.RawIOBase):

    def __init__(self, cfg):
        # There is no public __init__ method for RawIOBase so
        # we don't need to call super() in the __init__ method.
        # pylint: disable=super-init-not-called
        errorlog = logging.getLogger("gunicorn.error")
        handlers = errorlog.handlers
        self.streams = []

        if cfg.errorlog == "-":
            self.streams.append(sys.stderr)
            handlers = handlers[1:]

        for h in handlers:
            if hasattr(h, "stream"):
                self.streams.append(h.stream)

    def write(self, data):
        for stream in self.streams:
            try:
                stream.write(data)
            except UnicodeError:
                stream.write(data.encode("UTF-8"))
            stream.flush()


def base_environ(cfg):
    return {
        "wsgi.errors": WSGIErrorsWrapper(cfg),
        "wsgi.version": (1, 0),
        "wsgi.multithread": False,
        "wsgi.multiprocess": (cfg.workers > 1),
        "wsgi.run_once": False,
        "wsgi.file_wrapper": FileWrapper,
        "wsgi.input_terminated": True,
        "SERVER_SOFTWARE": SERVER_SOFTWARE,
    }


def default_environ(req, sock, cfg):
    env = base_environ(cfg)
    env.update({
        "wsgi.input": req.body,
        "gunicorn.socket": sock,
        "REQUEST_METHOD": req.method,
        "QUERY_STRING": req.query,
        "RAW_URI": req.uri,
        "SERVER_PROTOCOL": "HTTP/%s" % ".".join([str(v) for v in req.version])
    })
    return env


def proxy_environ(req):
    info = req.proxy_protocol_info

    if not info:
        return {}

    return {
        "PROXY_PROTOCOL": info["proxy_protocol"],
        "REMOTE_ADDR": info["client_addr"],
        "REMOTE_PORT": str(info["client_port"]),
        "PROXY_ADDR": info["proxy_addr"],
        "PROXY_PORT": str(info["proxy_port"]),
    }


def create(req, sock, client, server, cfg):
    resp = Response(req, sock, cfg)

    # set initial environ
    environ = default_environ(req, sock, cfg)

    # default variables
    host = None
    script_name = os.environ.get("SCRIPT_NAME", "")

    # add the headers to the environ
    for hdr_name, hdr_value in req.headers:
        if hdr_name == "EXPECT":
            # handle expect
            if hdr_value.lower() == "100-continue":
                sock.send(b"HTTP/1.1 100 Continue\r\n\r\n")
        elif hdr_name == 'HOST':
            host = hdr_value
        elif hdr_name == "SCRIPT_NAME":
            script_name = hdr_value
        elif hdr_name == "CONTENT-TYPE":
            environ['CONTENT_TYPE'] = hdr_value
            continue
        elif hdr_name == "CONTENT-LENGTH":
            environ['CONTENT_LENGTH'] = hdr_value
            continue

        key = 'HTTP_' + hdr_name.replace('-', '_')
        if key in environ:
            hdr_value = "%s,%s" % (environ[key], hdr_value)
        environ[key] = hdr_value

    # set the url scheme
    environ['wsgi.url_scheme'] = req.scheme

    # set the REMOTE_* keys in environ
    # authors should be aware that REMOTE_HOST and REMOTE_ADDR
    # may not qualify the remote addr:
    # http://www.ietf.org/rfc/rfc3875
    if isinstance(client, str):
        environ['REMOTE_ADDR'] = client
    elif isinstance(client, bytes):
        environ['REMOTE_ADDR'] = client.decode()
    else:
        environ['REMOTE_ADDR'] = client[0]
        environ['REMOTE_PORT'] = str(client[1])

    # handle the SERVER_*
    # Normally only the application should use the Host header but since the
    # WSGI spec doesn't support unix sockets, we are using it to create
    # viable SERVER_* if possible.
    if isinstance(server, str):
        server = server.split(":")
        if len(server) == 1:
            # unix socket
            if host:
                server = host.split(':')
                if len(server) == 1:
                    if req.scheme == "http":
                        server.append(80)
                    elif req.scheme == "https":
                        server.append(443)
                    else:
                        server.append('')
            else:
                # no host header given which means that we are not behind a
                # proxy, so append an empty port.
                server.append('')
    environ['SERVER_NAME'] = server[0]
    environ['SERVER_PORT'] = str(server[1])

    # set the path and script name
    path_info = req.path
    if script_name:
        path_info = path_info.split(script_name, 1)[1]
    environ['PATH_INFO'] = util.unquote_to_wsgi_str(path_info)
    environ['SCRIPT_NAME'] = script_name

    # override the environ with the correct remote and server address if
    # we are behind a proxy using the proxy protocol.
    environ.update(proxy_environ(req))
    return resp, environ


class Response(object):

    def __init__(self, req, sock, cfg):
        self.req = req
        self.sock = sock
        self.version = SERVER
        self.status = None
        self.chunked = False
        self.must_close = False
        self.headers = []
        self.headers_sent = False
        self.response_length = None
        self.sent = 0
        self.upgrade = False
        self.cfg = cfg

    def force_close(self):
        self.must_close = True

    def should_close(self):
        if self.must_close or self.req.should_close():
            return True
        if self.response_length is not None or self.chunked:
            return False
        if self.req.method == 'HEAD':
            return False
        if self.status_code < 200 or self.status_code in (204, 304):
            return False
        return True

    def start_response(self, status, headers, exc_info=None):
        if exc_info:
            try:
                if self.status and self.headers_sent:
                    util.reraise(exc_info[0], exc_info[1], exc_info[2])
            finally:
                exc_info = None
        elif self.status is not None:
            raise AssertionError("Response headers already set!")

        self.status = status

        # get the status code from the response here so we can use it to check
        # the need for the connection header later without parsing the string
        # each time.
        try:
            self.status_code = int(self.status.split()[0])
        except ValueError:
            self.status_code = None

        self.process_headers(headers)
        self.chunked = self.is_chunked()
        return self.write

    def process_headers(self, headers):
        for name, value in headers:
            if not isinstance(name, str):
                raise TypeError('%r is not a string' % name)

            if HEADER_RE.search(name):
                raise InvalidHeaderName('%r' % name)

            if not isinstance(value, str):
                raise TypeError('%r is not a string' % value)

            if HEADER_VALUE_RE.search(value):
                raise InvalidHeader('%r' % value)

            value = value.strip()
            lname = name.lower().strip()
            if lname == "content-length":
                self.response_length = int(value)
            elif util.is_hoppish(name):
                if lname == "connection":
                    # handle websocket
                    if value.lower().strip() == "upgrade":
                        self.upgrade = True
                elif lname == "upgrade":
                    if value.lower().strip() == "websocket":
                        self.headers.append((name.strip(), value))

                # ignore hopbyhop headers
                continue
            self.headers.append((name.strip(), value))

    def is_chunked(self):
        # Only use chunked responses when the client is
        # speaking HTTP/1.1 or newer and there was
        # no Content-Length header set.
        if self.response_length is not None:
            return False
        elif self.req.version <= (1, 0):
            return False
        elif self.req.method == 'HEAD':
            # Responses to a HEAD request MUST NOT contain a response body.
            return False
        elif self.status_code in (204, 304):
            # Do not use chunked responses when the response is guaranteed to
            # not have a response body.
            return False
        return True

    def default_headers(self):
        # set the connection header
        if self.upgrade:
            connection = "upgrade"
        elif self.should_close():
            connection = "close"
        else:
            connection = "keep-alive"

        headers = [
            "HTTP/%s.%s %s\r\n" % (self.req.version[0],
                                   self.req.version[1], self.status),
            "Server: %s\r\n" % self.version,
            "Date: %s\r\n" % util.http_date(),
            "Connection: %s\r\n" % connection
        ]
        if self.chunked:
            headers.append("Transfer-Encoding: chunked\r\n")
        return headers

    def send_headers(self):
        if self.headers_sent:
            return
        tosend = self.default_headers()
        tosend.extend(["%s: %s\r\n" % (k, v) for k, v in self.headers])

        header_str = "%s\r\n" % "".join(tosend)
        util.write(self.sock, util.to_bytestring(header_str, "latin-1"))
        self.headers_sent = True

    def write(self, arg):
        self.send_headers()
        if not isinstance(arg, bytes):
            raise TypeError('%r is not a byte' % arg)
        arglen = len(arg)
        tosend = arglen
        if self.response_length is not None:
            if self.sent >= self.response_length:
                # Never write more than self.response_length bytes
                return

            tosend = min(self.response_length - self.sent, tosend)
            if tosend < arglen:
                arg = arg[:tosend]

        # Sending an empty chunk signals the end of the
        # response and prematurely closes the response
        if self.chunked and tosend == 0:
            return

        self.sent += tosend
        util.write(self.sock, arg, self.chunked)

    def can_sendfile(self):
        return self.cfg.sendfile is not False

    def sendfile(self, respiter):
        if self.cfg.is_ssl or not self.can_sendfile():
            return False

        if not util.has_fileno(respiter.filelike):
            return False

        fileno = respiter.filelike.fileno()
        try:
            offset = os.lseek(fileno, 0, os.SEEK_CUR)
            if self.response_length is None:
                filesize = os.fstat(fileno).st_size
                nbytes = filesize - offset
            else:
                nbytes = self.response_length
        except (OSError, io.UnsupportedOperation):
            return False

        self.send_headers()

        if self.is_chunked():
            chunk_size = "%X\r\n" % nbytes
            self.sock.sendall(chunk_size.encode('utf-8'))
        if nbytes > 0:
            self.sock.sendfile(respiter.filelike, offset=offset, count=nbytes)

        if self.is_chunked():
            self.sock.sendall(b"\r\n")

        os.lseek(fileno, offset, os.SEEK_SET)

        return True

    def write_file(self, respiter):
        if not self.sendfile(respiter):
            for item in respiter:
                self.write(item)

    def close(self):
        if not self.headers_sent:
            self.send_headers()
        if self.chunked:
            util.write_chunk(self.sock, b"")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\gunicorn\http\wsgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\httpx\_transports\asgi.py ---

from __future__ import annotations

import typing

from .._models import Request, Response
from .._types import AsyncByteStream
from .base import AsyncBaseTransport

if typing.TYPE_CHECKING:  # pragma: no cover
    import asyncio

    import trio

    Event = typing.Union[asyncio.Event, trio.Event]


_Message = typing.MutableMapping[str, typing.Any]
_Receive = typing.Callable[[], typing.Awaitable[_Message]]
_Send = typing.Callable[
    [typing.MutableMapping[str, typing.Any]], typing.Awaitable[None]
]
_ASGIApp = typing.Callable[
    [typing.MutableMapping[str, typing.Any], _Receive, _Send], typing.Awaitable[None]
]

__all__ = ["ASGITransport"]


def is_running_trio() -> bool:
    try:
        # sniffio is a dependency of trio.

        # See https://github.com/python-trio/trio/issues/2802
        import sniffio

        if sniffio.current_async_library() == "trio":
            return True
    except ImportError:  # pragma: nocover
        pass

    return False


def create_event() -> Event:
    if is_running_trio():
        import trio

        return trio.Event()

    import asyncio

    return asyncio.Event()


class ASGIResponseStream(AsyncByteStream):
    def __init__(self, body: list[bytes]) -> None:
        self._body = body

    async def __aiter__(self) -> typing.AsyncIterator[bytes]:
        yield b"".join(self._body)


class ASGITransport(AsyncBaseTransport):
    """
    A custom AsyncTransport that handles sending requests directly to an ASGI app.

    ```python
    transport = httpx.ASGITransport(
        app=app,
        root_path="/submount",
        client=("1.2.3.4", 123)
    )
    client = httpx.AsyncClient(transport=transport)
    ```

    Arguments:

    * `app` - The ASGI application.
    * `raise_app_exceptions` - Boolean indicating if exceptions in the application
       should be raised. Default to `True`. Can be set to `False` for use cases
       such as testing the content of a client 500 response.
    * `root_path` - The root path on which the ASGI application should be mounted.
    * `client` - A two-tuple indicating the client IP and port of incoming requests.
    ```
    """

    def __init__(
        self,
        app: _ASGIApp,
        raise_app_exceptions: bool = True,
        root_path: str = "",
        client: tuple[str, int] = ("127.0.0.1", 123),
    ) -> None:
        self.app = app
        self.raise_app_exceptions = raise_app_exceptions
        self.root_path = root_path
        self.client = client

    async def handle_async_request(
        self,
        request: Request,
    ) -> Response:
        assert isinstance(request.stream, AsyncByteStream)

        # ASGI scope.
        scope = {
            "type": "http",
            "asgi": {"version": "3.0"},
            "http_version": "1.1",
            "method": request.method,
            "headers": [(k.lower(), v) for (k, v) in request.headers.raw],
            "scheme": request.url.scheme,
            "path": request.url.path,
            "raw_path": request.url.raw_path.split(b"?")[0],
            "query_string": request.url.query,
            "server": (request.url.host, request.url.port),
            "client": self.client,
            "root_path": self.root_path,
        }

        # Request.
        request_body_chunks = request.stream.__aiter__()
        request_complete = False

        # Response.
        status_code = None
        response_headers = None
        body_parts = []
        response_started = False
        response_complete = create_event()

        # ASGI callables.

        async def receive() -> dict[str, typing.Any]:
            nonlocal request_complete

            if request_complete:
                await response_complete.wait()
                return {"type": "http.disconnect"}

            try:
                body = await request_body_chunks.__anext__()
            except StopAsyncIteration:
                request_complete = True
                return {"type": "http.request", "body": b"", "more_body": False}
            return {"type": "http.request", "body": body, "more_body": True}

        async def send(message: typing.MutableMapping[str, typing.Any]) -> None:
            nonlocal status_code, response_headers, response_started

            if message["type"] == "http.response.start":
                assert not response_started

                status_code = message["status"]
                response_headers = message.get("headers", [])
                response_started = True

            elif message["type"] == "http.response.body":
                assert not response_complete.is_set()
                body = message.get("body", b"")
                more_body = message.get("more_body", False)

                if body and request.method != "HEAD":
                    body_parts.append(body)

                if not more_body:
                    response_complete.set()

        try:
            await self.app(scope, receive, send)
        except Exception:  # noqa: PIE-786
            if self.raise_app_exceptions:
                raise

            response_complete.set()
            if status_code is None:
                status_code = 500
            if response_headers is None:
                response_headers = {}

        assert response_complete.is_set()
        assert status_code is not None
        assert response_headers is not None

        stream = ASGIResponseStream(body_parts)

        return Response(status_code, headers=response_headers, stream=stream)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\httpx\_transports\asgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\httpx\_transports\wsgi.py ---

from __future__ import annotations

import io
import itertools
import sys
import typing

from .._models import Request, Response
from .._types import SyncByteStream
from .base import BaseTransport

if typing.TYPE_CHECKING:
    from _typeshed import OptExcInfo  # pragma: no cover
    from _typeshed.wsgi import WSGIApplication  # pragma: no cover

_T = typing.TypeVar("_T")


__all__ = ["WSGITransport"]


def _skip_leading_empty_chunks(body: typing.Iterable[_T]) -> typing.Iterable[_T]:
    body = iter(body)
    for chunk in body:
        if chunk:
            return itertools.chain([chunk], body)
    return []


class WSGIByteStream(SyncByteStream):
    def __init__(self, result: typing.Iterable[bytes]) -> None:
        self._close = getattr(result, "close", None)
        self._result = _skip_leading_empty_chunks(result)

    def __iter__(self) -> typing.Iterator[bytes]:
        for part in self._result:
            yield part

    def close(self) -> None:
        if self._close is not None:
            self._close()


class WSGITransport(BaseTransport):
    """
    A custom transport that handles sending requests directly to an WSGI app.
    The simplest way to use this functionality is to use the `app` argument.

    ```
    client = httpx.Client(app=app)
    ```

    Alternatively, you can setup the transport instance explicitly.
    This allows you to include any additional configuration arguments specific
    to the WSGITransport class:

    ```
    transport = httpx.WSGITransport(
        app=app,
        script_name="/submount",
        remote_addr="1.2.3.4"
    )
    client = httpx.Client(transport=transport)
    ```

    Arguments:

    * `app` - The WSGI application.
    * `raise_app_exceptions` - Boolean indicating if exceptions in the application
       should be raised. Default to `True`. Can be set to `False` for use cases
       such as testing the content of a client 500 response.
    * `script_name` - The root path on which the WSGI application should be mounted.
    * `remote_addr` - A string indicating the client IP of incoming requests.
    ```
    """

    def __init__(
        self,
        app: WSGIApplication,
        raise_app_exceptions: bool = True,
        script_name: str = "",
        remote_addr: str = "127.0.0.1",
        wsgi_errors: typing.TextIO | None = None,
    ) -> None:
        self.app = app
        self.raise_app_exceptions = raise_app_exceptions
        self.script_name = script_name
        self.remote_addr = remote_addr
        self.wsgi_errors = wsgi_errors

    def handle_request(self, request: Request) -> Response:
        request.read()
        wsgi_input = io.BytesIO(request.content)

        port = request.url.port or {"http": 80, "https": 443}[request.url.scheme]
        environ = {
            "wsgi.version": (1, 0),
            "wsgi.url_scheme": request.url.scheme,
            "wsgi.input": wsgi_input,
            "wsgi.errors": self.wsgi_errors or sys.stderr,
            "wsgi.multithread": True,
            "wsgi.multiprocess": False,
            "wsgi.run_once": False,
            "REQUEST_METHOD": request.method,
            "SCRIPT_NAME": self.script_name,
            "PATH_INFO": request.url.path,
            "QUERY_STRING": request.url.query.decode("ascii"),
            "SERVER_NAME": request.url.host,
            "SERVER_PORT": str(port),
            "SERVER_PROTOCOL": "HTTP/1.1",
            "REMOTE_ADDR": self.remote_addr,
        }
        for header_key, header_value in request.headers.raw:
            key = header_key.decode("ascii").upper().replace("-", "_")
            if key not in ("CONTENT_TYPE", "CONTENT_LENGTH"):
                key = "HTTP_" + key
            environ[key] = header_value.decode("ascii")

        seen_status = None
        seen_response_headers = None
        seen_exc_info = None

        def start_response(
            status: str,
            response_headers: list[tuple[str, str]],
            exc_info: OptExcInfo | None = None,
        ) -> typing.Callable[[bytes], typing.Any]:
            nonlocal seen_status, seen_response_headers, seen_exc_info
            seen_status = status
            seen_response_headers = response_headers
            seen_exc_info = exc_info
            return lambda _: None

        result = self.app(environ, start_response)

        stream = WSGIByteStream(result)

        assert seen_status is not None
        assert seen_response_headers is not None
        if seen_exc_info and seen_exc_info[0] and self.raise_app_exceptions:
            raise seen_exc_info[1]

        status_code = int(seen_status.split()[0])
        headers = [
            (key.encode("ascii"), value.encode("ascii"))
            for key, value in seen_response_headers
        ]

        return Response(status_code, headers=headers, stream=stream)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\httpx\_transports\wsgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\kombu\transport\sqlalchemy\models.py ---

"""Kombu transport using SQLAlchemy as the message store."""

from __future__ import annotations

import datetime

from sqlalchemy import (Boolean, Column, DateTime, ForeignKey, Index, Integer,
                        Sequence, SmallInteger, String, Text)
from sqlalchemy.orm import relationship
from sqlalchemy.schema import MetaData

try:
    from sqlalchemy.orm import declarative_base, declared_attr
except ImportError:
    # TODO: Remove this once we drop support for SQLAlchemy < 1.4.
    from sqlalchemy.ext.declarative import declarative_base, declared_attr

class_registry = {}
metadata = MetaData()
ModelBase = declarative_base(metadata=metadata, class_registry=class_registry)


class Queue:
    """The queue class."""

    __table_args__ = {'sqlite_autoincrement': True, 'mysql_engine': 'InnoDB'}

    id = Column(Integer, Sequence('queue_id_sequence'), primary_key=True,
                autoincrement=True)
    name = Column(String(200), unique=True)

    def __init__(self, name):
        self.name = name

    def __str__(self):
        return f'<Queue({self.name})>'

    @declared_attr
    def messages(cls):
        return relationship('Message', backref='queue', lazy='noload')


class Message:
    """The message class."""

    __table_args__ = (
        Index('ix_kombu_message_timestamp_id', 'timestamp', 'id'),
        {'sqlite_autoincrement': True, 'mysql_engine': 'InnoDB'}
    )

    id = Column(Integer, Sequence('message_id_sequence'),
                primary_key=True, autoincrement=True)
    visible = Column(Boolean, default=True, index=True)
    sent_at = Column('timestamp', DateTime, nullable=True, index=True,
                     onupdate=datetime.datetime.now)
    payload = Column(Text, nullable=False)
    version = Column(SmallInteger, nullable=False, default=1)

    __mapper_args__ = {'version_id_col': version}

    def __init__(self, payload, queue):
        self.payload = payload
        self.queue = queue

    def __str__(self):
        return '<Message: {0.sent_at} {0.payload} {0.queue_id}>'.format(self)

    @declared_attr
    def queue_id(self):
        return Column(
            Integer,
            ForeignKey(
                '%s.id' % class_registry['Queue'].__tablename__,
                name='FK_kombu_message_queue'
            )
        )

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\kombu\transport\sqlalchemy\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\langchain\chains\constitutional_ai\models.py ---

"""Models for the Constitutional AI chain."""

from pydantic import BaseModel


class ConstitutionalPrinciple(BaseModel):
    """Class for a constitutional principle."""

    critique_request: str
    revision_request: str
    name: str = "Constitutional Principle"

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\langchain\chains\constitutional_ai\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\langchain\tools\eleven_labs\models.py ---

from typing import TYPE_CHECKING, Any

from langchain._api import create_importer

if TYPE_CHECKING:
    from langchain_community.tools.eleven_labs.models import ElevenLabsModel

# Create a way to dynamically look up deprecated imports.
# Used to consolidate logic for raising deprecation warnings and
# handling optional imports.
DEPRECATED_LOOKUP = {"ElevenLabsModel": "langchain_community.tools.eleven_labs.models"}

_import_attribute = create_importer(__package__, deprecated_lookups=DEPRECATED_LOOKUP)


def __getattr__(name: str) -> Any:
    """Look up attributes dynamically."""
    return _import_attribute(name)


__all__ = [
    "ElevenLabsModel",
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\langchain\tools\eleven_labs\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\pip\_internal\utils\urls.py ---

import os
import string
import urllib.parse
import urllib.request

from .compat import WINDOWS


def path_to_url(path: str) -> str:
    """
    Convert a path to a file: URL.  The path will be made absolute and have
    quoted path parts.
    """
    path = os.path.normpath(os.path.abspath(path))
    url = urllib.parse.urljoin("file:", urllib.request.pathname2url(path))
    return url


def url_to_path(url: str) -> str:
    """
    Convert a file: URL to a path.
    """
    assert url.startswith(
        "file:"
    ), f"You can only turn file: urls into filenames (not {url!r})"

    _, netloc, path, _, _ = urllib.parse.urlsplit(url)

    if not netloc or netloc == "localhost":
        # According to RFC 8089, same as empty authority.
        netloc = ""
    elif WINDOWS:
        # If we have a UNC path, prepend UNC share notation.
        netloc = "\\\\" + netloc
    else:
        raise ValueError(
            f"non-local file URIs are not supported on this platform: {url!r}"
        )

    path = urllib.request.url2pathname(netloc + path)

    # On Windows, urlsplit parses the path as something like "/C:/Users/foo".
    # This creates issues for path-related functions like io.open(), so we try
    # to detect and strip the leading slash.
    if (
        WINDOWS
        and not netloc  # Not UNC.
        and len(path) >= 3
        and path[0] == "/"  # Leading slash to strip.
        and path[1] in string.ascii_letters  # Drive letter.
        and path[2:4] in (":", ":/")  # Colon + end of string, or colon + absolute path.
    ):
        path = path[1:]

    return path

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\pip\_internal\utils\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\pip\_vendor\requests\models.py ---

"""
requests.models
~~~~~~~~~~~~~~~

This module contains the primary objects that power Requests.
"""

import datetime

# Import encoding now, to avoid implicit import later.
# Implicit import within threads may cause LookupError when standard library is in a ZIP,
# such as in Embedded Python. See https://github.com/psf/requests/issues/3578.
import encodings.idna  # noqa: F401
from io import UnsupportedOperation

from pip._vendor.urllib3.exceptions import (
    DecodeError,
    LocationParseError,
    ProtocolError,
    ReadTimeoutError,
    SSLError,
)
from pip._vendor.urllib3.fields import RequestField
from pip._vendor.urllib3.filepost import encode_multipart_formdata
from pip._vendor.urllib3.util import parse_url

from ._internal_utils import to_native_string, unicode_is_ascii
from .auth import HTTPBasicAuth
from .compat import (
    Callable,
    JSONDecodeError,
    Mapping,
    basestring,
    builtin_str,
    chardet,
    cookielib,
)
from .compat import json as complexjson
from .compat import urlencode, urlsplit, urlunparse
from .cookies import _copy_cookie_jar, cookiejar_from_dict, get_cookie_header
from .exceptions import (
    ChunkedEncodingError,
    ConnectionError,
    ContentDecodingError,
    HTTPError,
    InvalidJSONError,
    InvalidURL,
)
from .exceptions import JSONDecodeError as RequestsJSONDecodeError
from .exceptions import MissingSchema
from .exceptions import SSLError as RequestsSSLError
from .exceptions import StreamConsumedError
from .hooks import default_hooks
from .status_codes import codes
from .structures import CaseInsensitiveDict
from .utils import (
    check_header_validity,
    get_auth_from_url,
    guess_filename,
    guess_json_utf,
    iter_slices,
    parse_header_links,
    requote_uri,
    stream_decode_response_unicode,
    super_len,
    to_key_val_list,
)

#: The set of HTTP status codes that indicate an automatically
#: processable redirect.
REDIRECT_STATI = (
    codes.moved,  # 301
    codes.found,  # 302
    codes.other,  # 303
    codes.temporary_redirect,  # 307
    codes.permanent_redirect,  # 308
)

DEFAULT_REDIRECT_LIMIT = 30
CONTENT_CHUNK_SIZE = 10 * 1024
ITER_CHUNK_SIZE = 512


class RequestEncodingMixin:
    @property
    def path_url(self):
        """Build the path URL to use."""

        url = []

        p = urlsplit(self.url)

        path = p.path
        if not path:
            path = "/"

        url.append(path)

        query = p.query
        if query:
            url.append("?")
            url.append(query)

        return "".join(url)

    @staticmethod
    def _encode_params(data):
        """Encode parameters in a piece of data.

        Will successfully encode parameters when passed as a dict or a list of
        2-tuples. Order is retained if data is a list of 2-tuples but arbitrary
        if parameters are supplied as a dict.
        """

        if isinstance(data, (str, bytes)):
            return data
        elif hasattr(data, "read"):
            return data
        elif hasattr(data, "__iter__"):
            result = []
            for k, vs in to_key_val_list(data):
                if isinstance(vs, basestring) or not hasattr(vs, "__iter__"):
                    vs = [vs]
                for v in vs:
                    if v is not None:
                        result.append(
                            (
                                k.encode("utf-8") if isinstance(k, str) else k,
                                v.encode("utf-8") if isinstance(v, str) else v,
                            )
                        )
            return urlencode(result, doseq=True)
        else:
            return data

    @staticmethod
    def _encode_files(files, data):
        """Build the body for a multipart/form-data request.

        Will successfully encode files when passed as a dict or a list of
        tuples. Order is retained if data is a list of tuples but arbitrary
        if parameters are supplied as a dict.
        The tuples may be 2-tuples (filename, fileobj), 3-tuples (filename, fileobj, contentype)
        or 4-tuples (filename, fileobj, contentype, custom_headers).
        """
        if not files:
            raise ValueError("Files must be provided.")
        elif isinstance(data, basestring):
            raise ValueError("Data must not be a string.")

        new_fields = []
        fields = to_key_val_list(data or {})
        files = to_key_val_list(files or {})

        for field, val in fields:
            if isinstance(val, basestring) or not hasattr(val, "__iter__"):
                val = [val]
            for v in val:
                if v is not None:
                    # Don't call str() on bytestrings: in Py3 it all goes wrong.
                    if not isinstance(v, bytes):
                        v = str(v)

                    new_fields.append(
                        (
                            field.decode("utf-8")
                            if isinstance(field, bytes)
                            else field,
                            v.encode("utf-8") if isinstance(v, str) else v,
                        )
                    )

        for k, v in files:
            # support for explicit filename
            ft = None
            fh = None
            if isinstance(v, (tuple, list)):
                if len(v) == 2:
                    fn, fp = v
                elif len(v) == 3:
                    fn, fp, ft = v
                else:
                    fn, fp, ft, fh = v
            else:
                fn = guess_filename(v) or k
                fp = v

            if isinstance(fp, (str, bytes, bytearray)):
                fdata = fp
            elif hasattr(fp, "read"):
                fdata = fp.read()
            elif fp is None:
                continue
            else:
                fdata = fp

            rf = RequestField(name=k, data=fdata, filename=fn, headers=fh)
            rf.make_multipart(content_type=ft)
            new_fields.append(rf)

        body, content_type = encode_multipart_formdata(new_fields)

        return body, content_type


class RequestHooksMixin:
    def register_hook(self, event, hook):
        """Properly register a hook."""

        if event not in self.hooks:
            raise ValueError(f'Unsupported event specified, with event name "{event}"')

        if isinstance(hook, Callable):
            self.hooks[event].append(hook)
        elif hasattr(hook, "__iter__"):
            self.hooks[event].extend(h for h in hook if isinstance(h, Callable))

    def deregister_hook(self, event, hook):
        """Deregister a previously registered hook.
        Returns True if the hook existed, False if not.
        """

        try:
            self.hooks[event].remove(hook)
            return True
        except ValueError:
            return False


class Request(RequestHooksMixin):
    """A user-created :class:`Request <Request>` object.

    Used to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.

    :param method: HTTP method to use.
    :param url: URL to send.
    :param headers: dictionary of headers to send.
    :param files: dictionary of {filename: fileobject} files to multipart upload.
    :param data: the body to attach to the request. If a dictionary or
        list of tuples ``[(key, value)]`` is provided, form-encoding will
        take place.
    :param json: json for the body to attach to the request (if files or data is not specified).
    :param params: URL parameters to append to the URL. If a dictionary or
        list of tuples ``[(key, value)]`` is provided, form-encoding will
        take place.
    :param auth: Auth handler or (user, pass) tuple.
    :param cookies: dictionary or CookieJar of cookies to attach to this request.
    :param hooks: dictionary of callback hooks, for internal usage.

    Usage::

      >>> import requests
      >>> req = requests.Request('GET', 'https://httpbin.org/get')
      >>> req.prepare()
      <PreparedRequest [GET]>
    """

    def __init__(
        self,
        method=None,
        url=None,
        headers=None,
        files=None,
        data=None,
        params=None,
        auth=None,
        cookies=None,
        hooks=None,
        json=None,
    ):
        # Default empty dicts for dict params.
        data = [] if data is None else data
        files = [] if files is None else files
        headers = {} if headers is None else headers
        params = {} if params is None else params
        hooks = {} if hooks is None else hooks

        self.hooks = default_hooks()
        for k, v in list(hooks.items()):
            self.register_hook(event=k, hook=v)

        self.method = method
        self.url = url
        self.headers = headers
        self.files = files
        self.data = data
        self.json = json
        self.params = params
        self.auth = auth
        self.cookies = cookies

    def __repr__(self):
        return f"<Request [{self.method}]>"

    def prepare(self):
        """Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it."""
        p = PreparedRequest()
        p.prepare(
            method=self.method,
            url=self.url,
            headers=self.headers,
            files=self.files,
            data=self.data,
            json=self.json,
            params=self.params,
            auth=self.auth,
            cookies=self.cookies,
            hooks=self.hooks,
        )
        return p


class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):
    """The fully mutable :class:`PreparedRequest <PreparedRequest>` object,
    containing the exact bytes that will be sent to the server.

    Instances are generated from a :class:`Request <Request>` object, and
    should not be instantiated manually; doing so may produce undesirable
    effects.

    Usage::

      >>> import requests
      >>> req = requests.Request('GET', 'https://httpbin.org/get')
      >>> r = req.prepare()
      >>> r
      <PreparedRequest [GET]>

      >>> s = requests.Session()
      >>> s.send(r)
      <Response [200]>
    """

    def __init__(self):
        #: HTTP verb to send to the server.
        self.method = None
        #: HTTP URL to send the request to.
        self.url = None
        #: dictionary of HTTP headers.
        self.headers = None
        # The `CookieJar` used to create the Cookie header will be stored here
        # after prepare_cookies is called
        self._cookies = None
        #: request body to send to the server.
        self.body = None
        #: dictionary of callback hooks, for internal usage.
        self.hooks = default_hooks()
        #: integer denoting starting position of a readable file-like body.
        self._body_position = None

    def prepare(
        self,
        method=None,
        url=None,
        headers=None,
        files=None,
        data=None,
        params=None,
        auth=None,
        cookies=None,
        hooks=None,
        json=None,
    ):
        """Prepares the entire request with the given parameters."""

        self.prepare_method(method)
        self.prepare_url(url, params)
        self.prepare_headers(headers)
        self.prepare_cookies(cookies)
        self.prepare_body(data, files, json)
        self.prepare_auth(auth, url)

        # Note that prepare_auth must be last to enable authentication schemes
        # such as OAuth to work on a fully prepared request.

        # This MUST go after prepare_auth. Authenticators could add a hook
        self.prepare_hooks(hooks)

    def __repr__(self):
        return f"<PreparedRequest [{self.method}]>"

    def copy(self):
        p = PreparedRequest()
        p.method = self.method
        p.url = self.url
        p.headers = self.headers.copy() if self.headers is not None else None
        p._cookies = _copy_cookie_jar(self._cookies)
        p.body = self.body
        p.hooks = self.hooks
        p._body_position = self._body_position
        return p

    def prepare_method(self, method):
        """Prepares the given HTTP method."""
        self.method = method
        if self.method is not None:
            self.method = to_native_string(self.method.upper())

    @staticmethod
    def _get_idna_encoded_host(host):
        from pip._vendor import idna

        try:
            host = idna.encode(host, uts46=True).decode("utf-8")
        except idna.IDNAError:
            raise UnicodeError
        return host

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)

        # Remove leading whitespaces from url
        url = url.lstrip()

        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return

        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)

        if not scheme:
            raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )

        if not host:
            raise InvalidURL(f"Invalid URL {url!r}: No host supplied")

        # In general, we want to try IDNA encoding the hostname if the string contains
        # non-ASCII characters. This allows users to automatically get the correct IDNA
        # behaviour. For strings containing only ASCII characters, we need to also verify
        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.
        if not unicode_is_ascii(host):
            try:
                host = self._get_idna_encoded_host(host)
            except UnicodeError:
                raise InvalidURL("URL has an invalid label.")
        elif host.startswith(("*", ".")):
            raise InvalidURL("URL has an invalid label.")

        # Carefully reconstruct the network location
        netloc = auth or ""
        if netloc:
            netloc += "@"
        netloc += host
        if port:
            netloc += f":{port}"

        # Bare domains aren't valid URLs.
        if not path:
            path = "/"

        if isinstance(params, (str, bytes)):
            params = to_native_string(params)

        enc_params = self._encode_params(params)
        if enc_params:
            if query:
                query = f"{query}&{enc_params}"
            else:
                query = enc_params

        url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))
        self.url = url

    def prepare_headers(self, headers):
        """Prepares the given HTTP headers."""

        self.headers = CaseInsensitiveDict()
        if headers:
            for header in headers.items():
                # Raise exception on invalid header value.
                check_header_validity(header)
                name, value = header
                self.headers[to_native_string(name)] = value

    def prepare_body(self, data, files, json=None):
        """Prepares the given HTTP body data."""

        # Check if file, fo, generator, iterator.
        # If not, run through normal process.

        # Nottin' on you.
        body = None
        content_type = None

        if not data and json is not None:
            # urllib3 requires a bytes-like body. Python 2's json.dumps
            # provides this natively, but Python 3 gives a Unicode string.
            content_type = "application/json"

            try:
                body = complexjson.dumps(json, allow_nan=False)
            except ValueError as ve:
                raise InvalidJSONError(ve, request=self)

            if not isinstance(body, bytes):
                body = body.encode("utf-8")

        is_stream = all(
            [
                hasattr(data, "__iter__"),
                not isinstance(data, (basestring, list, tuple, Mapping)),
            ]
        )

        if is_stream:
            try:
                length = super_len(data)
            except (TypeError, AttributeError, UnsupportedOperation):
                length = None

            body = data

            if getattr(body, "tell", None) is not None:
                # Record the current file position before reading.
                # This will allow us to rewind a file in the event
                # of a redirect.
                try:
                    self._body_position = body.tell()
                except OSError:
                    # This differentiates from None, allowing us to catch
                    # a failed `tell()` later when trying to rewind the body
                    self._body_position = object()

            if files:
                raise NotImplementedError(
                    "Streamed bodies and files are mutually exclusive."
                )

            if length:
                self.headers["Content-Length"] = builtin_str(length)
            else:
                self.headers["Transfer-Encoding"] = "chunked"
        else:
            # Multi-part file uploads.
            if files:
                (body, content_type) = self._encode_files(files, data)
            else:
                if data:
                    body = self._encode_params(data)
                    if isinstance(data, basestring) or hasattr(data, "read"):
                        content_type = None
                    else:
                        content_type = "application/x-www-form-urlencoded"

            self.prepare_content_length(body)

            # Add content-type if it wasn't explicitly provided.
            if content_type and ("content-type" not in self.headers):
                self.headers["Content-Type"] = content_type

        self.body = body

    def prepare_content_length(self, body):
        """Prepare Content-Length header based on request method and body"""
        if body is not None:
            length = super_len(body)
            if length:
                # If length exists, set it. Otherwise, we fallback
                # to Transfer-Encoding: chunked.
                self.headers["Content-Length"] = builtin_str(length)
        elif (
            self.method not in ("GET", "HEAD")
            and self.headers.get("Content-Length") is None
        ):
            # Set Content-Length to 0 for methods that can have a body
            # but don't provide one. (i.e. not GET or HEAD)
            self.headers["Content-Length"] = "0"

    def prepare_auth(self, auth, url=""):
        """Prepares the given HTTP auth data."""

        # If no Auth is explicitly provided, extract it from the URL first.
        if auth is None:
            url_auth = get_auth_from_url(self.url)
            auth = url_auth if any(url_auth) else None

        if auth:
            if isinstance(auth, tuple) and len(auth) == 2:
                # special-case basic HTTP auth
                auth = HTTPBasicAuth(*auth)

            # Allow auth to make its changes.
            r = auth(self)

            # Update self to reflect the auth changes.
            self.__dict__.update(r.__dict__)

            # Recompute Content-Length
            self.prepare_content_length(self.body)

    def prepare_cookies(self, cookies):
        """Prepares the given HTTP cookie data.

        This function eventually generates a ``Cookie`` header from the
        given cookies using cookielib. Due to cookielib's design, the header
        will not be regenerated if it already exists, meaning this function
        can only be called once for the life of the
        :class:`PreparedRequest <PreparedRequest>` object. Any subsequent calls
        to ``prepare_cookies`` will have no actual effect, unless the "Cookie"
        header is removed beforehand.
        """
        if isinstance(cookies, cookielib.CookieJar):
            self._cookies = cookies
        else:
            self._cookies = cookiejar_from_dict(cookies)

        cookie_header = get_cookie_header(self._cookies, self)
        if cookie_header is not None:
            self.headers["Cookie"] = cookie_header

    def prepare_hooks(self, hooks):
        """Prepares the given hooks."""
        # hooks can be passed as None to the prepare method and to this
        # method. To prevent iterating over None, simply use an empty list
        # if hooks is False-y
        hooks = hooks or []
        for event in hooks:
            self.register_hook(event, hooks[event])


class Response:
    """The :class:`Response <Response>` object, which contains a
    server's response to an HTTP request.
    """

    __attrs__ = [
        "_content",
        "status_code",
        "headers",
        "url",
        "history",
        "encoding",
        "reason",
        "cookies",
        "elapsed",
        "request",
    ]

    def __init__(self):
        self._content = False
        self._content_consumed = False
        self._next = None

        #: Integer Code of responded HTTP Status, e.g. 404 or 200.
        self.status_code = None

        #: Case-insensitive Dictionary of Response Headers.
        #: For example, ``headers['content-encoding']`` will return the
        #: value of a ``'Content-Encoding'`` response header.
        self.headers = CaseInsensitiveDict()

        #: File-like object representation of response (for advanced usage).
        #: Use of ``raw`` requires that ``stream=True`` be set on the request.
        #: This requirement does not apply for use internally to Requests.
        self.raw = None

        #: Final URL location of Response.
        self.url = None

        #: Encoding to decode with when accessing r.text.
        self.encoding = None

        #: A list of :class:`Response <Response>` objects from
        #: the history of the Request. Any redirect responses will end
        #: up here. The list is sorted from the oldest to the most recent request.
        self.history = []

        #: Textual reason of responded HTTP Status, e.g. "Not Found" or "OK".
        self.reason = None

        #: A CookieJar of Cookies the server sent back.
        self.cookies = cookiejar_from_dict({})

        #: The amount of time elapsed between sending the request
        #: and the arrival of the response (as a timedelta).
        #: This property specifically measures the time taken between sending
        #: the first byte of the request and finishing parsing the headers. It
        #: is therefore unaffected by consuming the response content or the
        #: value of the ``stream`` keyword argument.
        self.elapsed = datetime.timedelta(0)

        #: The :class:`PreparedRequest <PreparedRequest>` object to which this
        #: is a response.
        self.request = None

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def __getstate__(self):
        # Consume everything; accessing the content attribute makes
        # sure the content has been fully read.
        if not self._content_consumed:
            self.content

        return {attr: getattr(self, attr, None) for attr in self.__attrs__}

    def __setstate__(self, state):
        for name, value in state.items():
            setattr(self, name, value)

        # pickled objects do not have .raw
        setattr(self, "_content_consumed", True)
        setattr(self, "raw", None)

    def __repr__(self):
        return f"<Response [{self.status_code}]>"

    def __bool__(self):
        """Returns True if :attr:`status_code` is less than 400.

        This attribute checks if the status code of the response is between
        400 and 600 to see if there was a client error or a server error. If
        the status code, is between 200 and 400, this will return True. This
        is **not** a check to see if the response code is ``200 OK``.
        """
        return self.ok

    def __nonzero__(self):
        """Returns True if :attr:`status_code` is less than 400.

        This attribute checks if the status code of the response is between
        400 and 600 to see if there was a client error or a server error. If
        the status code, is between 200 and 400, this will return True. This
        is **not** a check to see if the response code is ``200 OK``.
        """
        return self.ok

    def __iter__(self):
        """Allows you to use a response as an iterator."""
        return self.iter_content(128)

    @property
    def ok(self):
        """Returns True if :attr:`status_code` is less than 400, False if not.

        This attribute checks if the status code of the response is between
        400 and 600 to see if there was a client error or a server error. If
        the status code is between 200 and 400, this will return True. This
        is **not** a check to see if the response code is ``200 OK``.
        """
        try:
            self.raise_for_status()
        except HTTPError:
            return False
        return True

    @property
    def is_redirect(self):
        """True if this Response is a well-formed HTTP redirect that could have
        been processed automatically (by :meth:`Session.resolve_redirects`).
        """
        return "location" in self.headers and self.status_code in REDIRECT_STATI

    @property
    def is_permanent_redirect(self):
        """True if this Response one of the permanent versions of redirect."""
        return "location" in self.headers and self.status_code in (
            codes.moved_permanently,
            codes.permanent_redirect,
        )

    @property
    def next(self):
        """Returns a PreparedRequest for the next request in a redirect chain, if there is one."""
        return self._next

    @property
    def apparent_encoding(self):
        """The apparent encoding, provided by the charset_normalizer or chardet libraries."""
        if chardet is not None:
            return chardet.detect(self.content)["encoding"]
        else:
            # If no character detection library is available, we'll fall back
            # to a standard Python utf-8 str.
            return "utf-8"

    def iter_content(self, chunk_size=1, decode_unicode=False):
        """Iterates over the response data.  When stream=True is set on the
        request, this avoids reading the content at once into memory for
        large responses.  The chunk size is the number of bytes it should
        read into memory.  This is not necessarily the length of each item
        returned as decoding can take place.

        chunk_size must be of type int or None. A value of None will
        function differently depending on the value of `stream`.
        stream=True will read data as it arrives in whatever size the
        chunks are received. If stream=False, data is returned as
        a single chunk.

        If decode_unicode is True, content will be decoded using the best
        available encoding based on the response.
        """

        def generate():
            # Special case for urllib3.
            if hasattr(self.raw, "stream"):
                try:
                    yield from self.raw.stream(chunk_size, decode_content=True)
                except ProtocolError as e:
                    raise ChunkedEncodingError(e)
                except DecodeError as e:
                    raise ContentDecodingError(e)
                except ReadTimeoutError as e:
                    raise ConnectionError(e)
                except SSLError as e:
                    raise RequestsSSLError(e)
            else:
                # Standard file-like object.
                while True:
                    chunk = self.raw.read(chunk_size)
                    if not chunk:
                        break
                    yield chunk

            self._content_consumed = True

        if self._content_consumed and isinstance(self._content, bool):
            raise StreamConsumedError()
        elif chunk_size is not None and not isinstance(chunk_size, int):
            raise TypeError(
                f"chunk_size must be an int, it is instead a {type(chunk_size)}."
            )
        # simulate reading small chunks of the content
        reused_chunks = iter_slices(self._content, chunk_size)

        stream_chunks = generate()

        chunks = reused_chunks if self._content_consumed else stream_chunks

        if decode_unicode:
            chunks = stream_decode_response_unicode(chunks, self)

        return chunks

    def iter_lines(
        self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None
    ):
        """Iterates over the response data, one line at a time.  When
        stream=True is set on the request, this avoids reading the
        content at once into memory for large responses.

        .. note:: This method is not reentrant safe.
        """

        pending = None

        for chunk in self.iter_content(
            chunk_size=chunk_size, decode_unicode=decode_unicode
        ):
            if pending is not None:
                chunk = pending + chunk

            if delimiter:
                lines = chunk.split(delimiter)
            else:
                lines = chunk.splitlines()

            if lines and lines[-1] and chunk and lines[-1][-1] == chunk[-1]:
                pending = lines.pop()
            else:
                pending = None

            yield from lines

        if pending is not None:
            yield pending

    @property
    def content(self):
        """Content of the response, in bytes."""

        if self._content is False:
            # Read the contents.
            if self._content_consumed:
                raise RuntimeError("The content for this response was already consumed")

            if self.status_code == 0 or self.raw is None:
                self._content = None
            else:
                self._content = b"".join(self.iter_content(CONTENT_CHUNK_SIZE)) or b""

        self._content_consumed = True
        # don't need to release the connection; that's been handled by urllib3
        # since we exhausted the data.
        return self._content

    @property
    def text(self):
        """Content of the response, in unicode.

        If Response.encoding is None, encoding will be guessed using
        ``charset_normalizer`` or ``chardet``.

        The encoding of the response content is determined based solely on HTTP
        headers, following RFC 2616 to the letter. If you can take advantage of
        non-HTTP knowledge to make a better guess at the encoding, you should
        set ``r.encoding`` appropriately before accessing this property.
        """

        # Try charset from content-type
        content = None
        encoding = self.encoding

        if not self.content:
            return ""

        # Fallback to auto-detected encoding.
        if self.encoding is None:
            encoding = self.apparent_encoding

        # Decode unicode from given encoding.
        try:
            content = str(self.content, encoding, errors="replace")
        except (LookupError, TypeError):
            # A LookupError is raised if the encoding was not found which could
            # indicate a misspelling or similar mistake.
            #
            # A TypeError can be raised if encoding is None
            #
            # So we try blindly encoding.
            content = str(self.content, errors="replace")

        return content

    def json(self, **kwargs):
        r"""Returns the json-encoded content of a response, if any.

        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """

        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)

        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
            raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)

    @property
    def links(self):
        """Returns the parsed header links of the response, if any."""

        header = self.headers.get("link")

        resolved_links = {}

        if header:
            links = parse_header_links(header)

            for link in links:
                key = link.get("rel") or link.get("url")
                resolved_links[key] = link

        return resolved_links

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""

        http_error_msg = ""
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode("utf-8")
            except UnicodeDecodeError:
                reason = self.reason.decode("iso-8859-1")
        else:
            reason = self.reason

        if 400 <= self.status_code < 500:
            http_error_msg = (
                f"{self.status_code} Client Error: {reason} for url: {self.url}"
            )

        elif 500 <= self.status_code < 600:
            http_error_msg = (
                f"{self.status_code} Server Error: {reason} for url: {self.url}"
            )

        if http_error_msg:
            raise HTTPError(http_error_msg, response=self)

    def close(self):
        """Releases the connection back to the pool. Once this method has been
        called the underlying ``raw`` object must not be accessed again.

        *Note: Should not normally need to be called explicitly.*
        """
        if not self._content_consumed:
            self.raw.close()

        release_conn = getattr(self.raw, "release_conn", None)
        if release_conn is not None:
            release_conn()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\pip\_vendor\requests\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\plotly\serializers.py ---

from .basedatatypes import Undefined
from .optional_imports import get_module

np = get_module("numpy")


def _py_to_js(v, widget_manager):
    """
    Python -> Javascript ipywidget serializer

    This function must repalce all objects that the ipywidget library
    can't serialize natively (e.g. numpy arrays) with serializable
    representations

    Parameters
    ----------
    v
        Object to be serialized
    widget_manager
        ipywidget widget_manager (unused)

    Returns
    -------
    any
        Value that the ipywidget library can serialize natively
    """

    # Handle dict recursively
    # -----------------------
    if isinstance(v, dict):
        return {k: _py_to_js(v, widget_manager) for k, v in v.items()}

    # Handle list/tuple recursively
    # -----------------------------
    elif isinstance(v, (list, tuple)):
        return [_py_to_js(v, widget_manager) for v in v]

    # Handle numpy array
    # ------------------
    elif np is not None and isinstance(v, np.ndarray):
        # Convert 1D numpy arrays with numeric types to memoryviews with
        # datatype and shape metadata.
        if (
            v.ndim == 1
            and v.dtype.kind in ["u", "i", "f"]
            and v.dtype != "int64"
            and v.dtype != "uint64"
        ):

            # We have a numpy array the we can directly map to a JavaScript
            # Typed array
            return {"buffer": memoryview(v), "dtype": str(v.dtype), "shape": v.shape}
        else:
            # Convert all other numpy arrays to lists
            return v.tolist()

    # Handle Undefined
    # ----------------
    if v is Undefined:
        return "_undefined_"

    # Handle simple value
    # -------------------
    else:
        return v


def _js_to_py(v, widget_manager):
    """
    Javascript -> Python ipywidget deserializer

    Parameters
    ----------
    v
        Object to be deserialized
    widget_manager
        ipywidget widget_manager (unused)

    Returns
    -------
    any
        Deserialized object for use by the Python side of the library
    """
    # Handle dict
    # -----------
    if isinstance(v, dict):
        return {k: _js_to_py(v, widget_manager) for k, v in v.items()}

    # Handle list/tuple
    # -----------------
    elif isinstance(v, (list, tuple)):
        return [_js_to_py(v, widget_manager) for v in v]

    # Handle Undefined
    # ----------------
    elif isinstance(v, str) and v == "_undefined_":
        return Undefined

    # Handle simple value
    # -------------------
    else:
        return v


# Custom serializer dict for use in ipywidget traitlet definitions
custom_serializers = {"from_json": _js_to_py, "to_json": _py_to_js}

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\plotly\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\prometheus_client\asgi.py ---

from typing import Callable
from urllib.parse import parse_qs

from .exposition import _bake_output
from .registry import CollectorRegistry, REGISTRY


def make_asgi_app(registry: CollectorRegistry = REGISTRY, disable_compression: bool = False) -> Callable:
    """Create a ASGI app which serves the metrics from a registry."""

    async def prometheus_app(scope, receive, send):
        assert scope.get("type") == "http"
        # Prepare parameters
        params = parse_qs(scope.get('query_string', b''))
        accept_header = ",".join([
            value.decode("utf8") for (name, value) in scope.get('headers')
            if name.decode("utf8").lower() == 'accept'
        ])
        accept_encoding_header = ",".join([
            value.decode("utf8") for (name, value) in scope.get('headers')
            if name.decode("utf8").lower() == 'accept-encoding'
        ])
        # Bake output
        status, headers, output = _bake_output(registry, accept_header, accept_encoding_header, params, disable_compression)
        formatted_headers = []
        for header in headers:
            formatted_headers.append(tuple(x.encode('utf8') for x in header))
        # Return output
        payload = await receive()
        if payload.get("type") == "http.request":
            await send(
                {
                    "type": "http.response.start",
                    "status": int(status.split(' ')[0]),
                    "headers": formatted_headers,
                }
            )
            await send({"type": "http.response.body", "body": output})

    return prometheus_app

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\prometheus_client\asgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\requests\models.py ---

"""
requests.models
~~~~~~~~~~~~~~~

This module contains the primary objects that power Requests.
"""

import datetime

# Import encoding now, to avoid implicit import later.
# Implicit import within threads may cause LookupError when standard library is in a ZIP,
# such as in Embedded Python. See https://github.com/psf/requests/issues/3578.
import encodings.idna  # noqa: F401
from io import UnsupportedOperation

from urllib3.exceptions import (
    DecodeError,
    LocationParseError,
    ProtocolError,
    ReadTimeoutError,
    SSLError,
)
from urllib3.fields import RequestField
from urllib3.filepost import encode_multipart_formdata
from urllib3.util import parse_url

from ._internal_utils import to_native_string, unicode_is_ascii
from .auth import HTTPBasicAuth
from .compat import (
    Callable,
    JSONDecodeError,
    Mapping,
    basestring,
    builtin_str,
    chardet,
    cookielib,
)
from .compat import json as complexjson
from .compat import urlencode, urlsplit, urlunparse
from .cookies import _copy_cookie_jar, cookiejar_from_dict, get_cookie_header
from .exceptions import (
    ChunkedEncodingError,
    ConnectionError,
    ContentDecodingError,
    HTTPError,
    InvalidJSONError,
    InvalidURL,
)
from .exceptions import JSONDecodeError as RequestsJSONDecodeError
from .exceptions import MissingSchema
from .exceptions import SSLError as RequestsSSLError
from .exceptions import StreamConsumedError
from .hooks import default_hooks
from .status_codes import codes
from .structures import CaseInsensitiveDict
from .utils import (
    check_header_validity,
    get_auth_from_url,
    guess_filename,
    guess_json_utf,
    iter_slices,
    parse_header_links,
    requote_uri,
    stream_decode_response_unicode,
    super_len,
    to_key_val_list,
)

#: The set of HTTP status codes that indicate an automatically
#: processable redirect.
REDIRECT_STATI = (
    codes.moved,  # 301
    codes.found,  # 302
    codes.other,  # 303
    codes.temporary_redirect,  # 307
    codes.permanent_redirect,  # 308
)

DEFAULT_REDIRECT_LIMIT = 30
CONTENT_CHUNK_SIZE = 10 * 1024
ITER_CHUNK_SIZE = 512


class RequestEncodingMixin:
    @property
    def path_url(self):
        """Build the path URL to use."""

        url = []

        p = urlsplit(self.url)

        path = p.path
        if not path:
            path = "/"

        url.append(path)

        query = p.query
        if query:
            url.append("?")
            url.append(query)

        return "".join(url)

    @staticmethod
    def _encode_params(data):
        """Encode parameters in a piece of data.

        Will successfully encode parameters when passed as a dict or a list of
        2-tuples. Order is retained if data is a list of 2-tuples but arbitrary
        if parameters are supplied as a dict.
        """

        if isinstance(data, (str, bytes)):
            return data
        elif hasattr(data, "read"):
            return data
        elif hasattr(data, "__iter__"):
            result = []
            for k, vs in to_key_val_list(data):
                if isinstance(vs, basestring) or not hasattr(vs, "__iter__"):
                    vs = [vs]
                for v in vs:
                    if v is not None:
                        result.append(
                            (
                                k.encode("utf-8") if isinstance(k, str) else k,
                                v.encode("utf-8") if isinstance(v, str) else v,
                            )
                        )
            return urlencode(result, doseq=True)
        else:
            return data

    @staticmethod
    def _encode_files(files, data):
        """Build the body for a multipart/form-data request.

        Will successfully encode files when passed as a dict or a list of
        tuples. Order is retained if data is a list of tuples but arbitrary
        if parameters are supplied as a dict.
        The tuples may be 2-tuples (filename, fileobj), 3-tuples (filename, fileobj, contentype)
        or 4-tuples (filename, fileobj, contentype, custom_headers).
        """
        if not files:
            raise ValueError("Files must be provided.")
        elif isinstance(data, basestring):
            raise ValueError("Data must not be a string.")

        new_fields = []
        fields = to_key_val_list(data or {})
        files = to_key_val_list(files or {})

        for field, val in fields:
            if isinstance(val, basestring) or not hasattr(val, "__iter__"):
                val = [val]
            for v in val:
                if v is not None:
                    # Don't call str() on bytestrings: in Py3 it all goes wrong.
                    if not isinstance(v, bytes):
                        v = str(v)

                    new_fields.append(
                        (
                            field.decode("utf-8")
                            if isinstance(field, bytes)
                            else field,
                            v.encode("utf-8") if isinstance(v, str) else v,
                        )
                    )

        for k, v in files:
            # support for explicit filename
            ft = None
            fh = None
            if isinstance(v, (tuple, list)):
                if len(v) == 2:
                    fn, fp = v
                elif len(v) == 3:
                    fn, fp, ft = v
                else:
                    fn, fp, ft, fh = v
            else:
                fn = guess_filename(v) or k
                fp = v

            if isinstance(fp, (str, bytes, bytearray)):
                fdata = fp
            elif hasattr(fp, "read"):
                fdata = fp.read()
            elif fp is None:
                continue
            else:
                fdata = fp

            rf = RequestField(name=k, data=fdata, filename=fn, headers=fh)
            rf.make_multipart(content_type=ft)
            new_fields.append(rf)

        body, content_type = encode_multipart_formdata(new_fields)

        return body, content_type


class RequestHooksMixin:
    def register_hook(self, event, hook):
        """Properly register a hook."""

        if event not in self.hooks:
            raise ValueError(f'Unsupported event specified, with event name "{event}"')

        if isinstance(hook, Callable):
            self.hooks[event].append(hook)
        elif hasattr(hook, "__iter__"):
            self.hooks[event].extend(h for h in hook if isinstance(h, Callable))

    def deregister_hook(self, event, hook):
        """Deregister a previously registered hook.
        Returns True if the hook existed, False if not.
        """

        try:
            self.hooks[event].remove(hook)
            return True
        except ValueError:
            return False


class Request(RequestHooksMixin):
    """A user-created :class:`Request <Request>` object.

    Used to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.

    :param method: HTTP method to use.
    :param url: URL to send.
    :param headers: dictionary of headers to send.
    :param files: dictionary of {filename: fileobject} files to multipart upload.
    :param data: the body to attach to the request. If a dictionary or
        list of tuples ``[(key, value)]`` is provided, form-encoding will
        take place.
    :param json: json for the body to attach to the request (if files or data is not specified).
    :param params: URL parameters to append to the URL. If a dictionary or
        list of tuples ``[(key, value)]`` is provided, form-encoding will
        take place.
    :param auth: Auth handler or (user, pass) tuple.
    :param cookies: dictionary or CookieJar of cookies to attach to this request.
    :param hooks: dictionary of callback hooks, for internal usage.

    Usage::

      >>> import requests
      >>> req = requests.Request('GET', 'https://httpbin.org/get')
      >>> req.prepare()
      <PreparedRequest [GET]>
    """

    def __init__(
        self,
        method=None,
        url=None,
        headers=None,
        files=None,
        data=None,
        params=None,
        auth=None,
        cookies=None,
        hooks=None,
        json=None,
    ):
        # Default empty dicts for dict params.
        data = [] if data is None else data
        files = [] if files is None else files
        headers = {} if headers is None else headers
        params = {} if params is None else params
        hooks = {} if hooks is None else hooks

        self.hooks = default_hooks()
        for k, v in list(hooks.items()):
            self.register_hook(event=k, hook=v)

        self.method = method
        self.url = url
        self.headers = headers
        self.files = files
        self.data = data
        self.json = json
        self.params = params
        self.auth = auth
        self.cookies = cookies

    def __repr__(self):
        return f"<Request [{self.method}]>"

    def prepare(self):
        """Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it."""
        p = PreparedRequest()
        p.prepare(
            method=self.method,
            url=self.url,
            headers=self.headers,
            files=self.files,
            data=self.data,
            json=self.json,
            params=self.params,
            auth=self.auth,
            cookies=self.cookies,
            hooks=self.hooks,
        )
        return p


class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):
    """The fully mutable :class:`PreparedRequest <PreparedRequest>` object,
    containing the exact bytes that will be sent to the server.

    Instances are generated from a :class:`Request <Request>` object, and
    should not be instantiated manually; doing so may produce undesirable
    effects.

    Usage::

      >>> import requests
      >>> req = requests.Request('GET', 'https://httpbin.org/get')
      >>> r = req.prepare()
      >>> r
      <PreparedRequest [GET]>

      >>> s = requests.Session()
      >>> s.send(r)
      <Response [200]>
    """

    def __init__(self):
        #: HTTP verb to send to the server.
        self.method = None
        #: HTTP URL to send the request to.
        self.url = None
        #: dictionary of HTTP headers.
        self.headers = None
        # The `CookieJar` used to create the Cookie header will be stored here
        # after prepare_cookies is called
        self._cookies = None
        #: request body to send to the server.
        self.body = None
        #: dictionary of callback hooks, for internal usage.
        self.hooks = default_hooks()
        #: integer denoting starting position of a readable file-like body.
        self._body_position = None

    def prepare(
        self,
        method=None,
        url=None,
        headers=None,
        files=None,
        data=None,
        params=None,
        auth=None,
        cookies=None,
        hooks=None,
        json=None,
    ):
        """Prepares the entire request with the given parameters."""

        self.prepare_method(method)
        self.prepare_url(url, params)
        self.prepare_headers(headers)
        self.prepare_cookies(cookies)
        self.prepare_body(data, files, json)
        self.prepare_auth(auth, url)

        # Note that prepare_auth must be last to enable authentication schemes
        # such as OAuth to work on a fully prepared request.

        # This MUST go after prepare_auth. Authenticators could add a hook
        self.prepare_hooks(hooks)

    def __repr__(self):
        return f"<PreparedRequest [{self.method}]>"

    def copy(self):
        p = PreparedRequest()
        p.method = self.method
        p.url = self.url
        p.headers = self.headers.copy() if self.headers is not None else None
        p._cookies = _copy_cookie_jar(self._cookies)
        p.body = self.body
        p.hooks = self.hooks
        p._body_position = self._body_position
        return p

    def prepare_method(self, method):
        """Prepares the given HTTP method."""
        self.method = method
        if self.method is not None:
            self.method = to_native_string(self.method.upper())

    @staticmethod
    def _get_idna_encoded_host(host):
        import idna

        try:
            host = idna.encode(host, uts46=True).decode("utf-8")
        except idna.IDNAError:
            raise UnicodeError
        return host

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)

        # Remove leading whitespaces from url
        url = url.lstrip()

        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return

        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)

        if not scheme:
            raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )

        if not host:
            raise InvalidURL(f"Invalid URL {url!r}: No host supplied")

        # In general, we want to try IDNA encoding the hostname if the string contains
        # non-ASCII characters. This allows users to automatically get the correct IDNA
        # behaviour. For strings containing only ASCII characters, we need to also verify
        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.
        if not unicode_is_ascii(host):
            try:
                host = self._get_idna_encoded_host(host)
            except UnicodeError:
                raise InvalidURL("URL has an invalid label.")
        elif host.startswith(("*", ".")):
            raise InvalidURL("URL has an invalid label.")

        # Carefully reconstruct the network location
        netloc = auth or ""
        if netloc:
            netloc += "@"
        netloc += host
        if port:
            netloc += f":{port}"

        # Bare domains aren't valid URLs.
        if not path:
            path = "/"

        if isinstance(params, (str, bytes)):
            params = to_native_string(params)

        enc_params = self._encode_params(params)
        if enc_params:
            if query:
                query = f"{query}&{enc_params}"
            else:
                query = enc_params

        url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))
        self.url = url

    def prepare_headers(self, headers):
        """Prepares the given HTTP headers."""

        self.headers = CaseInsensitiveDict()
        if headers:
            for header in headers.items():
                # Raise exception on invalid header value.
                check_header_validity(header)
                name, value = header
                self.headers[to_native_string(name)] = value

    def prepare_body(self, data, files, json=None):
        """Prepares the given HTTP body data."""

        # Check if file, fo, generator, iterator.
        # If not, run through normal process.

        # Nottin' on you.
        body = None
        content_type = None

        if not data and json is not None:
            # urllib3 requires a bytes-like body. Python 2's json.dumps
            # provides this natively, but Python 3 gives a Unicode string.
            content_type = "application/json"

            try:
                body = complexjson.dumps(json, allow_nan=False)
            except ValueError as ve:
                raise InvalidJSONError(ve, request=self)

            if not isinstance(body, bytes):
                body = body.encode("utf-8")

        is_stream = all(
            [
                hasattr(data, "__iter__"),
                not isinstance(data, (basestring, list, tuple, Mapping)),
            ]
        )

        if is_stream:
            try:
                length = super_len(data)
            except (TypeError, AttributeError, UnsupportedOperation):
                length = None

            body = data

            if getattr(body, "tell", None) is not None:
                # Record the current file position before reading.
                # This will allow us to rewind a file in the event
                # of a redirect.
                try:
                    self._body_position = body.tell()
                except OSError:
                    # This differentiates from None, allowing us to catch
                    # a failed `tell()` later when trying to rewind the body
                    self._body_position = object()

            if files:
                raise NotImplementedError(
                    "Streamed bodies and files are mutually exclusive."
                )

            if length:
                self.headers["Content-Length"] = builtin_str(length)
            else:
                self.headers["Transfer-Encoding"] = "chunked"
        else:
            # Multi-part file uploads.
            if files:
                (body, content_type) = self._encode_files(files, data)
            else:
                if data:
                    body = self._encode_params(data)
                    if isinstance(data, basestring) or hasattr(data, "read"):
                        content_type = None
                    else:
                        content_type = "application/x-www-form-urlencoded"

            self.prepare_content_length(body)

            # Add content-type if it wasn't explicitly provided.
            if content_type and ("content-type" not in self.headers):
                self.headers["Content-Type"] = content_type

        self.body = body

    def prepare_content_length(self, body):
        """Prepare Content-Length header based on request method and body"""
        if body is not None:
            length = super_len(body)
            if length:
                # If length exists, set it. Otherwise, we fallback
                # to Transfer-Encoding: chunked.
                self.headers["Content-Length"] = builtin_str(length)
        elif (
            self.method not in ("GET", "HEAD")
            and self.headers.get("Content-Length") is None
        ):
            # Set Content-Length to 0 for methods that can have a body
            # but don't provide one. (i.e. not GET or HEAD)
            self.headers["Content-Length"] = "0"

    def prepare_auth(self, auth, url=""):
        """Prepares the given HTTP auth data."""

        # If no Auth is explicitly provided, extract it from the URL first.
        if auth is None:
            url_auth = get_auth_from_url(self.url)
            auth = url_auth if any(url_auth) else None

        if auth:
            if isinstance(auth, tuple) and len(auth) == 2:
                # special-case basic HTTP auth
                auth = HTTPBasicAuth(*auth)

            # Allow auth to make its changes.
            r = auth(self)

            # Update self to reflect the auth changes.
            self.__dict__.update(r.__dict__)

            # Recompute Content-Length
            self.prepare_content_length(self.body)

    def prepare_cookies(self, cookies):
        """Prepares the given HTTP cookie data.

        This function eventually generates a ``Cookie`` header from the
        given cookies using cookielib. Due to cookielib's design, the header
        will not be regenerated if it already exists, meaning this function
        can only be called once for the life of the
        :class:`PreparedRequest <PreparedRequest>` object. Any subsequent calls
        to ``prepare_cookies`` will have no actual effect, unless the "Cookie"
        header is removed beforehand.
        """
        if isinstance(cookies, cookielib.CookieJar):
            self._cookies = cookies
        else:
            self._cookies = cookiejar_from_dict(cookies)

        cookie_header = get_cookie_header(self._cookies, self)
        if cookie_header is not None:
            self.headers["Cookie"] = cookie_header

    def prepare_hooks(self, hooks):
        """Prepares the given hooks."""
        # hooks can be passed as None to the prepare method and to this
        # method. To prevent iterating over None, simply use an empty list
        # if hooks is False-y
        hooks = hooks or []
        for event in hooks:
            self.register_hook(event, hooks[event])


class Response:
    """The :class:`Response <Response>` object, which contains a
    server's response to an HTTP request.
    """

    __attrs__ = [
        "_content",
        "status_code",
        "headers",
        "url",
        "history",
        "encoding",
        "reason",
        "cookies",
        "elapsed",
        "request",
    ]

    def __init__(self):
        self._content = False
        self._content_consumed = False
        self._next = None

        #: Integer Code of responded HTTP Status, e.g. 404 or 200.
        self.status_code = None

        #: Case-insensitive Dictionary of Response Headers.
        #: For example, ``headers['content-encoding']`` will return the
        #: value of a ``'Content-Encoding'`` response header.
        self.headers = CaseInsensitiveDict()

        #: File-like object representation of response (for advanced usage).
        #: Use of ``raw`` requires that ``stream=True`` be set on the request.
        #: This requirement does not apply for use internally to Requests.
        self.raw = None

        #: Final URL location of Response.
        self.url = None

        #: Encoding to decode with when accessing r.text.
        self.encoding = None

        #: A list of :class:`Response <Response>` objects from
        #: the history of the Request. Any redirect responses will end
        #: up here. The list is sorted from the oldest to the most recent request.
        self.history = []

        #: Textual reason of responded HTTP Status, e.g. "Not Found" or "OK".
        self.reason = None

        #: A CookieJar of Cookies the server sent back.
        self.cookies = cookiejar_from_dict({})

        #: The amount of time elapsed between sending the request
        #: and the arrival of the response (as a timedelta).
        #: This property specifically measures the time taken between sending
        #: the first byte of the request and finishing parsing the headers. It
        #: is therefore unaffected by consuming the response content or the
        #: value of the ``stream`` keyword argument.
        self.elapsed = datetime.timedelta(0)

        #: The :class:`PreparedRequest <PreparedRequest>` object to which this
        #: is a response.
        self.request = None

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def __getstate__(self):
        # Consume everything; accessing the content attribute makes
        # sure the content has been fully read.
        if not self._content_consumed:
            self.content

        return {attr: getattr(self, attr, None) for attr in self.__attrs__}

    def __setstate__(self, state):
        for name, value in state.items():
            setattr(self, name, value)

        # pickled objects do not have .raw
        setattr(self, "_content_consumed", True)
        setattr(self, "raw", None)

    def __repr__(self):
        return f"<Response [{self.status_code}]>"

    def __bool__(self):
        """Returns True if :attr:`status_code` is less than 400.

        This attribute checks if the status code of the response is between
        400 and 600 to see if there was a client error or a server error. If
        the status code, is between 200 and 400, this will return True. This
        is **not** a check to see if the response code is ``200 OK``.
        """
        return self.ok

    def __nonzero__(self):
        """Returns True if :attr:`status_code` is less than 400.

        This attribute checks if the status code of the response is between
        400 and 600 to see if there was a client error or a server error. If
        the status code, is between 200 and 400, this will return True. This
        is **not** a check to see if the response code is ``200 OK``.
        """
        return self.ok

    def __iter__(self):
        """Allows you to use a response as an iterator."""
        return self.iter_content(128)

    @property
    def ok(self):
        """Returns True if :attr:`status_code` is less than 400, False if not.

        This attribute checks if the status code of the response is between
        400 and 600 to see if there was a client error or a server error. If
        the status code is between 200 and 400, this will return True. This
        is **not** a check to see if the response code is ``200 OK``.
        """
        try:
            self.raise_for_status()
        except HTTPError:
            return False
        return True

    @property
    def is_redirect(self):
        """True if this Response is a well-formed HTTP redirect that could have
        been processed automatically (by :meth:`Session.resolve_redirects`).
        """
        return "location" in self.headers and self.status_code in REDIRECT_STATI

    @property
    def is_permanent_redirect(self):
        """True if this Response one of the permanent versions of redirect."""
        return "location" in self.headers and self.status_code in (
            codes.moved_permanently,
            codes.permanent_redirect,
        )

    @property
    def next(self):
        """Returns a PreparedRequest for the next request in a redirect chain, if there is one."""
        return self._next

    @property
    def apparent_encoding(self):
        """The apparent encoding, provided by the charset_normalizer or chardet libraries."""
        if chardet is not None:
            return chardet.detect(self.content)["encoding"]
        else:
            # If no character detection library is available, we'll fall back
            # to a standard Python utf-8 str.
            return "utf-8"

    def iter_content(self, chunk_size=1, decode_unicode=False):
        """Iterates over the response data.  When stream=True is set on the
        request, this avoids reading the content at once into memory for
        large responses.  The chunk size is the number of bytes it should
        read into memory.  This is not necessarily the length of each item
        returned as decoding can take place.

        chunk_size must be of type int or None. A value of None will
        function differently depending on the value of `stream`.
        stream=True will read data as it arrives in whatever size the
        chunks are received. If stream=False, data is returned as
        a single chunk.

        If decode_unicode is True, content will be decoded using the best
        available encoding based on the response.
        """

        def generate():
            # Special case for urllib3.
            if hasattr(self.raw, "stream"):
                try:
                    yield from self.raw.stream(chunk_size, decode_content=True)
                except ProtocolError as e:
                    raise ChunkedEncodingError(e)
                except DecodeError as e:
                    raise ContentDecodingError(e)
                except ReadTimeoutError as e:
                    raise ConnectionError(e)
                except SSLError as e:
                    raise RequestsSSLError(e)
            else:
                # Standard file-like object.
                while True:
                    chunk = self.raw.read(chunk_size)
                    if not chunk:
                        break
                    yield chunk

            self._content_consumed = True

        if self._content_consumed and isinstance(self._content, bool):
            raise StreamConsumedError()
        elif chunk_size is not None and not isinstance(chunk_size, int):
            raise TypeError(
                f"chunk_size must be an int, it is instead a {type(chunk_size)}."
            )
        # simulate reading small chunks of the content
        reused_chunks = iter_slices(self._content, chunk_size)

        stream_chunks = generate()

        chunks = reused_chunks if self._content_consumed else stream_chunks

        if decode_unicode:
            chunks = stream_decode_response_unicode(chunks, self)

        return chunks

    def iter_lines(
        self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None
    ):
        """Iterates over the response data, one line at a time.  When
        stream=True is set on the request, this avoids reading the
        content at once into memory for large responses.

        .. note:: This method is not reentrant safe.
        """

        pending = None

        for chunk in self.iter_content(
            chunk_size=chunk_size, decode_unicode=decode_unicode
        ):
            if pending is not None:
                chunk = pending + chunk

            if delimiter:
                lines = chunk.split(delimiter)
            else:
                lines = chunk.splitlines()

            if lines and lines[-1] and chunk and lines[-1][-1] == chunk[-1]:
                pending = lines.pop()
            else:
                pending = None

            yield from lines

        if pending is not None:
            yield pending

    @property
    def content(self):
        """Content of the response, in bytes."""

        if self._content is False:
            # Read the contents.
            if self._content_consumed:
                raise RuntimeError("The content for this response was already consumed")

            if self.status_code == 0 or self.raw is None:
                self._content = None
            else:
                self._content = b"".join(self.iter_content(CONTENT_CHUNK_SIZE)) or b""

        self._content_consumed = True
        # don't need to release the connection; that's been handled by urllib3
        # since we exhausted the data.
        return self._content

    @property
    def text(self):
        """Content of the response, in unicode.

        If Response.encoding is None, encoding will be guessed using
        ``charset_normalizer`` or ``chardet``.

        The encoding of the response content is determined based solely on HTTP
        headers, following RFC 2616 to the letter. If you can take advantage of
        non-HTTP knowledge to make a better guess at the encoding, you should
        set ``r.encoding`` appropriately before accessing this property.
        """

        # Try charset from content-type
        content = None
        encoding = self.encoding

        if not self.content:
            return ""

        # Fallback to auto-detected encoding.
        if self.encoding is None:
            encoding = self.apparent_encoding

        # Decode unicode from given encoding.
        try:
            content = str(self.content, encoding, errors="replace")
        except (LookupError, TypeError):
            # A LookupError is raised if the encoding was not found which could
            # indicate a misspelling or similar mistake.
            #
            # A TypeError can be raised if encoding is None
            #
            # So we try blindly encoding.
            content = str(self.content, errors="replace")

        return content

    def json(self, **kwargs):
        r"""Returns the json-encoded content of a response, if any.

        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """

        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)

        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
            raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)

    @property
    def links(self):
        """Returns the parsed header links of the response, if any."""

        header = self.headers.get("link")

        resolved_links = {}

        if header:
            links = parse_header_links(header)

            for link in links:
                key = link.get("rel") or link.get("url")
                resolved_links[key] = link

        return resolved_links

    def raise_for_status(self):
        """Raises :class:`HTTPError`, if one occurred."""

        http_error_msg = ""
        if isinstance(self.reason, bytes):
            # We attempt to decode utf-8 first because some servers
            # choose to localize their reason strings. If the string
            # isn't utf-8, we fall back to iso-8859-1 for all other
            # encodings. (See PR #3538)
            try:
                reason = self.reason.decode("utf-8")
            except UnicodeDecodeError:
                reason = self.reason.decode("iso-8859-1")
        else:
            reason = self.reason

        if 400 <= self.status_code < 500:
            http_error_msg = (
                f"{self.status_code} Client Error: {reason} for url: {self.url}"
            )

        elif 500 <= self.status_code < 600:
            http_error_msg = (
                f"{self.status_code} Server Error: {reason} for url: {self.url}"
            )

        if http_error_msg:
            raise HTTPError(http_error_msg, response=self)

    def close(self):
        """Releases the connection back to the pool. Once this method has been
        called the underlying ``raw`` object must not be accessed again.

        *Note: Should not normally need to be called explicitly.*
        """
        if not self._content_consumed:
            self.raw.close()

        release_conn = getattr(self.raw, "release_conn", None)
        if release_conn is not None:
            release_conn()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\requests\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\authtoken\admin.py ---

from django.contrib import admin
from django.contrib.admin.utils import quote
from django.contrib.admin.views.main import ChangeList
from django.contrib.auth import get_user_model
from django.core.exceptions import ValidationError
from django.urls import reverse
from django.utils.translation import gettext_lazy as _

from rest_framework.authtoken.models import Token, TokenProxy

User = get_user_model()


class TokenChangeList(ChangeList):
    """Map to matching User id"""
    def url_for_result(self, result):
        pk = result.user.pk
        return reverse('admin:%s_%s_change' % (self.opts.app_label,
                                               self.opts.model_name),
                       args=(quote(pk),),
                       current_app=self.model_admin.admin_site.name)


class TokenAdmin(admin.ModelAdmin):
    list_display = ('key', 'user', 'created')
    fields = ('user',)
    search_fields = ('user__username',)
    search_help_text = _('Username')
    ordering = ('-created',)
    actions = None  # Actions not compatible with mapped IDs.

    def get_changelist(self, request, **kwargs):
        return TokenChangeList

    def get_object(self, request, object_id, from_field=None):
        """
        Map from User ID to matching Token.
        """
        queryset = self.get_queryset(request)
        field = User._meta.pk
        try:
            object_id = field.to_python(object_id)
            user = User.objects.get(**{field.name: object_id})
            return queryset.get(user=user)
        except (queryset.model.DoesNotExist, User.DoesNotExist, ValidationError, ValueError):
            return None

    def delete_model(self, request, obj):
        # Map back to actual Token, since delete() uses pk.
        token = Token.objects.get(key=obj.key)
        return super().delete_model(request, token)


admin.site.register(TokenProxy, TokenAdmin)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\authtoken\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\authtoken\apps.py ---

from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _


class AuthTokenConfig(AppConfig):
    name = 'rest_framework.authtoken'
    verbose_name = _("Auth Token")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\authtoken\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\authtoken\models.py ---

import binascii
import os

from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _


class Token(models.Model):
    """
    The default authorization token model.
    """
    key = models.CharField(_("Key"), max_length=40, primary_key=True)
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL, related_name='auth_token',
        on_delete=models.CASCADE, verbose_name=_("User")
    )
    created = models.DateTimeField(_("Created"), auto_now_add=True)

    class Meta:
        # Work around for a bug in Django:
        # https://code.djangoproject.com/ticket/19422
        #
        # Also see corresponding ticket:
        # https://github.com/encode/django-rest-framework/issues/705
        abstract = 'rest_framework.authtoken' not in settings.INSTALLED_APPS
        verbose_name = _("Token")
        verbose_name_plural = _("Tokens")

    def save(self, *args, **kwargs):
        if not self.key:
            self.key = self.generate_key()
        return super().save(*args, **kwargs)

    @classmethod
    def generate_key(cls):
        return binascii.hexlify(os.urandom(20)).decode()

    def __str__(self):
        return self.key


class TokenProxy(Token):
    """
    Proxy mapping pk to user pk for use in admin.
    """
    @property
    def pk(self):
        return self.user_id

    class Meta:
        proxy = 'rest_framework.authtoken' in settings.INSTALLED_APPS
        abstract = 'rest_framework.authtoken' not in settings.INSTALLED_APPS
        verbose_name = _("Token")
        verbose_name_plural = _("Tokens")

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\authtoken\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\authtoken\serializers.py ---

from django.contrib.auth import authenticate
from django.utils.translation import gettext_lazy as _

from rest_framework import serializers


class AuthTokenSerializer(serializers.Serializer):
    username = serializers.CharField(
        label=_("Username"),
        write_only=True
    )
    password = serializers.CharField(
        label=_("Password"),
        style={'input_type': 'password'},
        trim_whitespace=False,
        write_only=True
    )
    token = serializers.CharField(
        label=_("Token"),
        read_only=True
    )

    def validate(self, attrs):
        username = attrs.get('username')
        password = attrs.get('password')

        if username and password:
            user = authenticate(request=self.context.get('request'),
                                username=username, password=password)

            # The authenticate call simply returns None for is_active=False
            # users. (Assuming the default ModelBackend authentication
            # backend.)
            if not user:
                msg = _('Unable to log in with provided credentials.')
                raise serializers.ValidationError(msg, code='authorization')
        else:
            msg = _('Must include "username" and "password".')
            raise serializers.ValidationError(msg, code='authorization')

        attrs['user'] = user
        return attrs

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\authtoken\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\authtoken\views.py ---

from rest_framework import parsers, renderers
from rest_framework.authtoken.models import Token
from rest_framework.authtoken.serializers import AuthTokenSerializer
from rest_framework.compat import coreapi, coreschema
from rest_framework.response import Response
from rest_framework.schemas import ManualSchema
from rest_framework.schemas import coreapi as coreapi_schema
from rest_framework.views import APIView


class ObtainAuthToken(APIView):
    throttle_classes = ()
    permission_classes = ()
    parser_classes = (parsers.FormParser, parsers.MultiPartParser, parsers.JSONParser,)
    renderer_classes = (renderers.JSONRenderer,)
    serializer_class = AuthTokenSerializer

    if coreapi_schema.is_enabled():
        schema = ManualSchema(
            fields=[
                coreapi.Field(
                    name="username",
                    required=True,
                    location='form',
                    schema=coreschema.String(
                        title="Username",
                        description="Valid username for authentication",
                    ),
                ),
                coreapi.Field(
                    name="password",
                    required=True,
                    location='form',
                    schema=coreschema.String(
                        title="Password",
                        description="Valid password for authentication",
                    ),
                ),
            ],
            encoding="application/json",
        )

    def get_serializer_context(self):
        return {
            'request': self.request,
            'format': self.format_kwarg,
            'view': self
        }

    def get_serializer(self, *args, **kwargs):
        kwargs['context'] = self.get_serializer_context()
        return self.serializer_class(*args, **kwargs)

    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.validated_data['user']
        token, created = Token.objects.get_or_create(user=user)
        return Response({'token': token.key})


obtain_auth_token = ObtainAuthToken.as_view()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\authtoken\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\schemas\views.py ---

"""
views.py        # Houses `SchemaView`, `APIView` subclass.

See schemas.__init__.py for package overview.
"""
from rest_framework import exceptions, renderers
from rest_framework.response import Response
from rest_framework.schemas import coreapi
from rest_framework.settings import api_settings
from rest_framework.views import APIView


class SchemaView(APIView):
    _ignore_model_permissions = True
    schema = None  # exclude from schema
    renderer_classes = None
    schema_generator = None
    public = False

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.renderer_classes is None:
            if coreapi.is_enabled():
                self.renderer_classes = [
                    renderers.CoreAPIOpenAPIRenderer,
                    renderers.CoreJSONRenderer
                ]
            else:
                self.renderer_classes = [
                    renderers.OpenAPIRenderer,
                    renderers.JSONOpenAPIRenderer,
                ]
            if renderers.BrowsableAPIRenderer in api_settings.DEFAULT_RENDERER_CLASSES:
                self.renderer_classes += [renderers.BrowsableAPIRenderer]

    def get(self, request, *args, **kwargs):
        schema = self.schema_generator.get_schema(request, self.public)
        if schema is None:
            raise exceptions.PermissionDenied()
        return Response(schema)

    def handle_exception(self, exc):
        # Schema renderers do not render exceptions, so re-perform content
        # negotiation with default renderers.
        self.renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES
        neg = self.perform_content_negotiation(self.request, force=True)
        self.request.accepted_renderer, self.request.accepted_media_type = neg
        return super().handle_exception(exc)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\schemas\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\utils\urls.py ---

from urllib import parse

from django.utils.encoding import force_str


def replace_query_param(url, key, val):
    """
    Given a URL and a key/val pair, set or replace an item in the query
    parameters of the URL, and return the new URL.
    """
    (scheme, netloc, path, query, fragment) = parse.urlsplit(force_str(url))
    query_dict = parse.parse_qs(query, keep_blank_values=True)
    query_dict[force_str(key)] = [force_str(val)]
    query = parse.urlencode(sorted(query_dict.items()), doseq=True)
    return parse.urlunsplit((scheme, netloc, path, query, fragment))


def remove_query_param(url, key):
    """
    Given a URL and a key/val pair, remove an item in the query
    parameters of the URL, and return the new URL.
    """
    (scheme, netloc, path, query, fragment) = parse.urlsplit(force_str(url))
    query_dict = parse.parse_qs(query, keep_blank_values=True)
    query_dict.pop(key, None)
    query = parse.urlencode(sorted(query_dict.items()), doseq=True)
    return parse.urlunsplit((scheme, netloc, path, query, fragment))

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\utils\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\apps.py ---

from django.apps import AppConfig


class RestFrameworkConfig(AppConfig):
    name = 'rest_framework'
    verbose_name = "Django REST framework"

    def ready(self):
        # Add System checks
        from .checks import pagination_system_check  # NOQA

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\serializers.py ---

"""
Serializers and ModelSerializers are similar to Forms and ModelForms.
Unlike forms, they are not constrained to dealing with HTML output, and
form encoded input.

Serialization in REST framework is a two-phase process:

1. Serializers marshal between complex types like model instances, and
python primitives.
2. The process of marshalling between python primitives and request and
response content is handled by parsers and renderers.
"""

import contextlib
import copy
import inspect
import traceback
from collections import defaultdict
from collections.abc import Mapping

from django.core.exceptions import FieldDoesNotExist, ImproperlyConfigured
from django.core.exceptions import ValidationError as DjangoValidationError
from django.db import models
from django.db.models.fields import Field as DjangoModelField
from django.utils import timezone
from django.utils.functional import cached_property
from django.utils.translation import gettext_lazy as _

from rest_framework.compat import postgres_fields
from rest_framework.exceptions import ErrorDetail, ValidationError
from rest_framework.fields import get_error_detail
from rest_framework.settings import api_settings
from rest_framework.utils import html, model_meta, representation
from rest_framework.utils.field_mapping import (
    ClassLookupDict, get_field_kwargs, get_nested_relation_kwargs,
    get_relation_kwargs, get_url_kwargs
)
from rest_framework.utils.serializer_helpers import (
    BindingDict, BoundField, JSONBoundField, NestedBoundField, ReturnDict,
    ReturnList
)
from rest_framework.validators import (
    UniqueForDateValidator, UniqueForMonthValidator, UniqueForYearValidator,
    UniqueTogetherValidator
)

# Note: We do the following so that users of the framework can use this style:
#
#     example_field = serializers.CharField(...)
#
# This helps keep the separation between model fields, form fields, and
# serializer fields more explicit.
from rest_framework.fields import (  # NOQA # isort:skip
    BooleanField, CharField, ChoiceField, DateField, DateTimeField, DecimalField,
    DictField, DurationField, EmailField, Field, FileField, FilePathField, FloatField,
    HiddenField, HStoreField, IPAddressField, ImageField, IntegerField, JSONField,
    ListField, ModelField, MultipleChoiceField, ReadOnlyField,
    RegexField, SerializerMethodField, SlugField, TimeField, URLField, UUIDField,
)
from rest_framework.relations import (  # NOQA # isort:skip
    HyperlinkedIdentityField, HyperlinkedRelatedField, ManyRelatedField,
    PrimaryKeyRelatedField, RelatedField, SlugRelatedField, StringRelatedField,
)

# Non-field imports, but public API
from rest_framework.fields import (  # NOQA # isort:skip
    CreateOnlyDefault, CurrentUserDefault, SkipField, empty
)
from rest_framework.relations import Hyperlink, PKOnlyObject  # NOQA # isort:skip

# We assume that 'validators' are intended for the child serializer,
# rather than the parent serializer.
LIST_SERIALIZER_KWARGS = (
    'read_only', 'write_only', 'required', 'default', 'initial', 'source',
    'label', 'help_text', 'style', 'error_messages', 'allow_empty',
    'instance', 'data', 'partial', 'context', 'allow_null',
    'max_length', 'min_length'
)
LIST_SERIALIZER_KWARGS_REMOVE = ('allow_empty', 'min_length', 'max_length')

ALL_FIELDS = '__all__'


# BaseSerializer
# --------------

class BaseSerializer(Field):
    """
    The BaseSerializer class provides a minimal class which may be used
    for writing custom serializer implementations.

    Note that we strongly restrict the ordering of operations/properties
    that may be used on the serializer in order to enforce correct usage.

    In particular, if a `data=` argument is passed then:

    .is_valid() - Available.
    .initial_data - Available.
    .validated_data - Only available after calling `is_valid()`
    .errors - Only available after calling `is_valid()`
    .data - Only available after calling `is_valid()`

    If a `data=` argument is not passed then:

    .is_valid() - Not available.
    .initial_data - Not available.
    .validated_data - Not available.
    .errors - Not available.
    .data - Available.
    """

    def __init__(self, instance=None, data=empty, **kwargs):
        self.instance = instance
        if data is not empty:
            self.initial_data = data
        self.partial = kwargs.pop('partial', False)
        self._context = kwargs.pop('context', {})
        kwargs.pop('many', None)
        super().__init__(**kwargs)

    def __new__(cls, *args, **kwargs):
        # We override this method in order to automatically create
        # `ListSerializer` classes instead when `many=True` is set.
        if kwargs.pop('many', False):
            return cls.many_init(*args, **kwargs)
        return super().__new__(cls, *args, **kwargs)

    # Allow type checkers to make serializers generic.
    def __class_getitem__(cls, *args, **kwargs):
        return cls

    @classmethod
    def many_init(cls, *args, **kwargs):
        """
        This method implements the creation of a `ListSerializer` parent
        class when `many=True` is used. You can customize it if you need to
        control which keyword arguments are passed to the parent, and
        which are passed to the child.

        Note that we're over-cautious in passing most arguments to both parent
        and child classes in order to try to cover the general case. If you're
        overriding this method you'll probably want something much simpler, eg:

        @classmethod
        def many_init(cls, *args, **kwargs):
            kwargs['child'] = cls()
            return CustomListSerializer(*args, **kwargs)
        """
        list_kwargs = {}
        for key in LIST_SERIALIZER_KWARGS_REMOVE:
            value = kwargs.pop(key, None)
            if value is not None:
                list_kwargs[key] = value
        list_kwargs['child'] = cls(*args, **kwargs)
        list_kwargs.update({
            key: value for key, value in kwargs.items()
            if key in LIST_SERIALIZER_KWARGS
        })
        meta = getattr(cls, 'Meta', None)
        list_serializer_class = getattr(meta, 'list_serializer_class', ListSerializer)
        return list_serializer_class(*args, **list_kwargs)

    def to_internal_value(self, data):
        raise NotImplementedError('`to_internal_value()` must be implemented.')

    def to_representation(self, instance):
        raise NotImplementedError('`to_representation()` must be implemented.')

    def update(self, instance, validated_data):
        raise NotImplementedError('`update()` must be implemented.')

    def create(self, validated_data):
        raise NotImplementedError('`create()` must be implemented.')

    def save(self, **kwargs):
        assert hasattr(self, '_errors'), (
            'You must call `.is_valid()` before calling `.save()`.'
        )

        assert not self.errors, (
            'You cannot call `.save()` on a serializer with invalid data.'
        )

        # Guard against incorrect use of `serializer.save(commit=False)`
        assert 'commit' not in kwargs, (
            "'commit' is not a valid keyword argument to the 'save()' method. "
            "If you need to access data before committing to the database then "
            "inspect 'serializer.validated_data' instead. "
            "You can also pass additional keyword arguments to 'save()' if you "
            "need to set extra attributes on the saved model instance. "
            "For example: 'serializer.save(owner=request.user)'.'"
        )

        assert not hasattr(self, '_data'), (
            "You cannot call `.save()` after accessing `serializer.data`."
            "If you need to access data before committing to the database then "
            "inspect 'serializer.validated_data' instead. "
        )

        validated_data = {**self.validated_data, **kwargs}

        if self.instance is not None:
            self.instance = self.update(self.instance, validated_data)
            assert self.instance is not None, (
                '`update()` did not return an object instance.'
            )
        else:
            self.instance = self.create(validated_data)
            assert self.instance is not None, (
                '`create()` did not return an object instance.'
            )

        return self.instance

    def is_valid(self, *, raise_exception=False):
        assert hasattr(self, 'initial_data'), (
            'Cannot call `.is_valid()` as no `data=` keyword argument was '
            'passed when instantiating the serializer instance.'
        )

        if not hasattr(self, '_validated_data'):
            try:
                self._validated_data = self.run_validation(self.initial_data)
            except ValidationError as exc:
                self._validated_data = {}
                self._errors = exc.detail
            else:
                self._errors = {}

        if self._errors and raise_exception:
            raise ValidationError(self.errors)

        return not bool(self._errors)

    @property
    def data(self):
        if hasattr(self, 'initial_data') and not hasattr(self, '_validated_data'):
            msg = (
                'When a serializer is passed a `data` keyword argument you '
                'must call `.is_valid()` before attempting to access the '
                'serialized `.data` representation.\n'
                'You should either call `.is_valid()` first, '
                'or access `.initial_data` instead.'
            )
            raise AssertionError(msg)

        if not hasattr(self, '_data'):
            if self.instance is not None and not getattr(self, '_errors', None):
                self._data = self.to_representation(self.instance)
            elif hasattr(self, '_validated_data') and not getattr(self, '_errors', None):
                self._data = self.to_representation(self.validated_data)
            else:
                self._data = self.get_initial()
        return self._data

    @property
    def errors(self):
        if not hasattr(self, '_errors'):
            msg = 'You must call `.is_valid()` before accessing `.errors`.'
            raise AssertionError(msg)
        return self._errors

    @property
    def validated_data(self):
        if not hasattr(self, '_validated_data'):
            msg = 'You must call `.is_valid()` before accessing `.validated_data`.'
            raise AssertionError(msg)
        return self._validated_data


# Serializer & ListSerializer classes
# -----------------------------------

class SerializerMetaclass(type):
    """
    This metaclass sets a dictionary named `_declared_fields` on the class.

    Any instances of `Field` included as attributes on either the class
    or on any of its superclasses will be include in the
    `_declared_fields` dictionary.
    """

    @classmethod
    def _get_declared_fields(cls, bases, attrs):
        fields = [(field_name, attrs.pop(field_name))
                  for field_name, obj in list(attrs.items())
                  if isinstance(obj, Field)]
        fields.sort(key=lambda x: x[1]._creation_counter)

        # Ensures a base class field doesn't override cls attrs, and maintains
        # field precedence when inheriting multiple parents. e.g. if there is a
        # class C(A, B), and A and B both define 'field', use 'field' from A.
        known = set(attrs)

        def visit(name):
            known.add(name)
            return name

        base_fields = [
            (visit(name), f)
            for base in bases if hasattr(base, '_declared_fields')
            for name, f in base._declared_fields.items() if name not in known
        ]

        return dict(base_fields + fields)

    def __new__(cls, name, bases, attrs):
        attrs['_declared_fields'] = cls._get_declared_fields(bases, attrs)
        return super().__new__(cls, name, bases, attrs)


def as_serializer_error(exc):
    assert isinstance(exc, (ValidationError, DjangoValidationError))

    if isinstance(exc, DjangoValidationError):
        detail = get_error_detail(exc)
    else:
        detail = exc.detail

    if isinstance(detail, Mapping):
        # If errors may be a dict we use the standard {key: list of values}.
        # Here we ensure that all the values are *lists* of errors.
        return {
            key: value if isinstance(value, (list, Mapping)) else [value]
            for key, value in detail.items()
        }
    elif isinstance(detail, list):
        # Errors raised as a list are non-field errors.
        return {
            api_settings.NON_FIELD_ERRORS_KEY: detail
        }
    # Errors raised as a string are non-field errors.
    return {
        api_settings.NON_FIELD_ERRORS_KEY: [detail]
    }


class Serializer(BaseSerializer, metaclass=SerializerMetaclass):
    default_error_messages = {
        'invalid': _('Invalid data. Expected a dictionary, but got {datatype}.')
    }

    def set_value(self, dictionary, keys, value):
        """
        Similar to Python's built in `dictionary[key] = value`,
        but takes a list of nested keys instead of a single key.

        set_value({'a': 1}, [], {'b': 2}) -> {'a': 1, 'b': 2}
        set_value({'a': 1}, ['x'], 2) -> {'a': 1, 'x': 2}
        set_value({'a': 1}, ['x', 'y'], 2) -> {'a': 1, 'x': {'y': 2}}
        """
        if not keys:
            dictionary.update(value)
            return

        for key in keys[:-1]:
            if key not in dictionary:
                dictionary[key] = {}
            dictionary = dictionary[key]

        dictionary[keys[-1]] = value

    @cached_property
    def fields(self):
        """
        A dictionary of {field_name: field_instance}.
        """
        # `fields` is evaluated lazily. We do this to ensure that we don't
        # have issues importing modules that use ModelSerializers as fields,
        # even if Django's app-loading stage has not yet run.
        fields = BindingDict(self)
        for key, value in self.get_fields().items():
            fields[key] = value
        return fields

    @property
    def _writable_fields(self):
        for field in self.fields.values():
            if not field.read_only:
                yield field

    @property
    def _readable_fields(self):
        for field in self.fields.values():
            if not field.write_only:
                yield field

    def get_fields(self):
        """
        Returns a dictionary of {field_name: field_instance}.
        """
        # Every new serializer is created with a clone of the field instances.
        # This allows users to dynamically modify the fields on a serializer
        # instance without affecting every other serializer instance.
        return copy.deepcopy(self._declared_fields)

    def get_validators(self):
        """
        Returns a list of validator callables.
        """
        # Used by the lazily-evaluated `validators` property.
        meta = getattr(self, 'Meta', None)
        validators = getattr(meta, 'validators', None)
        return list(validators) if validators else []

    def get_initial(self):
        if hasattr(self, 'initial_data'):
            # initial_data may not be a valid type
            if not isinstance(self.initial_data, Mapping):
                return {}

            return {
                field_name: field.get_value(self.initial_data)
                for field_name, field in self.fields.items()
                if (field.get_value(self.initial_data) is not empty) and
                not field.read_only
            }

        return {
            field.field_name: field.get_initial()
            for field in self.fields.values()
            if not field.read_only
        }

    def get_value(self, dictionary):
        # We override the default field access in order to support
        # nested HTML forms.
        if html.is_html_input(dictionary):
            return html.parse_html_dict(dictionary, prefix=self.field_name) or empty
        return dictionary.get(self.field_name, empty)

    def run_validation(self, data=empty):
        """
        We override the default `run_validation`, because the validation
        performed by validators and the `.validate()` method should
        be coerced into an error dictionary with a 'non_fields_error' key.
        """
        (is_empty_value, data) = self.validate_empty_values(data)
        if is_empty_value:
            return data

        value = self.to_internal_value(data)
        try:
            self.run_validators(value)
            value = self.validate(value)
            assert value is not None, '.validate() should return the validated data'
        except (ValidationError, DjangoValidationError) as exc:
            raise ValidationError(detail=as_serializer_error(exc))

        return value

    def _read_only_defaults(self):
        fields = [
            field for field in self.fields.values()
            if (field.read_only) and (field.default != empty) and (field.source != '*') and ('.' not in field.source)
        ]

        defaults = {}
        for field in fields:
            try:
                default = field.get_default()
            except SkipField:
                continue
            defaults[field.source] = default

        return defaults

    def run_validators(self, value):
        """
        Add read_only fields with defaults to value before running validators.
        """
        if isinstance(value, dict):
            to_validate = self._read_only_defaults()
            to_validate.update(value)
        else:
            to_validate = value
        super().run_validators(to_validate)

    def to_internal_value(self, data):
        """
        Dict of native values <- Dict of primitive datatypes.
        """
        if not isinstance(data, Mapping):
            message = self.error_messages['invalid'].format(
                datatype=type(data).__name__
            )
            raise ValidationError({
                api_settings.NON_FIELD_ERRORS_KEY: [message]
            }, code='invalid')

        ret = {}
        errors = {}
        fields = self._writable_fields

        for field in fields:
            validate_method = getattr(self, 'validate_' + field.field_name, None)
            primitive_value = field.get_value(data)
            try:
                validated_value = field.run_validation(primitive_value)
                if validate_method is not None:
                    validated_value = validate_method(validated_value)
            except ValidationError as exc:
                errors[field.field_name] = exc.detail
            except DjangoValidationError as exc:
                errors[field.field_name] = get_error_detail(exc)
            except SkipField:
                pass
            else:
                self.set_value(ret, field.source_attrs, validated_value)

        if errors:
            raise ValidationError(errors)

        return ret

    def to_representation(self, instance):
        """
        Object instance -> Dict of primitive datatypes.
        """
        ret = {}
        fields = self._readable_fields

        for field in fields:
            try:
                attribute = field.get_attribute(instance)
            except SkipField:
                continue

            # We skip `to_representation` for `None` values so that fields do
            # not have to explicitly deal with that case.
            #
            # For related fields with `use_pk_only_optimization` we need to
            # resolve the pk value.
            check_for_none = attribute.pk if isinstance(attribute, PKOnlyObject) else attribute
            if check_for_none is None:
                ret[field.field_name] = None
            else:
                ret[field.field_name] = field.to_representation(attribute)

        return ret

    def validate(self, attrs):
        return attrs

    def __repr__(self):
        return representation.serializer_repr(self, indent=1)

    # The following are used for accessing `BoundField` instances on the
    # serializer, for the purposes of presenting a form-like API onto the
    # field values and field errors.

    def __iter__(self):
        for field in self.fields.values():
            yield self[field.field_name]

    def __getitem__(self, key):
        field = self.fields[key]
        value = self.data.get(key)
        error = self.errors.get(key) if hasattr(self, '_errors') else None
        if isinstance(field, Serializer):
            return NestedBoundField(field, value, error)
        if isinstance(field, JSONField):
            return JSONBoundField(field, value, error)
        return BoundField(field, value, error)

    # Include a backlink to the serializer class on return objects.
    # Allows renderers such as HTMLFormRenderer to get the full field info.

    @property
    def data(self):
        ret = super().data
        return ReturnDict(ret, serializer=self)

    @property
    def errors(self):
        ret = super().errors
        if isinstance(ret, list) and len(ret) == 1 and getattr(ret[0], 'code', None) == 'null':
            # Edge case. Provide a more descriptive error than
            # "this field may not be null", when no data is passed.
            detail = ErrorDetail('No data provided', code='null')
            ret = {api_settings.NON_FIELD_ERRORS_KEY: [detail]}
        return ReturnDict(ret, serializer=self)


# There's some replication of `ListField` here,
# but that's probably better than obfuscating the call hierarchy.

class ListSerializer(BaseSerializer):
    child = None
    many = True

    default_error_messages = {
        'not_a_list': _('Expected a list of items but got type "{input_type}".'),
        'empty': _('This list may not be empty.'),
        'max_length': _('Ensure this field has no more than {max_length} elements.'),
        'min_length': _('Ensure this field has at least {min_length} elements.')
    }

    def __init__(self, *args, **kwargs):
        self.child = kwargs.pop('child', copy.deepcopy(self.child))
        self.allow_empty = kwargs.pop('allow_empty', True)
        self.max_length = kwargs.pop('max_length', None)
        self.min_length = kwargs.pop('min_length', None)
        assert self.child is not None, '`child` is a required argument.'
        assert not inspect.isclass(self.child), '`child` has not been instantiated.'
        super().__init__(*args, **kwargs)
        self.child.bind(field_name='', parent=self)

    def get_initial(self):
        if hasattr(self, 'initial_data'):
            return self.to_representation(self.initial_data)
        return []

    def get_value(self, dictionary):
        """
        Given the input dictionary, return the field value.
        """
        # We override the default field access in order to support
        # lists in HTML forms.
        if html.is_html_input(dictionary):
            return html.parse_html_list(dictionary, prefix=self.field_name, default=empty)
        return dictionary.get(self.field_name, empty)

    def run_validation(self, data=empty):
        """
        We override the default `run_validation`, because the validation
        performed by validators and the `.validate()` method should
        be coerced into an error dictionary with a 'non_fields_error' key.
        """
        (is_empty_value, data) = self.validate_empty_values(data)
        if is_empty_value:
            return data

        value = self.to_internal_value(data)
        try:
            self.run_validators(value)
            value = self.validate(value)
            assert value is not None, '.validate() should return the validated data'
        except (ValidationError, DjangoValidationError) as exc:
            raise ValidationError(detail=as_serializer_error(exc))

        return value

    def run_child_validation(self, data):
        """
        Run validation on child serializer.
        You may need to override this method to support multiple updates. For example:

        self.child.instance = self.instance.get(pk=data['id'])
        self.child.initial_data = data
        return super().run_child_validation(data)
        """
        return self.child.run_validation(data)

    def to_internal_value(self, data):
        """
        List of dicts of native values <- List of dicts of primitive datatypes.
        """
        if html.is_html_input(data):
            data = html.parse_html_list(data, default=[])

        if not isinstance(data, list):
            message = self.error_messages['not_a_list'].format(
                input_type=type(data).__name__
            )
            raise ValidationError({
                api_settings.NON_FIELD_ERRORS_KEY: [message]
            }, code='not_a_list')

        if not self.allow_empty and len(data) == 0:
            message = self.error_messages['empty']
            raise ValidationError({
                api_settings.NON_FIELD_ERRORS_KEY: [message]
            }, code='empty')

        if self.max_length is not None and len(data) > self.max_length:
            message = self.error_messages['max_length'].format(max_length=self.max_length)
            raise ValidationError({
                api_settings.NON_FIELD_ERRORS_KEY: [message]
            }, code='max_length')

        if self.min_length is not None and len(data) < self.min_length:
            message = self.error_messages['min_length'].format(min_length=self.min_length)
            raise ValidationError({
                api_settings.NON_FIELD_ERRORS_KEY: [message]
            }, code='min_length')

        ret = []
        errors = []

        for item in data:
            try:
                validated = self.run_child_validation(item)
            except ValidationError as exc:
                errors.append(exc.detail)
            else:
                ret.append(validated)
                errors.append({})

        if any(errors):
            raise ValidationError(errors)

        return ret

    def to_representation(self, data):
        """
        List of object instances -> List of dicts of primitive datatypes.
        """
        # Dealing with nested relationships, data can be a Manager,
        # so, first get a queryset from the Manager if needed
        iterable = data.all() if isinstance(data, models.manager.BaseManager) else data

        return [
            self.child.to_representation(item) for item in iterable
        ]

    def validate(self, attrs):
        return attrs

    def update(self, instance, validated_data):
        raise NotImplementedError(
            "Serializers with many=True do not support multiple update by "
            "default, only multiple create. For updates it is unclear how to "
            "deal with insertions and deletions. If you need to support "
            "multiple update, use a `ListSerializer` class and override "
            "`.update()` so you can specify the behavior exactly."
        )

    def create(self, validated_data):
        return [
            self.child.create(attrs) for attrs in validated_data
        ]

    def save(self, **kwargs):
        """
        Save and return a list of object instances.
        """
        # Guard against incorrect use of `serializer.save(commit=False)`
        assert 'commit' not in kwargs, (
            "'commit' is not a valid keyword argument to the 'save()' method. "
            "If you need to access data before committing to the database then "
            "inspect 'serializer.validated_data' instead. "
            "You can also pass additional keyword arguments to 'save()' if you "
            "need to set extra attributes on the saved model instance. "
            "For example: 'serializer.save(owner=request.user)'.'"
        )

        validated_data = [
            {**attrs, **kwargs} for attrs in self.validated_data
        ]

        if self.instance is not None:
            self.instance = self.update(self.instance, validated_data)
            assert self.instance is not None, (
                '`update()` did not return an object instance.'
            )
        else:
            self.instance = self.create(validated_data)
            assert self.instance is not None, (
                '`create()` did not return an object instance.'
            )

        return self.instance

    def is_valid(self, *, raise_exception=False):
        # This implementation is the same as the default,
        # except that we use lists, rather than dicts, as the empty case.
        assert hasattr(self, 'initial_data'), (
            'Cannot call `.is_valid()` as no `data=` keyword argument was '
            'passed when instantiating the serializer instance.'
        )

        if not hasattr(self, '_validated_data'):
            try:
                self._validated_data = self.run_validation(self.initial_data)
            except ValidationError as exc:
                self._validated_data = []
                self._errors = exc.detail
            else:
                self._errors = []

        if self._errors and raise_exception:
            raise ValidationError(self.errors)

        return not bool(self._errors)

    def __repr__(self):
        return representation.list_repr(self, indent=1)

    # Include a backlink to the serializer class on return objects.
    # Allows renderers such as HTMLFormRenderer to get the full field info.

    @property
    def data(self):
        ret = super().data
        return ReturnList(ret, serializer=self)

    @property
    def errors(self):
        ret = super().errors
        if isinstance(ret, list) and len(ret) == 1 and getattr(ret[0], 'code', None) == 'null':
            # Edge case. Provide a more descriptive error than
            # "this field may not be null", when no data is passed.
            detail = ErrorDetail('No data provided', code='null')
            ret = {api_settings.NON_FIELD_ERRORS_KEY: [detail]}
        if isinstance(ret, dict):
            return ReturnDict(ret, serializer=self)
        return ReturnList(ret, serializer=self)


# ModelSerializer & HyperlinkedModelSerializer
# --------------------------------------------

def raise_errors_on_nested_writes(method_name, serializer, validated_data):
    """
    Give explicit errors when users attempt to pass writable nested data.

    If we don't do this explicitly they'd get a less helpful error when
    calling `.save()` on the serializer.

    We don't *automatically* support these sorts of nested writes because
    there are too many ambiguities to define a default behavior.

    Eg. Suppose we have a `UserSerializer` with a nested profile. How should
    we handle the case of an update, where the `profile` relationship does
    not exist? Any of the following might be valid:

    * Raise an application error.
    * Silently ignore the nested part of the update.
    * Automatically create a profile instance.
    """
    ModelClass = serializer.Meta.model
    model_field_info = model_meta.get_field_info(ModelClass)

    # Ensure we don't have a writable nested field. For example:
    #
    # class UserSerializer(ModelSerializer):
    #     ...
    #     profile = ProfileSerializer()
    assert not any(
        isinstance(field, BaseSerializer) and
        (field.source in validated_data) and
        (field.source in model_field_info.relations) and
        isinstance(validated_data[field.source], (list, dict))
        for field in serializer._writable_fields
    ), (
        'The `.{method_name}()` method does not support writable nested '
        'fields by default.\nWrite an explicit `.{method_name}()` method for '
        'serializer `{module}.{class_name}`, or set `read_only=True` on '
        'nested serializer fields.'.format(
            method_name=method_name,
            module=serializer.__class__.__module__,
            class_name=serializer.__class__.__name__
        )
    )

    # Ensure we don't have a writable dotted-source field. For example:
    #
    # class UserSerializer(ModelSerializer):
    #     ...
    #     address = serializer.CharField('profile.address')
    #
    # Though, non-relational fields (e.g., JSONField) are acceptable. For example:
    #
    # class NonRelationalPersonModel(models.Model):
    #     profile = JSONField()
    #
    # class UserSerializer(ModelSerializer):
    #     ...
    #     address = serializer.CharField('profile.address')
    assert not any(
        len(field.source_attrs) > 1 and
        (field.source_attrs[0] in validated_data) and
        (field.source_attrs[0] in model_field_info.relations) and
        isinstance(validated_data[field.source_attrs[0]], (list, dict))
        for field in serializer._writable_fields
    ), (
        'The `.{method_name}()` method does not support writable dotted-source '
        'fields by default.\nWrite an explicit `.{method_name}()` method for '
        'serializer `{module}.{class_name}`, or set `read_only=True` on '
        'dotted-source serializer fields.'.format(
            method_name=method_name,
            module=serializer.__class__.__module__,
            class_name=serializer.__class__.__name__
        )
    )


class ModelSerializer(Serializer):
    """
    A `ModelSerializer` is just a regular `Serializer`, except that:

    * A set of default fields are automatically populated.
    * A set of default validators are automatically populated.
    * Default `.create()` and `.update()` implementations are provided.

    The process of automatically determining a set of serializer fields
    based on the model fields is reasonably complex, but you almost certainly
    don't need to dig into the implementation.

    If the `ModelSerializer` class *doesn't* generate the set of fields that
    you need you should either declare the extra/differing fields explicitly on
    the serializer class, or simply use a `Serializer` class.
    """
    serializer_field_mapping = {
        models.AutoField: IntegerField,
        models.BigIntegerField: IntegerField,
        models.BooleanField: BooleanField,
        models.CharField: CharField,
        models.CommaSeparatedIntegerField: CharField,
        models.DateField: DateField,
        models.DateTimeField: DateTimeField,
        models.DecimalField: DecimalField,
        models.DurationField: DurationField,
        models.EmailField: EmailField,
        models.Field: ModelField,
        models.FileField: FileField,
        models.FloatField: FloatField,
        models.ImageField: ImageField,
        models.IntegerField: IntegerField,
        models.NullBooleanField: BooleanField,
        models.PositiveIntegerField: IntegerField,
        models.PositiveSmallIntegerField: IntegerField,
        models.SlugField: SlugField,
        models.SmallIntegerField: IntegerField,
        models.TextField: CharField,
        models.TimeField: TimeField,
        models.URLField: URLField,
        models.UUIDField: UUIDField,
        models.GenericIPAddressField: IPAddressField,
        models.FilePathField: FilePathField,
    }
    if hasattr(models, 'JSONField'):
        serializer_field_mapping[models.JSONField] = JSONField
    if postgres_fields:
        serializer_field_mapping[postgres_fields.HStoreField] = HStoreField
        serializer_field_mapping[postgres_fields.ArrayField] = ListField
        serializer_field_mapping[postgres_fields.JSONField] = JSONField
    serializer_related_field = PrimaryKeyRelatedField
    serializer_related_to_field = SlugRelatedField
    serializer_url_field = HyperlinkedIdentityField
    serializer_choice_field = ChoiceField

    # The field name for hyperlinked identity fields. Defaults to 'url'.
    # You can modify this using the API setting.
    #
    # Note that if you instead need modify this on a per-serializer basis,
    # you'll also need to ensure you update the `create` method on any generic
    # views, to correctly handle the 'Location' response header for
    # "HTTP 201 Created" responses.
    url_field_name = None

    # Default `create` and `update` behavior...
    def create(self, validated_data):
        """
        We have a bit of extra checking around this in order to provide
        descriptive messages when something goes wrong, but this method is
        essentially just:

            return ExampleModel.objects.create(**validated_data)

        If there are many to many fields present on the instance then they
        cannot be set until the model is instantiated, in which case the
        implementation is like so:

            example_relationship = validated_data.pop('example_relationship')
            instance = ExampleModel.objects.create(**validated_data)
            instance.example_relationship = example_relationship
            return instance

        The default implementation also does not handle nested relationships.
        If you want to support writable nested relationships you'll need
        to write an explicit `.create()` method.
        """
        raise_errors_on_nested_writes('create', self, validated_data)

        ModelClass = self.Meta.model

        # Remove many-to-many relationships from validated_data.
        # They are not valid arguments to the default `.create()` method,
        # as they require that the instance has already been saved.
        info = model_meta.get_field_info(ModelClass)
        many_to_many = {}
        for field_name, relation_info in info.relations.items():
            if relation_info.to_many and (field_name in validated_data):
                many_to_many[field_name] = validated_data.pop(field_name)

        try:
            instance = ModelClass._default_manager.create(**validated_data)
        except TypeError:
            tb = traceback.format_exc()
            msg = (
                'Got a `TypeError` when calling `%s.%s.create()`. '
                'This may be because you have a writable field on the '
                'serializer class that is not a valid argument to '
                '`%s.%s.create()`. You may need to make the field '
                'read-only, or override the %s.create() method to handle '
                'this correctly.\nOriginal exception was:\n %s' %
                (
                    ModelClass.__name__,
                    ModelClass._default_manager.name,
                    ModelClass.__name__,
                    ModelClass._default_manager.name,
                    self.__class__.__name__,
                    tb
                )
            )
            raise TypeError(msg)

        # Save many-to-many relationships after the instance is created.
        if many_to_many:
            for field_name, value in many_to_many.items():
                field = getattr(instance, field_name)
                field.set(value)

        return instance

    def update(self, instance, validated_data):
        raise_errors_on_nested_writes('update', self, validated_data)
        info = model_meta.get_field_info(instance)

        # Simply set each attribute on the instance, and then save it.
        # Note that unlike `.create()` we don't need to treat many-to-many
        # relationships as being a special case. During updates we already
        # have an instance pk for the relationships to be associated with.
        m2m_fields = []
        for attr, value in validated_data.items():
            if attr in info.relations and info.relations[attr].to_many:
                m2m_fields.append((attr, value))
            else:
                setattr(instance, attr, value)

        instance.save()

        # Note that many-to-many fields are set after updating instance.
        # Setting m2m fields triggers signals which could potentially change
        # updated instance and we do not want it to collide with .update()
        for attr, value in m2m_fields:
            field = getattr(instance, attr)
            field.set(value)

        return instance

    # Determine the fields to apply...

    def get_fields(self):
        """
        Return the dict of field names -> field instances that should be
        used for `self.fields` when instantiating the serializer.
        """
        if self.url_field_name is None:
            self.url_field_name = api_settings.URL_FIELD_NAME

        assert hasattr(self, 'Meta'), (
            'Class {serializer_class} missing "Meta" attribute'.format(
                serializer_class=self.__class__.__name__
            )
        )
        assert hasattr(self.Meta, 'model'), (
            'Class {serializer_class} missing "Meta.model" attribute'.format(
                serializer_class=self.__class__.__name__
            )
        )
        if model_meta.is_abstract_model(self.Meta.model):
            raise ValueError(
                'Cannot use ModelSerializer with Abstract Models.'
            )

        declared_fields = copy.deepcopy(self._declared_fields)
        model = getattr(self.Meta, 'model')
        depth = getattr(self.Meta, 'depth', 0)

        if depth is not None:
            assert depth >= 0, "'depth' may not be negative."
            assert depth <= 10, "'depth' may not be greater than 10."

        # Retrieve metadata about fields & relationships on the model class.
        info = model_meta.get_field_info(model)
        field_names = self.get_field_names(declared_fields, info)

        # Determine any extra field arguments and hidden fields that
        # should be included
        extra_kwargs = self.get_extra_kwargs()
        extra_kwargs, hidden_fields = self.get_uniqueness_extra_kwargs(
            field_names, declared_fields, extra_kwargs
        )

        # Determine the fields that should be included on the serializer.
        fields = {}

        for field_name in field_names:
            # If the field is explicitly declared on the class then use that.
            if field_name in declared_fields:
                fields[field_name] = declared_fields[field_name]
                continue

            extra_field_kwargs = extra_kwargs.get(field_name, {})
            source = extra_field_kwargs.get('source', '*')
            if source == '*':
                source = field_name

            # Determine the serializer field class and keyword arguments.
            field_class, field_kwargs = self.build_field(
                source, info, model, depth
            )

            # Include any kwargs defined in `Meta.extra_kwargs`
            field_kwargs = self.include_extra_kwargs(
                field_kwargs, extra_field_kwargs
            )

            # Create the serializer field.
            fields[field_name] = field_class(**field_kwargs)

        # Add in any hidden fields.
        fields.update(hidden_fields)

        return fields

    # Methods for determining the set of field names to include...

    def get_field_names(self, declared_fields, info):
        """
        Returns the list of all field names that should be created when
        instantiating this serializer class. This is based on the default
        set of fields, but also takes into account the `Meta.fields` or
        `Meta.exclude` options if they have been specified.
        """
        fields = getattr(self.Meta, 'fields', None)
        exclude = getattr(self.Meta, 'exclude', None)

        if fields and fields != ALL_FIELDS and not isinstance(fields, (list, tuple)):
            raise TypeError(
                'The `fields` option must be a list or tuple or "__all__". '
                'Got %s.' % type(fields).__name__
            )

        if exclude and not isinstance(exclude, (list, tuple)):
            raise TypeError(
                'The `exclude` option must be a list or tuple. Got %s.' %
                type(exclude).__name__
            )

        assert not (fields and exclude), (
            "Cannot set both 'fields' and 'exclude' options on "
            "serializer {serializer_class}.".format(
                serializer_class=self.__class__.__name__
            )
        )

        assert not (fields is None and exclude is None), (
            "Creating a ModelSerializer without either the 'fields' attribute "
            "or the 'exclude' attribute has been deprecated since 3.3.0, "
            "and is now disallowed. Add an explicit fields = '__all__' to the "
            "{serializer_class} serializer.".format(
                serializer_class=self.__class__.__name__
            ),
        )

        if fields == ALL_FIELDS:
            fields = None

        if fields is not None:
            # Ensure that all declared fields have also been included in the
            # `Meta.fields` option.

            # Do not require any fields that are declared in a parent class,
            # in order to allow serializer subclasses to only include
            # a subset of fields.
            required_field_names = set(declared_fields)
            for cls in self.__class__.__bases__:
                required_field_names -= set(getattr(cls, '_declared_fields', []))

            for field_name in required_field_names:
                assert field_name in fields, (
                    "The field '{field_name}' was declared on serializer "
                    "{serializer_class}, but has not been included in the "
                    "'fields' option.".format(
                        field_name=field_name,
                        serializer_class=self.__class__.__name__
                    )
                )
            return fields

        # Use the default set of field names if `Meta.fields` is not specified.
        fields = self.get_default_field_names(declared_fields, info)

        if exclude is not None:
            # If `Meta.exclude` is included, then remove those fields.
            for field_name in exclude:
                assert field_name not in self._declared_fields, (
                    "Cannot both declare the field '{field_name}' and include "
                    "it in the {serializer_class} 'exclude' option. Remove the "
                    "field or, if inherited from a parent serializer, disable "
                    "with `{field_name} = None`."
                    .format(
                        field_name=field_name,
                        serializer_class=self.__class__.__name__
                    )
                )

                assert field_name in fields, (
                    "The field '{field_name}' was included on serializer "
                    "{serializer_class} in the 'exclude' option, but does "
                    "not match any model field.".format(
                        field_name=field_name,
                        serializer_class=self.__class__.__name__
                    )
                )
                fields.remove(field_name)

        return fields

    def get_default_field_names(self, declared_fields, model_info):
        """
        Return the default list of field names that will be used if the
        `Meta.fields` option is not specified.
        """
        return (
            [model_info.pk.name] +
            list(declared_fields) +
            list(model_info.fields) +
            list(model_info.forward_relations)
        )

    # Methods for constructing serializer fields...

    def build_field(self, field_name, info, model_class, nested_depth):
        """
        Return a two tuple of (cls, kwargs) to build a serializer field with.
        """
        if field_name in info.fields_and_pk:
            model_field = info.fields_and_pk[field_name]
            return self.build_standard_field(field_name, model_field)

        elif field_name in info.relations:
            relation_info = info.relations[field_name]
            if not nested_depth:
                return self.build_relational_field(field_name, relation_info)
            else:
                return self.build_nested_field(field_name, relation_info, nested_depth)

        elif hasattr(model_class, field_name):
            return self.build_property_field(field_name, model_class)

        elif field_name == self.url_field_name:
            return self.build_url_field(field_name, model_class)

        return self.build_unknown_field(field_name, model_class)

    def build_standard_field(self, field_name, model_field):
        """
        Create regular model fields.
        """
        field_mapping = ClassLookupDict(self.serializer_field_mapping)

        field_class = field_mapping[model_field]
        field_kwargs = get_field_kwargs(field_name, model_field)

        # Special case to handle when a OneToOneField is also the primary key
        if model_field.one_to_one and model_field.primary_key:
            field_class = self.serializer_related_field
            field_kwargs['queryset'] = model_field.related_model.objects

        if 'choices' in field_kwargs:
            # Fields with choices get coerced into `ChoiceField`
            # instead of using their regular typed field.
            field_class = self.serializer_choice_field
            # Some model fields may introduce kwargs that would not be valid
            # for the choice field. We need to strip these out.
            # Eg. models.DecimalField(max_digits=3, decimal_places=1, choices=DECIMAL_CHOICES)
            valid_kwargs = {
                'read_only', 'write_only',
                'required', 'default', 'initial', 'source',
                'label', 'help_text', 'style',
                'error_messages', 'validators', 'allow_null', 'allow_blank',
                'choices'
            }
            for key in list(field_kwargs):
                if key not in valid_kwargs:
                    field_kwargs.pop(key)

        if not issubclass(field_class, ModelField):
            # `model_field` is only valid for the fallback case of
            # `ModelField`, which is used when no other typed field
            # matched to the model field.
            field_kwargs.pop('model_field', None)

        if not issubclass(field_class, CharField) and not issubclass(field_class, ChoiceField):
            # `allow_blank` is only valid for textual fields.
            field_kwargs.pop('allow_blank', None)

        is_django_jsonfield = hasattr(models, 'JSONField') and isinstance(model_field, models.JSONField)
        if (postgres_fields and isinstance(model_field, postgres_fields.JSONField)) or is_django_jsonfield:
            # Populate the `encoder` argument of `JSONField` instances generated
            # for the model `JSONField`.
            field_kwargs['encoder'] = getattr(model_field, 'encoder', None)
            if is_django_jsonfield:
                field_kwargs['decoder'] = getattr(model_field, 'decoder', None)

        if postgres_fields and isinstance(model_field, postgres_fields.ArrayField):
            # Populate the `child` argument on `ListField` instances generated
            # for the PostgreSQL specific `ArrayField`.
            child_model_field = model_field.base_field
            child_field_class, child_field_kwargs = self.build_standard_field(
                'child', child_model_field
            )
            field_kwargs['child'] = child_field_class(**child_field_kwargs)

        return field_class, field_kwargs

    def build_relational_field(self, field_name, relation_info):
        """
        Create fields for forward and reverse relationships.
        """
        field_class = self.serializer_related_field
        field_kwargs = get_relation_kwargs(field_name, relation_info)

        to_field = field_kwargs.pop('to_field', None)
        if to_field and not relation_info.reverse and not relation_info.related_model._meta.get_field(to_field).primary_key:
            field_kwargs['slug_field'] = to_field
            field_class = self.serializer_related_to_field

        # `view_name` is only valid for hyperlinked relationships.
        if not issubclass(field_class, HyperlinkedRelatedField):
            field_kwargs.pop('view_name', None)

        return field_class, field_kwargs

    def build_nested_field(self, field_name, relation_info, nested_depth):
        """
        Create nested fields for forward and reverse relationships.
        """
        class NestedSerializer(ModelSerializer):
            class Meta:
                model = relation_info.related_model
                depth = nested_depth - 1
                fields = '__all__'

        field_class = NestedSerializer
        field_kwargs = get_nested_relation_kwargs(relation_info)

        return field_class, field_kwargs

    def build_property_field(self, field_name, model_class):
        """
        Create a read only field for model methods and properties.
        """
        field_class = ReadOnlyField
        field_kwargs = {}

        return field_class, field_kwargs

    def build_url_field(self, field_name, model_class):
        """
        Create a field representing the object's own URL.
        """
        field_class = self.serializer_url_field
        field_kwargs = get_url_kwargs(model_class)

        return field_class, field_kwargs

    def build_unknown_field(self, field_name, model_class):
        """
        Raise an error on any unknown fields.
        """
        raise ImproperlyConfigured(
            'Field name `%s` is not valid for model `%s` in `%s.%s`.' %
            (field_name, model_class.__name__, self.__class__.__module__, self.__class__.__name__)
        )

    def include_extra_kwargs(self, kwargs, extra_kwargs):
        """
        Include any 'extra_kwargs' that have been included for this field,
        possibly removing any incompatible existing keyword arguments.
        """
        if extra_kwargs.get('read_only', False):
            for attr in [
                'required', 'default', 'allow_blank', 'min_length',
                'max_length', 'min_value', 'max_value', 'validators', 'queryset'
            ]:
                kwargs.pop(attr, None)

        if extra_kwargs.get('default') and kwargs.get('required') is False:
            kwargs.pop('required')

        if extra_kwargs.get('read_only', kwargs.get('read_only', False)):
            extra_kwargs.pop('required', None)  # Read only fields should always omit the 'required' argument.

        kwargs.update(extra_kwargs)

        return kwargs

    # Methods for determining additional keyword arguments to apply...

    def get_extra_kwargs(self):
        """
        Return a dictionary mapping field names to a dictionary of
        additional keyword arguments.
        """
        extra_kwargs = copy.deepcopy(getattr(self.Meta, 'extra_kwargs', {}))

        read_only_fields = getattr(self.Meta, 'read_only_fields', None)
        if read_only_fields is not None:
            if not isinstance(read_only_fields, (list, tuple)):
                raise TypeError(
                    'The `read_only_fields` option must be a list or tuple. '
                    'Got %s.' % type(read_only_fields).__name__
                )
            for field_name in read_only_fields:
                kwargs = extra_kwargs.get(field_name, {})
                kwargs['read_only'] = True
                extra_kwargs[field_name] = kwargs

        else:
            # Guard against the possible misspelling `readonly_fields` (used
            # by the Django admin and others).
            assert not hasattr(self.Meta, 'readonly_fields'), (
                'Serializer `%s.%s` has field `readonly_fields`; '
                'the correct spelling for the option is `read_only_fields`.' %
                (self.__class__.__module__, self.__class__.__name__)
            )

        return extra_kwargs

    def get_unique_together_constraints(self, model):
        """
        Returns iterator of (fields, queryset), each entry describes an unique together
        constraint on `fields` in `queryset`.
        """
        for parent_class in [model] + list(model._meta.parents):
            for unique_together in parent_class._meta.unique_together:
                yield unique_together, model._default_manager
            for constraint in parent_class._meta.constraints:
                if isinstance(constraint, models.UniqueConstraint) and len(constraint.fields) > 1:
                    yield (
                        constraint.fields,
                        model._default_manager
                        if constraint.condition is None
                        else model._default_manager.filter(constraint.condition)
                    )

    def get_uniqueness_extra_kwargs(self, field_names, declared_fields, extra_kwargs):
        """
        Return any additional field options that need to be included as a
        result of uniqueness constraints on the model. This is returned as
        a two-tuple of:

        ('dict of updated extra kwargs', 'mapping of hidden fields')
        """
        if getattr(self.Meta, 'validators', None) is not None:
            return (extra_kwargs, {})

        model = getattr(self.Meta, 'model')
        model_fields = self._get_model_fields(
            field_names, declared_fields, extra_kwargs
        )

        # Determine if we need any additional `HiddenField` or extra keyword
        # arguments to deal with `unique_for` dates that are required to
        # be in the input data in order to validate it.
        unique_constraint_names = set()

        for model_field in model_fields.values():
            # Include each of the `unique_for_*` field names.
            unique_constraint_names |= {model_field.unique_for_date, model_field.unique_for_month,
                                        model_field.unique_for_year}

        unique_constraint_names -= {None}

        # Include each of the `unique_together` and `UniqueConstraint` field names,
        # so long as all the field names are included on the serializer.
        for unique_together_list, queryset in self.get_unique_together_constraints(model):
            if set(field_names).issuperset(unique_together_list):
                unique_constraint_names |= set(unique_together_list)

        # Now we have all the field names that have uniqueness constraints
        # applied, we can add the extra 'required=...' or 'default=...'
        # arguments that are appropriate to these fields, or add a `HiddenField` for it.
        hidden_fields = {}
        uniqueness_extra_kwargs = {}

        for unique_constraint_name in unique_constraint_names:
            # Get the model field that is referred too.
            unique_constraint_field = model._meta.get_field(unique_constraint_name)

            if getattr(unique_constraint_field, 'auto_now_add', None):
                default = CreateOnlyDefault(timezone.now)
            elif getattr(unique_constraint_field, 'auto_now', None):
                default = timezone.now
            elif unique_constraint_field.has_default():
                default = unique_constraint_field.default
            else:
                default = empty

            if unique_constraint_name in model_fields:
                # The corresponding field is present in the serializer
                if default is empty:
                    uniqueness_extra_kwargs[unique_constraint_name] = {'required': True}
                else:
                    uniqueness_extra_kwargs[unique_constraint_name] = {'default': default}
            elif default is not empty:
                # The corresponding field is not present in the
                # serializer. We have a default to use for it, so
                # add in a hidden field that populates it.
                hidden_fields[unique_constraint_name] = HiddenField(default=default)

        # Update `extra_kwargs` with any new options.
        for key, value in uniqueness_extra_kwargs.items():
            if key in extra_kwargs:
                value.update(extra_kwargs[key])
            extra_kwargs[key] = value

        return extra_kwargs, hidden_fields

    def _get_model_fields(self, field_names, declared_fields, extra_kwargs):
        """
        Returns all the model fields that are being mapped to by fields
        on the serializer class.
        Returned as a dict of 'model field name' -> 'model field'.
        Used internally by `get_uniqueness_field_options`.
        """
        model = getattr(self.Meta, 'model')
        model_fields = {}

        for field_name in field_names:
            if field_name in declared_fields:
                # If the field is declared on the serializer
                field = declared_fields[field_name]
                source = field.source or field_name
            else:
                try:
                    source = extra_kwargs[field_name]['source']
                except KeyError:
                    source = field_name

            if '.' in source or source == '*':
                # Model fields will always have a simple source mapping,
                # they can't be nested attribute lookups.
                continue

            with contextlib.suppress(FieldDoesNotExist):
                field = model._meta.get_field(source)
                if isinstance(field, DjangoModelField):
                    model_fields[source] = field

        return model_fields

    # Determine the validators to apply...

    def get_validators(self):
        """
        Determine the set of validators to use when instantiating serializer.
        """
        # If the validators have been declared explicitly then use that.
        validators = getattr(getattr(self, 'Meta', None), 'validators', None)
        if validators is not None:
            return list(validators)

        # Otherwise use the default set of validators.
        return (
            self.get_unique_together_validators() +
            self.get_unique_for_date_validators()
        )

    def get_unique_together_validators(self):
        """
        Determine a default set of validators for any unique_together constraints.
        """
        # The field names we're passing though here only include fields
        # which may map onto a model field. Any dotted field name lookups
        # cannot map to a field, and must be a traversal, so we're not
        # including those.
        field_sources = {
            field.field_name: field.source for field in self._writable_fields
            if (field.source != '*') and ('.' not in field.source)
        }

        # Special Case: Add read_only fields with defaults.
        field_sources.update({
            field.field_name: field.source for field in self.fields.values()
            if (field.read_only) and (field.default != empty) and (field.source != '*') and ('.' not in field.source)
        })

        # Invert so we can find the serializer field names that correspond to
        # the model field names in the unique_together sets. This also allows
        # us to check that multiple fields don't map to the same source.
        source_map = defaultdict(list)
        for name, source in field_sources.items():
            source_map[source].append(name)

        # Note that we make sure to check `unique_together` both on the
        # base model class, but also on any parent classes.
        validators = []
        for unique_together, queryset in self.get_unique_together_constraints(self.Meta.model):
            # Skip if serializer does not map to all unique together sources
            if not set(source_map).issuperset(unique_together):
                continue

            for source in unique_together:
                assert len(source_map[source]) == 1, (
                    "Unable to create `UniqueTogetherValidator` for "
                    "`{model}.{field}` as `{serializer}` has multiple "
                    "fields ({fields}) that map to this model field. "
                    "Either remove the extra fields, or override "
                    "`Meta.validators` with a `UniqueTogetherValidator` "
                    "using the desired field names."
                    .format(
                        model=self.Meta.model.__name__,
                        serializer=self.__class__.__name__,
                        field=source,
                        fields=', '.join(source_map[source]),
                    )
                )

            field_names = tuple(source_map[f][0] for f in unique_together)
            validator = UniqueTogetherValidator(
                queryset=queryset,
                fields=field_names
            )
            validators.append(validator)
        return validators

    def get_unique_for_date_validators(self):
        """
        Determine a default set of validators for the following constraints:

        * unique_for_date
        * unique_for_month
        * unique_for_year
        """
        info = model_meta.get_field_info(self.Meta.model)
        default_manager = self.Meta.model._default_manager
        field_names = [field.source for field in self.fields.values()]

        validators = []

        for field_name, field in info.fields_and_pk.items():
            if field.unique_for_date and field_name in field_names:
                validator = UniqueForDateValidator(
                    queryset=default_manager,
                    field=field_name,
                    date_field=field.unique_for_date
                )
                validators.append(validator)

            if field.unique_for_month and field_name in field_names:
                validator = UniqueForMonthValidator(
                    queryset=default_manager,
                    field=field_name,
                    date_field=field.unique_for_month
                )
                validators.append(validator)

            if field.unique_for_year and field_name in field_names:
                validator = UniqueForYearValidator(
                    queryset=default_manager,
                    field=field_name,
                    date_field=field.unique_for_year
                )
                validators.append(validator)

        return validators


class HyperlinkedModelSerializer(ModelSerializer):
    """
    A type of `ModelSerializer` that uses hyperlinked relationships instead
    of primary key relationships. Specifically:

    * A 'url' field is included instead of the 'id' field.
    * Relationships to other instances are hyperlinks, instead of primary keys.
    """
    serializer_related_field = HyperlinkedRelatedField

    def get_default_field_names(self, declared_fields, model_info):
        """
        Return the default list of field names that will be used if the
        `Meta.fields` option is not specified.
        """
        return (
            [self.url_field_name] +
            list(declared_fields) +
            list(model_info.fields) +
            list(model_info.forward_relations)
        )

    def build_nested_field(self, field_name, relation_info, nested_depth):
        """
        Create nested fields for forward and reverse relationships.
        """
        class NestedSerializer(HyperlinkedModelSerializer):
            class Meta:
                model = relation_info.related_model
                depth = nested_depth - 1
                fields = '__all__'

        field_class = NestedSerializer
        field_kwargs = get_nested_relation_kwargs(relation_info)

        return field_class, field_kwargs

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\settings.py ---

"""
Settings for REST framework are all namespaced in the REST_FRAMEWORK setting.
For example your project's `settings.py` file might look like this:

REST_FRAMEWORK = {
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.TemplateHTMLRenderer',
    ],
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser',
        'rest_framework.parsers.FormParser',
        'rest_framework.parsers.MultiPartParser',
    ],
}

This module provides the `api_setting` object, that is used to access
REST framework settings, checking for user settings first, then falling
back to the defaults.
"""
from django.conf import settings
# Import from `django.core.signals` instead of the official location
# `django.test.signals` to avoid importing the test module unnecessarily.
from django.core.signals import setting_changed
from django.utils.module_loading import import_string

from rest_framework import ISO_8601

DEFAULTS = {
    # Base API policies
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
    ],
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser',
        'rest_framework.parsers.FormParser',
        'rest_framework.parsers.MultiPartParser'
    ],
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication'
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny',
    ],
    'DEFAULT_THROTTLE_CLASSES': [],
    'DEFAULT_CONTENT_NEGOTIATION_CLASS': 'rest_framework.negotiation.DefaultContentNegotiation',
    'DEFAULT_METADATA_CLASS': 'rest_framework.metadata.SimpleMetadata',
    'DEFAULT_VERSIONING_CLASS': None,

    # Generic view behavior
    'DEFAULT_PAGINATION_CLASS': None,
    'DEFAULT_FILTER_BACKENDS': [],

    # Schema
    'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.openapi.AutoSchema',

    # Throttling
    'DEFAULT_THROTTLE_RATES': {
        'user': None,
        'anon': None,
    },
    'NUM_PROXIES': None,

    # Pagination
    'PAGE_SIZE': None,

    # Filtering
    'SEARCH_PARAM': 'search',
    'ORDERING_PARAM': 'ordering',

    # Versioning
    'DEFAULT_VERSION': None,
    'ALLOWED_VERSIONS': None,
    'VERSION_PARAM': 'version',

    # Authentication
    'UNAUTHENTICATED_USER': 'django.contrib.auth.models.AnonymousUser',
    'UNAUTHENTICATED_TOKEN': None,

    # View configuration
    'VIEW_NAME_FUNCTION': 'rest_framework.views.get_view_name',
    'VIEW_DESCRIPTION_FUNCTION': 'rest_framework.views.get_view_description',

    # Exception handling
    'EXCEPTION_HANDLER': 'rest_framework.views.exception_handler',
    'NON_FIELD_ERRORS_KEY': 'non_field_errors',

    # Testing
    'TEST_REQUEST_RENDERER_CLASSES': [
        'rest_framework.renderers.MultiPartRenderer',
        'rest_framework.renderers.JSONRenderer'
    ],
    'TEST_REQUEST_DEFAULT_FORMAT': 'multipart',

    # Hyperlink settings
    'URL_FORMAT_OVERRIDE': 'format',
    'FORMAT_SUFFIX_KWARG': 'format',
    'URL_FIELD_NAME': 'url',

    # Input and output formats
    'DATE_FORMAT': ISO_8601,
    'DATE_INPUT_FORMATS': [ISO_8601],

    'DATETIME_FORMAT': ISO_8601,
    'DATETIME_INPUT_FORMATS': [ISO_8601],

    'TIME_FORMAT': ISO_8601,
    'TIME_INPUT_FORMATS': [ISO_8601],

    # Encoding
    'UNICODE_JSON': True,
    'COMPACT_JSON': True,
    'STRICT_JSON': True,
    'COERCE_DECIMAL_TO_STRING': True,
    'UPLOADED_FILES_USE_URL': True,

    # Browsable API
    'HTML_SELECT_CUTOFF': 1000,
    'HTML_SELECT_CUTOFF_TEXT': "More than {count} items...",

    # Schemas
    'SCHEMA_COERCE_PATH_PK': True,
    'SCHEMA_COERCE_METHOD_NAMES': {
        'retrieve': 'read',
        'destroy': 'delete'
    },
}


# List of settings that may be in string import notation.
IMPORT_STRINGS = [
    'DEFAULT_RENDERER_CLASSES',
    'DEFAULT_PARSER_CLASSES',
    'DEFAULT_AUTHENTICATION_CLASSES',
    'DEFAULT_PERMISSION_CLASSES',
    'DEFAULT_THROTTLE_CLASSES',
    'DEFAULT_CONTENT_NEGOTIATION_CLASS',
    'DEFAULT_METADATA_CLASS',
    'DEFAULT_VERSIONING_CLASS',
    'DEFAULT_PAGINATION_CLASS',
    'DEFAULT_FILTER_BACKENDS',
    'DEFAULT_SCHEMA_CLASS',
    'EXCEPTION_HANDLER',
    'TEST_REQUEST_RENDERER_CLASSES',
    'UNAUTHENTICATED_USER',
    'UNAUTHENTICATED_TOKEN',
    'VIEW_NAME_FUNCTION',
    'VIEW_DESCRIPTION_FUNCTION'
]


# List of settings that have been removed
REMOVED_SETTINGS = [
    'PAGINATE_BY', 'PAGINATE_BY_PARAM', 'MAX_PAGINATE_BY',
]


def perform_import(val, setting_name):
    """
    If the given setting is a string import notation,
    then perform the necessary import or imports.
    """
    if val is None:
        return None
    elif isinstance(val, str):
        return import_from_string(val, setting_name)
    elif isinstance(val, (list, tuple)):
        return [import_from_string(item, setting_name) for item in val]
    return val


def import_from_string(val, setting_name):
    """
    Attempt to import a class from a string representation.
    """
    try:
        return import_string(val)
    except ImportError as e:
        msg = "Could not import '%s' for API setting '%s'. %s: %s." % (val, setting_name, e.__class__.__name__, e)
        raise ImportError(msg)


class APISettings:
    """
    A settings object that allows REST Framework settings to be accessed as
    properties. For example:

        from rest_framework.settings import api_settings
        print(api_settings.DEFAULT_RENDERER_CLASSES)

    Any setting with string import paths will be automatically resolved
    and return the class, rather than the string literal.

    Note:
    This is an internal class that is only compatible with settings namespaced
    under the REST_FRAMEWORK name. It is not intended to be used by 3rd-party
    apps, and test helpers like `override_settings` may not work as expected.
    """
    def __init__(self, user_settings=None, defaults=None, import_strings=None):
        if user_settings:
            self._user_settings = self.__check_user_settings(user_settings)
        self.defaults = defaults or DEFAULTS
        self.import_strings = import_strings or IMPORT_STRINGS
        self._cached_attrs = set()

    @property
    def user_settings(self):
        if not hasattr(self, '_user_settings'):
            self._user_settings = getattr(settings, 'REST_FRAMEWORK', {})
        return self._user_settings

    def __getattr__(self, attr):
        if attr not in self.defaults:
            raise AttributeError("Invalid API setting: '%s'" % attr)

        try:
            # Check if present in user settings
            val = self.user_settings[attr]
        except KeyError:
            # Fall back to defaults
            val = self.defaults[attr]

        # Coerce import strings into classes
        if attr in self.import_strings:
            val = perform_import(val, attr)

        # Cache the result
        self._cached_attrs.add(attr)
        setattr(self, attr, val)
        return val

    def __check_user_settings(self, user_settings):
        SETTINGS_DOC = "https://www.django-rest-framework.org/api-guide/settings/"
        for setting in REMOVED_SETTINGS:
            if setting in user_settings:
                raise RuntimeError("The '%s' setting has been removed. Please refer to '%s' for available settings." % (setting, SETTINGS_DOC))
        return user_settings

    def reload(self):
        for attr in self._cached_attrs:
            delattr(self, attr)
        self._cached_attrs.clear()
        if hasattr(self, '_user_settings'):
            delattr(self, '_user_settings')


api_settings = APISettings(None, DEFAULTS, IMPORT_STRINGS)


def reload_api_settings(*args, **kwargs):
    setting = kwargs['setting']
    if setting == 'REST_FRAMEWORK':
        api_settings.reload()


setting_changed.connect(reload_api_settings)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\settings.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\urls.py ---

"""
Login and logout views for the browsable API.

Add these to your root URLconf if you're using the browsable API and
your API requires authentication:

    urlpatterns = [
        ...
        path('auth/', include('rest_framework.urls'))
    ]

You should make sure your authentication settings include `SessionAuthentication`.
"""
from django.contrib.auth import views
from django.urls import path

app_name = 'rest_framework'
urlpatterns = [
    path('login/', views.LoginView.as_view(template_name='rest_framework/login.html'), name='login'),
    path('logout/', views.LogoutView.as_view(), name='logout'),
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\views.py ---

"""
Provides an APIView class that is the base of all views in REST framework.
"""
from django.conf import settings
from django.core.exceptions import PermissionDenied
from django.db import connections, models
from django.http import Http404
from django.http.response import HttpResponseBase
from django.utils.cache import cc_delim_re, patch_vary_headers
from django.utils.encoding import smart_str
from django.views.decorators.csrf import csrf_exempt
from django.views.generic import View

from rest_framework import exceptions, status
from rest_framework.request import Request
from rest_framework.response import Response
from rest_framework.schemas import DefaultSchema
from rest_framework.settings import api_settings
from rest_framework.utils import formatting


def get_view_name(view):
    """
    Given a view instance, return a textual name to represent the view.
    This name is used in the browsable API, and in OPTIONS responses.

    This function is the default for the `VIEW_NAME_FUNCTION` setting.
    """
    # Name may be set by some Views, such as a ViewSet.
    name = getattr(view, 'name', None)
    if name is not None:
        return name

    name = view.__class__.__name__
    name = formatting.remove_trailing_string(name, 'View')
    name = formatting.remove_trailing_string(name, 'ViewSet')
    name = formatting.camelcase_to_spaces(name)

    # Suffix may be set by some Views, such as a ViewSet.
    suffix = getattr(view, 'suffix', None)
    if suffix:
        name += ' ' + suffix

    return name


def get_view_description(view, html=False):
    """
    Given a view instance, return a textual description to represent the view.
    This name is used in the browsable API, and in OPTIONS responses.

    This function is the default for the `VIEW_DESCRIPTION_FUNCTION` setting.
    """
    # Description may be set by some Views, such as a ViewSet.
    description = getattr(view, 'description', None)
    if description is None:
        description = view.__class__.__doc__ or ''

    description = formatting.dedent(smart_str(description))
    if html:
        return formatting.markup_description(description)
    return description


def set_rollback():
    for db in connections.all():
        if db.settings_dict['ATOMIC_REQUESTS'] and db.in_atomic_block:
            db.set_rollback(True)


def exception_handler(exc, context):
    """
    Returns the response that should be used for any given exception.

    By default we handle the REST framework `APIException`, and also
    Django's built-in `Http404` and `PermissionDenied` exceptions.

    Any unhandled exceptions may return `None`, which will cause a 500 error
    to be raised.
    """
    if isinstance(exc, Http404):
        exc = exceptions.NotFound(*(exc.args))
    elif isinstance(exc, PermissionDenied):
        exc = exceptions.PermissionDenied(*(exc.args))

    if isinstance(exc, exceptions.APIException):
        headers = {}
        if getattr(exc, 'auth_header', None):
            headers['WWW-Authenticate'] = exc.auth_header
        if getattr(exc, 'wait', None):
            headers['Retry-After'] = '%d' % exc.wait

        if isinstance(exc.detail, (list, dict)):
            data = exc.detail
        else:
            data = {'detail': exc.detail}

        set_rollback()
        return Response(data, status=exc.status_code, headers=headers)

    return None


class APIView(View):

    # The following policies may be set at either globally, or per-view.
    renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES
    parser_classes = api_settings.DEFAULT_PARSER_CLASSES
    authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES
    throttle_classes = api_settings.DEFAULT_THROTTLE_CLASSES
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES
    content_negotiation_class = api_settings.DEFAULT_CONTENT_NEGOTIATION_CLASS
    metadata_class = api_settings.DEFAULT_METADATA_CLASS
    versioning_class = api_settings.DEFAULT_VERSIONING_CLASS

    # Allow dependency injection of other settings to make testing easier.
    settings = api_settings

    schema = DefaultSchema()

    @classmethod
    def as_view(cls, **initkwargs):
        """
        Store the original class on the view function.

        This allows us to discover information about the view when we do URL
        reverse lookups.  Used for breadcrumb generation.
        """
        if isinstance(getattr(cls, 'queryset', None), models.query.QuerySet):
            def force_evaluation():
                raise RuntimeError(
                    'Do not evaluate the `.queryset` attribute directly, '
                    'as the result will be cached and reused between requests. '
                    'Use `.all()` or call `.get_queryset()` instead.'
                )
            cls.queryset._fetch_all = force_evaluation

        view = super().as_view(**initkwargs)
        view.cls = cls
        view.initkwargs = initkwargs

        # Note: session based authentication is explicitly CSRF validated,
        # all other authentication is CSRF exempt.
        return csrf_exempt(view)

    @property
    def allowed_methods(self):
        """
        Wrap Django's private `_allowed_methods` interface in a public property.
        """
        return self._allowed_methods()

    @property
    def default_response_headers(self):
        headers = {
            'Allow': ', '.join(self.allowed_methods),
        }
        if len(self.renderer_classes) > 1:
            headers['Vary'] = 'Accept'
        return headers

    def http_method_not_allowed(self, request, *args, **kwargs):
        """
        If `request.method` does not correspond to a handler method,
        determine what kind of exception to raise.
        """
        raise exceptions.MethodNotAllowed(request.method)

    def permission_denied(self, request, message=None, code=None):
        """
        If request is not permitted, determine what kind of exception to raise.
        """
        if request.authenticators and not request.successful_authenticator:
            raise exceptions.NotAuthenticated()
        raise exceptions.PermissionDenied(detail=message, code=code)

    def throttled(self, request, wait):
        """
        If request is throttled, determine what kind of exception to raise.
        """
        raise exceptions.Throttled(wait)

    def get_authenticate_header(self, request):
        """
        If a request is unauthenticated, determine the WWW-Authenticate
        header to use for 401 responses, if any.
        """
        authenticators = self.get_authenticators()
        if authenticators:
            return authenticators[0].authenticate_header(request)

    def get_parser_context(self, http_request):
        """
        Returns a dict that is passed through to Parser.parse(),
        as the `parser_context` keyword argument.
        """
        # Note: Additionally `request` and `encoding` will also be added
        #       to the context by the Request object.
        return {
            'view': self,
            'args': getattr(self, 'args', ()),
            'kwargs': getattr(self, 'kwargs', {})
        }

    def get_renderer_context(self):
        """
        Returns a dict that is passed through to Renderer.render(),
        as the `renderer_context` keyword argument.
        """
        # Note: Additionally 'response' will also be added to the context,
        #       by the Response object.
        return {
            'view': self,
            'args': getattr(self, 'args', ()),
            'kwargs': getattr(self, 'kwargs', {}),
            'request': getattr(self, 'request', None)
        }

    def get_exception_handler_context(self):
        """
        Returns a dict that is passed through to EXCEPTION_HANDLER,
        as the `context` argument.
        """
        return {
            'view': self,
            'args': getattr(self, 'args', ()),
            'kwargs': getattr(self, 'kwargs', {}),
            'request': getattr(self, 'request', None)
        }

    def get_view_name(self):
        """
        Return the view name, as used in OPTIONS responses and in the
        browsable API.
        """
        func = self.settings.VIEW_NAME_FUNCTION
        return func(self)

    def get_view_description(self, html=False):
        """
        Return some descriptive text for the view, as used in OPTIONS responses
        and in the browsable API.
        """
        func = self.settings.VIEW_DESCRIPTION_FUNCTION
        return func(self, html)

    # API policy instantiation methods

    def get_format_suffix(self, **kwargs):
        """
        Determine if the request includes a '.json' style format suffix
        """
        if self.settings.FORMAT_SUFFIX_KWARG:
            return kwargs.get(self.settings.FORMAT_SUFFIX_KWARG)

    def get_renderers(self):
        """
        Instantiates and returns the list of renderers that this view can use.
        """
        return [renderer() for renderer in self.renderer_classes]

    def get_parsers(self):
        """
        Instantiates and returns the list of parsers that this view can use.
        """
        return [parser() for parser in self.parser_classes]

    def get_authenticators(self):
        """
        Instantiates and returns the list of authenticators that this view can use.
        """
        return [auth() for auth in self.authentication_classes]

    def get_permissions(self):
        """
        Instantiates and returns the list of permissions that this view requires.
        """
        return [permission() for permission in self.permission_classes]

    def get_throttles(self):
        """
        Instantiates and returns the list of throttles that this view uses.
        """
        return [throttle() for throttle in self.throttle_classes]

    def get_content_negotiator(self):
        """
        Instantiate and return the content negotiation class to use.
        """
        if not getattr(self, '_negotiator', None):
            self._negotiator = self.content_negotiation_class()
        return self._negotiator

    def get_exception_handler(self):
        """
        Returns the exception handler that this view uses.
        """
        return self.settings.EXCEPTION_HANDLER

    # API policy implementation methods

    def perform_content_negotiation(self, request, force=False):
        """
        Determine which renderer and media type to use render the response.
        """
        renderers = self.get_renderers()
        conneg = self.get_content_negotiator()

        try:
            return conneg.select_renderer(request, renderers, self.format_kwarg)
        except Exception:
            if force:
                return (renderers[0], renderers[0].media_type)
            raise

    def perform_authentication(self, request):
        """
        Perform authentication on the incoming request.

        Note that if you override this and simply 'pass', then authentication
        will instead be performed lazily, the first time either
        `request.user` or `request.auth` is accessed.
        """
        request.user

    def check_permissions(self, request):
        """
        Check if the request should be permitted.
        Raises an appropriate exception if the request is not permitted.
        """
        for permission in self.get_permissions():
            if not permission.has_permission(request, self):
                self.permission_denied(
                    request,
                    message=getattr(permission, 'message', None),
                    code=getattr(permission, 'code', None)
                )

    def check_object_permissions(self, request, obj):
        """
        Check if the request should be permitted for a given object.
        Raises an appropriate exception if the request is not permitted.
        """
        for permission in self.get_permissions():
            if not permission.has_object_permission(request, self, obj):
                self.permission_denied(
                    request,
                    message=getattr(permission, 'message', None),
                    code=getattr(permission, 'code', None)
                )

    def check_throttles(self, request):
        """
        Check if request should be throttled.
        Raises an appropriate exception if the request is throttled.
        """
        throttle_durations = []
        for throttle in self.get_throttles():
            if not throttle.allow_request(request, self):
                throttle_durations.append(throttle.wait())

        if throttle_durations:
            # Filter out `None` values which may happen in case of config / rate
            # changes, see #1438
            durations = [
                duration for duration in throttle_durations
                if duration is not None
            ]

            duration = max(durations, default=None)
            self.throttled(request, duration)

    def determine_version(self, request, *args, **kwargs):
        """
        If versioning is being used, then determine any API version for the
        incoming request. Returns a two-tuple of (version, versioning_scheme)
        """
        if self.versioning_class is None:
            return (None, None)
        scheme = self.versioning_class()
        return (scheme.determine_version(request, *args, **kwargs), scheme)

    # Dispatch methods

    def initialize_request(self, request, *args, **kwargs):
        """
        Returns the initial request object.
        """
        parser_context = self.get_parser_context(request)

        return Request(
            request,
            parsers=self.get_parsers(),
            authenticators=self.get_authenticators(),
            negotiator=self.get_content_negotiator(),
            parser_context=parser_context
        )

    def initial(self, request, *args, **kwargs):
        """
        Runs anything that needs to occur prior to calling the method handler.
        """
        self.format_kwarg = self.get_format_suffix(**kwargs)

        # Perform content negotiation and store the accepted info on the request
        neg = self.perform_content_negotiation(request)
        request.accepted_renderer, request.accepted_media_type = neg

        # Determine the API version, if versioning is in use.
        version, scheme = self.determine_version(request, *args, **kwargs)
        request.version, request.versioning_scheme = version, scheme

        # Ensure that the incoming request is permitted
        self.perform_authentication(request)
        self.check_permissions(request)
        self.check_throttles(request)

    def finalize_response(self, request, response, *args, **kwargs):
        """
        Returns the final response object.
        """
        # Make the error obvious if a proper response is not returned
        assert isinstance(response, HttpResponseBase), (
            'Expected a `Response`, `HttpResponse` or `StreamingHttpResponse` '
            'to be returned from the view, but received a `%s`'
            % type(response)
        )

        if isinstance(response, Response):
            if not getattr(request, 'accepted_renderer', None):
                neg = self.perform_content_negotiation(request, force=True)
                request.accepted_renderer, request.accepted_media_type = neg

            response.accepted_renderer = request.accepted_renderer
            response.accepted_media_type = request.accepted_media_type
            response.renderer_context = self.get_renderer_context()

        # Add new vary headers to the response instead of overwriting.
        vary_headers = self.headers.pop('Vary', None)
        if vary_headers is not None:
            patch_vary_headers(response, cc_delim_re.split(vary_headers))

        for key, value in self.headers.items():
            response[key] = value

        return response

    def handle_exception(self, exc):
        """
        Handle any exception that occurs, by returning an appropriate response,
        or re-raising the error.
        """
        if isinstance(exc, (exceptions.NotAuthenticated,
                            exceptions.AuthenticationFailed)):
            # WWW-Authenticate header for 401 responses, else coerce to 403
            auth_header = self.get_authenticate_header(self.request)

            if auth_header:
                exc.auth_header = auth_header
            else:
                exc.status_code = status.HTTP_403_FORBIDDEN

        exception_handler = self.get_exception_handler()

        context = self.get_exception_handler_context()
        response = exception_handler(exc, context)

        if response is None:
            self.raise_uncaught_exception(exc)

        response.exception = True
        return response

    def raise_uncaught_exception(self, exc):
        if settings.DEBUG:
            request = self.request
            renderer_format = getattr(request.accepted_renderer, 'format')
            use_plaintext_traceback = renderer_format not in ('html', 'api', 'admin')
            request.force_plaintext_errors(use_plaintext_traceback)
        raise exc

    # Note: Views are made CSRF exempt from within `as_view` as to prevent
    # accidental removal of this exemption in cases where `dispatch` needs to
    # be overridden.
    def dispatch(self, request, *args, **kwargs):
        """
        `.dispatch()` is pretty much the same as Django's regular dispatch,
        but with extra hooks for startup, finalize, and exception handling.
        """
        self.args = args
        self.kwargs = kwargs
        request = self.initialize_request(request, *args, **kwargs)
        self.request = request
        self.headers = self.default_response_headers  # deprecate?

        try:
            self.initial(request, *args, **kwargs)

            # Get the appropriate handler method
            if request.method.lower() in self.http_method_names:
                handler = getattr(self, request.method.lower(),
                                  self.http_method_not_allowed)
            else:
                handler = self.http_method_not_allowed

            response = handler(request, *args, **kwargs)

        except Exception as exc:
            response = self.handle_exception(exc)

        self.response = self.finalize_response(request, response, *args, **kwargs)
        return self.response

    def options(self, request, *args, **kwargs):
        """
        Handler method for HTTP 'OPTIONS' request.
        """
        if self.metadata_class is None:
            return self.http_method_not_allowed(request, *args, **kwargs)
        data = self.metadata_class().determine_metadata(request, self)
        return Response(data, status=status.HTTP_200_OK)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\token_blacklist\admin.py ---

from django.contrib import admin
from django.utils.translation import gettext_lazy as _

from .models import BlacklistedToken, OutstandingToken


class OutstandingTokenAdmin(admin.ModelAdmin):
    list_display = (
        "jti",
        "user",
        "created_at",
        "expires_at",
    )
    search_fields = (
        "user__id",
        "jti",
    )
    ordering = ("user",)

    def get_queryset(self, *args, **kwargs):
        qs = super().get_queryset(*args, **kwargs)

        return qs.select_related("user")

    # Read-only behavior defined below
    actions = None

    def get_readonly_fields(self, *args, **kwargs):
        return [f.name for f in self.model._meta.fields]

    def has_add_permission(self, *args, **kwargs):
        return False

    def has_delete_permission(self, *args, **kwargs):
        return False

    def has_change_permission(self, request, obj=None):
        return request.method in ["GET", "HEAD"] and super().has_change_permission(
            request, obj
        )


admin.site.register(OutstandingToken, OutstandingTokenAdmin)


class BlacklistedTokenAdmin(admin.ModelAdmin):
    list_display = (
        "token_jti",
        "token_user",
        "token_created_at",
        "token_expires_at",
        "blacklisted_at",
    )
    search_fields = (
        "token__user__id",
        "token__jti",
    )
    ordering = ("token__user",)

    def get_queryset(self, *args, **kwargs):
        qs = super().get_queryset(*args, **kwargs)

        return qs.select_related("token__user")

    def token_jti(self, obj):
        return obj.token.jti

    token_jti.short_description = _("jti")
    token_jti.admin_order_field = "token__jti"

    def token_user(self, obj):
        return obj.token.user

    token_user.short_description = _("user")
    token_user.admin_order_field = "token__user"

    def token_created_at(self, obj):
        return obj.token.created_at

    token_created_at.short_description = _("created at")
    token_created_at.admin_order_field = "token__created_at"

    def token_expires_at(self, obj):
        return obj.token.expires_at

    token_expires_at.short_description = _("expires at")
    token_expires_at.admin_order_field = "token__expires_at"


admin.site.register(BlacklistedToken, BlacklistedTokenAdmin)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\token_blacklist\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\token_blacklist\apps.py ---

from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _


class TokenBlacklistConfig(AppConfig):
    name = "rest_framework_simplejwt.token_blacklist"
    verbose_name = _("Token Blacklist")
    default_auto_field = "django.db.models.BigAutoField"

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\token_blacklist\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\token_blacklist\models.py ---

from django.conf import settings
from django.db import models


class OutstandingToken(models.Model):
    id = models.BigAutoField(primary_key=True, serialize=False)
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, blank=True
    )

    jti = models.CharField(unique=True, max_length=255)
    token = models.TextField()

    created_at = models.DateTimeField(null=True, blank=True)
    expires_at = models.DateTimeField()

    class Meta:
        # Work around for a bug in Django:
        # https://code.djangoproject.com/ticket/19422
        #
        # Also see corresponding ticket:
        # https://github.com/encode/django-rest-framework/issues/705
        abstract = (
            "rest_framework_simplejwt.token_blacklist" not in settings.INSTALLED_APPS
        )
        ordering = ("user",)

    def __str__(self):
        return "Token for {} ({})".format(
            self.user,
            self.jti,
        )


class BlacklistedToken(models.Model):
    id = models.BigAutoField(primary_key=True, serialize=False)
    token = models.OneToOneField(OutstandingToken, on_delete=models.CASCADE)

    blacklisted_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        # Work around for a bug in Django:
        # https://code.djangoproject.com/ticket/19422
        #
        # Also see corresponding ticket:
        # https://github.com/encode/django-rest-framework/issues/705
        abstract = (
            "rest_framework_simplejwt.token_blacklist" not in settings.INSTALLED_APPS
        )

    def __str__(self):
        return f"Blacklisted token for {self.token.user}"

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\token_blacklist\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\models.py ---

from django.contrib.auth import models as auth_models
from django.db.models.manager import EmptyManager
from django.utils.functional import cached_property

from .compat import CallableFalse, CallableTrue
from .settings import api_settings


class TokenUser:
    """
    A dummy user class modeled after django.contrib.auth.models.AnonymousUser.
    Used in conjunction with the `JWTStatelessUserAuthentication` backend to
    implement single sign-on functionality across services which share the same
    secret key.  `JWTStatelessUserAuthentication` will return an instance of this
    class instead of a `User` model instance.  Instances of this class act as
    stateless user objects which are backed by validated tokens.
    """

    # User is always active since Simple JWT will never issue a token for an
    # inactive user
    is_active = True

    _groups = EmptyManager(auth_models.Group)
    _user_permissions = EmptyManager(auth_models.Permission)

    def __init__(self, token):
        self.token = token

    def __str__(self):
        return f"TokenUser {self.id}"

    @cached_property
    def id(self):
        return self.token[api_settings.USER_ID_CLAIM]

    @cached_property
    def pk(self):
        return self.id

    @cached_property
    def username(self):
        return self.token.get("username", "")

    @cached_property
    def is_staff(self):
        return self.token.get("is_staff", False)

    @cached_property
    def is_superuser(self):
        return self.token.get("is_superuser", False)

    def __eq__(self, other):
        return self.id == other.id

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash(self.id)

    def save(self):
        raise NotImplementedError("Token users have no DB representation")

    def delete(self):
        raise NotImplementedError("Token users have no DB representation")

    def set_password(self, raw_password):
        raise NotImplementedError("Token users have no DB representation")

    def check_password(self, raw_password):
        raise NotImplementedError("Token users have no DB representation")

    @property
    def groups(self):
        return self._groups

    @property
    def user_permissions(self):
        return self._user_permissions

    def get_group_permissions(self, obj=None):
        return set()

    def get_all_permissions(self, obj=None):
        return set()

    def has_perm(self, perm, obj=None):
        return False

    def has_perms(self, perm_list, obj=None):
        return False

    def has_module_perms(self, module):
        return False

    @property
    def is_anonymous(self):
        return CallableFalse

    @property
    def is_authenticated(self):
        return CallableTrue

    def get_username(self):
        return self.username

    def __getattr__(self, attr):
        """This acts as a backup attribute getter for custom claims defined in Token serializers."""
        return self.token.get(attr, None)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\serializers.py ---

from django.conf import settings
from django.contrib.auth import authenticate, get_user_model
from django.contrib.auth.models import update_last_login
from django.utils.translation import gettext_lazy as _
from rest_framework import exceptions, serializers
from rest_framework.exceptions import ValidationError

from .settings import api_settings
from .tokens import RefreshToken, SlidingToken, UntypedToken

if api_settings.BLACKLIST_AFTER_ROTATION:
    from .token_blacklist.models import BlacklistedToken


class PasswordField(serializers.CharField):
    def __init__(self, *args, **kwargs):
        kwargs.setdefault("style", {})

        kwargs["style"]["input_type"] = "password"
        kwargs["write_only"] = True

        super().__init__(*args, **kwargs)


class TokenObtainSerializer(serializers.Serializer):
    username_field = get_user_model().USERNAME_FIELD
    token_class = None

    default_error_messages = {
        "no_active_account": _("No active account found with the given credentials")
    }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.fields[self.username_field] = serializers.CharField()
        self.fields["password"] = PasswordField()

    def validate(self, attrs):
        authenticate_kwargs = {
            self.username_field: attrs[self.username_field],
            "password": attrs["password"],
        }
        try:
            authenticate_kwargs["request"] = self.context["request"]
        except KeyError:
            pass

        self.user = authenticate(**authenticate_kwargs)

        if not api_settings.USER_AUTHENTICATION_RULE(self.user):
            raise exceptions.AuthenticationFailed(
                self.error_messages["no_active_account"],
                "no_active_account",
            )

        return {}

    @classmethod
    def get_token(cls, user):
        return cls.token_class.for_user(user)


class TokenObtainPairSerializer(TokenObtainSerializer):
    token_class = RefreshToken

    def validate(self, attrs):
        data = super().validate(attrs)

        refresh = self.get_token(self.user)

        data["refresh"] = str(refresh)
        data["access"] = str(refresh.access_token)

        if api_settings.UPDATE_LAST_LOGIN:
            update_last_login(None, self.user)

        return data


class TokenObtainSlidingSerializer(TokenObtainSerializer):
    token_class = SlidingToken

    def validate(self, attrs):
        data = super().validate(attrs)

        token = self.get_token(self.user)

        data["token"] = str(token)

        if api_settings.UPDATE_LAST_LOGIN:
            update_last_login(None, self.user)

        return data


class TokenRefreshSerializer(serializers.Serializer):
    refresh = serializers.CharField()
    access = serializers.CharField(read_only=True)
    token_class = RefreshToken

    def validate(self, attrs):
        refresh = self.token_class(attrs["refresh"])

        data = {"access": str(refresh.access_token)}

        if api_settings.ROTATE_REFRESH_TOKENS:
            if api_settings.BLACKLIST_AFTER_ROTATION:
                try:
                    # Attempt to blacklist the given refresh token
                    refresh.blacklist()
                except AttributeError:
                    # If blacklist app not installed, `blacklist` method will
                    # not be present
                    pass

            refresh.set_jti()
            refresh.set_exp()
            refresh.set_iat()

            data["refresh"] = str(refresh)

        return data


class TokenRefreshSlidingSerializer(serializers.Serializer):
    token = serializers.CharField()
    token_class = SlidingToken

    def validate(self, attrs):
        token = self.token_class(attrs["token"])

        # Check that the timestamp in the "refresh_exp" claim has not
        # passed
        token.check_exp(api_settings.SLIDING_TOKEN_REFRESH_EXP_CLAIM)

        # Update the "exp" and "iat" claims
        token.set_exp()
        token.set_iat()

        return {"token": str(token)}


class TokenVerifySerializer(serializers.Serializer):
    token = serializers.CharField()

    def validate(self, attrs):
        token = UntypedToken(attrs["token"])

        if (
            api_settings.BLACKLIST_AFTER_ROTATION
            and "rest_framework_simplejwt.token_blacklist" in settings.INSTALLED_APPS
        ):
            jti = token.get(api_settings.JTI_CLAIM)
            if BlacklistedToken.objects.filter(token__jti=jti).exists():
                raise ValidationError("Token is blacklisted")

        return {}


class TokenBlacklistSerializer(serializers.Serializer):
    refresh = serializers.CharField()
    token_class = RefreshToken

    def validate(self, attrs):
        refresh = self.token_class(attrs["refresh"])
        try:
            refresh.blacklist()
        except AttributeError:
            pass
        return {}

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\settings.py ---

from datetime import timedelta

from django.conf import settings
from django.test.signals import setting_changed
from django.utils.translation import gettext_lazy as _
from rest_framework.settings import APISettings as _APISettings

from .utils import format_lazy

USER_SETTINGS = getattr(settings, "SIMPLE_JWT", None)

DEFAULTS = {
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=5),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=1),
    "ROTATE_REFRESH_TOKENS": False,
    "BLACKLIST_AFTER_ROTATION": False,
    "UPDATE_LAST_LOGIN": False,
    "ALGORITHM": "HS256",
    "SIGNING_KEY": settings.SECRET_KEY,
    "VERIFYING_KEY": "",
    "AUDIENCE": None,
    "ISSUER": None,
    "JSON_ENCODER": None,
    "JWK_URL": None,
    "LEEWAY": 0,
    "AUTH_HEADER_TYPES": ("Bearer",),
    "AUTH_HEADER_NAME": "HTTP_AUTHORIZATION",
    "USER_ID_FIELD": "id",
    "USER_ID_CLAIM": "user_id",
    "USER_AUTHENTICATION_RULE": "rest_framework_simplejwt.authentication.default_user_authentication_rule",
    "AUTH_TOKEN_CLASSES": ("rest_framework_simplejwt.tokens.AccessToken",),
    "TOKEN_TYPE_CLAIM": "token_type",
    "JTI_CLAIM": "jti",
    "TOKEN_USER_CLASS": "rest_framework_simplejwt.models.TokenUser",
    "SLIDING_TOKEN_REFRESH_EXP_CLAIM": "refresh_exp",
    "SLIDING_TOKEN_LIFETIME": timedelta(minutes=5),
    "SLIDING_TOKEN_REFRESH_LIFETIME": timedelta(days=1),
    "TOKEN_OBTAIN_SERIALIZER": "rest_framework_simplejwt.serializers.TokenObtainPairSerializer",
    "TOKEN_REFRESH_SERIALIZER": "rest_framework_simplejwt.serializers.TokenRefreshSerializer",
    "TOKEN_VERIFY_SERIALIZER": "rest_framework_simplejwt.serializers.TokenVerifySerializer",
    "TOKEN_BLACKLIST_SERIALIZER": "rest_framework_simplejwt.serializers.TokenBlacklistSerializer",
    "SLIDING_TOKEN_OBTAIN_SERIALIZER": "rest_framework_simplejwt.serializers.TokenObtainSlidingSerializer",
    "SLIDING_TOKEN_REFRESH_SERIALIZER": "rest_framework_simplejwt.serializers.TokenRefreshSlidingSerializer",
}

IMPORT_STRINGS = (
    "AUTH_TOKEN_CLASSES",
    "JSON_ENCODER",
    "TOKEN_USER_CLASS",
    "USER_AUTHENTICATION_RULE",
)

REMOVED_SETTINGS = (
    "AUTH_HEADER_TYPE",
    "AUTH_TOKEN_CLASS",
    "SECRET_KEY",
    "TOKEN_BACKEND_CLASS",
)


class APISettings(_APISettings):  # pragma: no cover
    def __check_user_settings(self, user_settings):
        SETTINGS_DOC = "https://django-rest-framework-simplejwt.readthedocs.io/en/latest/settings.html"

        for setting in REMOVED_SETTINGS:
            if setting in user_settings:
                raise RuntimeError(
                    format_lazy(
                        _(
                            "The '{}' setting has been removed. Please refer to '{}' for available settings."
                        ),
                        setting,
                        SETTINGS_DOC,
                    )
                )

        return user_settings


api_settings = APISettings(USER_SETTINGS, DEFAULTS, IMPORT_STRINGS)


def reload_api_settings(*args, **kwargs):  # pragma: no cover
    global api_settings

    setting, value = kwargs["setting"], kwargs["value"]

    if setting == "SIMPLE_JWT":
        api_settings = APISettings(value, DEFAULTS, IMPORT_STRINGS)


setting_changed.connect(reload_api_settings)

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\settings.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\views.py ---

from django.utils.module_loading import import_string
from rest_framework import generics, status
from rest_framework.response import Response

from . import serializers
from .authentication import AUTH_HEADER_TYPES
from .exceptions import InvalidToken, TokenError
from .settings import api_settings


class TokenViewBase(generics.GenericAPIView):
    permission_classes = ()
    authentication_classes = ()

    serializer_class = None
    _serializer_class = ""

    www_authenticate_realm = "api"

    def get_serializer_class(self):
        """
        If serializer_class is set, use it directly. Otherwise get the class from settings.
        """

        if self.serializer_class:
            return self.serializer_class
        try:
            return import_string(self._serializer_class)
        except ImportError:
            msg = "Could not import serializer '%s'" % self._serializer_class
            raise ImportError(msg)

    def get_authenticate_header(self, request):
        return '{} realm="{}"'.format(
            AUTH_HEADER_TYPES[0],
            self.www_authenticate_realm,
        )

    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)

        try:
            serializer.is_valid(raise_exception=True)
        except TokenError as e:
            raise InvalidToken(e.args[0])

        return Response(serializer.validated_data, status=status.HTTP_200_OK)


class TokenObtainPairView(TokenViewBase):
    """
    Takes a set of user credentials and returns an access and refresh JSON web
    token pair to prove the authentication of those credentials.
    """

    _serializer_class = api_settings.TOKEN_OBTAIN_SERIALIZER


token_obtain_pair = TokenObtainPairView.as_view()


class TokenRefreshView(TokenViewBase):
    """
    Takes a refresh type JSON web token and returns an access type JSON web
    token if the refresh token is valid.
    """

    _serializer_class = api_settings.TOKEN_REFRESH_SERIALIZER


token_refresh = TokenRefreshView.as_view()


class TokenObtainSlidingView(TokenViewBase):
    """
    Takes a set of user credentials and returns a sliding JSON web token to
    prove the authentication of those credentials.
    """

    _serializer_class = api_settings.SLIDING_TOKEN_OBTAIN_SERIALIZER


token_obtain_sliding = TokenObtainSlidingView.as_view()


class TokenRefreshSlidingView(TokenViewBase):
    """
    Takes a sliding JSON web token and returns a new, refreshed version if the
    token's refresh period has not expired.
    """

    _serializer_class = api_settings.SLIDING_TOKEN_REFRESH_SERIALIZER


token_refresh_sliding = TokenRefreshSlidingView.as_view()


class TokenVerifyView(TokenViewBase):
    """
    Takes a token and indicates if it is valid.  This view provides no
    information about a token's fitness for a particular use.
    """

    _serializer_class = api_settings.TOKEN_VERIFY_SERIALIZER


token_verify = TokenVerifyView.as_view()


class TokenBlacklistView(TokenViewBase):
    """
    Takes a token and blacklists it. Must be used with the
    `rest_framework_simplejwt.token_blacklist` app installed.
    """

    _serializer_class = api_settings.TOKEN_BLACKLIST_SERIALIZER


token_blacklist = TokenBlacklistView.as_view()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\rest_framework_simplejwt\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\sentry_sdk\integrations\django\asgi.py ---

"""
Instrumentation for Django 3.0

Since this file contains `async def` it is conditionally imported in
`sentry_sdk.integrations.django` (depending on the existence of
`django.core.handlers.asgi`.
"""

import asyncio

from sentry_sdk import Hub, _functools
from sentry_sdk._types import TYPE_CHECKING
from sentry_sdk.consts import OP

from sentry_sdk.integrations.asgi import SentryAsgiMiddleware

if TYPE_CHECKING:
    from typing import Any
    from typing import Union
    from typing import Callable

    from django.http.response import HttpResponse


def patch_django_asgi_handler_impl(cls):
    # type: (Any) -> None

    from sentry_sdk.integrations.django import DjangoIntegration

    old_app = cls.__call__

    async def sentry_patched_asgi_handler(self, scope, receive, send):
        # type: (Any, Any, Any, Any) -> Any
        if Hub.current.get_integration(DjangoIntegration) is None:
            return await old_app(self, scope, receive, send)

        middleware = SentryAsgiMiddleware(
            old_app.__get__(self, cls), unsafe_context_data=True
        )._run_asgi3
        return await middleware(scope, receive, send)

    cls.__call__ = sentry_patched_asgi_handler


def patch_get_response_async(cls, _before_get_response):
    # type: (Any, Any) -> None
    old_get_response_async = cls.get_response_async

    async def sentry_patched_get_response_async(self, request):
        # type: (Any, Any) -> Union[HttpResponse, BaseException]
        _before_get_response(request)
        return await old_get_response_async(self, request)

    cls.get_response_async = sentry_patched_get_response_async


def patch_channels_asgi_handler_impl(cls):
    # type: (Any) -> None

    import channels  # type: ignore
    from sentry_sdk.integrations.django import DjangoIntegration

    if channels.__version__ < "3.0.0":
        old_app = cls.__call__

        async def sentry_patched_asgi_handler(self, receive, send):
            # type: (Any, Any, Any) -> Any
            if Hub.current.get_integration(DjangoIntegration) is None:
                return await old_app(self, receive, send)

            middleware = SentryAsgiMiddleware(
                lambda _scope: old_app.__get__(self, cls), unsafe_context_data=True
            )

            return await middleware(self.scope)(receive, send)

        cls.__call__ = sentry_patched_asgi_handler

    else:
        # The ASGI handler in Channels >= 3 has the same signature as
        # the Django handler.
        patch_django_asgi_handler_impl(cls)


def wrap_async_view(hub, callback):
    # type: (Hub, Any) -> Any
    @_functools.wraps(callback)
    async def sentry_wrapped_callback(request, *args, **kwargs):
        # type: (Any, *Any, **Any) -> Any

        with hub.configure_scope() as sentry_scope:
            if sentry_scope.profile is not None:
                sentry_scope.profile.update_active_thread_id()

            with hub.start_span(
                op=OP.VIEW_RENDER, description=request.resolver_match.view_name
            ):
                return await callback(request, *args, **kwargs)

    return sentry_wrapped_callback


def _asgi_middleware_mixin_factory(_check_middleware_span):
    # type: (Callable[..., Any]) -> Any
    """
    Mixin class factory that generates a middleware mixin for handling requests
    in async mode.
    """

    class SentryASGIMixin:
        if TYPE_CHECKING:
            _inner = None

        def __init__(self, get_response):
            # type: (Callable[..., Any]) -> None
            self.get_response = get_response
            self._acall_method = None
            self._async_check()

        def _async_check(self):
            # type: () -> None
            """
            If get_response is a coroutine function, turns us into async mode so
            a thread is not consumed during a whole request.
            Taken from django.utils.deprecation::MiddlewareMixin._async_check
            """
            if asyncio.iscoroutinefunction(self.get_response):
                self._is_coroutine = asyncio.coroutines._is_coroutine  # type: ignore

        def async_route_check(self):
            # type: () -> bool
            """
            Function that checks if we are in async mode,
            and if we are forwards the handling of requests to __acall__
            """
            return asyncio.iscoroutinefunction(self.get_response)

        async def __acall__(self, *args, **kwargs):
            # type: (*Any, **Any) -> Any
            f = self._acall_method
            if f is None:
                if hasattr(self._inner, "__acall__"):
                    self._acall_method = f = self._inner.__acall__  # type: ignore
                else:
                    self._acall_method = f = self._inner

            middleware_span = _check_middleware_span(old_method=f)

            if middleware_span is None:
                return await f(*args, **kwargs)

            with middleware_span:
                return await f(*args, **kwargs)

    return SentryASGIMixin

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\sentry_sdk\integrations\django\asgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\sentry_sdk\integrations\django\views.py ---

from sentry_sdk.consts import OP
from sentry_sdk.hub import Hub
from sentry_sdk._types import TYPE_CHECKING
from sentry_sdk import _functools

if TYPE_CHECKING:
    from typing import Any


try:
    from asyncio import iscoroutinefunction
except ImportError:
    iscoroutinefunction = None  # type: ignore


try:
    from sentry_sdk.integrations.django.asgi import wrap_async_view
except (ImportError, SyntaxError):
    wrap_async_view = None  # type: ignore


def patch_views():
    # type: () -> None

    from django.core.handlers.base import BaseHandler
    from django.template.response import SimpleTemplateResponse
    from sentry_sdk.integrations.django import DjangoIntegration

    old_make_view_atomic = BaseHandler.make_view_atomic
    old_render = SimpleTemplateResponse.render

    def sentry_patched_render(self):
        # type: (SimpleTemplateResponse) -> Any
        hub = Hub.current
        with hub.start_span(
            op=OP.VIEW_RESPONSE_RENDER, description="serialize response"
        ):
            return old_render(self)

    @_functools.wraps(old_make_view_atomic)
    def sentry_patched_make_view_atomic(self, *args, **kwargs):
        # type: (Any, *Any, **Any) -> Any
        callback = old_make_view_atomic(self, *args, **kwargs)

        # XXX: The wrapper function is created for every request. Find more
        # efficient way to wrap views (or build a cache?)

        hub = Hub.current
        integration = hub.get_integration(DjangoIntegration)

        if integration is not None and integration.middleware_spans:
            if (
                iscoroutinefunction is not None
                and wrap_async_view is not None
                and iscoroutinefunction(callback)
            ):
                sentry_wrapped_callback = wrap_async_view(hub, callback)
            else:
                sentry_wrapped_callback = _wrap_sync_view(hub, callback)

        else:
            sentry_wrapped_callback = callback

        return sentry_wrapped_callback

    SimpleTemplateResponse.render = sentry_patched_render
    BaseHandler.make_view_atomic = sentry_patched_make_view_atomic


def _wrap_sync_view(hub, callback):
    # type: (Hub, Any) -> Any
    @_functools.wraps(callback)
    def sentry_wrapped_callback(request, *args, **kwargs):
        # type: (Any, *Any, **Any) -> Any
        with hub.configure_scope() as sentry_scope:
            # set the active thread id to the handler thread for sync views
            # this isn't necessary for async views since that runs on main
            if sentry_scope.profile is not None:
                sentry_scope.profile.update_active_thread_id()

            with hub.start_span(
                op=OP.VIEW_RENDER, description=request.resolver_match.view_name
            ):
                return callback(request, *args, **kwargs)

    return sentry_wrapped_callback

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\sentry_sdk\integrations\django\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\sentry_sdk\integrations\asgi.py ---

"""
An ASGI middleware.

Based on Tom Christie's `sentry-asgi <https://github.com/encode/sentry-asgi>`.
"""

import asyncio
import inspect
from copy import deepcopy

from sentry_sdk._functools import partial
from sentry_sdk._types import TYPE_CHECKING
from sentry_sdk.api import continue_trace
from sentry_sdk.consts import OP
from sentry_sdk.hub import Hub

from sentry_sdk.integrations._asgi_common import (
    _get_headers,
    _get_request_data,
    _get_url,
)
from sentry_sdk.integrations.modules import _get_installed_modules
from sentry_sdk.sessions import auto_session_tracking
from sentry_sdk.tracing import (
    SOURCE_FOR_STYLE,
    TRANSACTION_SOURCE_ROUTE,
    TRANSACTION_SOURCE_URL,
    TRANSACTION_SOURCE_COMPONENT,
)
from sentry_sdk.utils import (
    ContextVar,
    event_from_exception,
    HAS_REAL_CONTEXTVARS,
    CONTEXTVARS_ERROR_MESSAGE,
    logger,
    transaction_from_function,
)
from sentry_sdk.tracing import Transaction

if TYPE_CHECKING:
    from typing import Any
    from typing import Callable
    from typing import Dict
    from typing import Optional
    from typing import Tuple

    from sentry_sdk._types import Event, Hint


_asgi_middleware_applied = ContextVar("sentry_asgi_middleware_applied")

_DEFAULT_TRANSACTION_NAME = "generic ASGI request"

TRANSACTION_STYLE_VALUES = ("endpoint", "url")


def _capture_exception(hub, exc, mechanism_type="asgi"):
    # type: (Hub, Any, str) -> None

    # Check client here as it might have been unset while streaming response
    if hub.client is not None:
        event, hint = event_from_exception(
            exc,
            client_options=hub.client.options,
            mechanism={"type": mechanism_type, "handled": False},
        )
        hub.capture_event(event, hint=hint)


def _looks_like_asgi3(app):
    # type: (Any) -> bool
    """
    Try to figure out if an application object supports ASGI3.

    This is how uvicorn figures out the application version as well.
    """
    if inspect.isclass(app):
        return hasattr(app, "__await__")
    elif inspect.isfunction(app):
        return asyncio.iscoroutinefunction(app)
    else:
        call = getattr(app, "__call__", None)  # noqa
        return asyncio.iscoroutinefunction(call)


class SentryAsgiMiddleware:
    __slots__ = ("app", "__call__", "transaction_style", "mechanism_type")

    def __init__(
        self,
        app,
        unsafe_context_data=False,
        transaction_style="endpoint",
        mechanism_type="asgi",
    ):
        # type: (Any, bool, str, str) -> None
        """
        Instrument an ASGI application with Sentry. Provides HTTP/websocket
        data to sent events and basic handling for exceptions bubbling up
        through the middleware.

        :param unsafe_context_data: Disable errors when a proper contextvars installation could not be found. We do not recommend changing this from the default.
        """
        if not unsafe_context_data and not HAS_REAL_CONTEXTVARS:
            # We better have contextvars or we're going to leak state between
            # requests.
            raise RuntimeError(
                "The ASGI middleware for Sentry requires Python 3.7+ "
                "or the aiocontextvars package." + CONTEXTVARS_ERROR_MESSAGE
            )
        if transaction_style not in TRANSACTION_STYLE_VALUES:
            raise ValueError(
                "Invalid value for transaction_style: %s (must be in %s)"
                % (transaction_style, TRANSACTION_STYLE_VALUES)
            )

        asgi_middleware_while_using_starlette_or_fastapi = (
            mechanism_type == "asgi" and "starlette" in _get_installed_modules()
        )
        if asgi_middleware_while_using_starlette_or_fastapi:
            logger.warning(
                "The Sentry Python SDK can now automatically support ASGI frameworks like Starlette and FastAPI. "
                "Please remove 'SentryAsgiMiddleware' from your project. "
                "See https://docs.sentry.io/platforms/python/guides/asgi/ for more information."
            )

        self.transaction_style = transaction_style
        self.mechanism_type = mechanism_type
        self.app = app

        if _looks_like_asgi3(app):
            self.__call__ = self._run_asgi3  # type: Callable[..., Any]
        else:
            self.__call__ = self._run_asgi2

    def _run_asgi2(self, scope):
        # type: (Any) -> Any
        async def inner(receive, send):
            # type: (Any, Any) -> Any
            return await self._run_app(scope, receive, send, asgi_version=2)

        return inner

    async def _run_asgi3(self, scope, receive, send):
        # type: (Any, Any, Any) -> Any
        return await self._run_app(scope, receive, send, asgi_version=3)

    async def _run_app(self, scope, receive, send, asgi_version):
        # type: (Any, Any, Any, Any, int) -> Any
        is_recursive_asgi_middleware = _asgi_middleware_applied.get(False)
        is_lifespan = scope["type"] == "lifespan"
        if is_recursive_asgi_middleware or is_lifespan:
            try:
                if asgi_version == 2:
                    return await self.app(scope)(receive, send)
                else:
                    return await self.app(scope, receive, send)

            except Exception as exc:
                _capture_exception(Hub.current, exc, mechanism_type=self.mechanism_type)
                raise exc from None

        _asgi_middleware_applied.set(True)
        try:
            hub = Hub(Hub.current)
            with auto_session_tracking(hub, session_mode="request"):
                with hub:
                    with hub.configure_scope() as sentry_scope:
                        sentry_scope.clear_breadcrumbs()
                        sentry_scope._name = "asgi"
                        processor = partial(self.event_processor, asgi_scope=scope)
                        sentry_scope.add_event_processor(processor)

                    ty = scope["type"]
                    (
                        transaction_name,
                        transaction_source,
                    ) = self._get_transaction_name_and_source(
                        self.transaction_style,
                        scope,
                    )

                    if ty in ("http", "websocket"):
                        transaction = continue_trace(
                            _get_headers(scope),
                            op="{}.server".format(ty),
                            name=transaction_name,
                            source=transaction_source,
                        )
                        logger.debug(
                            "[ASGI] Created transaction (continuing trace): %s",
                            transaction,
                        )
                    else:
                        transaction = Transaction(
                            op=OP.HTTP_SERVER,
                            name=transaction_name,
                            source=transaction_source,
                        )
                        logger.debug(
                            "[ASGI] Created transaction (new): %s", transaction
                        )

                    transaction.set_tag("asgi.type", ty)
                    logger.debug(
                        "[ASGI] Set transaction name and source on transaction: '%s' / '%s'",
                        transaction.name,
                        transaction.source,
                    )

                    with hub.start_transaction(
                        transaction, custom_sampling_context={"asgi_scope": scope}
                    ):
                        logger.debug("[ASGI] Started transaction: %s", transaction)
                        try:

                            async def _sentry_wrapped_send(event):
                                # type: (Dict[str, Any]) -> Any
                                is_http_response = (
                                    event.get("type") == "http.response.start"
                                    and transaction is not None
                                    and "status" in event
                                )
                                if is_http_response:
                                    transaction.set_http_status(event["status"])

                                return await send(event)

                            if asgi_version == 2:
                                return await self.app(scope)(
                                    receive, _sentry_wrapped_send
                                )
                            else:
                                return await self.app(
                                    scope, receive, _sentry_wrapped_send
                                )
                        except Exception as exc:
                            _capture_exception(
                                hub, exc, mechanism_type=self.mechanism_type
                            )
                            raise exc from None
        finally:
            _asgi_middleware_applied.set(False)

    def event_processor(self, event, hint, asgi_scope):
        # type: (Event, Hint, Any) -> Optional[Event]
        request_data = event.get("request", {})
        request_data.update(_get_request_data(asgi_scope))
        event["request"] = deepcopy(request_data)

        # Only set transaction name if not already set by Starlette or FastAPI (or other frameworks)
        already_set = event["transaction"] != _DEFAULT_TRANSACTION_NAME and event[
            "transaction_info"
        ].get("source") in [
            TRANSACTION_SOURCE_COMPONENT,
            TRANSACTION_SOURCE_ROUTE,
        ]
        if not already_set:
            name, source = self._get_transaction_name_and_source(
                self.transaction_style, asgi_scope
            )
            event["transaction"] = name
            event["transaction_info"] = {"source": source}

            logger.debug(
                "[ASGI] Set transaction name and source in event_processor: '%s' / '%s'",
                event["transaction"],
                event["transaction_info"]["source"],
            )

        return event

    # Helper functions.
    #
    # Note: Those functions are not public API. If you want to mutate request
    # data to your liking it's recommended to use the `before_send` callback
    # for that.

    def _get_transaction_name_and_source(self, transaction_style, asgi_scope):
        # type: (SentryAsgiMiddleware, str, Any) -> Tuple[str, str]
        name = None
        source = SOURCE_FOR_STYLE[transaction_style]
        ty = asgi_scope.get("type")

        if transaction_style == "endpoint":
            endpoint = asgi_scope.get("endpoint")
            # Webframeworks like Starlette mutate the ASGI env once routing is
            # done, which is sometime after the request has started. If we have
            # an endpoint, overwrite our generic transaction name.
            if endpoint:
                name = transaction_from_function(endpoint) or ""
            else:
                name = _get_url(asgi_scope, "http" if ty == "http" else "ws", host=None)
                source = TRANSACTION_SOURCE_URL

        elif transaction_style == "url":
            # FastAPI includes the route object in the scope to let Sentry extract the
            # path from it for the transaction name
            route = asgi_scope.get("route")
            if route:
                path = getattr(route, "path", None)
                if path is not None:
                    name = path
            else:
                name = _get_url(asgi_scope, "http" if ty == "http" else "ws", host=None)
                source = TRANSACTION_SOURCE_URL

        if name is None:
            name = _DEFAULT_TRANSACTION_NAME
            source = TRANSACTION_SOURCE_ROUTE
            return name, source

        return name, source

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\sentry_sdk\integrations\asgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\sentry_sdk\integrations\wsgi.py ---

import sys

from sentry_sdk._compat import PY2, reraise
from sentry_sdk._functools import partial
from sentry_sdk._types import TYPE_CHECKING
from sentry_sdk._werkzeug import get_host, _get_headers
from sentry_sdk.api import continue_trace
from sentry_sdk.consts import OP
from sentry_sdk.hub import Hub, _should_send_default_pii
from sentry_sdk.utils import (
    ContextVar,
    capture_internal_exceptions,
    event_from_exception,
)
from sentry_sdk.tracing import Transaction, TRANSACTION_SOURCE_ROUTE
from sentry_sdk.sessions import auto_session_tracking
from sentry_sdk.integrations._wsgi_common import _filter_headers

if TYPE_CHECKING:
    from typing import Callable
    from typing import Dict
    from typing import Iterator
    from typing import Any
    from typing import Tuple
    from typing import Optional
    from typing import TypeVar
    from typing import Protocol

    from sentry_sdk.utils import ExcInfo
    from sentry_sdk._types import EventProcessor

    WsgiResponseIter = TypeVar("WsgiResponseIter")
    WsgiResponseHeaders = TypeVar("WsgiResponseHeaders")
    WsgiExcInfo = TypeVar("WsgiExcInfo")

    class StartResponse(Protocol):
        def __call__(self, status, response_headers, exc_info=None):  # type: ignore
            # type: (str, WsgiResponseHeaders, Optional[WsgiExcInfo]) -> WsgiResponseIter
            pass


_wsgi_middleware_applied = ContextVar("sentry_wsgi_middleware_applied")


if PY2:

    def wsgi_decoding_dance(s, charset="utf-8", errors="replace"):
        # type: (str, str, str) -> str
        return s.decode(charset, errors)

else:

    def wsgi_decoding_dance(s, charset="utf-8", errors="replace"):
        # type: (str, str, str) -> str
        return s.encode("latin1").decode(charset, errors)


def get_request_url(environ, use_x_forwarded_for=False):
    # type: (Dict[str, str], bool) -> str
    """Return the absolute URL without query string for the given WSGI
    environment."""
    return "%s://%s/%s" % (
        environ.get("wsgi.url_scheme"),
        get_host(environ, use_x_forwarded_for),
        wsgi_decoding_dance(environ.get("PATH_INFO") or "").lstrip("/"),
    )


class SentryWsgiMiddleware(object):
    __slots__ = ("app", "use_x_forwarded_for")

    def __init__(self, app, use_x_forwarded_for=False):
        # type: (Callable[[Dict[str, str], Callable[..., Any]], Any], bool) -> None
        self.app = app
        self.use_x_forwarded_for = use_x_forwarded_for

    def __call__(self, environ, start_response):
        # type: (Dict[str, str], Callable[..., Any]) -> _ScopedResponse
        if _wsgi_middleware_applied.get(False):
            return self.app(environ, start_response)

        _wsgi_middleware_applied.set(True)
        try:
            hub = Hub(Hub.current)
            with auto_session_tracking(hub, session_mode="request"):
                with hub:
                    with capture_internal_exceptions():
                        with hub.configure_scope() as scope:
                            scope.clear_breadcrumbs()
                            scope._name = "wsgi"
                            scope.add_event_processor(
                                _make_wsgi_event_processor(
                                    environ, self.use_x_forwarded_for
                                )
                            )

                    transaction = continue_trace(
                        environ,
                        op=OP.HTTP_SERVER,
                        name="generic WSGI request",
                        source=TRANSACTION_SOURCE_ROUTE,
                    )

                    with hub.start_transaction(
                        transaction, custom_sampling_context={"wsgi_environ": environ}
                    ):
                        try:
                            rv = self.app(
                                environ,
                                partial(
                                    _sentry_start_response, start_response, transaction
                                ),
                            )
                        except BaseException:
                            reraise(*_capture_exception(hub))
        finally:
            _wsgi_middleware_applied.set(False)

        return _ScopedResponse(hub, rv)


def _sentry_start_response(  # type: ignore
    old_start_response,  # type: StartResponse
    transaction,  # type: Transaction
    status,  # type: str
    response_headers,  # type: WsgiResponseHeaders
    exc_info=None,  # type: Optional[WsgiExcInfo]
):
    # type: (...) -> WsgiResponseIter
    with capture_internal_exceptions():
        status_int = int(status.split(" ", 1)[0])
        transaction.set_http_status(status_int)

    if exc_info is None:
        # The Django Rest Framework WSGI test client, and likely other
        # (incorrect) implementations, cannot deal with the exc_info argument
        # if one is present. Avoid providing a third argument if not necessary.
        return old_start_response(status, response_headers)
    else:
        return old_start_response(status, response_headers, exc_info)


def _get_environ(environ):
    # type: (Dict[str, str]) -> Iterator[Tuple[str, str]]
    """
    Returns our explicitly included environment variables we want to
    capture (server name, port and remote addr if pii is enabled).
    """
    keys = ["SERVER_NAME", "SERVER_PORT"]
    if _should_send_default_pii():
        # make debugging of proxy setup easier. Proxy headers are
        # in headers.
        keys += ["REMOTE_ADDR"]

    for key in keys:
        if key in environ:
            yield key, environ[key]


def get_client_ip(environ):
    # type: (Dict[str, str]) -> Optional[Any]
    """
    Infer the user IP address from various headers. This cannot be used in
    security sensitive situations since the value may be forged from a client,
    but it's good enough for the event payload.
    """
    try:
        return environ["HTTP_X_FORWARDED_FOR"].split(",")[0].strip()
    except (KeyError, IndexError):
        pass

    try:
        return environ["HTTP_X_REAL_IP"]
    except KeyError:
        pass

    return environ.get("REMOTE_ADDR")


def _capture_exception(hub):
    # type: (Hub) -> ExcInfo
    exc_info = sys.exc_info()

    # Check client here as it might have been unset while streaming response
    if hub.client is not None:
        e = exc_info[1]

        # SystemExit(0) is the only uncaught exception that is expected behavior
        should_skip_capture = isinstance(e, SystemExit) and e.code in (0, None)
        if not should_skip_capture:
            event, hint = event_from_exception(
                exc_info,
                client_options=hub.client.options,
                mechanism={"type": "wsgi", "handled": False},
            )
            hub.capture_event(event, hint=hint)

    return exc_info


class _ScopedResponse(object):
    __slots__ = ("_response", "_hub")

    def __init__(self, hub, response):
        # type: (Hub, Iterator[bytes]) -> None
        self._hub = hub
        self._response = response

    def __iter__(self):
        # type: () -> Iterator[bytes]
        iterator = iter(self._response)

        while True:
            with self._hub:
                try:
                    chunk = next(iterator)
                except StopIteration:
                    break
                except BaseException:
                    reraise(*_capture_exception(self._hub))

            yield chunk

    def close(self):
        # type: () -> None
        with self._hub:
            try:
                self._response.close()  # type: ignore
            except AttributeError:
                pass
            except BaseException:
                reraise(*_capture_exception(self._hub))


def _make_wsgi_event_processor(environ, use_x_forwarded_for):
    # type: (Dict[str, str], bool) -> EventProcessor
    # It's a bit unfortunate that we have to extract and parse the request data
    # from the environ so eagerly, but there are a few good reasons for this.
    #
    # We might be in a situation where the scope/hub never gets torn down
    # properly. In that case we will have an unnecessary strong reference to
    # all objects in the environ (some of which may take a lot of memory) when
    # we're really just interested in a few of them.
    #
    # Keeping the environment around for longer than the request lifecycle is
    # also not necessarily something uWSGI can deal with:
    # https://github.com/unbit/uwsgi/issues/1950

    client_ip = get_client_ip(environ)
    request_url = get_request_url(environ, use_x_forwarded_for)
    query_string = environ.get("QUERY_STRING")
    method = environ.get("REQUEST_METHOD")
    env = dict(_get_environ(environ))
    headers = _filter_headers(dict(_get_headers(environ)))

    def event_processor(event, hint):
        # type: (Dict[str, Any], Dict[str, Any]) -> Dict[str, Any]
        with capture_internal_exceptions():
            # if the code below fails halfway through we at least have some data
            request_info = event.setdefault("request", {})

            if _should_send_default_pii():
                user_info = event.setdefault("user", {})
                if client_ip:
                    user_info.setdefault("ip_address", client_ip)

            request_info["url"] = request_url
            request_info["query_string"] = query_string
            request_info["method"] = method
            request_info["env"] = env
            request_info["headers"] = headers

        return event

    return event_processor

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\sentry_sdk\integrations\wsgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\timezone_field\models.py ---

# intentionally left blank

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\timezone_field\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\quickstart\admin.py ---

from django.contrib import admin

# Register your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\quickstart\admin.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\quickstart\apps.py ---

from django.apps import AppConfig


class QuickstartConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'quickstart'

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\quickstart\apps.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\quickstart\models.py ---

from django.db import models

# Create your models here.

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\quickstart\models.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\quickstart\serializers.py ---

from django.contrib.auth.models import Group, User
from rest_framework import serializers


class UserSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = User
        fields = ['url', 'username', 'email', 'groups']


class GroupSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = Group
        fields = ['url', 'name']

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\quickstart\serializers.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\quickstart\views.py ---

from django.contrib.auth.models import Group, User
from rest_framework import permissions, viewsets, views, response

from tutorial.quickstart.serializers import GroupSerializer, UserSerializer


class UserViewSet(viewsets.ModelViewSet):
    """
    API endpoint that allows users to be viewed or edited.
    """
    queryset = User.objects.all().order_by('-date_joined')
    serializer_class = UserSerializer
    permission_classes = [permissions.IsAuthenticated]


class GroupViewSet(viewsets.ModelViewSet):
    """
    API endpoint that allows groups to be viewed or edited.
    """
    queryset = Group.objects.all().order_by('name')
    serializer_class = GroupSerializer
    permission_classes = [permissions.IsAuthenticated]


class Index(views.APIView):
    def get(self, request):
        bar = request.GET.get('bar', '')
        r = response.Response(data={'message': 'Hello, world!'})
        #r.headers['Location'] = '\n\n'
        r.headers['Location'] = f'http://localhost:8000/api/?bar={bar}'
        return r

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\quickstart\views.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\asgi.py ---

"""
ASGI config for tutorial project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tutorial.settings')

application = get_asgi_application()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\asgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\settings.py ---

"""
Django settings for tutorial project.

Generated by 'django-admin startproject' using Django 5.0.3.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-g56qefvrrgnx_ygpsz-#!ao71tv@!fjk49mukq68@lh#p*6%t+'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'tutorial.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'tutorial.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\settings.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\urls.py ---

from django.urls import include, path
from rest_framework import routers

from tutorial.quickstart import views

router = routers.DefaultRouter()
router.register(r'users', views.UserViewSet)
router.register(r'groups', views.GroupViewSet)

# Wire up our API using automatic URL routing.
# Additionally, we include login URLs for the browsable API.
urlpatterns = [
    path('api', views.Index.as_view()),
    path('api-auth/', include('rest_framework.urls', namespace='rest_framework'))
]

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\wsgi.py ---

"""
WSGI config for tutorial project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tutorial.settings')

application = get_wsgi_application()

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\tutorial\wsgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\weasyprint\urls.py ---

"""Various utility functions and classes for URL management."""

import codecs
import contextlib
import os.path
import re
import sys
import traceback
import zlib
from gzip import GzipFile
from pathlib import Path
from urllib.parse import quote, unquote, urljoin, urlsplit
from urllib.request import Request, pathname2url, urlopen

from . import __version__
from .logger import LOGGER

# See https://stackoverflow.com/a/11687993/1162888
# Both are needed in Python 3 as the re module does not like to mix
# https://datatracker.ietf.org/doc/html/rfc3986#section-3.1
UNICODE_SCHEME_RE = re.compile('^([a-zA-Z][a-zA-Z0-9.+-]+):')
BYTES_SCHEME_RE = re.compile(b'^([a-zA-Z][a-zA-Z0-9.+-]+):')

# getfilesystemencoding() on Linux is sometimes stupidâ€¦
FILESYSTEM_ENCODING = sys.getfilesystemencoding()
try:  # pragma: no cover
    if codecs.lookup(FILESYSTEM_ENCODING).name == 'ascii':
        FILESYSTEM_ENCODING = 'utf-8'
except LookupError:  # pragma: no cover
    FILESYSTEM_ENCODING = 'utf-8'

HTTP_HEADERS = {
    'User-Agent': f'WeasyPrint {__version__}',
    'Accept': '*/*',
    'Accept-Encoding': 'gzip, deflate',
}


class StreamingGzipFile(GzipFile):
    def __init__(self, fileobj):
        GzipFile.__init__(self, fileobj=fileobj)
        self.fileobj_to_close = fileobj

    def close(self):
        GzipFile.close(self)
        self.fileobj_to_close.close()

    # Inform html5lib to not rely on these:
    seek = tell = None


def iri_to_uri(url):
    """Turn a Unicode IRI into an ASCII-only URI that conforms to RFC 3986."""
    if url.startswith('data:'):
        # Data URIs can be huge, but donâ€™t need this anyway.
        return url
    # Use UTF-8 as per RFC 3987 (IRI), except for file://
    url = url.encode(
        FILESYSTEM_ENCODING if url.startswith('file:') else 'utf-8')
    # This is a full URI, not just a component. Only %-encode characters
    # that are not allowed at all in URIs. Everthing else is "safe":
    # * Reserved characters: /:?#[]@!$&'()*+,;=
    # * Unreserved characters: ASCII letters, digits and -._~
    #   Of these, only '~' is not in urllibâ€™s "always safe" list.
    # * '%' to avoid double-encoding
    return quote(url, safe=b"/:?#[]@!$&'()*+,;=~%")


def path2url(path):
    """Return file URL of `path`.

    Accepts 'str', 'bytes' or 'Path', returns 'str'.

    """
    # Ensure 'str'
    if isinstance(path, Path):
        path = str(path)
    elif isinstance(path, bytes):
        path = path.decode(FILESYSTEM_ENCODING)
    # If a trailing path.sep is given, keep it
    wants_trailing_slash = path.endswith(os.path.sep) or path.endswith('/')
    path = os.path.abspath(path)
    if wants_trailing_slash or os.path.isdir(path):
        # Make sure directory names have a trailing slash.
        # Otherwise relative URIs are resolved from the parent directory.
        path += os.path.sep
        wants_trailing_slash = True
    path = pathname2url(path)
    # On Windows pathname2url cuts off trailing slash
    if wants_trailing_slash and not path.endswith('/'):
        path += '/'  # pragma: no cover
    if path.startswith('///'):
        # On Windows pathname2url(r'C:\foo') is apparently '///C:/foo'
        # That enough slashes already.
        return f'file:{path}'  # pragma: no cover
    else:
        return f'file://{path}'


def url_is_absolute(url):
    """Return whether an URL (bytes or string) is absolute."""
    scheme = UNICODE_SCHEME_RE if isinstance(url, str) else BYTES_SCHEME_RE
    return bool(scheme.match(url))


def get_url_attribute(element, attr_name, base_url, allow_relative=False):
    """Get the URI corresponding to the ``attr_name`` attribute.

    Return ``None`` if:

    * the attribute is empty or missing or,
    * the value is a relative URI but the document has no base URI and
      ``allow_relative`` is ``False``.

    Otherwise return an URI, absolute if possible.

    """
    value = element.get(attr_name, '').strip()
    if value:
        return url_join(
            base_url or '', value, allow_relative, '<%s %s="%s">',
            (element.tag, attr_name, value))


def url_join(base_url, url, allow_relative, context, context_args):
    """Like urllib.urljoin, but warn if base_url is required but missing."""
    if url_is_absolute(url):
        return iri_to_uri(url)
    elif base_url:
        return iri_to_uri(urljoin(base_url, url))
    elif allow_relative:
        return iri_to_uri(url)
    else:
        LOGGER.error(
            f'Relative URI reference without a base URI: {context}',
            *context_args)
        return None


def get_link_attribute(element, attr_name, base_url):
    """Get the URL value of an element attribute.

    Return ``('external', absolute_uri)``, or ``('internal',
    unquoted_fragment_id)``, or ``None``.

    """
    attr_value = element.get(attr_name, '').strip()
    if attr_value.startswith('#') and len(attr_value) > 1:
        # Do not require a base_url when the value is just a fragment.
        return ('url', ('internal', unquote(attr_value[1:])))
    uri = get_url_attribute(element, attr_name, base_url, allow_relative=True)
    if uri:
        if base_url:
            parsed = urlsplit(uri)
            # Compare with fragments removed
            if parsed[:-1] == urlsplit(base_url)[:-1]:
                return ('url', ('internal', unquote(parsed.fragment)))
        return ('url', ('external', uri))


def ensure_url(string):
    """Get a ``scheme://path`` URL from ``string``.

    If ``string`` looks like an URL, return it unchanged. Otherwise assume a
    filename and convert it to a ``file://`` URL.

    """
    return string if url_is_absolute(string) else path2url(string)


def default_url_fetcher(url, timeout=10, ssl_context=None):
    """Fetch an external resource such as an image or stylesheet.

    Another callable with the same signature can be given as the
    ``url_fetcher`` argument to :class:`HTML` or :class:`CSS`.
    (See :ref:`URL Fetchers`.)

    :param str url: The URL of the resource to fetch.
    :param int timeout: The number of seconds before HTTP requests are dropped.
    :param ssl.SSLContext ssl_context: An SSL context used for HTTP requests.
    :raises: An exception indicating failure, e.g. :obj:`ValueError` on
        syntactically invalid URL.
    :returns: A :obj:`dict` with the following keys:

        * One of ``string`` (a :obj:`bytestring <bytes>`) or ``file_obj``
          (a :term:`file object`).
        * Optionally: ``mime_type``, a MIME type extracted e.g. from a
          *Content-Type* header. If not provided, the type is guessed from the
          file extension in the URL.
        * Optionally: ``encoding``, a character encoding extracted e.g. from a
          *charset* parameter in a *Content-Type* header
        * Optionally: ``redirected_url``, the actual URL of the resource
          if there were e.g. HTTP redirects.
        * Optionally: ``filename``, the filename of the resource. Usually
          derived from the *filename* parameter in a *Content-Disposition*
          header

        If a ``file_obj`` key is given, it is the callerâ€™s responsibility
        to call ``file_obj.close()``. The default function used internally to
        fetch data in WeasyPrint tries to close the file object after
        retreiving; but if this URL fetcher is used elsewhere, the file object
        has to be closed manually.

    """
    if UNICODE_SCHEME_RE.match(url):
        # See https://bugs.python.org/issue34702
        if url.startswith('file://'):
            url = url.split('?')[0]

        url = iri_to_uri(url)
        response = urlopen(
            Request(url, headers=HTTP_HEADERS), timeout=timeout,
            context=ssl_context)
        response_info = response.info()
        result = {
            'redirected_url': response.geturl(),
            'mime_type': response_info.get_content_type(),
            'encoding': response_info.get_param('charset'),
            'filename': response_info.get_filename(),
        }
        content_encoding = response_info.get('Content-Encoding')
        if content_encoding == 'gzip':
            result['file_obj'] = StreamingGzipFile(fileobj=response)
        elif content_encoding == 'deflate':
            data = response.read()
            try:
                result['string'] = zlib.decompress(data)
            except zlib.error:
                # Try without zlib header or checksum
                result['string'] = zlib.decompress(data, -15)
        else:
            result['file_obj'] = response
        return result
    else:  # pragma: no cover
        raise ValueError('Not an absolute URI: %r' % url)


class URLFetchingError(IOError):
    """Some error happened when fetching an URL."""


@contextlib.contextmanager
def fetch(url_fetcher, url):
    """Call an url_fetcher, fill in optional data, and clean up."""
    try:
        result = url_fetcher(url)
    except Exception as exception:
        raise URLFetchingError(f'{type(exception).__name__}: {exception}')
    result.setdefault('redirected_url', url)
    result.setdefault('mime_type', None)
    if 'file_obj' in result:
        try:
            yield result
        finally:
            try:
                result['file_obj'].close()
            except Exception:  # pragma: no cover
                # May already be closed or something.
                # This is just cleanup anyway: log but make it non-fatal.
                LOGGER.warning(
                    'Error when closing stream for %s:\n%s',
                    url, traceback.format_exc())
    else:
        yield result

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\weasyprint\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\werkzeug\urls.py ---

"""Functions for working with URLs.

Contains implementations of functions from :mod:`urllib.parse` that
handle bytes and strings.
"""
import codecs
import os
import re
import typing as t

from ._internal import _check_str_tuple
from ._internal import _decode_idna
from ._internal import _encode_idna
from ._internal import _make_encode_wrapper
from ._internal import _to_str

if t.TYPE_CHECKING:
    from . import datastructures as ds

# A regular expression for what a valid schema looks like
_scheme_re = re.compile(r"^[a-zA-Z0-9+-.]+$")

# Characters that are safe in any part of an URL.
_always_safe = frozenset(
    bytearray(
        b"abcdefghijklmnopqrstuvwxyz"
        b"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        b"0123456789"
        b"-._~"
        b"$!'()*+,;"  # RFC3986 sub-delims set, not including query string delimiters &=
    )
)

_hexdigits = "0123456789ABCDEFabcdef"
_hextobyte = {
    f"{a}{b}".encode("ascii"): int(f"{a}{b}", 16)
    for a in _hexdigits
    for b in _hexdigits
}
_bytetohex = [f"%{char:02X}".encode("ascii") for char in range(256)]


class _URLTuple(t.NamedTuple):
    scheme: str
    netloc: str
    path: str
    query: str
    fragment: str


class BaseURL(_URLTuple):
    """Superclass of :py:class:`URL` and :py:class:`BytesURL`."""

    __slots__ = ()
    _at: str
    _colon: str
    _lbracket: str
    _rbracket: str

    def __str__(self) -> str:
        return self.to_url()

    def replace(self, **kwargs: t.Any) -> "BaseURL":
        """Return an URL with the same values, except for those parameters
        given new values by whichever keyword arguments are specified."""
        return self._replace(**kwargs)

    @property
    def host(self) -> t.Optional[str]:
        """The host part of the URL if available, otherwise `None`.  The
        host is either the hostname or the IP address mentioned in the
        URL.  It will not contain the port.
        """
        return self._split_host()[0]

    @property
    def ascii_host(self) -> t.Optional[str]:
        """Works exactly like :attr:`host` but will return a result that
        is restricted to ASCII.  If it finds a netloc that is not ASCII
        it will attempt to idna decode it.  This is useful for socket
        operations when the URL might include internationalized characters.
        """
        rv = self.host
        if rv is not None and isinstance(rv, str):
            try:
                rv = _encode_idna(rv)  # type: ignore
            except UnicodeError:
                rv = rv.encode("ascii", "ignore")  # type: ignore
        return _to_str(rv, "ascii", "ignore")

    @property
    def port(self) -> t.Optional[int]:
        """The port in the URL as an integer if it was present, `None`
        otherwise.  This does not fill in default ports.
        """
        try:
            rv = int(_to_str(self._split_host()[1]))
            if 0 <= rv <= 65535:
                return rv
        except (ValueError, TypeError):
            pass
        return None

    @property
    def auth(self) -> t.Optional[str]:
        """The authentication part in the URL if available, `None`
        otherwise.
        """
        return self._split_netloc()[0]

    @property
    def username(self) -> t.Optional[str]:
        """The username if it was part of the URL, `None` otherwise.
        This undergoes URL decoding and will always be a string.
        """
        rv = self._split_auth()[0]
        if rv is not None:
            return _url_unquote_legacy(rv)
        return None

    @property
    def raw_username(self) -> t.Optional[str]:
        """The username if it was part of the URL, `None` otherwise.
        Unlike :attr:`username` this one is not being decoded.
        """
        return self._split_auth()[0]

    @property
    def password(self) -> t.Optional[str]:
        """The password if it was part of the URL, `None` otherwise.
        This undergoes URL decoding and will always be a string.
        """
        rv = self._split_auth()[1]
        if rv is not None:
            return _url_unquote_legacy(rv)
        return None

    @property
    def raw_password(self) -> t.Optional[str]:
        """The password if it was part of the URL, `None` otherwise.
        Unlike :attr:`password` this one is not being decoded.
        """
        return self._split_auth()[1]

    def decode_query(self, *args: t.Any, **kwargs: t.Any) -> "ds.MultiDict[str, str]":
        """Decodes the query part of the URL.  Ths is a shortcut for
        calling :func:`url_decode` on the query argument.  The arguments and
        keyword arguments are forwarded to :func:`url_decode` unchanged.
        """
        return url_decode(self.query, *args, **kwargs)

    def join(self, *args: t.Any, **kwargs: t.Any) -> "BaseURL":
        """Joins this URL with another one.  This is just a convenience
        function for calling into :meth:`url_join` and then parsing the
        return value again.
        """
        return url_parse(url_join(self, *args, **kwargs))

    def to_url(self) -> str:
        """Returns a URL string or bytes depending on the type of the
        information stored.  This is just a convenience function
        for calling :meth:`url_unparse` for this URL.
        """
        return url_unparse(self)

    def encode_netloc(self) -> str:
        """Encodes the netloc part to an ASCII safe URL as bytes."""
        rv = self.ascii_host or ""
        if ":" in rv:
            rv = f"[{rv}]"
        port = self.port
        if port is not None:
            rv = f"{rv}:{port}"
        auth = ":".join(
            filter(
                None,
                [
                    url_quote(self.raw_username or "", "utf-8", "strict", "/:%"),
                    url_quote(self.raw_password or "", "utf-8", "strict", "/:%"),
                ],
            )
        )
        if auth:
            rv = f"{auth}@{rv}"
        return rv

    def decode_netloc(self) -> str:
        """Decodes the netloc part into a string."""
        rv = _decode_idna(self.host or "")

        if ":" in rv:
            rv = f"[{rv}]"
        port = self.port
        if port is not None:
            rv = f"{rv}:{port}"
        auth = ":".join(
            filter(
                None,
                [
                    _url_unquote_legacy(self.raw_username or "", "/:%@"),
                    _url_unquote_legacy(self.raw_password or "", "/:%@"),
                ],
            )
        )
        if auth:
            rv = f"{auth}@{rv}"
        return rv

    def to_uri_tuple(self) -> "BaseURL":
        """Returns a :class:`BytesURL` tuple that holds a URI.  This will
        encode all the information in the URL properly to ASCII using the
        rules a web browser would follow.

        It's usually more interesting to directly call :meth:`iri_to_uri` which
        will return a string.
        """
        return url_parse(iri_to_uri(self))

    def to_iri_tuple(self) -> "BaseURL":
        """Returns a :class:`URL` tuple that holds a IRI.  This will try
        to decode as much information as possible in the URL without
        losing information similar to how a web browser does it for the
        URL bar.

        It's usually more interesting to directly call :meth:`uri_to_iri` which
        will return a string.
        """
        return url_parse(uri_to_iri(self))

    def get_file_location(
        self, pathformat: t.Optional[str] = None
    ) -> t.Tuple[t.Optional[str], t.Optional[str]]:
        """Returns a tuple with the location of the file in the form
        ``(server, location)``.  If the netloc is empty in the URL or
        points to localhost, it's represented as ``None``.

        The `pathformat` by default is autodetection but needs to be set
        when working with URLs of a specific system.  The supported values
        are ``'windows'`` when working with Windows or DOS paths and
        ``'posix'`` when working with posix paths.

        If the URL does not point to a local file, the server and location
        are both represented as ``None``.

        :param pathformat: The expected format of the path component.
                           Currently ``'windows'`` and ``'posix'`` are
                           supported.  Defaults to ``None`` which is
                           autodetect.
        """
        if self.scheme != "file":
            return None, None

        path = url_unquote(self.path)
        host = self.netloc or None

        if pathformat is None:
            if os.name == "nt":
                pathformat = "windows"
            else:
                pathformat = "posix"

        if pathformat == "windows":
            if path[:1] == "/" and path[1:2].isalpha() and path[2:3] in "|:":
                path = f"{path[1:2]}:{path[3:]}"
            windows_share = path[:3] in ("\\" * 3, "/" * 3)
            import ntpath

            path = ntpath.normpath(path)
            # Windows shared drives are represented as ``\\host\\directory``.
            # That results in a URL like ``file://///host/directory``, and a
            # path like ``///host/directory``. We need to special-case this
            # because the path contains the hostname.
            if windows_share and host is None:
                parts = path.lstrip("\\").split("\\", 1)
                if len(parts) == 2:
                    host, path = parts
                else:
                    host = parts[0]
                    path = ""
        elif pathformat == "posix":
            import posixpath

            path = posixpath.normpath(path)
        else:
            raise TypeError(f"Invalid path format {pathformat!r}")

        if host in ("127.0.0.1", "::1", "localhost"):
            host = None

        return host, path

    def _split_netloc(self) -> t.Tuple[t.Optional[str], str]:
        if self._at in self.netloc:
            auth, _, netloc = self.netloc.partition(self._at)
            return auth, netloc
        return None, self.netloc

    def _split_auth(self) -> t.Tuple[t.Optional[str], t.Optional[str]]:
        auth = self._split_netloc()[0]
        if not auth:
            return None, None
        if self._colon not in auth:
            return auth, None

        username, _, password = auth.partition(self._colon)
        return username, password

    def _split_host(self) -> t.Tuple[t.Optional[str], t.Optional[str]]:
        rv = self._split_netloc()[1]
        if not rv:
            return None, None

        if not rv.startswith(self._lbracket):
            if self._colon in rv:
                host, _, port = rv.partition(self._colon)
                return host, port
            return rv, None

        idx = rv.find(self._rbracket)
        if idx < 0:
            return rv, None

        host = rv[1:idx]
        rest = rv[idx + 1 :]
        if rest.startswith(self._colon):
            return host, rest[1:]
        return host, None


class URL(BaseURL):
    """Represents a parsed URL.  This behaves like a regular tuple but
    also has some extra attributes that give further insight into the
    URL.
    """

    __slots__ = ()
    _at = "@"
    _colon = ":"
    _lbracket = "["
    _rbracket = "]"

    def encode(self, charset: str = "utf-8", errors: str = "replace") -> "BytesURL":
        """Encodes the URL to a tuple made out of bytes.  The charset is
        only being used for the path, query and fragment.
        """
        return BytesURL(
            self.scheme.encode("ascii"),  # type: ignore
            self.encode_netloc(),
            self.path.encode(charset, errors),  # type: ignore
            self.query.encode(charset, errors),  # type: ignore
            self.fragment.encode(charset, errors),  # type: ignore
        )


class BytesURL(BaseURL):
    """Represents a parsed URL in bytes."""

    __slots__ = ()
    _at = b"@"  # type: ignore
    _colon = b":"  # type: ignore
    _lbracket = b"["  # type: ignore
    _rbracket = b"]"  # type: ignore

    def __str__(self) -> str:
        return self.to_url().decode("utf-8", "replace")  # type: ignore

    def encode_netloc(self) -> bytes:  # type: ignore
        """Returns the netloc unchanged as bytes."""
        return self.netloc  # type: ignore

    def decode(self, charset: str = "utf-8", errors: str = "replace") -> "URL":
        """Decodes the URL to a tuple made out of strings.  The charset is
        only being used for the path, query and fragment.
        """
        return URL(
            self.scheme.decode("ascii"),  # type: ignore
            self.decode_netloc(),
            self.path.decode(charset, errors),  # type: ignore
            self.query.decode(charset, errors),  # type: ignore
            self.fragment.decode(charset, errors),  # type: ignore
        )


_unquote_maps: t.Dict[t.FrozenSet[int], t.Dict[bytes, int]] = {frozenset(): _hextobyte}


def _unquote_to_bytes(
    string: t.Union[str, bytes], unsafe: t.Union[str, bytes] = ""
) -> bytes:
    if isinstance(string, str):
        string = string.encode("utf-8")

    if isinstance(unsafe, str):
        unsafe = unsafe.encode("utf-8")

    unsafe = frozenset(bytearray(unsafe))
    groups = iter(string.split(b"%"))
    result = bytearray(next(groups, b""))

    try:
        hex_to_byte = _unquote_maps[unsafe]
    except KeyError:
        hex_to_byte = _unquote_maps[unsafe] = {
            h: b for h, b in _hextobyte.items() if b not in unsafe
        }

    for group in groups:
        code = group[:2]

        if code in hex_to_byte:
            result.append(hex_to_byte[code])
            result.extend(group[2:])
        else:
            result.append(37)  # %
            result.extend(group)

    return bytes(result)


def _url_encode_impl(
    obj: t.Union[t.Mapping[str, str], t.Iterable[t.Tuple[str, str]]],
    charset: str,
    sort: bool,
    key: t.Optional[t.Callable[[t.Tuple[str, str]], t.Any]],
) -> t.Iterator[str]:
    from .datastructures import iter_multi_items

    iterable: t.Iterable[t.Tuple[str, str]] = iter_multi_items(obj)

    if sort:
        iterable = sorted(iterable, key=key)

    for key_str, value_str in iterable:
        if value_str is None:
            continue

        if not isinstance(key_str, bytes):
            key_bytes = str(key_str).encode(charset)
        else:
            key_bytes = key_str

        if not isinstance(value_str, bytes):
            value_bytes = str(value_str).encode(charset)
        else:
            value_bytes = value_str

        yield f"{_fast_url_quote_plus(key_bytes)}={_fast_url_quote_plus(value_bytes)}"


def _url_unquote_legacy(value: str, unsafe: str = "") -> str:
    try:
        return url_unquote(value, charset="utf-8", errors="strict", unsafe=unsafe)
    except UnicodeError:
        return url_unquote(value, charset="latin1", unsafe=unsafe)


def url_parse(
    url: str, scheme: t.Optional[str] = None, allow_fragments: bool = True
) -> BaseURL:
    """Parses a URL from a string into a :class:`URL` tuple.  If the URL
    is lacking a scheme it can be provided as second argument. Otherwise,
    it is ignored.  Optionally fragments can be stripped from the URL
    by setting `allow_fragments` to `False`.

    The inverse of this function is :func:`url_unparse`.

    :param url: the URL to parse.
    :param scheme: the default schema to use if the URL is schemaless.
    :param allow_fragments: if set to `False` a fragment will be removed
                            from the URL.
    """
    s = _make_encode_wrapper(url)
    is_text_based = isinstance(url, str)

    if scheme is None:
        scheme = s("")
    netloc = query = fragment = s("")
    i = url.find(s(":"))
    if i > 0 and _scheme_re.match(_to_str(url[:i], errors="replace")):
        # make sure "iri" is not actually a port number (in which case
        # "scheme" is really part of the path)
        rest = url[i + 1 :]
        if not rest or any(c not in s("0123456789") for c in rest):
            # not a port number
            scheme, url = url[:i].lower(), rest

    if url[:2] == s("//"):
        delim = len(url)
        for c in s("/?#"):
            wdelim = url.find(c, 2)
            if wdelim >= 0:
                delim = min(delim, wdelim)
        netloc, url = url[2:delim], url[delim:]
        if (s("[") in netloc and s("]") not in netloc) or (
            s("]") in netloc and s("[") not in netloc
        ):
            raise ValueError("Invalid IPv6 URL")

    if allow_fragments and s("#") in url:
        url, fragment = url.split(s("#"), 1)
    if s("?") in url:
        url, query = url.split(s("?"), 1)

    result_type = URL if is_text_based else BytesURL
    return result_type(scheme, netloc, url, query, fragment)


def _make_fast_url_quote(
    charset: str = "utf-8",
    errors: str = "strict",
    safe: t.Union[str, bytes] = "/:",
    unsafe: t.Union[str, bytes] = "",
) -> t.Callable[[bytes], str]:
    """Precompile the translation table for a URL encoding function.

    Unlike :func:`url_quote`, the generated function only takes the
    string to quote.

    :param charset: The charset to encode the result with.
    :param errors: How to handle encoding errors.
    :param safe: An optional sequence of safe characters to never encode.
    :param unsafe: An optional sequence of unsafe characters to always encode.
    """
    if isinstance(safe, str):
        safe = safe.encode(charset, errors)

    if isinstance(unsafe, str):
        unsafe = unsafe.encode(charset, errors)

    safe = (frozenset(bytearray(safe)) | _always_safe) - frozenset(bytearray(unsafe))
    table = [chr(c) if c in safe else f"%{c:02X}" for c in range(256)]

    def quote(string: bytes) -> str:
        return "".join([table[c] for c in string])

    return quote


_fast_url_quote = _make_fast_url_quote()
_fast_quote_plus = _make_fast_url_quote(safe=" ", unsafe="+")


def _fast_url_quote_plus(string: bytes) -> str:
    return _fast_quote_plus(string).replace(" ", "+")


def url_quote(
    string: t.Union[str, bytes],
    charset: str = "utf-8",
    errors: str = "strict",
    safe: t.Union[str, bytes] = "/:",
    unsafe: t.Union[str, bytes] = "",
) -> str:
    """URL encode a single string with a given encoding.

    :param s: the string to quote.
    :param charset: the charset to be used.
    :param safe: an optional sequence of safe characters.
    :param unsafe: an optional sequence of unsafe characters.

    .. versionadded:: 0.9.2
       The `unsafe` parameter was added.
    """
    if not isinstance(string, (str, bytes, bytearray)):
        string = str(string)
    if isinstance(string, str):
        string = string.encode(charset, errors)
    if isinstance(safe, str):
        safe = safe.encode(charset, errors)
    if isinstance(unsafe, str):
        unsafe = unsafe.encode(charset, errors)
    safe = (frozenset(bytearray(safe)) | _always_safe) - frozenset(bytearray(unsafe))
    rv = bytearray()
    for char in bytearray(string):
        if char in safe:
            rv.append(char)
        else:
            rv.extend(_bytetohex[char])
    return bytes(rv).decode(charset)


def url_quote_plus(
    string: str, charset: str = "utf-8", errors: str = "strict", safe: str = ""
) -> str:
    """URL encode a single string with the given encoding and convert
    whitespace to "+".

    :param s: The string to quote.
    :param charset: The charset to be used.
    :param safe: An optional sequence of safe characters.
    """
    return url_quote(string, charset, errors, safe + " ", "+").replace(" ", "+")


def url_unparse(components: t.Tuple[str, str, str, str, str]) -> str:
    """The reverse operation to :meth:`url_parse`.  This accepts arbitrary
    as well as :class:`URL` tuples and returns a URL as a string.

    :param components: the parsed URL as tuple which should be converted
                       into a URL string.
    """
    _check_str_tuple(components)
    scheme, netloc, path, query, fragment = components
    s = _make_encode_wrapper(scheme)
    url = s("")

    # We generally treat file:///x and file:/x the same which is also
    # what browsers seem to do.  This also allows us to ignore a schema
    # register for netloc utilization or having to differentiate between
    # empty and missing netloc.
    if netloc or (scheme and path.startswith(s("/"))):
        if path and path[:1] != s("/"):
            path = s("/") + path
        url = s("//") + (netloc or s("")) + path
    elif path:
        url += path
    if scheme:
        url = scheme + s(":") + url
    if query:
        url = url + s("?") + query
    if fragment:
        url = url + s("#") + fragment
    return url


def url_unquote(
    s: t.Union[str, bytes],
    charset: str = "utf-8",
    errors: str = "replace",
    unsafe: str = "",
) -> str:
    """URL decode a single string with a given encoding.  If the charset
    is set to `None` no decoding is performed and raw bytes are
    returned.

    :param s: the string to unquote.
    :param charset: the charset of the query string.  If set to `None`
        no decoding will take place.
    :param errors: the error handling for the charset decoding.
    """
    rv = _unquote_to_bytes(s, unsafe)
    if charset is None:
        return rv
    return rv.decode(charset, errors)


def url_unquote_plus(
    s: t.Union[str, bytes], charset: str = "utf-8", errors: str = "replace"
) -> str:
    """URL decode a single string with the given `charset` and decode "+" to
    whitespace.

    Per default encoding errors are ignored.  If you want a different behavior
    you can set `errors` to ``'replace'`` or ``'strict'``.

    :param s: The string to unquote.
    :param charset: the charset of the query string.  If set to `None`
        no decoding will take place.
    :param errors: The error handling for the `charset` decoding.
    """
    if isinstance(s, str):
        s = s.replace("+", " ")
    else:
        s = s.replace(b"+", b" ")
    return url_unquote(s, charset, errors)


def url_fix(s: str, charset: str = "utf-8") -> str:
    r"""Sometimes you get an URL by a user that just isn't a real URL because
    it contains unsafe characters like ' ' and so on. This function can fix
    some of the problems in a similar way browsers handle data entered by the
    user:

    >>> url_fix('http://de.wikipedia.org/wiki/Elf (Begriffskl\xe4rung)')
    'http://de.wikipedia.org/wiki/Elf%20(Begriffskl%C3%A4rung)'

    :param s: the string with the URL to fix.
    :param charset: The target charset for the URL if the url was given
        as a string.
    """
    # First step is to switch to text processing and to convert
    # backslashes (which are invalid in URLs anyways) to slashes.  This is
    # consistent with what Chrome does.
    s = _to_str(s, charset, "replace").replace("\\", "/")

    # For the specific case that we look like a malformed windows URL
    # we want to fix this up manually:
    if s.startswith("file://") and s[7:8].isalpha() and s[8:10] in (":/", "|/"):
        s = f"file:///{s[7:]}"

    url = url_parse(s)
    path = url_quote(url.path, charset, safe="/%+$!*'(),")
    qs = url_quote_plus(url.query, charset, safe=":&%=+$!*'(),")
    anchor = url_quote_plus(url.fragment, charset, safe=":&%=+$!*'(),")
    return url_unparse((url.scheme, url.encode_netloc(), path, qs, anchor))


# not-unreserved characters remain quoted when unquoting to IRI
_to_iri_unsafe = "".join([chr(c) for c in range(128) if c not in _always_safe])


def _codec_error_url_quote(e: UnicodeError) -> t.Tuple[str, int]:
    """Used in :func:`uri_to_iri` after unquoting to re-quote any
    invalid bytes.
    """
    # the docs state that UnicodeError does have these attributes,
    # but mypy isn't picking them up
    out = _fast_url_quote(e.object[e.start : e.end])  # type: ignore
    return out, e.end  # type: ignore


codecs.register_error("werkzeug.url_quote", _codec_error_url_quote)


def uri_to_iri(
    uri: t.Union[str, t.Tuple[str, str, str, str, str]],
    charset: str = "utf-8",
    errors: str = "werkzeug.url_quote",
) -> str:
    """Convert a URI to an IRI. All valid UTF-8 characters are unquoted,
    leaving all reserved and invalid characters quoted. If the URL has
    a domain, it is decoded from Punycode.

    >>> uri_to_iri("http://xn--n3h.net/p%C3%A5th?q=%C3%A8ry%DF")
    'http://\\u2603.net/p\\xe5th?q=\\xe8ry%DF'

    :param uri: The URI to convert.
    :param charset: The encoding to encode unquoted bytes with.
    :param errors: Error handler to use during ``bytes.encode``. By
        default, invalid bytes are left quoted.

    .. versionchanged:: 0.15
        All reserved and invalid characters remain quoted. Previously,
        only some reserved characters were preserved, and invalid bytes
        were replaced instead of left quoted.

    .. versionadded:: 0.6
    """
    if isinstance(uri, tuple):
        uri = url_unparse(uri)

    uri = url_parse(_to_str(uri, charset))
    path = url_unquote(uri.path, charset, errors, _to_iri_unsafe)
    query = url_unquote(uri.query, charset, errors, _to_iri_unsafe)
    fragment = url_unquote(uri.fragment, charset, errors, _to_iri_unsafe)
    return url_unparse((uri.scheme, uri.decode_netloc(), path, query, fragment))


# reserved characters remain unquoted when quoting to URI
_to_uri_safe = ":/?#[]@!$&'()*+,;=%"


def iri_to_uri(
    iri: t.Union[str, t.Tuple[str, str, str, str, str]],
    charset: str = "utf-8",
    errors: str = "strict",
    safe_conversion: bool = False,
) -> str:
    """Convert an IRI to a URI. All non-ASCII and unsafe characters are
    quoted. If the URL has a domain, it is encoded to Punycode.

    >>> iri_to_uri('http://\\u2603.net/p\\xe5th?q=\\xe8ry%DF')
    'http://xn--n3h.net/p%C3%A5th?q=%C3%A8ry%DF'

    :param iri: The IRI to convert.
    :param charset: The encoding of the IRI.
    :param errors: Error handler to use during ``bytes.encode``.
    :param safe_conversion: Return the URL unchanged if it only contains
        ASCII characters and no whitespace. See the explanation below.

    There is a general problem with IRI conversion with some protocols
    that are in violation of the URI specification. Consider the
    following two IRIs::

        magnet:?xt=uri:whatever
        itms-services://?action=download-manifest

    After parsing, we don't know if the scheme requires the ``//``,
    which is dropped if empty, but conveys different meanings in the
    final URL if it's present or not. In this case, you can use
    ``safe_conversion``, which will return the URL unchanged if it only
    contains ASCII characters and no whitespace. This can result in a
    URI with unquoted characters if it was not already quoted correctly,
    but preserves the URL's semantics. Werkzeug uses this for the
    ``Location`` header for redirects.

    .. versionchanged:: 0.15
        All reserved characters remain unquoted. Previously, only some
        reserved characters were left unquoted.

    .. versionchanged:: 0.9.6
       The ``safe_conversion`` parameter was added.

    .. versionadded:: 0.6
    """
    if isinstance(iri, tuple):
        iri = url_unparse(iri)

    if safe_conversion:
        # If we're not sure if it's safe to convert the URL, and it only
        # contains ASCII characters, return it unconverted.
        try:
            native_iri = _to_str(iri)
            ascii_iri = native_iri.encode("ascii")

            # Only return if it doesn't have whitespace. (Why?)
            if len(ascii_iri.split()) == 1:
                return native_iri
        except UnicodeError:
            pass

    iri = url_parse(_to_str(iri, charset, errors))
    path = url_quote(iri.path, charset, errors, _to_uri_safe)
    query = url_quote(iri.query, charset, errors, _to_uri_safe)
    fragment = url_quote(iri.fragment, charset, errors, _to_uri_safe)
    return url_unparse((iri.scheme, iri.encode_netloc(), path, query, fragment))


def url_decode(
    s: t.AnyStr,
    charset: str = "utf-8",
    include_empty: bool = True,
    errors: str = "replace",
    separator: str = "&",
    cls: t.Optional[t.Type["ds.MultiDict"]] = None,
) -> "ds.MultiDict[str, str]":
    """Parse a query string and return it as a :class:`MultiDict`.

    :param s: The query string to parse.
    :param charset: Decode bytes to string with this charset. If not
        given, bytes are returned as-is.
    :param include_empty: Include keys with empty values in the dict.
    :param errors: Error handling behavior when decoding bytes.
    :param separator: Separator character between pairs.
    :param cls: Container to hold result instead of :class:`MultiDict`.

    .. versionchanged:: 2.0
        The ``decode_keys`` parameter is deprecated and will be removed
        in Werkzeug 2.1.

    .. versionchanged:: 0.5
        In previous versions ";" and "&" could be used for url decoding.
        Now only "&" is supported. If you want to use ";", a different
        ``separator`` can be provided.

    .. versionchanged:: 0.5
        The ``cls`` parameter was added.
    """
    if cls is None:
        from .datastructures import MultiDict  # noqa: F811

        cls = MultiDict
    if isinstance(s, str) and not isinstance(separator, str):
        separator = separator.decode(charset or "ascii")
    elif isinstance(s, bytes) and not isinstance(separator, bytes):
        separator = separator.encode(charset or "ascii")  # type: ignore
    return cls(
        _url_decode_impl(
            s.split(separator), charset, include_empty, errors  # type: ignore
        )
    )


def url_decode_stream(
    stream: t.IO[bytes],
    charset: str = "utf-8",
    include_empty: bool = True,
    errors: str = "replace",
    separator: bytes = b"&",
    cls: t.Optional[t.Type["ds.MultiDict"]] = None,
    limit: t.Optional[int] = None,
) -> "ds.MultiDict[str, str]":
    """Works like :func:`url_decode` but decodes a stream.  The behavior
    of stream and limit follows functions like
    :func:`~werkzeug.wsgi.make_line_iter`.  The generator of pairs is
    directly fed to the `cls` so you can consume the data while it's
    parsed.

    :param stream: a stream with the encoded querystring
    :param charset: the charset of the query string.  If set to `None`
        no decoding will take place.
    :param include_empty: Set to `False` if you don't want empty values to
                          appear in the dict.
    :param errors: the decoding error behavior.
    :param separator: the pair separator to be used, defaults to ``&``
    :param cls: an optional dict class to use.  If this is not specified
                       or `None` the default :class:`MultiDict` is used.
    :param limit: the content length of the URL data.  Not necessary if
                  a limited stream is provided.

    .. versionchanged:: 2.0
        The ``decode_keys`` and ``return_iterator`` parameters are
        deprecated and will be removed in Werkzeug 2.1.

    .. versionadded:: 0.8
    """
    from .wsgi import make_chunk_iter

    pair_iter = make_chunk_iter(stream, separator, limit)
    decoder = _url_decode_impl(pair_iter, charset, include_empty, errors)

    if cls is None:
        from .datastructures import MultiDict  # noqa: F811

        cls = MultiDict

    return cls(decoder)


def _url_decode_impl(
    pair_iter: t.Iterable[t.AnyStr], charset: str, include_empty: bool, errors: str
) -> t.Iterator[t.Tuple[str, str]]:
    for pair in pair_iter:
        if not pair:
            continue
        s = _make_encode_wrapper(pair)
        equal = s("=")
        if equal in pair:
            key, value = pair.split(equal, 1)
        else:
            if not include_empty:
                continue
            key = pair
            value = s("")
        yield (
            url_unquote_plus(key, charset, errors),
            url_unquote_plus(value, charset, errors),
        )


def url_encode(
    obj: t.Union[t.Mapping[str, str], t.Iterable[t.Tuple[str, str]]],
    charset: str = "utf-8",
    sort: bool = False,
    key: t.Optional[t.Callable[[t.Tuple[str, str]], t.Any]] = None,
    separator: str = "&",
) -> str:
    """URL encode a dict/`MultiDict`.  If a value is `None` it will not appear
    in the result string.  Per default only values are encoded into the target
    charset strings.

    :param obj: the object to encode into a query string.
    :param charset: the charset of the query string.
    :param sort: set to `True` if you want parameters to be sorted by `key`.
    :param separator: the separator to be used for the pairs.
    :param key: an optional function to be used for sorting.  For more details
                check out the :func:`sorted` documentation.

    .. versionchanged:: 2.0
        The ``encode_keys`` parameter is deprecated and will be removed
        in Werkzeug 2.1.

    .. versionchanged:: 0.5
        Added the ``sort``, ``key``, and ``separator`` parameters.
    """
    separator = _to_str(separator, "ascii")
    return separator.join(_url_encode_impl(obj, charset, sort, key))


def url_encode_stream(
    obj: t.Union[t.Mapping[str, str], t.Iterable[t.Tuple[str, str]]],
    stream: t.Optional[t.IO[str]] = None,
    charset: str = "utf-8",
    sort: bool = False,
    key: t.Optional[t.Callable[[t.Tuple[str, str]], t.Any]] = None,
    separator: str = "&",
) -> None:
    """Like :meth:`url_encode` but writes the results to a stream
    object.  If the stream is `None` a generator over all encoded
    pairs is returned.

    :param obj: the object to encode into a query string.
    :param stream: a stream to write the encoded object into or `None` if
                   an iterator over the encoded pairs should be returned.  In
                   that case the separator argument is ignored.
    :param charset: the charset of the query string.
    :param sort: set to `True` if you want parameters to be sorted by `key`.
    :param separator: the separator to be used for the pairs.
    :param key: an optional function to be used for sorting.  For more details
                check out the :func:`sorted` documentation.

    .. versionchanged:: 2.0
        The ``encode_keys`` parameter is deprecated and will be removed
        in Werkzeug 2.1.

    .. versionadded:: 0.8
    """
    separator = _to_str(separator, "ascii")
    gen = _url_encode_impl(obj, charset, sort, key)
    if stream is None:
        return gen  # type: ignore
    for idx, chunk in enumerate(gen):
        if idx:
            stream.write(separator)
        stream.write(chunk)
    return None


def url_join(
    base: t.Union[str, t.Tuple[str, str, str, str, str]],
    url: t.Union[str, t.Tuple[str, str, str, str, str]],
    allow_fragments: bool = True,
) -> str:
    """Join a base URL and a possibly relative URL to form an absolute
    interpretation of the latter.

    :param base: the base URL for the join operation.
    :param url: the URL to join.
    :param allow_fragments: indicates whether fragments should be allowed.
    """
    if isinstance(base, tuple):
        base = url_unparse(base)
    if isinstance(url, tuple):
        url = url_unparse(url)

    _check_str_tuple((base, url))
    s = _make_encode_wrapper(base)

    if not base:
        return url
    if not url:
        return base

    bscheme, bnetloc, bpath, bquery, bfragment = url_parse(
        base, allow_fragments=allow_fragments
    )
    scheme, netloc, path, query, fragment = url_parse(url, bscheme, allow_fragments)
    if scheme != bscheme:
        return url
    if netloc:
        return url_unparse((scheme, netloc, path, query, fragment))
    netloc = bnetloc

    if path[:1] == s("/"):
        segments = path.split(s("/"))
    elif not path:
        segments = bpath.split(s("/"))
        if not query:
            query = bquery
    else:
        segments = bpath.split(s("/"))[:-1] + path.split(s("/"))

    # If the rightmost part is "./" we want to keep the slash but
    # remove the dot.
    if segments[-1] == s("."):
        segments[-1] = s("")

    # Resolve ".." and "."
    segments = [segment for segment in segments if segment != s(".")]
    while True:
        i = 1
        n = len(segments) - 1
        while i < n:
            if segments[i] == s("..") and segments[i - 1] not in (s(""), s("..")):
                del segments[i - 1 : i + 1]
                break
            i += 1
        else:
            break

    # Remove trailing ".." if the URL is absolute
    unwanted_marker = [s(""), s("..")]
    while segments[:2] == unwanted_marker:
        del segments[1]

    path = s("/").join(segments)
    return url_unparse((scheme, netloc, path, query, fragment))

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\werkzeug\urls.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\werkzeug\wsgi.py ---

import io
import re
import typing as t
import warnings
from functools import partial
from functools import update_wrapper
from itertools import chain

from ._internal import _make_encode_wrapper
from ._internal import _to_bytes
from ._internal import _to_str
from .sansio import utils as _sansio_utils
from .sansio.utils import host_is_trusted  # noqa: F401 # Imported as part of API
from .urls import _URLTuple
from .urls import uri_to_iri
from .urls import url_join
from .urls import url_parse
from .urls import url_quote

if t.TYPE_CHECKING:
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment


def responder(f: t.Callable[..., "WSGIApplication"]) -> "WSGIApplication":
    """Marks a function as responder.  Decorate a function with it and it
    will automatically call the return value as WSGI application.

    Example::

        @responder
        def application(environ, start_response):
            return Response('Hello World!')
    """
    return update_wrapper(lambda *a: f(*a)(*a[-2:]), f)


def get_current_url(
    environ: "WSGIEnvironment",
    root_only: bool = False,
    strip_querystring: bool = False,
    host_only: bool = False,
    trusted_hosts: t.Optional[t.Iterable[str]] = None,
) -> str:
    """Recreate the URL for a request from the parts in a WSGI
    environment.

    The URL is an IRI, not a URI, so it may contain Unicode characters.
    Use :func:`~werkzeug.urls.iri_to_uri` to convert it to ASCII.

    :param environ: The WSGI environment to get the URL parts from.
    :param root_only: Only build the root path, don't include the
        remaining path or query string.
    :param strip_querystring: Don't include the query string.
    :param host_only: Only build the scheme and host.
    :param trusted_hosts: A list of trusted host names to validate the
        host against.
    """
    parts = {
        "scheme": environ["wsgi.url_scheme"],
        "host": get_host(environ, trusted_hosts),
    }

    if not host_only:
        parts["root_path"] = environ.get("SCRIPT_NAME", "")

        if not root_only:
            parts["path"] = environ.get("PATH_INFO", "")

            if not strip_querystring:
                parts["query_string"] = environ.get("QUERY_STRING", "").encode("latin1")

    return _sansio_utils.get_current_url(**parts)


def _get_server(
    environ: "WSGIEnvironment",
) -> t.Optional[t.Tuple[str, t.Optional[int]]]:
    name = environ.get("SERVER_NAME")

    if name is None:
        return None

    try:
        port: t.Optional[int] = int(environ.get("SERVER_PORT", None))
    except (TypeError, ValueError):
        # unix socket
        port = None

    return name, port


def get_host(
    environ: "WSGIEnvironment", trusted_hosts: t.Optional[t.Iterable[str]] = None
) -> str:
    """Return the host for the given WSGI environment.

    The ``Host`` header is preferred, then ``SERVER_NAME`` if it's not
    set. The returned host will only contain the port if it is different
    than the standard port for the protocol.

    Optionally, verify that the host is trusted using
    :func:`host_is_trusted` and raise a
    :exc:`~werkzeug.exceptions.SecurityError` if it is not.

    :param environ: A WSGI environment dict.
    :param trusted_hosts: A list of trusted host names.

    :return: Host, with port if necessary.
    :raise ~werkzeug.exceptions.SecurityError: If the host is not
        trusted.
    """
    return _sansio_utils.get_host(
        environ["wsgi.url_scheme"],
        environ.get("HTTP_HOST"),
        _get_server(environ),
        trusted_hosts,
    )


def get_content_length(environ: "WSGIEnvironment") -> t.Optional[int]:
    """Returns the content length from the WSGI environment as
    integer. If it's not available or chunked transfer encoding is used,
    ``None`` is returned.

    .. versionadded:: 0.9

    :param environ: the WSGI environ to fetch the content length from.
    """
    return _sansio_utils.get_content_length(
        http_content_length=environ.get("CONTENT_LENGTH"),
        http_transfer_encoding=environ.get("HTTP_TRANSFER_ENCODING", ""),
    )


def get_input_stream(
    environ: "WSGIEnvironment", safe_fallback: bool = True
) -> t.IO[bytes]:
    """Returns the input stream from the WSGI environment and wraps it
    in the most sensible way possible. The stream returned is not the
    raw WSGI stream in most cases but one that is safe to read from
    without taking into account the content length.

    If content length is not set, the stream will be empty for safety reasons.
    If the WSGI server supports chunked or infinite streams, it should set
    the ``wsgi.input_terminated`` value in the WSGI environ to indicate that.

    .. versionadded:: 0.9

    :param environ: the WSGI environ to fetch the stream from.
    :param safe_fallback: use an empty stream as a safe fallback when the
        content length is not set. Disabling this allows infinite streams,
        which can be a denial-of-service risk.
    """
    stream = t.cast(t.IO[bytes], environ["wsgi.input"])
    content_length = get_content_length(environ)

    # A wsgi extension that tells us if the input is terminated.  In
    # that case we return the stream unchanged as we know we can safely
    # read it until the end.
    if environ.get("wsgi.input_terminated"):
        return stream

    # If the request doesn't specify a content length, returning the stream is
    # potentially dangerous because it could be infinite, malicious or not. If
    # safe_fallback is true, return an empty stream instead for safety.
    if content_length is None:
        return io.BytesIO() if safe_fallback else stream

    # Otherwise limit the stream to the content length
    return t.cast(t.IO[bytes], LimitedStream(stream, content_length))


def get_query_string(environ: "WSGIEnvironment") -> str:
    """Returns the ``QUERY_STRING`` from the WSGI environment. This also
    takes care of the WSGI decoding dance. The string returned will be
    restricted to ASCII characters.

    :param environ: WSGI environment to get the query string from.

    .. deprecated:: 2.2
        Will be removed in Werkzeug 2.3.

    .. versionadded:: 0.9
    """
    warnings.warn(
        "'get_query_string' is deprecated and will be removed in Werkzeug 2.3.",
        DeprecationWarning,
        stacklevel=2,
    )
    qs = environ.get("QUERY_STRING", "").encode("latin1")
    # QUERY_STRING really should be ascii safe but some browsers
    # will send us some unicode stuff (I am looking at you IE).
    # In that case we want to urllib quote it badly.
    return url_quote(qs, safe=":&%=+$!*'(),")


def get_path_info(
    environ: "WSGIEnvironment", charset: str = "utf-8", errors: str = "replace"
) -> str:
    """Return the ``PATH_INFO`` from the WSGI environment and decode it
    unless ``charset`` is ``None``.

    :param environ: WSGI environment to get the path from.
    :param charset: The charset for the path info, or ``None`` if no
        decoding should be performed.
    :param errors: The decoding error handling.

    .. versionadded:: 0.9
    """
    path = environ.get("PATH_INFO", "").encode("latin1")
    return _to_str(path, charset, errors, allow_none_charset=True)  # type: ignore


def get_script_name(
    environ: "WSGIEnvironment", charset: str = "utf-8", errors: str = "replace"
) -> str:
    """Return the ``SCRIPT_NAME`` from the WSGI environment and decode
    it unless `charset` is set to ``None``.

    :param environ: WSGI environment to get the path from.
    :param charset: The charset for the path, or ``None`` if no decoding
        should be performed.
    :param errors: The decoding error handling.

    .. deprecated:: 2.2
        Will be removed in Werkzeug 2.3.

    .. versionadded:: 0.9
    """
    warnings.warn(
        "'get_script_name' is deprecated and will be removed in Werkzeug 2.3.",
        DeprecationWarning,
        stacklevel=2,
    )
    path = environ.get("SCRIPT_NAME", "").encode("latin1")
    return _to_str(path, charset, errors, allow_none_charset=True)  # type: ignore


def pop_path_info(
    environ: "WSGIEnvironment", charset: str = "utf-8", errors: str = "replace"
) -> t.Optional[str]:
    """Removes and returns the next segment of `PATH_INFO`, pushing it onto
    `SCRIPT_NAME`.  Returns `None` if there is nothing left on `PATH_INFO`.

    If the `charset` is set to `None` bytes are returned.

    If there are empty segments (``'/foo//bar``) these are ignored but
    properly pushed to the `SCRIPT_NAME`:

    >>> env = {'SCRIPT_NAME': '/foo', 'PATH_INFO': '/a/b'}
    >>> pop_path_info(env)
    'a'
    >>> env['SCRIPT_NAME']
    '/foo/a'
    >>> pop_path_info(env)
    'b'
    >>> env['SCRIPT_NAME']
    '/foo/a/b'

    .. deprecated:: 2.2
        Will be removed in Werkzeug 2.3.

    .. versionadded:: 0.5

    .. versionchanged:: 0.9
       The path is now decoded and a charset and encoding
       parameter can be provided.

    :param environ: the WSGI environment that is modified.
    :param charset: The ``encoding`` parameter passed to
        :func:`bytes.decode`.
    :param errors: The ``errors`` paramater passed to
        :func:`bytes.decode`.
    """
    warnings.warn(
        "'pop_path_info' is deprecated and will be removed in Werkzeug 2.3.",
        DeprecationWarning,
        stacklevel=2,
    )

    path = environ.get("PATH_INFO")
    if not path:
        return None

    script_name = environ.get("SCRIPT_NAME", "")

    # shift multiple leading slashes over
    old_path = path
    path = path.lstrip("/")
    if path != old_path:
        script_name += "/" * (len(old_path) - len(path))

    if "/" not in path:
        environ["PATH_INFO"] = ""
        environ["SCRIPT_NAME"] = script_name + path
        rv = path.encode("latin1")
    else:
        segment, path = path.split("/", 1)
        environ["PATH_INFO"] = f"/{path}"
        environ["SCRIPT_NAME"] = script_name + segment
        rv = segment.encode("latin1")

    return _to_str(rv, charset, errors, allow_none_charset=True)  # type: ignore


def peek_path_info(
    environ: "WSGIEnvironment", charset: str = "utf-8", errors: str = "replace"
) -> t.Optional[str]:
    """Returns the next segment on the `PATH_INFO` or `None` if there
    is none.  Works like :func:`pop_path_info` without modifying the
    environment:

    >>> env = {'SCRIPT_NAME': '/foo', 'PATH_INFO': '/a/b'}
    >>> peek_path_info(env)
    'a'
    >>> peek_path_info(env)
    'a'

    If the `charset` is set to `None` bytes are returned.

    .. deprecated:: 2.2
        Will be removed in Werkzeug 2.3.

    .. versionadded:: 0.5

    .. versionchanged:: 0.9
       The path is now decoded and a charset and encoding
       parameter can be provided.

    :param environ: the WSGI environment that is checked.
    """
    warnings.warn(
        "'peek_path_info' is deprecated and will be removed in Werkzeug 2.3.",
        DeprecationWarning,
        stacklevel=2,
    )

    segments = environ.get("PATH_INFO", "").lstrip("/").split("/", 1)
    if segments:
        return _to_str(  # type: ignore
            segments[0].encode("latin1"), charset, errors, allow_none_charset=True
        )
    return None


def extract_path_info(
    environ_or_baseurl: t.Union[str, "WSGIEnvironment"],
    path_or_url: t.Union[str, _URLTuple],
    charset: str = "utf-8",
    errors: str = "werkzeug.url_quote",
    collapse_http_schemes: bool = True,
) -> t.Optional[str]:
    """Extracts the path info from the given URL (or WSGI environment) and
    path. The path info returned is a string. The URLs might also be IRIs.

    If the path info could not be determined, `None` is returned.

    Some examples:

    >>> extract_path_info('http://example.com/app', '/app/hello')
    '/hello'
    >>> extract_path_info('http://example.com/app',
    ...                   'https://example.com/app/hello')
    '/hello'
    >>> extract_path_info('http://example.com/app',
    ...                   'https://example.com/app/hello',
    ...                   collapse_http_schemes=False) is None
    True

    Instead of providing a base URL you can also pass a WSGI environment.

    :param environ_or_baseurl: a WSGI environment dict, a base URL or
                               base IRI.  This is the root of the
                               application.
    :param path_or_url: an absolute path from the server root, a
                        relative path (in which case it's the path info)
                        or a full URL.
    :param charset: the charset for byte data in URLs
    :param errors: the error handling on decode
    :param collapse_http_schemes: if set to `False` the algorithm does
                                  not assume that http and https on the
                                  same server point to the same
                                  resource.

    .. deprecated:: 2.2
        Will be removed in Werkzeug 2.3.

    .. versionchanged:: 0.15
        The ``errors`` parameter defaults to leaving invalid bytes
        quoted instead of replacing them.

    .. versionadded:: 0.6

    """
    warnings.warn(
        "'extract_path_info' is deprecated and will be removed in Werkzeug 2.3.",
        DeprecationWarning,
        stacklevel=2,
    )

    def _normalize_netloc(scheme: str, netloc: str) -> str:
        parts = netloc.split("@", 1)[-1].split(":", 1)
        port: t.Optional[str]

        if len(parts) == 2:
            netloc, port = parts
            if (scheme == "http" and port == "80") or (
                scheme == "https" and port == "443"
            ):
                port = None
        else:
            netloc = parts[0]
            port = None

        if port is not None:
            netloc += f":{port}"

        return netloc

    # make sure whatever we are working on is a IRI and parse it
    path = uri_to_iri(path_or_url, charset, errors)
    if isinstance(environ_or_baseurl, dict):
        environ_or_baseurl = get_current_url(environ_or_baseurl, root_only=True)
    base_iri = uri_to_iri(environ_or_baseurl, charset, errors)
    base_scheme, base_netloc, base_path = url_parse(base_iri)[:3]
    cur_scheme, cur_netloc, cur_path = url_parse(url_join(base_iri, path))[:3]

    # normalize the network location
    base_netloc = _normalize_netloc(base_scheme, base_netloc)
    cur_netloc = _normalize_netloc(cur_scheme, cur_netloc)

    # is that IRI even on a known HTTP scheme?
    if collapse_http_schemes:
        for scheme in base_scheme, cur_scheme:
            if scheme not in ("http", "https"):
                return None
    else:
        if not (base_scheme in ("http", "https") and base_scheme == cur_scheme):
            return None

    # are the netlocs compatible?
    if base_netloc != cur_netloc:
        return None

    # are we below the application path?
    base_path = base_path.rstrip("/")
    if not cur_path.startswith(base_path):
        return None

    return f"/{cur_path[len(base_path) :].lstrip('/')}"


class ClosingIterator:
    """The WSGI specification requires that all middlewares and gateways
    respect the `close` callback of the iterable returned by the application.
    Because it is useful to add another close action to a returned iterable
    and adding a custom iterable is a boring task this class can be used for
    that::

        return ClosingIterator(app(environ, start_response), [cleanup_session,
                                                              cleanup_locals])

    If there is just one close function it can be passed instead of the list.

    A closing iterator is not needed if the application uses response objects
    and finishes the processing if the response is started::

        try:
            return response(environ, start_response)
        finally:
            cleanup_session()
            cleanup_locals()
    """

    def __init__(
        self,
        iterable: t.Iterable[bytes],
        callbacks: t.Optional[
            t.Union[t.Callable[[], None], t.Iterable[t.Callable[[], None]]]
        ] = None,
    ) -> None:
        iterator = iter(iterable)
        self._next = t.cast(t.Callable[[], bytes], partial(next, iterator))
        if callbacks is None:
            callbacks = []
        elif callable(callbacks):
            callbacks = [callbacks]
        else:
            callbacks = list(callbacks)
        iterable_close = getattr(iterable, "close", None)
        if iterable_close:
            callbacks.insert(0, iterable_close)
        self._callbacks = callbacks

    def __iter__(self) -> "ClosingIterator":
        return self

    def __next__(self) -> bytes:
        return self._next()

    def close(self) -> None:
        for callback in self._callbacks:
            callback()


def wrap_file(
    environ: "WSGIEnvironment", file: t.IO[bytes], buffer_size: int = 8192
) -> t.Iterable[bytes]:
    """Wraps a file.  This uses the WSGI server's file wrapper if available
    or otherwise the generic :class:`FileWrapper`.

    .. versionadded:: 0.5

    If the file wrapper from the WSGI server is used it's important to not
    iterate over it from inside the application but to pass it through
    unchanged.  If you want to pass out a file wrapper inside a response
    object you have to set :attr:`Response.direct_passthrough` to `True`.

    More information about file wrappers are available in :pep:`333`.

    :param file: a :class:`file`-like object with a :meth:`~file.read` method.
    :param buffer_size: number of bytes for one iteration.
    """
    return environ.get("wsgi.file_wrapper", FileWrapper)(  # type: ignore
        file, buffer_size
    )


class FileWrapper:
    """This class can be used to convert a :class:`file`-like object into
    an iterable.  It yields `buffer_size` blocks until the file is fully
    read.

    You should not use this class directly but rather use the
    :func:`wrap_file` function that uses the WSGI server's file wrapper
    support if it's available.

    .. versionadded:: 0.5

    If you're using this object together with a :class:`Response` you have
    to use the `direct_passthrough` mode.

    :param file: a :class:`file`-like object with a :meth:`~file.read` method.
    :param buffer_size: number of bytes for one iteration.
    """

    def __init__(self, file: t.IO[bytes], buffer_size: int = 8192) -> None:
        self.file = file
        self.buffer_size = buffer_size

    def close(self) -> None:
        if hasattr(self.file, "close"):
            self.file.close()

    def seekable(self) -> bool:
        if hasattr(self.file, "seekable"):
            return self.file.seekable()
        if hasattr(self.file, "seek"):
            return True
        return False

    def seek(self, *args: t.Any) -> None:
        if hasattr(self.file, "seek"):
            self.file.seek(*args)

    def tell(self) -> t.Optional[int]:
        if hasattr(self.file, "tell"):
            return self.file.tell()
        return None

    def __iter__(self) -> "FileWrapper":
        return self

    def __next__(self) -> bytes:
        data = self.file.read(self.buffer_size)
        if data:
            return data
        raise StopIteration()


class _RangeWrapper:
    # private for now, but should we make it public in the future ?

    """This class can be used to convert an iterable object into
    an iterable that will only yield a piece of the underlying content.
    It yields blocks until the underlying stream range is fully read.
    The yielded blocks will have a size that can't exceed the original
    iterator defined block size, but that can be smaller.

    If you're using this object together with a :class:`Response` you have
    to use the `direct_passthrough` mode.

    :param iterable: an iterable object with a :meth:`__next__` method.
    :param start_byte: byte from which read will start.
    :param byte_range: how many bytes to read.
    """

    def __init__(
        self,
        iterable: t.Union[t.Iterable[bytes], t.IO[bytes]],
        start_byte: int = 0,
        byte_range: t.Optional[int] = None,
    ):
        self.iterable = iter(iterable)
        self.byte_range = byte_range
        self.start_byte = start_byte
        self.end_byte = None

        if byte_range is not None:
            self.end_byte = start_byte + byte_range

        self.read_length = 0
        self.seekable = hasattr(iterable, "seekable") and iterable.seekable()
        self.end_reached = False

    def __iter__(self) -> "_RangeWrapper":
        return self

    def _next_chunk(self) -> bytes:
        try:
            chunk = next(self.iterable)
            self.read_length += len(chunk)
            return chunk
        except StopIteration:
            self.end_reached = True
            raise

    def _first_iteration(self) -> t.Tuple[t.Optional[bytes], int]:
        chunk = None
        if self.seekable:
            self.iterable.seek(self.start_byte)  # type: ignore
            self.read_length = self.iterable.tell()  # type: ignore
            contextual_read_length = self.read_length
        else:
            while self.read_length <= self.start_byte:
                chunk = self._next_chunk()
            if chunk is not None:
                chunk = chunk[self.start_byte - self.read_length :]
            contextual_read_length = self.start_byte
        return chunk, contextual_read_length

    def _next(self) -> bytes:
        if self.end_reached:
            raise StopIteration()
        chunk = None
        contextual_read_length = self.read_length
        if self.read_length == 0:
            chunk, contextual_read_length = self._first_iteration()
        if chunk is None:
            chunk = self._next_chunk()
        if self.end_byte is not None and self.read_length >= self.end_byte:
            self.end_reached = True
            return chunk[: self.end_byte - contextual_read_length]
        return chunk

    def __next__(self) -> bytes:
        chunk = self._next()
        if chunk:
            return chunk
        self.end_reached = True
        raise StopIteration()

    def close(self) -> None:
        if hasattr(self.iterable, "close"):
            self.iterable.close()


def _make_chunk_iter(
    stream: t.Union[t.Iterable[bytes], t.IO[bytes]],
    limit: t.Optional[int],
    buffer_size: int,
) -> t.Iterator[bytes]:
    """Helper for the line and chunk iter functions."""
    if isinstance(stream, (bytes, bytearray, str)):
        raise TypeError(
            "Passed a string or byte object instead of true iterator or stream."
        )
    if not hasattr(stream, "read"):
        for item in stream:
            if item:
                yield item
        return
    stream = t.cast(t.IO[bytes], stream)
    if not isinstance(stream, LimitedStream) and limit is not None:
        stream = t.cast(t.IO[bytes], LimitedStream(stream, limit))
    _read = stream.read
    while True:
        item = _read(buffer_size)
        if not item:
            break
        yield item


def make_line_iter(
    stream: t.Union[t.Iterable[bytes], t.IO[bytes]],
    limit: t.Optional[int] = None,
    buffer_size: int = 10 * 1024,
    cap_at_buffer: bool = False,
) -> t.Iterator[bytes]:
    """Safely iterates line-based over an input stream.  If the input stream
    is not a :class:`LimitedStream` the `limit` parameter is mandatory.

    This uses the stream's :meth:`~file.read` method internally as opposite
    to the :meth:`~file.readline` method that is unsafe and can only be used
    in violation of the WSGI specification.  The same problem applies to the
    `__iter__` function of the input stream which calls :meth:`~file.readline`
    without arguments.

    If you need line-by-line processing it's strongly recommended to iterate
    over the input stream using this helper function.

    .. versionchanged:: 0.8
       This function now ensures that the limit was reached.

    .. versionadded:: 0.9
       added support for iterators as input stream.

    .. versionadded:: 0.11.10
       added support for the `cap_at_buffer` parameter.

    :param stream: the stream or iterate to iterate over.
    :param limit: the limit in bytes for the stream.  (Usually
                  content length.  Not necessary if the `stream`
                  is a :class:`LimitedStream`.
    :param buffer_size: The optional buffer size.
    :param cap_at_buffer: if this is set chunks are split if they are longer
                          than the buffer size.  Internally this is implemented
                          that the buffer size might be exhausted by a factor
                          of two however.
    """
    _iter = _make_chunk_iter(stream, limit, buffer_size)

    first_item = next(_iter, "")
    if not first_item:
        return

    s = _make_encode_wrapper(first_item)
    empty = t.cast(bytes, s(""))
    cr = t.cast(bytes, s("\r"))
    lf = t.cast(bytes, s("\n"))
    crlf = t.cast(bytes, s("\r\n"))

    _iter = t.cast(t.Iterator[bytes], chain((first_item,), _iter))

    def _iter_basic_lines() -> t.Iterator[bytes]:
        _join = empty.join
        buffer: t.List[bytes] = []
        while True:
            new_data = next(_iter, "")
            if not new_data:
                break
            new_buf: t.List[bytes] = []
            buf_size = 0
            for item in t.cast(
                t.Iterator[bytes], chain(buffer, new_data.splitlines(True))
            ):
                new_buf.append(item)
                buf_size += len(item)
                if item and item[-1:] in crlf:
                    yield _join(new_buf)
                    new_buf = []
                elif cap_at_buffer and buf_size >= buffer_size:
                    rv = _join(new_buf)
                    while len(rv) >= buffer_size:
                        yield rv[:buffer_size]
                        rv = rv[buffer_size:]
                    new_buf = [rv]
            buffer = new_buf
        if buffer:
            yield _join(buffer)

    # This hackery is necessary to merge 'foo\r' and '\n' into one item
    # of 'foo\r\n' if we were unlucky and we hit a chunk boundary.
    previous = empty
    for item in _iter_basic_lines():
        if item == lf and previous[-1:] == cr:
            previous += item
            item = empty
        if previous:
            yield previous
        previous = item
    if previous:
        yield previous


def make_chunk_iter(
    stream: t.Union[t.Iterable[bytes], t.IO[bytes]],
    separator: bytes,
    limit: t.Optional[int] = None,
    buffer_size: int = 10 * 1024,
    cap_at_buffer: bool = False,
) -> t.Iterator[bytes]:
    """Works like :func:`make_line_iter` but accepts a separator
    which divides chunks.  If you want newline based processing
    you should use :func:`make_line_iter` instead as it
    supports arbitrary newline markers.

    .. versionadded:: 0.8

    .. versionadded:: 0.9
       added support for iterators as input stream.

    .. versionadded:: 0.11.10
       added support for the `cap_at_buffer` parameter.

    :param stream: the stream or iterate to iterate over.
    :param separator: the separator that divides chunks.
    :param limit: the limit in bytes for the stream.  (Usually
                  content length.  Not necessary if the `stream`
                  is otherwise already limited).
    :param buffer_size: The optional buffer size.
    :param cap_at_buffer: if this is set chunks are split if they are longer
                          than the buffer size.  Internally this is implemented
                          that the buffer size might be exhausted by a factor
                          of two however.
    """
    _iter = _make_chunk_iter(stream, limit, buffer_size)

    first_item = next(_iter, b"")
    if not first_item:
        return

    _iter = t.cast(t.Iterator[bytes], chain((first_item,), _iter))
    if isinstance(first_item, str):
        separator = _to_str(separator)
        _split = re.compile(f"({re.escape(separator)})").split
        _join = "".join
    else:
        separator = _to_bytes(separator)
        _split = re.compile(b"(" + re.escape(separator) + b")").split
        _join = b"".join

    buffer: t.List[bytes] = []
    while True:
        new_data = next(_iter, b"")
        if not new_data:
            break
        chunks = _split(new_data)
        new_buf: t.List[bytes] = []
        buf_size = 0
        for item in chain(buffer, chunks):
            if item == separator:
                yield _join(new_buf)
                new_buf = []
                buf_size = 0
            else:
                buf_size += len(item)
                new_buf.append(item)

                if cap_at_buffer and buf_size >= buffer_size:
                    rv = _join(new_buf)
                    while len(rv) >= buffer_size:
                        yield rv[:buffer_size]
                        rv = rv[buffer_size:]
                    new_buf = [rv]
                    buf_size = len(rv)

        buffer = new_buf
    if buffer:
        yield _join(buffer)


class LimitedStream(io.IOBase):
    """Wraps a stream so that it doesn't read more than n bytes.  If the
    stream is exhausted and the caller tries to get more bytes from it
    :func:`on_exhausted` is called which by default returns an empty
    string.  The return value of that function is forwarded
    to the reader function.  So if it returns an empty string
    :meth:`read` will return an empty string as well.

    The limit however must never be higher than what the stream can
    output.  Otherwise :meth:`readlines` will try to read past the
    limit.

    .. admonition:: Note on WSGI compliance

       calls to :meth:`readline` and :meth:`readlines` are not
       WSGI compliant because it passes a size argument to the
       readline methods.  Unfortunately the WSGI PEP is not safely
       implementable without a size argument to :meth:`readline`
       because there is no EOF marker in the stream.  As a result
       of that the use of :meth:`readline` is discouraged.

       For the same reason iterating over the :class:`LimitedStream`
       is not portable.  It internally calls :meth:`readline`.

       We strongly suggest using :meth:`read` only or using the
       :func:`make_line_iter` which safely iterates line-based
       over a WSGI input stream.

    :param stream: the stream to wrap.
    :param limit: the limit for the stream, must not be longer than
                  what the string can provide if the stream does not
                  end with `EOF` (like `wsgi.input`)
    """

    def __init__(self, stream: t.IO[bytes], limit: int) -> None:
        self._read = stream.read
        self._readline = stream.readline
        self._pos = 0
        self.limit = limit

    def __iter__(self) -> "LimitedStream":
        return self

    @property
    def is_exhausted(self) -> bool:
        """If the stream is exhausted this attribute is `True`."""
        return self._pos >= self.limit

    def on_exhausted(self) -> bytes:
        """This is called when the stream tries to read past the limit.
        The return value of this function is returned from the reading
        function.
        """
        # Read null bytes from the stream so that we get the
        # correct end of stream marker.
        return self._read(0)

    def on_disconnect(self) -> bytes:
        """What should happen if a disconnect is detected?  The return
        value of this function is returned from read functions in case
        the client went away.  By default a
        :exc:`~werkzeug.exceptions.ClientDisconnected` exception is raised.
        """
        from .exceptions import ClientDisconnected

        raise ClientDisconnected()

    def _exhaust_chunks(self, chunk_size: int = 1024 * 64) -> t.Iterator[bytes]:
        """Exhaust the stream by reading until the limit is reached or the client
        disconnects, yielding each chunk.

        :param chunk_size: How many bytes to read at a time.

        :meta private:

        .. versionadded:: 2.2.3
        """
        to_read = self.limit - self._pos

        while to_read > 0:
            chunk = self.read(min(to_read, chunk_size))
            yield chunk
            to_read -= len(chunk)

    def exhaust(self, chunk_size: int = 1024 * 64) -> None:
        """Exhaust the stream by reading until the limit is reached or the client
        disconnects, discarding the data.

        :param chunk_size: How many bytes to read at a time.

        .. versionchanged:: 2.2.3
            Handle case where wrapped stream returns fewer bytes than requested.
        """
        for _ in self._exhaust_chunks(chunk_size):
            pass

    def read(self, size: t.Optional[int] = None) -> bytes:
        """Read up to ``size`` bytes from the underlying stream. If size is not
        provided, read until the limit.

        If the limit is reached, :meth:`on_exhausted` is called, which returns empty
        bytes.

        If no bytes are read and the limit is not reached, or if an error occurs during
        the read, :meth:`on_disconnect` is called, which raises
        :exc:`.ClientDisconnected`.

        :param size: The number of bytes to read. ``None``, default, reads until the
            limit is reached.

        .. versionchanged:: 2.2.3
            Handle case where wrapped stream returns fewer bytes than requested.
        """
        if self._pos >= self.limit:
            return self.on_exhausted()

        if size is None or size == -1:  # -1 is for consistency with file
            # Keep reading from the wrapped stream until the limit is reached. Can't
            # rely on stream.read(size) because it's not guaranteed to return size.
            buf = bytearray()

            for chunk in self._exhaust_chunks():
                buf.extend(chunk)

            return bytes(buf)

        to_read = min(self.limit - self._pos, size)

        try:
            read = self._read(to_read)
        except (OSError, ValueError):
            return self.on_disconnect()

        if to_read and not len(read):
            # If no data was read, treat it as a disconnect. As long as some data was
            # read, a subsequent call can still return more before reaching the limit.
            return self.on_disconnect()

        self._pos += len(read)
        return read

    def readline(self, size: t.Optional[int] = None) -> bytes:
        """Reads one line from the stream."""
        if self._pos >= self.limit:
            return self.on_exhausted()
        if size is None:
            size = self.limit - self._pos
        else:
            size = min(size, self.limit - self._pos)
        try:
            line = self._readline(size)
        except (ValueError, OSError):
            return self.on_disconnect()
        if size and not line:
            return self.on_disconnect()
        self._pos += len(line)
        return line

    def readlines(self, size: t.Optional[int] = None) -> t.List[bytes]:
        """Reads a file into a list of strings.  It calls :meth:`readline`
        until the file is read to the end.  It does support the optional
        `size` argument if the underlying stream supports it for
        `readline`.
        """
        last_pos = self._pos
        result = []
        if size is not None:
            end = min(self.limit, last_pos + size)
        else:
            end = self.limit
        while True:
            if size is not None:
                size -= last_pos - self._pos
            if self._pos >= end:
                break
            result.append(self.readline(size))
            if size is not None:
                last_pos = self._pos
        return result

    def tell(self) -> int:
        """Returns the position of the stream.

        .. versionadded:: 0.9
        """
        return self._pos

    def __next__(self) -> bytes:
        line = self.readline()
        if not line:
            raise StopIteration()
        return line

    def readable(self) -> bool:
        return True

# --- Fim do arquivo: C:\ClinicaAI\backend\venv\Lib\site-packages\werkzeug\wsgi.py ---


# --- Início do arquivo: C:\ClinicaAI\backend\manage.py ---

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'ClinicaAI.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

# --- Fim do arquivo: C:\ClinicaAI\backend\manage.py ---

